# 05. 上下文接口抽象

## Context Trait设计

### 核心Context Trait
```rust
/// 链环境上下文接口
/// 提供与区块链交互的所有必要方法
pub trait Context {
    // 身份相关方法
    fn owner(&self) -> Address;          // 合约拥有者
    fn invoker(&self) -> Address;        // 调用者地址
    fn self_address(&self) -> Address;   // 合约自身地址
    fn self_balance(&self) -> u64;       // 合约余额
    
    // 参数处理
    fn parameter<T: DeserializeOwned>(&self) -> T;  // 获取调用参数
    
    // 状态存储
    fn store_get<T: DeserializeOwned>(&self, key: String) -> T;      // 读取状态
    fn store_set(&self, key: String, value: String) -> bool;        // 写入状态
    
    // 错误和事件
    fn error(&self, err: String);                                  // 记录错误
    fn event(&self, event: String);                                 // 触发事件
    fn return_data(&self, data: String);                           // 设置返回数据
    
    // 代币操作
    fn transfer(&self, addr: Address, amount: u64) -> bool;       // 转账
    fn call(&self, addr: Address, amount: u64, func: String, args: String) -> bool; // 调用其他合约
    
    // 区块链信息
    fn block_time(&self) -> u64;                                   // 区块时间
    fn block_number(&self) -> u64;                                 // 区块高度
    fn tx_hash(&self) -> String;                                    // 交易哈希
}
```

### 泛型Context设计
```rust
/// 泛型Context实现，支持任意上下文类型
pub trait ContextTrait<C: Copy> {
    // 必须实现的方法
    fn get_owner(&self) -> Address;
    fn get_invoker(&self) -> Address;
    fn get_self_address(&self) -> Address;
    
    // 提供默认实现的方法
    fn get_parameter<T: DeserializeOwned>(&self) -> T {
        // 默认参数解析实现
    }
    
    fn emit_event<E: Serialize>(&self, event: E) -> Result<()> {
        // 默认事件触发实现
    }
}

// 为具体类型实现ContextTrait
impl ContextTrait<ContractContext> for ContractContext {
    fn get_owner(&self) -> Address {
        // 具体实现
    }
    // ... 其他方法实现
}
```

## 具体实现：ContractContext

### 空实现结构体
```rust
/// 空的合约上下文实现
/// 在编译时使用，实际运行时由虚拟机提供具体实现
#[derive(Clone, Copy, Debug)]
pub struct ContractContext;

// 为ContractContext实现Context trait
impl Context for ContractContext {
    fn owner(&self) -> Address {
        // 通过FFI调用获取合约拥有者
        let mut bytes: MaybeUninit<[u8; ADDRESS_LEN]> = MaybeUninit::uninit();
        let ptr = bytes.as_mut_ptr();
        
        unsafe {
            get_owner(ptr as *mut u8);  // 调用外部函数
            Address(bytes.assume_init())
        }
    }
    
    fn invoker(&self) -> Address {
        // 类似实现...
    }
    
    // 其他方法实现...
}
```

### 内存安全实现
```rust
impl ContractContext {
    /// 安全的内存读取封装
    fn safe_memory_read<T>(&self, ptr: *mut u8, len: usize) -> Result<T> 
    where
        T: DeserializeOwned,
    {
        // 边界检查
        if ptr.is_null() || len == 0 {
            return Err(ContractError::MemoryAccessError);
        }
        
        // 读取内存并反序列化
        let slice = unsafe { std::slice::from_raw_parts(ptr, len) };
        let value: T = deserialize(slice)?;
        
        Ok(value)
    }
    
    /// 安全的内存写入封装
    fn safe_memory_write<T>(&self, ptr: *mut u8, value: &T) -> Result<()> 
    where
        T: Serialize,
    {
        // 序列化数据
        let data = serialize(value)?;
        let len = data.len();
        
        // 边界检查
        if ptr.is_null() {
            return Err(ContractError::MemoryAccessError);
        }
        
        // 写入内存
        unsafe {
            std::ptr::copy_nonoverlapping(data.as_ptr(), ptr, len);
        }
        
        Ok(())
    }
}
```

## FFI外部函数接口

### 外部函数声明
```rust
/// WASM导入函数声明
/// 这些函数由虚拟机实现，合约通过FFI调用
#[cfg_attr(target_arch = "wasm32", link(wasm_import_module = "xq"))]
extern "C" {
    // 身份相关
    pub fn get_owner(value: *mut u8);
    pub fn get_invoker(value: *mut u8);
    pub fn get_contract_address(value: *mut u8);
    pub fn get_contract_balance() -> u64;
    
    // 参数处理
    pub fn get_parameter(value: *mut u8) -> u32;  // 返回参数长度
    
    // 状态存储
    pub fn store_get(key: *const u8, key_len: u32, value: *mut u8) -> u32;
    pub fn store_set(key: *const u8, key_len: u32, value: *const u8, value_len: u32) -> i32;
    
    // 事件和错误
    pub fn set_event(start: *const u8, length: u32) -> i32;
    pub fn set_error(start: *const u8, length: u32) -> i32;
    pub fn set_return_data(start: *const u8, length: u32) -> u32;
    
    // 代币操作
    pub fn transfer(addr: *const u8, amount: u64) -> i32;
    pub fn call_contract(
        addr: *const u8, 
        amount: u64, 
        func: *const u8, 
        func_len: u32, 
        args: *const u8, 
        args_len: u32
    ) -> i32;
    
    // 区块链信息
    pub fn get_block_time() -> u64;
    pub fn get_block_number() -> u64;
    pub fn get_block_hash(value: *mut u8) -> u64;
    pub fn get_tx_hash(value: *mut u8) -> u32;
    
    // Gas相关
    pub fn get_gas_remaining() -> u64;
    pub fn consume_gas(amount: u64) -> i32;
}
```

### 安全的FFI封装
```rust
/// 安全的FFI函数封装
pub mod safe_ffi {
    use super::*;
    
    /// 安全获取合约拥有者
    pub fn safe_get_owner() -> Result<Address> {
        let mut buffer = [0u8; ADDRESS_LEN];
        
        unsafe {
            get_owner(buffer.as_mut_ptr());
        }
        
        // 验证地址有效性
        if buffer.iter().all(|&b| b == 0) {
            return Err(ContractError::InvalidAddress);
        }
        
        Ok(Address(buffer))
    }
    
    /// 安全获取调用参数
    pub fn safe_get_parameter<T: DeserializeOwned>() -> Result<T> {
        // 先获取参数长度
        let mut len_buffer = [0u8; 4];
        let len_ptr = len_buffer.as_mut_ptr();
        
        let param_len = unsafe {
            get_parameter(len_ptr)
        };
        
        if param_len == 0 {
            return Err(ContractError::NoParameter);
        }
        
        // 分配内存并获取参数
        let mut param_buffer = vec![0u8; param_len as usize];
        
        unsafe {
            get_parameter(param_buffer.as_mut_ptr());
        }
        
        // 反序列化参数
        let param: T = deserialize(¶m_buffer)?;
        
        Ok(param)
    }
    
    /// 安全触发事件
    pub fn safe_set_event<E: Serialize>(event: &E) -> Result<()> {
        let event_json = serialize(event)?;
        
        let result = unsafe {
            set_event(event_json.as_ptr(), event_json.len() as u32)
        };
        
        if result != 0 {
            return Err(ContractError::EventError);
        }
        
        Ok(())
    }
}
```

## 运行时上下文实现

### 虚拟机端Context
```rust
/// 虚拟机端的上下文实现
/// 包含实际的链状态和数据
pub struct RuntimeContext {
    // 交易信息
    pub tx_hash: Hash,
    pub block_number: u64,
    pub block_time: u64,
    
    // 身份信息
    pub invoker: Address,
    pub contract_address: Address,
    pub contract_owner: Address,
    
    // 参数数据
    pub parameter_data: Vec<u8>,
    
    // 状态存储
    pub state_storage: HashMap<Vec<u8>, Vec<u8>>,
    
    // 事件和输出
    pub events: Vec<String>,
    pub return_data: Option<String>,
    pub error_message: Option<String>,
    
    // Gas管理
    pub gas_remaining: u64,
    pub gas_limit: u64,
}

impl RuntimeContext {
    /// 创建新的运行时上下文
    pub fn new(
        tx_hash: Hash,
        block_number: u64,
        block_time: u64,
        invoker: Address,
        contract_address: Address,
        contract_owner: Address,
        parameter_data: Vec<u8>,
        gas_limit: u64,
    ) -> Self {
        Self {
            tx_hash,
            block_number,
            block_time,
            invoker,
            contract_address,
            contract_owner,
            parameter_data,
            state_storage: HashMap::new(),
            events: Vec::new(),
            return_data: None,
            error_message: None,
            gas_remaining: gas_limit,
            gas_limit,
        }
    }
    
    /// 消耗Gas
    pub fn consume_gas(&mut self, amount: u64) -> Result<()> {
        if self.gas_remaining < amount {
            return Err(ExecutionError::OutOfGas);
        }
        self.gas_remaining -= amount;
        Ok(())
    }
}
```

### Linker集成
```rust
/// 配置Linker，添加所有上下文相关函数
pub fn configure_context_linker(linker: &mut Linker<RuntimeContext>) -> Result<()> {
    // 身份相关函数
    linker.func_wrap(
        "xq", 
        "get_owner", 
        |mut caller: Caller<RuntimeContext>, ptr: i32| {
            let ctx = caller.data_mut();
            let owner_bytes = ctx.contract_owner.0;
            
            // 写入内存
            let mem = get_memory(&caller)?;
            mem.write(caller, ptr as usize, &owner_bytes)
                .map_err(|_| "Memory write error")?;
            
            Ok(())
        }
    )?;
    
    // 参数获取函数
    linker.func_wrap(
        "xq",
        "get_parameter",
        |mut caller: Caller<RuntimeContext>, ptr: i32| -> Result<u32> {
            let ctx = caller.data_mut();
            let param_data = &ctx.parameter_data;
            
            // 写入内存并返回长度
            let mem = get_memory(&caller)?;
            mem.write(caller, ptr as usize, param_data)
                .map_err(|_| "Memory write error")?;
            
            Ok(param_data.len() as u32)
        }
    )?;
    
    // 状态存储函数
    linker.func_wrap(
        "xq",
        "store_get",
        |mut caller: Caller<RuntimeContext>, 
         key_ptr: i32, key_len: u32,
         value_ptr: i32| -> Result<u32> {
            
            let ctx = caller.data_mut();
            
            // 读取key
            let mem = get_memory(&caller)?;
            let key_bytes = read_memory(&mem, caller, key_ptr, key_len)?;
            
            // 查找值
            if let Some(value) = ctx.state_storage.get(&key_bytes) {
                // 写入值到内存
                mem.write(caller, value_ptr as usize, value)
                    .map_err(|_| "Memory write error")?;
                
                Ok(value.len() as u32)
            } else {
                Ok(0)  // 键不存在
            }
        }
    )?;
    
    // 其他函数配置...
    Ok(())
}
```

## 高级特性

### 异步上下文支持
```rust
/// 支持异步操作的上下文
#[async_trait]
pub trait AsyncContext: Send + Sync {
    // 异步身份获取
    async fn get_owner_async(&self) -> Result<Address>;
    
    // 异步状态读取
    async fn store_get_async<T: DeserializeOwned>(&self, key: String) -> Result<T>;
    
    // 异步合约调用
    async fn call_contract_async(
        &self,
        addr: Address,
        amount: u64,
        func: String,
        args: String
    ) -> Result<String>;
}

/// 异步上下文实现
pub struct AsyncRuntimeContext {
    // 内部同步上下文
    inner: RuntimeContext,
    
    // 异步执行器
    executor: Arc<dyn AsyncExecutor>,
}

#[async_trait]
impl AsyncContext for AsyncRuntimeContext {
    async fn get_owner_async(&self) -> Result<Address> {
        self.executor.execute(|| self.inner.owner()).await
    }
    
    async fn store_get_async<T: DeserializeOwned>(&self, key: String) -> Result<T> {
        self.executor.execute(|| self.inner.store_get(key)).await
    }
}
```

### 上下文缓存
```rust
/// 带缓存的上下文实现
pub struct CachedContext<C: Context> {
    inner: C,
    cache: HashMap<String, CachedValue>,
}

impl<C: Context> Context for CachedContext<C> {
    fn store_get<T: DeserializeOwned>(&self, key: String) -> T {
        // 先检查缓存
        if let Some(cached) = self.cache.get(&key) {
            if !cached.is_expired() {
                return cached.value.clone();
            }
        }
        
        // 缓存未命中，从底层获取
        let value = self.inner.store_get(key.clone());
        
        // 更新缓存
        self.cache.insert(key, CachedValue::new(value.clone()));
        
        value
    }
    
    // 其他方法委托给inner
    fn owner(&self) -> Address { self.inner.owner() }
    fn invoker(&self) -> Address { self.inner.invoker() }
    // ...
}
```

### 监控和审计
```rust
/// 带监控的上下文包装器
pub struct MonitoredContext<C: Context> {
    inner: C,
    metrics: Arc<ContextMetrics>,
    audit_log: Arc<Mutex<Vec<AuditEntry>>>,
}

impl<C: Context> Context for MonitoredContext<C> {
    fn store_set(&self, key: String, value: String) -> bool {
        let start = Instant::now();
        let result = self.inner.store_set(key.clone(), value.clone());
        let duration = start.elapsed();
        
        // 记录指标
        self.metrics.record_store_set(duration, result);
        
        // 审计日志
        self.audit_log.lock().unwrap().push(AuditEntry {
            timestamp: SystemTime::now(),
            operation: "store_set".to_string(),
            key: key,
            value: value,
            success: result,
            duration,
        });
        
        result
    }
    
    // 其他方法类似实现...
}
```

## 测试和模拟

### 测试上下文实现
```rust
/// 用于测试的模拟上下文
pub struct MockContext {
    pub owner: Address,
    pub invoker: Address,
    pub self_address: Address,
    pub self_balance: u64,
    pub block_time: u64,
    pub block_number: u64,
    pub storage: HashMap<String, String>,
    pub events: Vec<String>,
    pub errors: Vec<String>,
}

impl Context for MockContext {
    fn owner(&self) -> Address { self.owner }
    fn invoker(&self) -> Address { self.invoker }
    fn self_address(&self) -> Address { self.self_address }
    fn self_balance(&self) -> u64 { self.self_balance }
    
    fn store_get<T: DeserializeOwned>(&self, key: String) -> T {
        let value = self.storage.get(&key)
            .unwrap_or(&"null".to_string())
            .clone();
        
        deserialize(value.as_bytes()).unwrap()
    }
    
    fn store_set(&self, key: String, value: String) -> bool {
        self.storage.insert(key, value);
        true
    }
    
    fn event(&self, event: String) {
        self.events.push(event);
    }
    
    fn error(&self, err: String) {
        self.errors.push(err);
    }
}
```

### 上下文测试工具
```rust
/// 上下文测试工具函数
pub mod test_utils {
    use super::*;
    
    /// 创建测试用的默认上下文
    pub fn create_test_context() -> MockContext {
        MockContext {
            owner: Address([0x01; 20]),
            invoker: Address([0x02; 20]),
            self_address: Address([0x03; 20]),
            self_balance: 1000,
            block_time: 1234567890,
            block_number: 100,
            storage: HashMap::new(),
            events: Vec::new(),
            errors: Vec::new(),
        }
    }
    
    /// 断言事件被触发
    pub fn assert_event_emitted(context: &MockContext, expected_event: &str) {
        assert!(context.events.iter().any(|e| e.contains(expected_event)),
            "Event '{}' not found in emitted events: {:?}", 
            expected_event, context.events);
    }
    
    /// 断言存储值
    pub fn assert_storage_value<T: Serialize + PartialEq + Debug>(
        context: &MockContext, 
        key: &str, 
        expected_value: &T
    ) {
        let stored: T = context.store_get(key.to_string());
        assert_eq!(&stored, expected_value, 
            "Storage value mismatch for key '{}'", key);
    }
}
```

## 总结

上下文接口抽象是连接智能合约与区块链环境的关键桥梁。通过设计良好的Context trait和具体的实现，我们可以：

1. **提供统一的接口**：让合约代码与具体虚拟机实现解耦
2. **保证类型安全**：通过泛型和trait约束确保接口安全
3. **支持多种环境**：同时支持编译时、运行时和测试环境
4. **便于测试和模拟**：提供模拟实现便于单元测试
5. **扩展性强**：通过包装器模式添加监控、缓存等高级特性

xwasm项目的上下文设计充分考虑了这些因素，为智能合约开发提供了强大而灵活的基础设施。在下一章中，我们将深入探讨宏代码生成实现，了解如何将高级语法转换为实际的WASM代码。