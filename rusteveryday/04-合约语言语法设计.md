# 04. 合约语言语法设计

## 合约结构定义

### 基本合约结构
一个完整的智能合约通常包含以下要素：

```rust
#[contract("erc20")]  // 合约标识
mod erc20_contract {
    use super::*;
    
    // 状态定义
    #[state]  // 状态标记
    struct Balances {
        balances: HashMap<Address, u64>,
        total_supply: u64,
    }
    
    // 事件定义
    #[event]  // 事件标记
    enum Event {
        Transfer { from: Address, to: Address, amount: u64 },
        Approval { owner: Address, spender: Address, amount: u64 },
    }
    
    // 初始化函数
    #[init]  // 初始化标记
    fn initialize(initial_supply: u64) -> Result<()> {
        // 初始化逻辑
    }
    
    // 调用函数
    #[call]  // 调用标记
    fn transfer(to: Address, amount: u64) -> Result<()> {
        // 转账逻辑
    }
}
```

### 合约要素详解

#### 1. 合约标识（Contract Identity）
```rust
#[contract("erc20")]  // 合约名称
#[contract(version = "1.0.0")]  // 版本信息
#[contract(author = "0x1234...")]  // 作者地址
```

#### 2. 状态存储（State Storage）
```rust
#[state]  // 状态标记
struct ContractState {
    // 简单类型
    counter: u64,
    owner: Address,
    
    // 复杂类型
    balances: HashMap<Address, u64>,
    approvals: HashMap<(Address, Address), u64>,
    
    // 嵌套结构
    config: Config,
}

#[state]
struct Config {
    name: String,
    symbol: String,
    decimals: u8,
}
```

#### 3. 事件系统（Event System）
```rust
#[event]  // 事件标记
enum ContractEvent {
    // 简单事件
    ValueUpdated { old_value: u64, new_value: u64 },
    
    // 复杂事件
    Transfer {
        from: Address,
        to: Address,
        amount: u64,
        timestamp: u64,
    },
    
    // 带索引的事件（便于查询）
    #[indexed]  // 索引标记
    UserAction {
        user: Address,
        action_type: String,
        success: bool,
    },
}
```

## 函数类型与签名

### 初始化函数（Init Function）
```rust
#[init]  // 无参数版本
fn initialize() -> Result<()> {
    // 默认初始化
}

#[init(payable)]  // 可接收代币
fn initialize_with_funding(initial_supply: u64) -> Result<()> {
    // 带参数的初始化
}

#[init(contract = "token", version = "1.0")]  // 完整属性
fn detailed_init() -> Result<()> {
    // 详细的初始化逻辑
}
```

### 调用函数（Call Function）
```rust
#[call]  // 简单调用
fn simple_function() -> Result<()> {
    // 简单逻辑
}

#[call(name = "transfer")]  // 指定函数名
fn transfer_tokens(to: Address, amount: u64) -> Result<()> {
    // 转账逻辑
}

#[call(payable, event = "Transfer")]  // 多属性
fn payable_transfer(to: Address, amount: u64) -> Result<()> {
    // 可接收代币的转账
}
```

### 查询函数（View Function）
```rust
#[call(view)]  // 只读标记
fn get_balance(owner: Address) -> Result<u64> {
    // 查询余额，不修改状态
}

#[call(view, name = "totalSupply")]  // 只读+重命名
fn get_total_supply() -> Result<u64> {
    // 查询总供应量
}
```

## 类型系统与序列化

### 基本数据类型
```rust
// 原生类型支持
#[derive(Serialize, Deserialize, SchemaType)]
struct BasicTypes {
    number: u64,          // 整数
    decimal: f64,         // 浮点数
    flag: bool,           // 布尔值
    text: String,         // 字符串
    address: Address,     // 地址类型
    hash: Hash,           // 哈希值
}
```

### 复杂数据结构
```rust
// 集合类型
#[derive(Serialize, Deserialize, SchemaType)]
struct CollectionTypes {
    list: Vec<u64>,                    // 动态数组
    fixed_array: [u64; 10],            // 固定数组
    mapping: HashMap<Address, u64>,    // 映射表
    option: Option<String>,            // 可选值
    result: Result<(), String>,        // 结果类型
}

// 嵌套结构
#[derive(Serialize, Deserialize, SchemaType)]
struct NestedStruct {
    config: Config,
    users: Vec<UserInfo>,
    permissions: HashMap<Address, Vec<Permission>>,
}

#[derive(Serialize, Deserialize, SchemaType)]
struct UserInfo {
    name: String,
    balance: u64,
    roles: Vec<String>,
}
```

### 自定义类型
```rust
// 地址类型
#[derive(Clone, Copy, Serialize, Deserialize, SchemaType)]
pub struct Address([u8; 20]);

// 哈希类型
#[derive(Clone, Copy, Serialize, Deserialize, SchemaType)]
pub struct Hash([u8; 32]);

// 金额类型（带精度）
#[derive(Serialize, Deserialize, SchemaType)]
pub struct Amount {
    value: u64,
    decimals: u8,
}
```

## 属性宏参数设计

### 通用属性参数
```rust
// 合约相关
contract = "contract_name"      // 合约名称
version = "1.0.0"              // 合约版本
author = "0x1234..."           // 作者地址

// 函数相关
name = "function_name"         // 函数名称
payable                         // 可接收代币
event = "EventName"            // 关联事件
view                           // 只读标记

// 状态相关
persistent                     // 持久化存储
transient                      // 临时存储
indexed                        // 建立索引
```

### 参数解析实现
```rust
fn parse_attributes(attrs: AttributeArgs) -> Result<FunctionAttributes> {
    let mut attributes = FunctionAttributes::default();
    
    for attr in attrs {
        match attr {
            // 解析合约名称
            syn::NestedMeta::Meta(syn::Meta::NameValue(nv)) 
                if nv.path.is_ident("contract") => {
                if let syn::Lit::Str(s) = nv.lit {
                    attributes.contract_name = Some(s.value());
                }
            }
            
            // 解析函数名称
            syn::NestedMeta::Meta(syn::Meta::NameValue(nv)) 
                if nv.path.is_ident("name") => {
                if let syn::Lit::Str(s) = nv.lit {
                    attributes.function_name = Some(s.value());
                }
            }
            
            // 解析payable标记
            syn::NestedMeta::Meta(syn::Meta::Path(path)) 
                if path.is_ident("payable") => {
                attributes.payable = true;
            }
            
            // 其他属性...
            _ => return Err(syn::Error::new_spanned(attr, "Unknown attribute"))
        }
    }
    
    Ok(attributes)
}
```

## 错误处理设计

### 错误类型定义
```rust
#[derive(Debug, Serialize, Deserialize, SchemaType)]
pub enum ContractError {
    // 权限错误
    Unauthorized { 
        caller: Address, 
        required: Role 
    },
    
    // 参数错误
    InvalidArgument {
        name: String,
        value: String,
        reason: String,
    },
    
    // 状态错误
    InsufficientBalance {
        address: Address,
        required: u64,
        available: u64,
    },
    
    // 业务逻辑错误
    TransferFailed {
        from: Address,
        to: Address,
        amount: u64,
        reason: String,
    },
    
    // 系统错误
    OutOfGas,
    MemoryLimitExceeded,
    UnknownError(String),
}
```

### 错误处理宏
```rust
// 错误生成宏
macro_rules! contract_error {
    ($error:expr) => {
        Err(ContractError::from($error))
    };
    
    ($variant:ident, $($field:ident = $value:expr),*) => {
        Err(ContractError::$variant {
            $($field: $value,)*
        })
    };
}

// 使用示例
fn transfer_funds(from: Address, to: Address, amount: u64) -> Result<()> {
    if amount == 0 {
        return contract_error!(InvalidArgument, 
            name = "amount", 
            value = amount.to_string(), 
            reason = "Amount must be greater than zero"
        );
    }
    
    // 其他逻辑...
    Ok(())
}
```

## 序列化规范

### JSON序列化配置
```rust
// 序列化配置
pub fn serialize<T: Serialize>(value: &T) -> Result<String> {
    serde_json::to_string(value)
        .map_err(|e| ContractError::SerializationError(e.to_string()))
}

// 反序列化配置
pub fn deserialize<T: DeserializeOwned>(json: &str) -> Result<T> {
    serde_json::from_str(json)
        .map_err(|e| ContractError::DeserializationError(e.to_string()))
}

// 带Schema的类型序列化
pub trait SchemaType: Serialize + DeserializeOwned + Sized {
    fn schema() -> Schema;
    
    fn to_json(&self) -> Result<String> {
        serialize(self)
    }
    
    fn from_json(json: &str) -> Result<Self> {
        deserialize(json)
    }
}
```

### 自定义序列化规则
```rust
// 地址类型的自定义序列化
impl Serialize for Address {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        // 转换为十六进制字符串
        let hex_string = hex::encode(self.0);
        serializer.serialize_str(&hex_string)
    }
}

impl<'de> Deserialize<'de> for Address {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        let bytes = hex::decode(s)
            .map_err(|e| de::Error::custom(e.to_string()))?;
        
        if bytes.len() != 20 {
            return Err(de::Error::custom("Invalid address length"));
        }
        
        let mut array = [0u8; 20];
        array.copy_from_slice(&bytes);
        Ok(Address(array))
    }
}
```

## 最佳实践与约定

### 命名约定
```rust
// 合约名称：小写字母，简短明确
#[contract("erc20")]
#[contract("nft")]
#[contract("dex")]

// 函数名称：camelCase，动词开头
#[call(name = "transferFrom")]
#[call(name = "approve")]
#[call(name = "mintToken")]

// 事件名称：PascalCase，名词或动名词
#[event]
enum Event {
    TransferInitiated,
    ApprovalGranted,
    OwnershipTransferred,
}
```

### 文档注释
```rust
/// ERC20代币合约实现
/// 
/// # 功能
/// - 代币发行和转账
/// - 授权管理
/// - 余额查询
/// 
/// # 安全性
/// - 重入攻击防护
/// - 溢出检查
/// - 权限控制
#[contract("erc20")]
mod erc20_contract {
    // 合约实现...
}

/// 初始化代币合约
/// 
/// # 参数
/// - `initial_supply`: 初始发行量
/// 
/// # 返回
/// - 成功: `Ok(())`
/// - 失败: 相应的错误信息
/// 
/// # 示例
/// ```ignore
/// initialize(1000000)?;
/// ```
#[init]
fn initialize(initial_supply: u64) -> Result<()> {
    // 实现逻辑...
}
```

## 总结

良好的合约语言语法设计是构建高质量智能合约的基础。通过合理的类型系统、清晰的函数签名、完善的错误处理和详细的文档注释，可以创建出既安全又易用的智能合约。

xwasm的eDSL设计充分考虑了这些因素，提供了类型安全、表达力强且易于使用的合约开发体验。在下一章中，我们将深入探讨上下文接口抽象，了解如何设计与链环境交互的接口。