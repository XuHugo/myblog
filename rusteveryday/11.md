智能合约语言（eDSL）—— 并行化方案
​
        Block-STM：一个智能合约并行执行引擎，围绕着软件事务性内存的原则建立的（Software Transactional Memory）。Transaction组成block，每个block在不同的节点执行后都需要具有相同的结果。

        Block-STM的输入是一个区块（Block），其中包含n个预设了顺序的交易，tx1，tx2 …，txn，然后并发执行区块并产生最终状态，但是最终状态与，按顺序执行tx1,tx2,…,txn——每个txj在txj+1开始前执行完成的状态——的状态保持一致。



        在Block-STM中，每个交易Block-STM会维护一个读集和一个写集，读集合包含了读取的内存位置和对应的版本，写集描述了写入的位置 ，(memory location, value)对。在一个交易的一次执行之后，需要通过Validate，Validate会重新读取读取集并比较观察到的版本。

        至于交易什么时候执行，什么时候验证，都需要调度策略去选择，调度策略会根据当前整个块的交易执行情况，以及交易之间的依赖关系等条件，去选择合适的交易去执行交易，或者验证交易。

        如果交易验证发生错误，交易需要再次执行，所以每个交易可能会被执行几次；我们把交易的第i次执行的执行称为交易的incarnation i。

任务调度策略


        用多线程去并行的执行，验证，所有的交易；

        再调度器中，各有一个整形的变量，表示当前需要执行（exe idx）或者验证（val idx）的最小交易序号；

        当没有任务时，调度器可以选择当前的exe idx或者val idx，去执行，相当于选择id最小的交易去执行或者去验证；由于是多线程，所以exe idx与val idx并不是一致的，如果执行的交易很多，验证的拉下来很多，就会选择交易去验证，反之亦然；

        当完成了执行交易，则执行交易号就会增加；验证交易也是一样的；但是idx不是只会增加不会减少的；如果验证的时候，发现某笔交易i有问题，那么i之后，一直到当前的交易idx，都需要重新执行，因为i之后的交易都有可能依赖于i；所以这个时候，exe idx就会降低到i，则i之后的交易就会重新执行。

        验证失败之后，我们会标记这个交易，涉及到写集合，标记为ESTIMATE ，如果此后有其他的交易读取到这个数据，就会立即停止，停止的交易相当于依赖之前的交易，只有之前的交易完成了，他才能继续，所以停止的交易就会等待之前的交易完成后，才会执行。

任务执行
交易的执行

这就是普通的交易执行，可以根据不同虚拟机，进行灵活的替换，例如evm，move等但是输出有一些限制，需要把交易修改和读取的数据集合单独记录，其实就是交易的读写集，这个是为了方便后续校验，以及其他交易执行时，使用；

交易的验证

其实就是验证，交易的读集合是否涉及到变动，如果有，就需要重新执行；

任务挑选

如果没有任务了，则会根据策略中，则会根据策略，挑选一个执行任务或者验证任务；

等待

如果交易出现依赖，则需要等依赖的交易完成之后，才继续进行执行交易；

线程池
使用普通的线程池就可以了，没有什么特别的。

​