智能合约语言（eDSL）—— proc_macro实现合约init函数
​
        我们通过属性宏来实现合约的init函数，call函数其实和init是类似的；

        GitHub - XuHugo/xwasm

        构建属性宏，要在cargo.toml里面设置一些参数，这是必须的。一般来说，过程宏必须是一个库，或者作为工程的子库，不能单独作为一个源文件存在。

[dependencies]
syn = { version = "1.0.63", features = [ "full", "extra-traits" ] }
quote = "=1.0.0"
proc-macro2 = "1.0"

[lib]
proc-macro = true

而编写过程宏，在stable版本里，我们需要借助三个crate:

syn，这个是用来解析语法树(AST)的。各种语法构成
quote，解析语法树，生成rust代码，从而实现你想要的新功能。
proc_macro(std) 和 proc_macro2(3rd-party)
实现init的属性宏
        函数的签名如下，这个格式除了函数名字，其他的都不要修改；

#[proc_macro_attribute]
pub fn init(attr: TokenStream, item: TokenStream) -> TokenStream {
        需要加一个关键字proc_macro_attribute；由两个参数，一个attr，一个item；对应到合约里就是如下图；



        下一步解析attr，找到contract对应的合约名称放到contract变量中；

let attrs = parse_macro_input!(attr as AttributeArgs);
let contract = get_attribute(attrs.clone(), "contract").unwrap().unwrap();
        然后处理payable，之前没有讲解这个标记的作用，其实就是标记，合约函数是否可以接口币；

let mut setup_function_args = proc_macro2::TokenStream::new();
    let mut function_args = vec![];
    let amount_ident = format_ident!("amount");

    if contains_attribute2(attrs.clone(), "payable") {
        function_args.push(quote!(#amount_ident));
    } else {
        setup_function_args.extend(quote! {
            if #amount_ident != 0 {
                return -1;
            }
        });
    };
        就是通过contains_attribute2判断是否包含，payable，如果有，就会将用户传入的代币的数量记录，否则就判断，用户传入代币数量不为零，就返回-1；

        然后就是结合合约名字，给函数重新命令，我们设定，init函数的名字为，init_合约名称，如果单单用这个做标识会有冲突，先不管这个；

let ast = parse_macro_input!(item as Item);
    let init_function_name = format_ident!("init_{}", contract.value());
    let init_name = format!("init_{}", contract.value());
        现在开始处理item了，首先判断是否是函数；不是就返回错误了；

let function_name = if let syn::Item::Fn(itemfn) = ast.clone() {
        itemfn.sig.ident
    } else {
        return syn::Error::new(Span::call_site(), format!("#[init] must be function."))
            .into_compile_error()
            .into();
    };
        最后重新组合init函数，

let output = quote! {
        #ast
        #[export_name = #init_name]
        pub extern "C" fn #init_function_name(amount:u64)->i32{
            use xq_std::{ContractContext,serde_json};
            let initctx =  ContractContext;
            #setup_function_args
            match #function_name(initctx, #(#function_args),*){
                Ok(o)=>{
                    let r = serde_json::to_string(&o).unwrap();
                    ContractContext.return_data(r.clone());
                    return 1
                }
                Err(e)=>{
                    let err = e.to_string();
                    ContractContext.error(err.clone());
                    return 0
                }
            }
        }
    };
        pub extern "C" fn 需要注意，虽然我们用rust写合约，但是写完之后，是编译成wasm格式的，相当于一个库文件了，最终谁会调用并不明确，所以需要使用这FFI的形式。

        这部分其实还是最终调用了我们item部分的函数，只是再调用之前添加一些检测和前置工作，例如payable的检测；调用之后呢，也添加了一些工作，例如，将返回值转化为json的字符串。有点类似与python的修饰符。

        call函数的实现其实和这个是一样，有细微的差别，大家可以自己去对比一下。



​