# 14. 实际应用案例与最佳实践

## 概述

本章将通过具体的应用案例展示xwasm项目在实际场景中的应用，并总结开发、部署和运维的最佳实践。这些案例涵盖了DeFi、NFT、游戏、供应链等多个领域。

## DeFi应用案例

### 去中心化交易所（DEX）

```rust
// 去中心化交易所合约
#[xwasm::contract]
pub struct DecentralizedExchange {
    #[state]
    liquidity_pools: Map<PoolId, LiquidityPool>,
    
    #[state]
    user_positions: Map<UserId, UserPosition>,
    
    #[state]
    fee_config: FeeConfiguration,
}

#[xwasm::interface]
impl DecentralizedExchange {
    /// 添加流动性
    #[payable]
    pub fn add_liquidity(
        &mut self,
        ctx: Context,
        pool_id: PoolId,
        token_a_amount: u128,
        token_b_amount: u128,
    ) -> Result<LiquidityReceipt> {
        // 验证参数
        self.validate_liquidity_params(pool_id, token_a_amount, token_b_amount)?;
        
        // 转移代币
        self.transfer_tokens_for_liquidity(ctx.sender(), token_a_amount, token_b_amount)?;
        
        // 更新流动性池
        let liquidity_amount = self.update_liquidity_pool(
            pool_id,
            token_a_amount,
            token_b_amount,
            ctx.sender(),
        )?;
        
        // 记录用户头寸
        self.record_user_position(pool_id, ctx.sender(), liquidity_amount)?;
        
        // 生成流动性凭证
        let receipt = LiquidityReceipt {
            pool_id,
            liquidity_amount,
            timestamp: ctx.block_timestamp(),
        };
        
        Ok(receipt)
    }
    
    /// 执行交易
    pub fn swap(
        &mut self,
        ctx: Context,
        pool_id: PoolId,
        input_token: TokenId,
        input_amount: u128,
        min_output_amount: u128,
    ) -> Result<SwapResult> {
        // 验证交易参数
        self.validate_swap_params(pool_id, input_token, input_amount, min_output_amount)?;
        
        // 计算交易输出
        let output_amount = self.calculate_swap_output(
            pool_id,
            input_token,
            input_amount,
        )?;
        
        // 检查最小输出
        if output_amount < min_output_amount {
            return Err(Error::InsufficientOutput);
        }
        
        // 执行代币转移
        self.execute_token_transfer(
            ctx.sender(),
            input_token,
            input_amount,
            output_amount,
        )?;
        
        // 更新池子状态
        self.update_pool_after_swap(pool_id, input_token, input_amount, output_amount)?;
        
        // 收取交易费用
        let fees = self.collect_swap_fees(pool_id, input_amount)?;
        
        Ok(SwapResult {
            input_amount,
            output_amount,
            fees,
            price_impact: self.calculate_price_impact(pool_id, input_amount, output_amount),
        })
    }
    
    /// 移除流动性
    pub fn remove_liquidity(
        &mut self,
        ctx: Context,
        pool_id: PoolId,
        liquidity_amount: u128,
    ) -> Result<RemoveLiquidityResult> {
        // 验证用户头寸
        let position = self.validate_user_position(pool_id, ctx.sender(), liquidity_amount)?;
        
        // 计算应得代币
        let (token_a_amount, token_b_amount) = self.calculate_withdrawal_amounts(
            pool_id,
            liquidity_amount,
        )?;
        
        // 转移代币给用户
        self.transfer_tokens_to_user(
            ctx.sender(),
            token_a_amount,
            token_b_amount,
        )?;
        
        // 更新流动性池
        self.update_pool_after_withdrawal(pool_id, liquidity_amount)?;
        
        // 更新用户头寸
        self.update_user_position(pool_id, ctx.sender(), liquidity_amount)?;
        
        Ok(RemoveLiquidityResult {
            token_a_amount,
            token_b_amount,
            liquidity_removed: liquidity_amount,
        })
    }
}

// 流动性池管理
impl DecentralizedExchange {
    fn update_liquidity_pool(
        &mut self,
        pool_id: PoolId,
        token_a_amount: u128,
        token_b_amount: u128,
        provider: UserId,
    ) -> Result<u128> {
        let pool = self.liquidity_pools.get_mut(&pool_id)
            .ok_or(Error::PoolNotFound)?;
        
        // 计算流动性份额
        let liquidity_amount = pool.calculate_liquidity_amount(token_a_amount, token_b_amount);
        
        // 更新池子储备
        pool.reserve_a += token_a_amount;
        pool.reserve_b += token_b_amount;
        pool.total_liquidity += liquidity_amount;
        
        // 记录提供者份额
        pool.provider_shares.entry(provider)
            .and_modify(|shares| *shares += liquidity_amount)
            .or_insert(liquidity_amount);
        
        Ok(liquidity_amount)
    }
    
    fn calculate_swap_output(
        &self,
        pool_id: PoolId,
        input_token: TokenId,
        input_amount: u128,
    ) -> Result<u128> {
        let pool = self.liquidity_pools.get(&pool_id)
            .ok_or(Error::PoolNotFound)?;
        
        // 基于恒定乘积公式计算输出
        let (reserve_in, reserve_out) = match input_token {
            TokenId::A => (pool.reserve_a, pool.reserve_b),
            TokenId::B => (pool.reserve_b, pool.reserve_a),
        };
        
        let input_amount_with_fee = input_amount * (1000 - pool.fee_rate) / 1000;
        let numerator = input_amount_with_fee * reserve_out;
        let denominator = reserve_in * 1000 + input_amount_with_fee;
        
        Ok(numerator / denominator)
    }
}
```

### 借贷协议

```rust
// 借贷协议合约
#[xwasm::contract]
pub struct LendingProtocol {
    #[state]
    markets: Map<AssetId, Market>,
    
    #[state]
    user_balances: Map<UserId, UserBalance>,
    
    #[state]
    interest_rate_model: InterestRateModel,
}

#[xwasm::interface]
impl LendingProtocol {
    /// 存款
    #[payable]
    pub fn deposit(
        &mut self,
        ctx: Context,
        asset_id: AssetId,
        amount: u128,
    ) -> Result<DepositReceipt> {
        // 验证存款参数
        self.validate_deposit_params(asset_id, amount)?;
        
        // 转移存款资产
        self.transfer_deposit_asset(ctx.sender(), asset_id, amount)?;
        
        // 更新市场状态
        let interest_index = self.update_market_deposit(asset_id, amount)?;
        
        // 更新用户余额
        let user_balance = self.update_user_balance(
            ctx.sender(),
            asset_id,
            amount,
            interest_index,
        )?;
        
        // 铸造存款凭证
        self.mint_deposit_certificate(ctx.sender(), asset_id, amount)?;
        
        Ok(DepositReceipt {
            asset_id,
            amount,
            interest_index,
            user_balance,
        })
    }
    
    /// 借款
    pub fn borrow(
        &mut self,
        ctx: Context,
        asset_id: AssetId,
        amount: u128,
        collateral_asset: AssetId,
        collateral_amount: u128,
    ) -> Result<BorrowReceipt> {
        // 验证借款参数
        self.validate_borrow_params(
            ctx.sender(),
            asset_id,
            amount,
            collateral_asset,
            collateral_amount,
        )?;
        
        // 检查抵押品充足性
        self.check_collateral_sufficiency(
            ctx.sender(),
            collateral_asset,
            collateral_amount,
            asset_id,
            amount,
        )?;
        
        // 更新借款状态
        let borrow_info = self.update_borrow_state(
            ctx.sender(),
            asset_id,
            amount,
            collateral_asset,
            collateral_amount,
        )?;
        
        // 转移借款资产
        self.transfer_borrow_asset(ctx.sender(), asset_id, amount)?;
        
        // 记录借款事件
        self.record_borrow_event(ctx.sender(), asset_id, amount, borrow_info.interest_rate)?;
        
        Ok(BorrowReceipt {
            asset_id,
            amount,
            interest_rate: borrow_info.interest_rate,
            collateral_asset,
            collateral_amount,
        })
    }
    
    /// 还款
    pub fn repay(
        &mut self,
        ctx: Context,
        asset_id: AssetId,
        amount: u128,
    ) -> Result<RepayReceipt> {
        // 验证还款参数
        let (principal, interest) = self.validate_repay_params(ctx.sender(), asset_id, amount)?;
        
        // 转移还款资产
        self.transfer_repay_asset(ctx.sender(), asset_id, amount)?;
        
        // 更新借款状态
        let remaining_debt = self.update_repay_state(
            ctx.sender(),
            asset_id,
            principal,
            interest,
        )?;
        
        // 释放部分抵押品
        let released_collateral = self.release_collateral(ctx.sender(), asset_id, amount)?;
        
        Ok(RepayReceipt {
            asset_id,
            principal_repaid: principal,
            interest_paid: interest,
            remaining_debt,
            released_collateral,
        })
    }
}

// 利率模型实现
impl LendingProtocol {
    fn calculate_borrow_interest_rate(
        &self,
        asset_id: AssetId,
        utilization_rate: f64,
    ) -> f64 {
        let market = self.markets.get(&asset_id).expect("Market should exist");
        
        match market.interest_rate_model {
            InterestRateModel::Linear { base_rate, slope } => {
                base_rate + utilization_rate * slope
            }
            InterestRateModel::Kink { 
                base_rate, 
                slope1, 
                slope2, 
                kink 
            } => {
                if utilization_rate <= kink {
                    base_rate + utilization_rate * slope1
                } else {
                    base_rate + kink * slope1 + (utilization_rate - kink) * slope2
                }
            }
            InterestRateModel::Jump { 
                base_rate, 
                slope, 
                jump_slope, 
                jump_utilization 
            } => {
                if utilization_rate <= jump_utilization {
                    base_rate + utilization_rate * slope
                } else {
                    base_rate + jump_utilization * slope + 
                    (utilization_rate - jump_utilization) * jump_slope
                }
            }
        }
    }
    
    fn update_interest_accrual(&mut self, asset_id: AssetId) -> Result<()> {
        let market = self.markets.get_mut(&asset_id)
            .ok_or(Error::MarketNotFound)?;
        
        let current_timestamp = self.get_current_timestamp();
        let time_elapsed = current_timestamp - market.last_accrual_timestamp;
        
        if time_elapsed > 0 {
            // 计算应计利息
            let utilization_rate = market.calculate_utilization_rate();
            let borrow_rate = self.calculate_borrow_interest_rate(asset_id, utilization_rate);
            
            let interest_accrued = market.total_borrows * borrow_rate * time_elapsed as f64 / 365.25 / 24.0 / 3600.0;
            
            // 更新市场状态
            market.total_supply += interest_accrued as u128;
            market.total_borrows += interest_accrued as u128;
            market.interest_index *= (1.0 + borrow_rate * time_elapsed as f64 / 365.25 / 24.0 / 3600.0) as f64;
            market.last_accrual_timestamp = current_timestamp;
        }
        
        Ok(())
    }
}
```

## NFT应用案例

### NFT市场合约

```rust
// NFT市场合约
#[xwasm::contract]
pub struct NFTMarketplace {
    #[state]
    listings: Map<NftId, Listing>,
    
    #[state]
    offers: Map<OfferId, Offer>,
    
    #[state]
    fee_config: MarketplaceFeeConfig,
    
    #[state]
    royalty_registry: RoyaltyRegistry,
}

#[xwasm::interface]
impl NFTMarketplace {
    /// 上架NFT
    pub fn list_nft(
        &mut self,
        ctx: Context,
        nft_id: NftId,
        price: u128,
        currency: CurrencyId,
        duration: u64,
    ) -> Result<ListingReceipt> {
        // 验证NFT所有权
        self.validate_nft_ownership(ctx.sender(), nft_id)?;
        
        // 验证上架参数
        self.validate_listing_params(price, currency, duration)?;
        
        // 转移NFT到市场托管
        self.transfer_nft_to_escrow(ctx.sender(), nft_id)?;
        
        // 创建上架记录
        let listing = self.create_listing(
            nft_id,
            ctx.sender(),
            price,
            currency,
            duration,
            ctx.block_timestamp(),
        )?;
        
        Ok(ListingReceipt {
            listing_id: listing.id,
            nft_id,
            price,
            currency,
            expiration: listing.expiration,
        })
    }
    
    /// 购买NFT
    #[payable]
    pub fn buy_nft(
        &mut self,
        ctx: Context,
        listing_id: ListingId,
    ) -> Result<PurchaseReceipt> {
        // 验证上架有效性
        let listing = self.validate_listing(listing_id)?;
        
        // 验证支付金额
        self.validate_payment_amount(ctx.value(), listing.price, listing.currency)?;
        
        // 执行支付
        self.execute_payment(
            ctx.sender(),
            listing.seller,
            listing.price,
            listing.currency,
        )?;
        
        // 转移NFT所有权
        self.transfer_nft_ownership(listing.nft_id, ctx.sender())?;
        
        // 支付版税
        let royalties = self.pay_royalties(listing.nft_id, listing.price, listing.currency)?;
        
        // 支付市场费用
        let fees = self.collect_marketplace_fees(listing.price, listing.currency)?;
        
        // 更新上架状态
        self.update_listing_after_sale(listing_id)?;
        
        Ok(PurchaseReceipt {
            nft_id: listing.nft_id,
            price: listing.price,
            currency: listing.currency,
            royalties,
            fees,
        })
    }
    
    /// 取消上架
    pub fn cancel_listing(
        &mut self,
        ctx: Context,
        listing_id: ListingId,
    ) -> Result<CancelReceipt> {
        // 验证上架所有权
        let listing = self.validate_listing_ownership(ctx.sender(), listing_id)?;
        
        // 返还NFT
        self.return_nft_from_escrow(listing.seller, listing.nft_id)?;
        
        // 更新上架状态
        self.update_listing_after_cancellation(listing_id)?;
        
        Ok(CancelReceipt {
            listing_id,
            nft_id: listing.nft_id,
        })
    }
    
    /// 创建报价
    pub fn make_offer(
        &mut self,
        ctx: Context,
        nft_id: NftId,
        price: u128,
        currency: CurrencyId,
        expiration: u64,
    ) -> Result<OfferReceipt> {
        // 验证报价参数
        self.validate_offer_params(price, currency, expiration)?;
        
        // 锁定报价资金
        self.lock_offer_funds(ctx.sender(), price, currency)?;
        
        // 创建报价记录
        let offer = self.create_offer(
            nft_id,
            ctx.sender(),
            price,
            currency,
            expiration,
            ctx.block_timestamp(),
        )?;
        
        Ok(OfferReceipt {
            offer_id: offer.id,
            nft_id,
            price,
            currency,
            expiration: offer.expiration,
        })
    }
    
    /// 接受报价
    pub fn accept_offer(
        &mut self,
        ctx: Context,
        offer_id: OfferId,
    ) -> Result<AcceptOfferReceipt> {
        // 验证报价有效性
        let offer = self.validate_offer(offer_id)?;
        
        // 验证NFT所有权
        self.validate_nft_ownership(ctx.sender(), offer.nft_id)?;
        
        // 执行交易
        self.execute_offer_transaction(
            offer.buyer,
            ctx.sender(),
            offer.price,
            offer.currency,
            offer.nft_id,
        )?;
        
        // 支付版税和费用
        let royalties = self.pay_royalties(offer.nft_id, offer.price, offer.currency)?;
        let fees = self.collect_marketplace_fees(offer.price, offer.currency)?;
        
        // 更新报价状态
        self.update_offer_after_acceptance(offer_id)?;
        
        Ok(AcceptOfferReceipt {
            offer_id,
            nft_id: offer.nft_id,
            price: offer.price,
            currency: offer.currency,
            royalties,
            fees,
        })
    }
}

// 版税管理
impl NFTMarketplace {
    fn pay_royalties(
        &mut self,
        nft_id: NftId,
        sale_price: u128,
        currency: CurrencyId,
    ) -> Result<RoyaltyPayment> {
        // 获取版税信息
        let royalty_info = self.royalty_registry.get_royalty_info(nft_id)?;
        
        // 计算版税金额
        let royalty_amount = sale_price * royalty_info.percentage / 10000; // 基点表示
        
        if royalty_amount > 0 {
            // 支付版税
            self.transfer_royalty_payment(
                royalty_info.recipient,
                royalty_amount,
                currency,
            )?;
        }
        
        Ok(RoyaltyPayment {
            recipient: royalty_info.recipient,
            amount: royalty_amount,
            percentage: royalty_info.percentage,
        })
    }
    
    fn collect_marketplace_fees(
        &mut self,
        sale_price: u128,
        currency: CurrencyId,
    ) -> Result<MarketplaceFee> {
        let fee_amount = sale_price * self.fee_config.fee_percentage / 10000;
        
        if fee_amount > 0 {
            // 收取市场费用
            self.transfer_marketplace_fee(fee_amount, currency)?;
        }
        
        Ok(MarketplaceFee {
            amount: fee_amount,
            percentage: self.fee_config.fee_percentage,
            recipient: self.fee_config.fee_recipient,
        })
    }
}
```

### 游戏应用案例

```rust
// 游戏合约
#[xwasm::contract]
pub struct BlockchainGame {
    #[state]
    players: Map<PlayerId, Player>,
    
    #[state]
    items: Map<ItemId, GameItem>,
    
    #[state]
    battles: Map<BattleId, Battle>,
    
    #[state]
    economy: GameEconomy,
}

#[xwasm::interface]
impl BlockchainGame {
    /// 创建玩家
    pub fn create_player(
        &mut self,
        ctx: Context,
        name: String,
        character_class: CharacterClass,
    ) -> Result<PlayerCreationReceipt> {
        // 验证玩家名称
        self.validate_player_name(&name)?;
        
        // 创建玩家记录
        let player = self.create_player_record(
            ctx.sender(),
            name,
            character_class,
            ctx.block_timestamp(),
        )?;
        
        // 分配初始装备
        self.grant_initial_equipment(player.id)?;
        
        Ok(PlayerCreationReceipt {
            player_id: player.id,
            name: player.name,
            character_class: player.character_class,
            created_at: player.created_at,
        })
    }
    
    /// 开始战斗
    pub fn start_battle(
        &mut self,
        ctx: Context,
        opponent_id: PlayerId,
    ) -> Result<BattleStartReceipt> {
        // 验证玩家状态
        let player = self.validate_player_state(ctx.sender())?;
        let opponent = self.validate_player_state(opponent_id)?;
        
        // 验证战斗条件
        self.validate_battle_conditions(&player, &opponent)?;
        
        // 创建战斗记录
        let battle = self.create_battle_record(player.id, opponent.id, ctx.block_timestamp())?;
        
        // 扣除战斗能量
        self.deduct_battle_energy(player.id)?;
        
        Ok(BattleStartReceipt {
            battle_id: battle.id,
            player_id: player.id,
            opponent_id: opponent.id,
            start_time: battle.start_time,
        })
    }
    
    /// 结束战斗
    pub fn end_battle(
        &mut self,
        ctx: Context,
        battle_id: BattleId,
        player_actions: Vec<Action>,
        opponent_actions: Vec<Action>,
    ) -> Result<BattleResultReceipt> {
        // 验证战斗状态
        let battle = self.validate_battle_state(battle_id)?;
        
        // 验证参与者
        self.validate_battle_participants(ctx.sender(), battle.player_id, battle.opponent_id)?;
        
        // 模拟战斗
        let result = self.simulate_battle(
            battle.player_id,
            battle.opponent_id,
            player_actions,
            opponent_actions,
        )?;
        
        // 更新战斗结果
        self.update_battle_result(battle_id, &result)?;
        
        // 分配奖励
        let rewards = self.distribute_battle_rewards(&battle, &result)?;
        
        // 更新玩家状态
        self.update_players_after_battle(battle.player_id, battle.opponent_id, &result, &rewards)?;
        
        Ok(BattleResultReceipt {
            battle_id,
            winner: result.winner,
            rewards,
            experience_gained: result.experience_gained,
            duration: ctx.block_timestamp() - battle.start_time,
        })
    }
    
    /// 铸造游戏物品
    pub fn mint_item(
        &mut self,
        ctx: Context,
        item_template_id: ItemTemplateId,
        quantity: u32,
    ) -> Result<ItemMintingReceipt> {
        // 验证铸造权限
        self.validate_minting_permission(ctx.sender())?;
        
        // 验证物品模板
        let template = self.validate_item_template(item_template_id)?;
        
        // 计算铸造成本
        let cost = self.calculate_minting_cost(template, quantity)?;
        
        // 收取铸造费用
        self.collect_minting_fee(ctx.sender(), cost)?;
        
        // 生成物品
        let items = self.generate_items(template, quantity, ctx.block_timestamp())?;
        
        // 分配物品给玩家
        self.distribute_items_to_player(ctx.sender(), &items)?;
        
        Ok(ItemMintingReceipt {
            items: items.iter().map(|item| item.id).collect(),
            template_id: template.id,
            quantity,
            cost,
        })
    }
    
    /// 交易物品
    pub fn trade_item(
        &mut self,
        ctx: Context,
        item_id: ItemId,
        recipient: PlayerId,
        price: u128,
        currency: CurrencyId,
    ) -> Result<TradeReceipt> {
        // 验证物品所有权
        self.validate_item_ownership(ctx.sender(), item_id)?;
        
        // 验证交易参数
        self.validate_trade_params(recipient, price, currency)?;
        
        // 执行交易
        self.execute_trade(
            ctx.sender(),
            recipient,
            item_id,
            price,
            currency,
        )?;
        
        // 记录交易历史
        self.record_trade_history(
            item_id,
            ctx.sender(),
            recipient,
            price,
            currency,
            ctx.block_timestamp(),
        )?;
        
        Ok(TradeReceipt {
            item_id,
            seller: ctx.sender(),
            buyer: recipient,
            price,
            currency,
            timestamp: ctx.block_timestamp(),
        })
    }
}

// 战斗系统
impl BlockchainGame {
    fn simulate_battle(
        &self,
        player_id: PlayerId,
        opponent_id: PlayerId,
        player_actions: Vec<Action>,
        opponent_actions: Vec<Action>,
    ) -> Result<BattleResult> {
        let player = self.players.get(&player_id).ok_or(Error::PlayerNotFound)?;
        let opponent = self.players.get(&opponent_id).ok_or(Error::PlayerNotFound)?;
        
        let mut battle_simulator = BattleSimulator::new(player.clone(), opponent.clone());
        
        // 执行战斗回合
        for (player_action, opponent_action) in player_actions.iter().zip(opponent_actions.iter()) {
            battle_simulator.execute_round(player_action, opponent_action)?;
            
            if battle_simulator.is_battle_over() {
                break;
            }
        }
        
        // 生成战斗结果
        let result = battle_simulator.get_result();
        
        Ok(result)
    }
    
    fn distribute_battle_rewards(
        &mut self,
        battle: &Battle,
        result: &BattleResult,
    ) -> Result<BattleRewards> {
        let mut rewards = BattleRewards::new();
        
        // 经验奖励
        if let Some(winner_id) = result.winner {
            let experience = self.calculate_experience_reward(winner_id, result.difficulty);
            self.award_experience(winner_id, experience)?;
            rewards.experience = experience;
        }
        
        // 物品掉落
        if result.winner.is_some() {
            let dropped_items = self.generate_item_drops(result.difficulty, result.loot_table)?;
            if let Some(winner_id) = result.winner {
                self.award_items(winner_id, &dropped_items)?;
                rewards.items = dropped_items;
            }
        }
        
        // 货币奖励
        if let Some(winner_id) = result.winner {
            let currency_reward = self.calculate_currency_reward(result.difficulty);
            self.award_currency(winner_id, currency_reward)?;
            rewards.currency = currency_reward;
        }
        
        Ok(rewards)
    }
}
```

## 供应链应用案例

```rust
// 供应链追踪合约
#[xwasm::contract]
pub struct SupplyChain {
    #[state]
    products: Map<ProductId, Product>,
    
    #[state]
    batches: Map<BatchId, Batch>,
    
    #[state]
    shipments: Map<ShipmentId, Shipment>,
    
    #[state]
    participants: Map<ParticipantId, Participant>,
}

#[xwasm::interface]
impl SupplyChain {
    /// 注册产品
    pub fn register_product(
        &mut self,
        ctx: Context,
        name: String,
        description: String,
        specifications: ProductSpecifications,
    ) -> Result<ProductRegistrationReceipt> {
        // 验证注册权限
        self.validate_registration_permission(ctx.sender())?;
        
        // 创建产品记录
        let product = self.create_product_record(
            name,
            description,
            specifications,
            ctx.sender(),
            ctx.block_timestamp(),
        )?;
        
        Ok(ProductRegistrationReceipt {
            product_id: product.id,
            name: product.name,
            manufacturer: product.manufacturer,
            created_at: product.created_at,
        })
    }
    
    /// 创建生产批次
    pub fn create_batch(
        &mut self,
        ctx: Context,
        product_id: ProductId,
        quantity: u32,
        production_date: u64,
        expiration_date: u64,
        ingredients: Vec<Ingredient>,
    ) -> Result<BatchCreationReceipt> {
        // 验证产品权限
        self.validate_product_permission(ctx.sender(), product_id)?;
        
        // 创建批次记录
        let batch = self.create_batch_record(
            product_id,
            quantity,
            production_date,
            expiration_date,
            ingredients,
            ctx.sender(),
            ctx.block_timestamp(),
        )?;
        
        // 记录生产事件
        self.record_production_event(
            batch.id,
            product_id,
            quantity,
            ctx.sender(),
            ctx.block_timestamp(),
        )?;
        
        Ok(BatchCreationReceipt {
            batch_id: batch.id,
            product_id,
            quantity,
            production_date,
            manufacturer: batch.manufacturer,
        })
    }
    
    /// 运输货物
    pub fn ship_batch(
        &mut self,
        ctx: Context,
        batch_id: BatchId,
        destination: ParticipantId,
        shipping_method: ShippingMethod,
        estimated_duration: u64,
    ) -> Result<ShipmentReceipt> {
        // 验证批次所有权
        let batch = self.validate_batch_ownership(ctx.sender(), batch_id)?;
        
        // 验证目的地
        self.validate_destination(destination)?;
        
        // 创建运输记录
        let shipment = self.create_shipment_record(
            batch_id,
            batch.product_id,
            ctx.sender(),
            destination,
            shipping_method,
            estimated_duration,
            ctx.block_timestamp(),
        )?;
        
        // 更新批次状态
        self.update_batch_shipment_status(batch_id, shipment.id)?;
        
        // 记录运输事件
        self.record_shipping_event(
            shipment.id,
            batch_id,
            ctx.sender(),
            destination,
            ctx.block_timestamp(),
        )?;
        
        Ok(ShipmentReceipt {
            shipment_id: shipment.id,
            batch_id,
            shipper: ctx.sender(),
            destination,
            shipping_method,
            estimated_arrival: shipment.estimated_arrival,
        })
    }
    
    /// 确认收货
    pub fn confirm_receipt(
        &mut self,
        ctx: Context,
        shipment_id: ShipmentId,
        actual_quantity: u32,
        condition: ProductCondition,
    ) -> Result<ReceiptConfirmation> {
        // 验证收货权限
        let shipment = self.validate_receipt_permission(ctx.sender(), shipment_id)?;
        
        // 验证运输状态
        self.validate_shipment_status(shipment_id)?;
        
        // 更新收货信息
        self.update_receipt_information(
            shipment_id,
            actual_quantity,
            condition,
            ctx.block_timestamp(),
        )?;
        
        // 记录收货事件
        self.record_receipt_event(
            shipment_id,
            actual_quantity,
            condition,
            ctx.sender(),
            ctx.block_timestamp(),
        )?;
        
        // 更新库存
        self.update_inventory(
            shipment.product_id,
            actual_quantity,
            condition,
            ctx.sender(),
        )?;
        
        Ok(ReceiptConfirmation {
            shipment_id,
            batch_id: shipment.batch_id,
            actual_quantity,
            condition,
            received_at: ctx.block_timestamp(),
            receiver: ctx.sender(),
        })
    }
}

// 供应链追踪实现
impl SupplyChain {
    fn validate_registration_permission(&self, sender: ParticipantId) -> Result<()> {
        let participant = self.participants.get(&sender)
            .ok_or(Error::ParticipantNotFound)?;
        
        if !participant.roles.contains(&ParticipantRole::Manufacturer) {
            return Err(Error::InsufficientPermission);
        }
        
        Ok(())
    }
    
    fn create_product_record(
        &mut self,
        name: String,
        description: String,
        specifications: ProductSpecifications,
        manufacturer: ParticipantId,
        timestamp: u64,
    ) -> Result<Product> {
        let product_id = self.generate_product_id(&name, timestamp);
        
        let product = Product {
            id: product_id,
            name,
            description,
            specifications,
            manufacturer,
            created_at: timestamp,
            updated_at: timestamp,
            status: ProductStatus::Active,
        };
        
        self.products.insert(product.id, product.clone());
        
        Ok(product)
    }
    
    fn record_production_event(
        &mut self,
        batch_id: BatchId,
        product_id: ProductId,
        quantity: u32,
        manufacturer: ParticipantId,
        timestamp: u64,
    ) -> Result<()> {
        let event = ProductionEvent {
            id: self.generate_event_id(),
            batch_id,
            product_id,
            quantity,
            manufacturer,
            timestamp,
            location: self.get_participant_location(manufacturer)?,
            equipment: self.get_production_equipment(manufacturer)?,
            quality_metrics: self.calculate_quality_metrics(product_id, quantity)?,
        };
        
        self.production_events.insert(event.id, event);
        
        Ok(())
    }
}

## 最佳实践

### 开发最佳实践

#### 1. 代码组织和架构

```rust
// 推荐的项目结构
xwasm-project/
├── Cargo.toml
├── src/
│   ├── lib.rs              # 库入口点
│   ├── contract/           # 合约相关代码
│   │   ├── mod.rs
│   │   ├── dex.rs          # 去中心化交易所
│   │   ├── lending.rs       # 借贷协议
│   │   └── nft.rs          # NFT市场
│   ├── types/              # 类型定义
│   │   ├── mod.rs
│   │   ├── common.rs
│   │   ├── financial.rs
│   │   └── gaming.rs
│   ├── utils/              # 工具函数
│   │   ├── mod.rs
│   │   ├── math.rs
│   │   ├── validation.rs
│   │   └── conversion.rs
│   ├── error.rs            # 错误处理
│   └── config.rs           # 配置管理
├── tests/                  # 集成测试
│   ├── dex_test.rs
│   ├── lending_test.rs
│   └── nft_test.rs
└── benchmarks/             # 性能测试
    ├── dex_bench.rs
    └── lending_bench.rs
```

#### 2. 错误处理模式

```rust
// 统一的错误处理
#[derive(Debug, thiserror::Error)]
pub enum ContractError {
    #[error("权限不足: {0}")]
    InsufficientPermission(String),
    
    #[error("验证失败: {0}")]
    ValidationError(String),
    
    #[error("数学计算错误: {0}")]
    MathError(String),
    
    #[error("状态错误: {0}")]
    StateError(String),
    
    #[error("资源不足: {0}")]
    InsufficientResources(String),
    
    #[error("超时: {0}")]
    Timeout(String),
    
    #[error("未知错误: {0}")]
    Unknown(String),
}

// 错误处理宏
macro_rules! ensure_permission {
    ($condition:expr, $message:expr) => {
        if !$condition {
            return Err(ContractError::InsufficientPermission($message.to_string()));
        }
    };
}

macro_rules! ensure_validation {
    ($condition:expr, $message:expr) => {
        if !$condition {
            return Err(ContractError::ValidationError($message.to_string()));
        }
    };
}

// 使用示例
fn validate_transaction(
    &self,
    sender: UserId,
    amount: u128,
) -> Result<()> {
    ensure_permission!(
        self.is_user_active(sender),
        "用户账户未激活"
    );
    
    ensure_validation!(
        amount > 0,
        "交易金额必须大于零"
    );
    
    ensure_validation!(
        self.has_sufficient_balance(sender, amount),
        "余额不足"
    );
    
    Ok(())
}
```

#### 3. 测试策略

```rust
// 单元测试
#[cfg(test)]
mod tests {
    use super::*;
    use xwasm::mock::{MockContext, MockStorage};
    
    #[test]
    fn test_dex_add_liquidity() {
        let mut context = MockContext::new();
        let mut storage = MockStorage::new();
        
        // 初始化测试环境
        let mut dex = DecentralizedExchange::new();
        context.set_sender("user1");
        context.set_value(1000);
        
        // 执行测试
        let result = dex.add_liquidity(
            context.clone(),
            PoolId::new("ETH", "USDC"),
            500,
            2000,
        );
        
        // 验证结果
        assert!(result.is_ok());
        let receipt = result.unwrap();
        assert_eq!(receipt.liquidity_amount, 1000);
        
        // 验证状态变化
        let pool = dex.get_liquidity_pool(PoolId::new("ETH", "USDC")).unwrap();
        assert_eq!(pool.reserve_a, 500);
        assert_eq!(pool.reserve_b, 2000);
    }
    
    #[test]
    fn test_dex_swap_insufficient_output() {
        let mut context = MockContext::new();
        let mut storage = MockStorage::new();
        
        let mut dex = DecentralizedExchange::new();
        context.set_sender("user1");
        
        // 设置初始流动性
        dex.setup_test_liquidity();
        
        // 尝试执行会失败的交易
        let result = dex.swap(
            context.clone(),
            PoolId::new("ETH", "USDC"),
            TokenId::A,
            100,
            500, // 期望输出过高
        );
        
        // 验证错误
        assert!(result.is_err());
        assert_eq!(
            result.unwrap_err().to_string(),
            "ValidationError: 输出金额不足"
        );
    }
}

// 集成测试
#[cfg(test)]
mod integration_tests {
    use super::*;
    use xwasm::testing::TestRunner;
    
    #[test]
    fn test_complete_dex_workflow() {
        let mut runner = TestRunner::new();
        
        // 部署合约
        let dex_addr = runner.deploy_contract(DecentralizedExchange::new());
        
        // 初始化用户
        runner.create_user("user1", 10000);
        runner.create_user("user2", 5000);
        
        // 测试添加流动性
        let add_liq_result = runner.execute(
            dex_addr,
            "add_liquidity",
            json!({
                "pool_id": "ETH-USDC",
                "token_a_amount": 1000,
                "token_b_amount": 4000
            }),
            "user1",
            1000
        );
        
        assert!(add_liq_result.success);
        
        // 测试交易
        let swap_result = runner.execute(
            dex_addr,
            "swap",
            json!({
                "pool_id": "ETH-USDC",
                "input_token": "ETH",
                "input_amount": 100,
                "min_output_amount": 350
            }),
            "user2",
            100
        );
        
        assert!(swap_result.success);
        
        // 验证最终状态
        let pool_state = runner.query(
            dex_addr,
            "get_pool_state",
            json!({"pool_id": "ETH-USDC"})
        );
        
        assert_eq!(pool_state["reserve_a"], 1100);
        assert_eq!(pool_state["reserve_b"], 3636);
    }
}
```

#### 4. 性能优化

```rust
// 内存优化
struct OptimizedStorage {
    // 使用更紧凑的数据结构
    data: HashMap<Key, Value, BuildHasherDefault<FxHasher>>,
    
    // 批量操作减少状态写入
    pending_writes: Vec<(Key, Value)>,
    
    // 缓存频繁访问的数据
    cache: LruCache<Key, Value>,
}

// 计算优化
fn optimized_calculation(input: &[u128]) -> u128 {
    // 使用迭代器避免中间分配
    input.iter()
        .filter(|&&x| x > 0)
        .map(|&x| x * 2)
        .fold(0u128, |acc, x| acc.saturating_add(x))
}

// Gas优化
fn gas_optimized_operation(&mut self) -> Result<()> {
    // 尽早进行验证，避免不必要的计算
    self.validate_early()?;
    
    // 使用内联函数减少调用开销
    let result = self.do_calculation_inline();
    
    // 批量状态更新
    self.batch_update_state();
    
    Ok(())
}
```

### 部署最佳实践

#### 1. 环境配置

```rust
// 多环境配置
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EnvironmentConfig {
    pub network: NetworkConfig,
    pub database: DatabaseConfig,
    pub caching: CacheConfig,
    pub monitoring: MonitoringConfig,
    pub security: SecurityConfig,
}

// 环境特定的配置
impl EnvironmentConfig {
    pub fn development() -> Self {
        Self {
            network: NetworkConfig {
                rpc_url: "http://localhost:8545".to_string(),
                chain_id: 1337,
                gas_limit: 30_000_000,
            },
            database: DatabaseConfig {
                url: "postgresql://localhost:5432/dev".to_string(),
                pool_size: 10,
            },
            caching: CacheConfig {
                enabled: true,
                ttl: 300, // 5分钟
            },
            monitoring: MonitoringConfig {
                enabled: false,
                prometheus_url: "http://localhost:9090".to_string(),
            },
            security: SecurityConfig {
                https_only: false,
                rate_limiting: RateLimitConfig {
                    requests_per_minute: 1000,
                },
            },
        }
    }
    
    pub fn production() -> Self {
        Self {
            network: NetworkConfig {
                rpc_url: std::env::var("RPC_URL").expect("RPC_URL must be set"),
                chain_id: 1,
                gas_limit: 10_000_000,
            },
            database: DatabaseConfig {
                url: std::env::var("DATABASE_URL").expect("DATABASE_URL must be set"),
                pool_size: 50,
            },
            caching: CacheConfig {
                enabled: true,
                ttl: 60, // 1分钟
            },
            monitoring: MonitoringConfig {
                enabled: true,
                prometheus_url: std::env::var("PROMETHEUS_URL").expect("PROMETHEUS_URL must be set"),
            },
            security: SecurityConfig {
                https_only: true,
                rate_limiting: RateLimitConfig {
                    requests_per_minute: 100,
                },
            },
        }
    }
}
```

#### 2. 部署脚本

```bash
#!/bin/bash
# deploy.sh - 自动化部署脚本

set -euo pipefail

# 配置
ENVIRONMENT=${1:-production}
CONTRACT_NAME="DecentralizedExchange"
NETWORK="mainnet"

# 颜色输出
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

log() {
    echo -e "${GREEN}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} $1"
}

warn() {
    echo -e "${YELLOW}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} $1"
}

error() {
    echo -e "${RED}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} $1"
    exit 1
}

# 检查依赖
check_dependencies() {
    log "检查依赖..."
    
    command -v cargo >/dev/null 2>&1 || error "请安装 Rust 和 Cargo"
    command -v forge >/dev/null 2>&1 || error "请安装 Foundry"
    command -v node >/dev/null 2>&1 || error "请安装 Node.js"
    
    log "所有依赖已安装"
}

# 构建合约
build_contract() {
    log "构建合约..."
    
    cd contract/
    
    # 清理旧构建
    rm -rf target/ && rm -rf artifacts/
    
    # 测试
    log "运行测试..."
    cargo test --release -- --nocapture || error "测试失败"
    
    # 构建
    log "编译合约..."
    cargo build --release --target wasm32-unknown-unknown || error "编译失败"
    
    # 优化WASM
    log "优化WASM大小..."
    wasm-opt -Oz target/wasm32-unknown-unknown/release/${CONTRACT_NAME}.wasm \
        -o artifacts/${CONTRACT_NAME}.optimized.wasm
    
    cd ..
    
    log "合约构建完成"
}

# 部署到区块链
deploy_to_blockchain() {
    log "部署到 ${NETWORK}..."
    
    local DEPLOY_SCRIPT="script/Deploy.s.sol"
    local PRIVATE_KEY=${DEPLOYER_PRIVATE_KEY}
    local RPC_URL=${RPC_URL}
    
    if [[ -z "${PRIVATE_KEY}" ]]; then
        error "请设置 DEPLOYER_PRIVATE_KEY 环境变量"
    fi
    
    if [[ -z "${RPC_URL}" ]]; then
        error "请设置 RPC_URL 环境变量"
    fi
    
    # 执行部署
    forge script ${DEPLOY_SCRIPT} \
        --rpc-url ${RPC_URL} \
        --private-key ${PRIVATE_KEY} \
        --broadcast \
        --verify \
        --retries 3 \
        --delay 10 \
        --gas-limit 10000000 \
        -vvv
    
    log "部署完成"
}

# 验证合约
verify_contract() {
    log "验证合约..."
    
    local CONTRACT_ADDRESS=${CONTRACT_ADDRESS}
    local ETHERSCAN_API_KEY=${ETHERSCAN_API_KEY}
    
    if [[ -z "${CONTRACT_ADDRESS}" ]]; then
        warn "未设置 CONTRACT_ADDRESS，跳过验证"
        return
    fi
    
    if [[ -z "${ETHERSCAN_API_KEY}" ]]; then
        warn "未设置 ETHERSCAN_API_KEY，跳过验证"
        return
    fi
    
    forge verify-contract \
        ${CONTRACT_ADDRESS} \
        src/${CONTRACT_NAME}.sol:${CONTRACT_NAME} \
        --etherscan-api-key ${ETHERSCAN_API_KEY} \
        --compiler-version 0.8.19 \
        -vvv
    
    log "验证完成"
}

# 运行监控
setup_monitoring() {
    log "设置监控..."
    
    # 启动Prometheus
    docker-compose up -d prometheus
    
    # 启动Grafana
    docker-compose up -d grafana
    
    # 导入仪表板
    local DASHBOARD_FILE="monitoring/grafana/dashboards/contracts.json"
    curl -X POST \
        -H "Content-Type: application/json" \
        -d @${DASHBOARD_FILE} \
        http://admin:admin@localhost:3000/api/dashboards/db
    
    log "监控设置完成"
    log "Grafana: http://localhost:3000"
    log "Prometheus: http://localhost:9090"
}

# 主函数
main() {
    log "开始部署 ${CONTRACT_NAME} 到 ${ENVIRONMENT}"
    
    check_dependencies
    build_contract
    
    if [[ "${ENVIRONMENT}" == "production" ]]; then
        deploy_to_blockchain
        verify_contract
        setup_monitoring
    else
        log "开发环境部署完成"
        log "运行测试网络: npm run testnet"
    fi
    
    log "部署流程完成"
}

# 执行主函数
main "$@"
```

#### 3. 监控和告警

```rust
// 监控指标
#[derive(Debug, Clone, PrometheusMetrics)]
#[metrics(prefix = "xwasm_contract_")]
pub struct ContractMetrics {
    /// 交易数量
    #[metrics(labels = ["contract", "method"])]
    pub transactions_total: IntCounterVec,
    
    /// 交易延迟
    #[metrics(labels = ["contract", "method"])]
    pub transaction_duration_seconds: HistogramVec,
    
    /// Gas消耗
    #[metrics(labels = ["contract", "method"])]
    pub gas_used: HistogramVec,
    
    /// 错误数量
    #[metrics(labels = ["contract", "method", "error_type"])]
    pub errors_total: IntCounterVec,
    
    /// 内存使用
    #[metrics(labels = ["contract"])]
    pub memory_usage_bytes: GaugeVec,
    
    /// CPU使用率
    #[metrics(labels = ["contract"])]
    pub cpu_usage_percent: GaugeVec,
}

// 监控集成
impl ContractMetrics {
    pub fn new() -> Self {
        let metrics = Self {
            transactions_total: register_int_counter_vec_with_registry!(
                "transactions_total",
                "Total number of transactions",
                &["contract", "method"],
                prometheus::default_registry()
            ).unwrap(),
            
            transaction_duration_seconds: register_histogram_vec_with_registry!(
                "transaction_duration_seconds",
                "Transaction duration in seconds",
                &["contract", "method"],
                prometheus::default_registry()
            ).unwrap(),
            
            // ... 其他指标
        };
        
        metrics
    }
    
    pub fn record_transaction(
        &self,
        contract_name: &str,
        method_name: &str,
        duration: f64,
        gas_used: u64,
        success: bool,
    ) {
        self.transactions_total
            .with_label_values(&[contract_name, method_name])
            .inc();
        
        self.transaction_duration_seconds
            .with_label_values(&[contract_name, method_name])
            .observe(duration);
        
        self.gas_used
            .with_label_values(&[contract_name, method_name])
            .observe(gas_used as f64);
        
        if !success {
            self.errors_total
                .with_label_values(&[contract_name, method_name, "execution"])
                .inc();
        }
    }
}

// 告警配置
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AlertConfig {
    pub enabled: bool,
    pub check_interval: u64,
    pub thresholds: AlertThresholds,
    pub notifications: AlertNotifications,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AlertThresholds {
    pub high_gas_usage: u64,
    pub high_error_rate: f64,
    pub high_latency: f64,
    pub low_throughput: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AlertNotifications {
    pub email: Vec<String>,
    pub slack: Option<String>,
    pub pagerduty: Option<String>,
    pub webhook: Option<String>,
}

// 告警管理器
struct AlertManager {
    config: AlertConfig,
    metrics: ContractMetrics,
    last_check: Instant,
}

impl AlertManager {
    pub fn new(config: AlertConfig, metrics: ContractMetrics) -> Self {
        Self {
            config,
            metrics,
            last_check: Instant::now(),
        }
    }
    
    pub fn check_alerts(&mut self) -> Vec<Alert> {
        let mut alerts = Vec::new();
        
        // 检查Gas使用
        let gas_alerts = self.check_gas_usage();
        alerts.extend(gas_alerts);
        
        // 检查错误率
        let error_alerts = self.check_error_rate();
        alerts.extend(error_alerts);
        
        // 检查延迟
        let latency_alerts = self.check_latency();
        alerts.extend(latency_alerts);
        
        // 检查吞吐量
        let throughput_alerts = self.check_throughput();
        alerts.extend(throughput_alerts);
        
        self.last_check = Instant::now();
        alerts
    }
    
    fn check_gas_usage(&self) -> Vec<Alert> {
        // 实现Gas使用检查逻辑
        vec![]
    }
    
    fn check_error_rate(&self) -> Vec<Alert> {
        // 实现错误率检查逻辑
        vec![]
    }
    
    // 其他检查方法...
}
```

### 运维最佳实践

#### 1. 升级策略

```rust
// 可升级合约模式
#[xwasm::contract(upgradeable)]
pub struct UpgradeableContract {
    #[state]
    implementation: Address,
    
    #[state]
    admin: Address,
    
    #[state]
    upgrade_history: Vec<UpgradeRecord>,
}

#[xwasm::interface]
impl UpgradeableContract {
    /// 升级合约实现
    #[only_owner]
    pub fn upgrade(
        &mut self,
        ctx: Context,
        new_implementation: Address,
        migration_data: Vec<u8>,
    ) -> Result<UpgradeReceipt> {
        // 验证调用者权限
        self.validate_upgrade_permission(ctx.sender())?;
        
        // 验证新实现地址
        self.validate_implementation(new_implementation)?;
        
        // 执行数据迁移
        self.migrate_data(migration_data)?;
        
        // 更新实现地址
        let old_implementation = self.implementation;
        self.implementation = new_implementation;
        
        // 记录升级历史
        self.record_upgrade(
            old_implementation,
            new_implementation,
            ctx.block_timestamp(),
            ctx.tx_hash(),
        );
        
        Ok(UpgradeReceipt {
            old_implementation,
            new_implementation,
            timestamp: ctx.block_timestamp(),
        })
    }
    
    /// 回滚到之前的版本
    #[only_owner]
    pub fn rollback(
        &mut self,
        ctx: Context,
        target_version: u64,
    ) -> Result<RollbackReceipt> {
        // 查找目标版本
        let target_record = self.find_upgrade_record(target_version)?;
        
        // 执行回滚迁移
        self.migrate_rollback(target_record.migration_data.clone())?;
        
        // 更新实现地址
        let current_implementation = self.implementation;
        self.implementation = target_record.old_implementation;
        
        // 记录回滚
        self.record_rollback(
            current_implementation,
            target_record.old_implementation,
            ctx.block_timestamp(),
            ctx.tx_hash(),
        );
        
        Ok(RollbackReceipt {
            from_implementation: current_implementation,
            to_implementation: target_record.old_implementation,
            timestamp: ctx.block_timestamp(),
        })
    }
}

// 代理合约
#[xwasm::contract]
pub struct ProxyContract {
    #[state]
    implementation: Address,
}

impl ProxyContract {
    #[fallback]
    pub fn fallback(&self, ctx: Context) -> Result<Vec<u8>> {
        // 委托调用到实现合约
        let result = ctx.delegate_call(
            self.implementation,
            ctx.input_data(),
        )?;
        
        Ok(result)
    }
}
```

#### 2. 备份和恢复

```rust
// 备份管理器
struct BackupManager {
    storage: Arc<dyn Storage>,
    config: BackupConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BackupConfig {
    pub enabled: bool,
    pub interval: u64,
    pub retention_days: u32,
    pub storage_type: BackupStorageType,
    pub encryption: BackupEncryption,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum BackupStorageType {
    Local { path: String },
    S3 { bucket: String, region: String },
    Ipfs { gateway: String },
}

impl BackupManager {
    pub async fn create_backup(&self) -> Result<BackupResult> {
        let timestamp = Utc::now();
        let backup_id = format!("backup_{}", timestamp.format("%Y%m%d_%H%M%S"));
        
        // 导出状态数据
        let state_data = self.export_state()?;
        
        // 加密数据
        let encrypted_data = self.encrypt_data(state_data)?;
        
        // 存储备份
        let storage_path = self.store_backup(&backup_id, &encrypted_data).await?;
        
        // 清理旧备份
        self.cleanup_old_backups().await?;
        
        Ok(BackupResult {
            id: backup_id,
            timestamp,
            size: encrypted_data.len() as u64,
            storage_path,
            checksum: self.calculate_checksum(&encrypted_data),
        })
    }
    
    pub async fn restore_backup(&self, backup_id: &str) -> Result<()> {
        // 获取备份数据
        let encrypted_data = self.retrieve_backup(backup_id).await?;
        
        // 解密数据
        let state_data = self.decrypt_data(encrypted_data)?;
        
        // 导入状态
        self.import_state(state_data)?;
        
        Ok(())
    }
}
```

#### 3. 灾难恢复

```rust
// 灾难恢复计划
struct DisasterRecoveryPlan {
    backup_manager: BackupManager,
    config: DisasterRecoveryConfig,
    health_checker: HealthChecker,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DisasterRecoveryConfig {
    pub recovery_time_objective: u64, // RTO in seconds
    pub recovery_point_objective: u64, // RPO in seconds
    pub standby_nodes: Vec<String>,
    pub failover_strategy: FailoverStrategy,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FailoverStrategy {
    Automatic,
    Manual,
    Hybrid,
}

impl DisasterRecoveryPlan {
    pub async fn execute_failover(&self) -> Result<FailoverResult> {
        // 检测灾难事件
        if !self.health_checker.is_disaster() {
            return Ok(FailoverResult::NotNeeded);
        }
        
        // 选择备用节点
        let standby_node = self.select_standby_node()?;
        
        // 执行故障转移
        match self.config.failover_strategy {
            FailoverStrategy::Automatic => self.automatic_failover(standby_node).await,
            FailoverStrategy::Manual => self.manual_failover(standby_node).await,
            FailoverStrategy::Hybrid => self.hybrid_failover(standby_node).await,
        }
    }
    
    async fn automatic_failover(&self, standby_node: &str) -> Result<FailoverResult> {
        log::info!("执行自动故障转移到: {}", standby_node);
        
        // 停止主节点
        self.stop_primary_node().await?;
        
        // 启动备用节点
        self.start_standby_node(standby_node).await?;
        
        // 恢复最新备份
        let latest_backup = self.backup_manager.get_latest_backup().await?;
        self.backup_manager.restore_backup(&latest_backup.id).await?;
        
        // 更新DNS/负载均衡器
        self.update_infrastructure(standby_node).await?;
        
        Ok(FailoverResult::Success {
            timestamp: Utc::now(),
            standby_node: standby_node.to_string(),
            recovery_time: self.calculate_recovery_time(),
        })
    }
}
```

## 总结

本章通过具体的应用案例展示了xwasm项目在DeFi、NFT、游戏和供应链等多个领域的实际应用，并提供了从开发、测试到部署、运维的完整最佳实践指南。

### 关键收获

1. **多样化应用场景**: xwasm能够支持从金融协议到游戏、供应链等广泛的应用场景
2. **开发最佳实践**: 包括代码组织、错误处理、测试策略和性能优化
3. **部署运维**: 提供了完整的部署脚本、监控告警和灾难恢复方案
4. **可升级架构**: 支持合约的平滑升级和数据迁移

### 实践建议

1. **从小开始**: 从简单的应用场景开始，逐步增加复杂度
2. **测试驱动**: 编写全面的测试用例，确保合约安全性
3. **监控预警**: 建立完善的监控体系，及时发现和处理问题
4. **备份恢复**: 定期备份关键数据，制定灾难恢复计划

通过遵循这些最佳实践，开发者可以构建出安全、高效、可维护的区块链应用，充分发挥xwasm技术的优势。