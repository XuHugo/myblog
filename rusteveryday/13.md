智能合约语言（eDSL）—— 并行化方案——调度算法
​
3、调度算法
处理区块的时候，我们会同时启动多个线程去执行多个交易，这个时候我们需要一个良好的调度策略，来决定当前的线程是应该执行交易还是验证交易、提前结束还是立刻重新执行交易等，只有有一个良好调度策略才能保证所有交易都稳定有序的执行；

线程数量
这是一个不太容易确定的变量，因为这不单单和机器的核数有关，也与我们需要处理的而区块有关系；由于我们是处理计算类型的任务，所以肯定不会使用tokio这种类似协程的轻量级线程，所以与核数又密切关系；如果我们处理的区块中，交易依赖程度很高，那么大量的并行时，重复执行的概率肯定非常大；基于上述两者的考虑，我们可以选择机器的最大核数80%或者(txs-dep_txs)/2，选择较大的一个值；

任务划分
在并行处理交易的时候，算法需要调度的任务并不是只有执行交易这一种，还有一种任务是验证交易，这是因为我们并行的执行交易，不能保证执行完的交易，它依赖的状态都是正确的，所以需要进行验证，如果出现错误，可能就需要重新执行与验证；所以我们需要调度的任务有两种类型，执行和验证，下面我们分别讲一下：

执行任务
就是一个交易的正常执行；但是需要记录执行过程中的读取和写入状态数据的列表，这有两个原因，一个是方便后续的验证，一个是执行完所有交易后，写入数据库；

验证任务
就是验证一个已经执行完交易的读写集，因为我们并发的而执行多个交易的时候，会导致id靠后的交易先于id考前的交易执行完，这样id靠后的交易，依赖的数据，可能会出现问题；例如块内包含交易，tx1，tx2，，，tx10；tx7比tx5先执行完了；这个时候，我们就需要验证tx7，因为存在这样的情况，tx7读了key1的值，虽然tx5写了key1的值，但是tx5执行的慢，导致tx7读取key1的时候，tx5还没有写入，如果按照我们之前的标准，并行执行完整个块与串行执行的结果要一致，那么这种情况下，tx7就需要重新执行，这就是验证任务的意义所在。

调度算法


其实调度的算法也比较简单，核心就是依赖两个id；由于我们有两中任务，所以我们分别设置对应的两种id，一个验证任务id和一个执行任务id，我们主要依赖这两中id的变化来进行调度任务；

这两个id是从0开始，一直增长到blocksize；但是这个两个id的变化轨迹，不是线性从0递增到blocksize的；他可能是从往复的，最终是增长到blocksize；例如id可能从0线性递增到10，突然又10变成6，这都是有可能的——这其实就是对应于我们刚才说的验证失败的情况；

选择任务，它负责给根据当前系统状态，计算出下一个需要执行的人物，可能是执行任务，也可能是验证任务，或者结束也说不定。一般会比较验证id——vid和执行id——eid，选择一个较小的值作为下一个任务；为什么呢？因为我们肯定是先执行再验证，如果调度任务一直执行，而不验证，则两者——vid和eid——差距肯定越来越大，在这种情况下，但凡id小的任务，执行出现问题，那么，此id之后的的任务都需要重新执行。所以一个比较好的情况是，vid和eid的差距比较小，这样就让id处在一个比较小范围的交易，及时的执行，及时的验证；所以我们主要就是需要保证vid和eid差值不要太大；

依赖处理，如果有些任务执行的时候，因为读取数据出错了——他读取的数据被标记为有问题，则此时，当前任务就是阻塞了，它必须等之前写入该值的任务，重新执行完成且没有问题后，当前任务才可以继续执行，所以这时候我们会认为这两个任务有依赖关系；

通常我们会有数据结构专门记录依赖关系，hashmap<txid, vec<txsid>>用来记录所有依赖txid的交易vec<txsid>，当txid重复执行完且没有问题后，他就会通知依赖他的所有交易——vec<txsid>，这些交易就可以准备执行了；

Dep_num，表示某一个交易依赖交易的个数，因为某一个交易有可能依赖多个交易，只有所有依赖的交易都成功完成了，它才可以准备执行；

通过设置依赖关系，我们可以把某些任务推迟执行，让他处于休眠状态，从而避免它被提前调度而消耗过多的cpu；

​