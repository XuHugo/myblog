智能合约语言（eDSL）—— 如何使用wasmtime运行合约
​
     在我们使用高级语言生成了智能合约——WASM之后，接下来就是对智能合约——WASM的使用。首先，我们需要引入wasmtime库，使用wasmtime运行我们的合约。我们的Rust程序为：

use anyhow::Result;
use std::fs;
use wasmtime::*;

fn main() -> Result<()> {
    let wasm_bytes = fs::read("./adder.wasm")?;
    let engine = Engine::default();
    let mut store = Store::new(&engine, ());
    let module = Module::new(&engine, wasm_bytes)?;
    let instance = Instance::new(&mut store, &module, &[])?;
    let add = instance.get_typed_func::<(u32, u32), u32>(&mut store, "add")?;
    let sum = add.call(&mut store, (1, 2))?;
    println!("Sum is {sum}");
    Ok(())
}

读取合约
首先，我们通过Rust标准库，将WASM程序的字节码读入了内存wasm_bytes中，此时wasm_bytes的类型是Vec<u8>。这是因为我们后续在使用Module::new解析WASM时，会要求参数满足AsRef<[u8]>，因此我们一般都是直接读入内存即可。

store

随后，我们创建了一个默认的Store类型变量。Store实际上是一个通用的wasm的概念，但是放在Rust的代码里讲，就直观很多。我们知道，Rust是一个非常强调所有权和生命周期的编程语言。在一个WASM程序运行的过程中，会有很多全局的状态。例如，WASM程序中的函数本身，其生命周期理应是全局的。用来托管这些全局状态的，就称为Store。

模块
一个WASM程序就是一个module。可以看到，这个变量创建的过程中，需要store作为参数。这是因为需要引擎提供加持，所以要从store中提取目前的引擎。创建Module类型的变量，就完成了之前提到的WASM语义阶段中的「解码」和「验证」两个阶段（wasm规范中提及）。所以module中是编译后的wasm模块。这些结构包含来自wasm二进制文件的编译后的可执行代码，这些代码在实例化后准备执行。

instance
当我们创建Instance类型的变量时，就是真正执行WASM程序的过程。创建这个变量，就会初始化WASM程序，形成一个WASM实例。也就是说，我们WASM程序从现在开始正式进入执行阶段。

调用函数（相当于用户调用合约）
接下来，我们使用了get_typed_function来获得我们在WASM程序中导出的"add"函数，然后使用call来调用这个函数。我们知道，Rust是强类型的语言，所以需要提供这个函数的类型信息。TypedFunction<(u32, u32), u32>就提示编译器，这个add函数接收两个u32类型的参数，返回一个u32类型的值。

这只是一个demo实例，简单的介绍了一下如何使用wasmtime。具体实现可以看下这里。

xwasm/wasm/src/vm.rs at main · XuHugo/xwasm · GitHub

​