智能合约语言（eDSL）—— 合约表现形式
​
    我们写智能合约的时候，会发现，合约语言其实是有一个比较明显的范围限定的。

        GitHub - XuHugo/xwasm

例如solidity中，就有类似于面向对象中的类，将一个合约的属性与方法，都设定在一个合约类当中；而在fabric中链码，更接近我们普通的程序，合约分布在几个文件中，用户将其打包成一个智能合约。所以我们在设计智能合约语言的时候，第一步考虑的就是我们的合约是一个怎么样的形式。

        简单一点，一组变量和一组方法，基本可以满足合约的要求了。然后就是我们以什么样子的形式把其组织起来呢？先说一下我们的目标，我们希望这组变量和方法可以很明显的被观测到，他们属于一个合约。写合约的时候，也能够让开发者，足够方便且醒目，不至于开发的时候出现错误。

        我们的智能合约语言是基于rust实现的，利用rust语言开发一种新的语言——智能合约语言，不过这门新的语言不需要很强大的功能，它能覆盖智能合约需求即可；就具体实现来说，我们其实就是利用rust的宏，实现元编程。相对于ethereum和fabric的两种方法，我们采用标记的方法，即用户主动标记当前的元素——函数、变量——属于哪个合约。

    合约中的要素有哪些？
    合约标识：需要明确的表示该合约身份，例如地址，或者名字等手段； 

    函数：用户用来和链交互的接口，可能涉及到对链上数据的查询，修改；

     事件：合约被调用，发生一些状态变化，通知外部；

     链状态：链上数据再合约中的存储形式，一般都是由写合约的人进行定义的；

     链的环境接口：写合约的时候，需要获取链的一些状态，这部分是内嵌到合约语言中的；

     交互格式：主要是函数的参数与返回值，这部分都是与调用者有关系；不过主要都是

   我们合约中各要素的表现形式
    合约标识：
    我们主要是使用属性宏——proc_macro_attribute去实现我们的智能合约语言，然后通过他的第一个参数attr，设置合约的名称contract。

    例如，设置init函数所属的合约名称，contract = “xq”。

​​​​

   函数：
   给rcv函数，设置函数名字，function = “abc”



    事件
  设置事件

#[event(contract="xq")]

enum event {

… …

}

链状态
链上存储的方式，我们使用kv的形式；不局限与格式，只要可以序列化和反序列化的，都是可以的；但是需要提前定义好；

链环境接口
我们可以通过ctx，直接获取链上的一些信息；



交互格式
交互格式使用json，用户可以直接使用json格式作为参数，发送到链上；合约内部可以通过serde直接解析。



        但从智能合约的结构来说，有了这些就完全够用了。后边我们就以这个思路，将其具体展开来说一下。

   

​